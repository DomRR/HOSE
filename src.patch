diff -Naur src_origin/main/java/net/minecraft/server/Chunk.java src_new/main/java/net/minecraft/server/Chunk.java
--- src_origin/main/java/net/minecraft/server/Chunk.java	2016-02-05 01:52:04.131371288 +0800
+++ src_new/main/java/net/minecraft/server/Chunk.java	2016-02-10 12:21:05.693812382 +0800
@@ -890,26 +890,30 @@
         for (int k = i; k <= j; ++k) {
             if (!this.entitySlices[k].isEmpty()) {
                 Iterator iterator = this.entitySlices[k].iterator();
+                
+                try{
+                    while (iterator.hasNext()) {
+                        Entity entity1 = (Entity) iterator.next();
+
+                        if (entity1.getBoundingBox().b(axisalignedbb) && entity1 != entity) {
+                            if (predicate == null || predicate.apply(entity1)) {
+                                list.add(entity1);
+                            }
 
-                while (iterator.hasNext()) {
-                    Entity entity1 = (Entity) iterator.next();
-
-                    if (entity1.getBoundingBox().b(axisalignedbb) && entity1 != entity) {
-                        if (predicate == null || predicate.apply(entity1)) {
-                            list.add(entity1);
-                        }
-
-                        Entity[] aentity = entity1.aB();
+                            Entity[] aentity = entity1.aB();
 
-                        if (aentity != null) {
-                            for (int l = 0; l < aentity.length; ++l) {
-                                entity1 = aentity[l];
-                                if (entity1 != entity && entity1.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply(entity1))) {
-                                    list.add(entity1);
+                            if (aentity != null) {
+                                for (int l = 0; l < aentity.length; ++l) {
+                                    entity1 = aentity[l];
+                                    if (entity1 != entity && entity1.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply(entity1))) {
+                                        list.add(entity1);
+                                    }
                                 }
                             }
                         }
                     }
+                }catch(Exception ex){
+                    
                 }
             }
         }
@@ -922,16 +926,19 @@
 
         i = MathHelper.clamp(i, 0, this.entitySlices.length - 1);
         j = MathHelper.clamp(j, 0, this.entitySlices.length - 1);
-
+        
         for (int k = i; k <= j; ++k) {
             Iterator iterator = this.entitySlices[k].iterator(); // Spigot
+            try{
+                while (iterator.hasNext()) {
+                    Entity entity = (Entity) iterator.next();
 
-            while (iterator.hasNext()) {
-                Entity entity = (Entity) iterator.next();
-
-                if (oclass.isInstance(entity) && entity.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply((T) entity))) { // CraftBukkit - fix decompile error // Spigot
-                    list.add((T) entity); // Fix decompile error
+                    if (oclass.isInstance(entity) && entity.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply((T) entity))) { // CraftBukkit - fix decompile error // Spigot
+                        list.add((T) entity); // Fix decompile error
+                    }
                 }
+            }catch (Exception ex){
+                        
             }
         }
 
diff -Naur src_origin/main/java/net/minecraft/server/DedicatedServer.java src_new/main/java/net/minecraft/server/DedicatedServer.java
--- src_origin/main/java/net/minecraft/server/DedicatedServer.java	2016-02-05 01:52:05.123371240 +0800
+++ src_new/main/java/net/minecraft/server/DedicatedServer.java	2016-02-10 12:21:05.848812397 +0800
@@ -17,6 +17,7 @@
 
 // CraftBukkit start
 import java.io.PrintStream;
+import net.openhft.affinity.AffinityLock;
 import org.apache.logging.log4j.Level;
 
 import org.bukkit.craftbukkit.LoggerOutputStream;
@@ -49,11 +50,14 @@
             }
 
             public void run() {
+                AffinityLock al = AffinityLock.acquireLock();
                 while (true) {
                     try {
                         Thread.sleep(2147483647L);
                     } catch (InterruptedException interruptedexception) {
                         ;
+                    } finally {
+                        al.release();
                     }
                 }
             }
diff -Naur src_origin/main/java/net/minecraft/server/EntityEnderDragon.java src_new/main/java/net/minecraft/server/EntityEnderDragon.java
--- src_origin/main/java/net/minecraft/server/EntityEnderDragon.java	2016-02-05 01:52:06.000371197 +0800
+++ src_new/main/java/net/minecraft/server/EntityEnderDragon.java	2016-02-10 12:21:05.987812410 +0800
@@ -676,7 +676,8 @@
         // CraftBukkit end
     }
 
-    protected void D() {}
+    //protected void D() {}
+    public void D() {}
 
     public Entity[] aB() {
         return this.children;
diff -Naur src_origin/main/java/net/minecraft/server/EntityInsentient.java src_new/main/java/net/minecraft/server/EntityInsentient.java
--- src_origin/main/java/net/minecraft/server/EntityInsentient.java	2016-02-05 01:52:06.407371177 +0800
+++ src_new/main/java/net/minecraft/server/EntityInsentient.java	2016-02-10 12:21:06.056812416 +0800
@@ -1,8 +1,10 @@
 package net.minecraft.server;
 
+import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.UUID;
+import java.util.concurrent.FutureTask;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.event.CraftEventFactory;
@@ -11,21 +13,28 @@
 import org.bukkit.event.entity.EntityTargetEvent;
 import org.bukkit.event.entity.EntityUnleashEvent;
 import org.bukkit.event.entity.EntityUnleashEvent.UnleashReason;
+import org.hose.TickEntityPool;
+import org.spigotmc.SpigotWorldConfig;
+
 // CraftBukkit end
 
 public abstract class EntityInsentient extends EntityLiving {
 
     public int a_;
     protected int b_;
-    private ControllerLook lookController;
-    protected ControllerMove moveController;
-    protected ControllerJump g;
+    //private ControllerLook lookController;
+    public ControllerLook lookController;
+    //protected ControllerMove moveController;
+    public ControllerMove moveController;
+    //protected ControllerJump g;
+    public ControllerJump g;
     private EntityAIBodyControl b;
     protected NavigationAbstract navigation;
     public PathfinderGoalSelector goalSelector;
     public PathfinderGoalSelector targetSelector;
     private EntityLiving goalTarget;
-    private EntitySenses bk;
+    //private EntitySenses bk;
+    public EntitySenses bk;
     private ItemStack[] equipment = new ItemStack[5];
     public float[] dropChances = new float[5];
     public boolean canPickUpLoot;
@@ -317,8 +326,8 @@
             }
         }
 
-        this.bo = nbttagcompound.getBoolean("Leashed");
         if (this.bo && nbttagcompound.hasKeyOfType("Leash", 10)) {
+        this.bo = nbttagcompound.getBoolean("Leashed");
             this.bq = nbttagcompound.getCompound("Leash");
         }
 
@@ -426,7 +435,8 @@
         return true;
     }
 
-    protected void D() {
+    public void D() {
+    //protected void D() {
         if (this.persistent) {
             this.ticksFarFromPlayer = 0;
         } else {
@@ -451,11 +461,39 @@
 
         }
     }
-
+    
+    @Override
     protected final void doTick() {
         ++this.ticksFarFromPlayer;
+        //AffinityLock al = AffinityLock.acquireLock();
+        try {
+            SpigotWorldConfig.TickEntityTask = new FutureTask(new TickEntityPool(this));
+            SpigotWorldConfig.dotickpool_executor.submit(SpigotWorldConfig.TickEntityTask);
+            //SpigotWorldConfig.dotickpool_executor.execute(new TickEntityPool(this));
+            this.world.methodProfiler.a("goalSelector");
+            this.goalSelector.a();
+            this.world.methodProfiler.a("navigation");
+            this.navigation.k();
+            this.world.methodProfiler.b();
+            this.world.methodProfiler.a("mob tick");
+            this.E();
+        } catch(Exception e) {
+            //e.printStackTrace();
+        } finally {
+            //al.release();
+        }
+        /*SpigotWorldConfig.dotickpool_executor.execute(new DoTickPool(this));
+        try{
+            this.world.methodProfiler.a("goalSelector");
+            this.goalSelector.a();
+            this.world.methodProfiler.b();
+        } catch (Exception ex) {
+
+        }*/
+        /*
         this.world.methodProfiler.a("checkDespawn");
         this.D();
+        //SpigotWorldConfig.despawnpool_executor.execute(new DeSpawnPool(this));
         this.world.methodProfiler.b();
         // Spigot Start
         if ( this.fromMobSpawner )
@@ -486,7 +524,7 @@
         this.world.methodProfiler.c("jump");
         this.g.b();
         this.world.methodProfiler.b();
-        this.world.methodProfiler.b();
+        this.world.methodProfiler.b();*/
     }
 
     protected void E() {}
@@ -941,4 +979,6 @@
 
         private EnumEntityPositionType() {}
     }
+    
+    
 }
diff -Naur src_origin/main/java/net/minecraft/server/EntityLiving.java src_new/main/java/net/minecraft/server/EntityLiving.java
--- src_origin/main/java/net/minecraft/server/EntityLiving.java	2016-02-05 01:52:06.631371167 +0800
+++ src_new/main/java/net/minecraft/server/EntityLiving.java	2016-02-10 12:21:06.097812420 +0800
@@ -1650,6 +1650,7 @@
         this.bb *= 0.9F;
         SpigotTimings.timerEntityAIMove.startTiming(); // Spigot
         this.g(this.aZ, this.ba);
+        //SpigotWorldConfig.movepool_executor.execute(new MovePool(this, this.aZ, this.ba));
         SpigotTimings.timerEntityAIMove.stopTiming(); // Spigot
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("push");
@@ -1665,36 +1666,40 @@
     protected void doTick() {}
 
     protected void bL() {
-        List list = this.world.a((Entity) this, this.getBoundingBox().grow(0.20000000298023224D, 0.0D, 0.20000000298023224D), Predicates.and(IEntitySelector.d, new Predicate() {
-            public boolean a(Entity entity) {
-                return entity.ae();
-            }
-
-            public boolean apply(Object object) {
-                return this.a((Entity) object);
-            }
-        }));
+        try {
+            List list = this.world.a((Entity) this, this.getBoundingBox().grow(0.20000000298023224D, 0.0D, 0.20000000298023224D), Predicates.and(IEntitySelector.d, new Predicate() {
+                public boolean a(Entity entity) {
+                    return entity.ae();
+                }
 
-        if (this.ad() && !list.isEmpty()) { // Spigot: Add this.ad() condition
-            numCollisions -= world.spigotConfig.maxCollisionsPerEntity; // Spigot
-            for (int i = 0; i < list.size(); ++i) {
-                if (numCollisions > world.spigotConfig.maxCollisionsPerEntity) { break; } // Spigot
-                Entity entity = (Entity) list.get(i);
-
-                // TODO better check now?
-                // CraftBukkit start - Only handle mob (non-player) collisions every other tick
-                if (entity instanceof EntityLiving && !(this instanceof EntityPlayer) && this.ticksLived % 2 == 0) {
-                    continue;
+                public boolean apply(Object object) {
+                    return this.a((Entity) object);
                 }
-                // CraftBukkit end
+            }));
+        
 
-                entity.numCollisions++; // Spigot
-                numCollisions++; // Spigot
-                this.s(entity);
+            if (this.ad() && !list.isEmpty()) { // Spigot: Add this.ad() condition
+                numCollisions -= world.spigotConfig.maxCollisionsPerEntity; // Spigot
+                for (int i = 0; i < list.size(); ++i) {
+                    if (numCollisions > world.spigotConfig.maxCollisionsPerEntity) { break; } // Spigot
+                    Entity entity = (Entity) list.get(i);
+
+                    // TODO better check now?
+                    // CraftBukkit start - Only handle mob (non-player) collisions every other tick
+                    if (entity instanceof EntityLiving && !(this instanceof EntityPlayer) && this.ticksLived % 2 == 0) {
+                        continue;
+                    }
+                    // CraftBukkit end
+
+                    entity.numCollisions++; // Spigot
+                    numCollisions++; // Spigot
+                    this.s(entity);
+                }
+                numCollisions = 0; // Spigot
             }
-            numCollisions = 0; // Spigot
+        } catch(Exception ex){
+            
         }
-
     }
 
     protected void s(Entity entity) {
diff -Naur src_origin/main/java/net/minecraft/server/EntityTracker.java src_new/main/java/net/minecraft/server/EntityTracker.java
--- src_origin/main/java/net/minecraft/server/EntityTracker.java	2016-02-05 01:52:07.363371131 +0800
+++ src_new/main/java/net/minecraft/server/EntityTracker.java	2016-02-10 12:21:06.232812433 +0800
@@ -6,8 +6,11 @@
 import java.util.Iterator;
 import java.util.Set;
 import java.util.concurrent.Callable;
+import java.util.concurrent.FutureTask;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.hose.AddEntityTrackPool;
+import org.spigotmc.SpigotWorldConfig;
 
 public class EntityTracker {
 
@@ -95,6 +98,10 @@
 
     public void addEntity(Entity entity, int i, final int j, boolean flag) {
         org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
+        /*
+        SpigotWorldConfig.AddEntityTrackTask = new FutureTask(new AddEntityTrackPool(this, entity, i, j, flag));
+        SpigotWorldConfig.addentitytrackpool_executor.submit(SpigotWorldConfig.AddEntityTrackTask);*/
+        
         i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
         if (i > this.e) {
             i = this.e;
@@ -145,6 +152,59 @@
 
     }
 
+    public void addEntity_run(Entity entity, int i, final int j, boolean flag) {
+        //org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
+        i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
+        if (i > this.e) {
+            i = this.e;
+        }
+
+        try {
+            if (this.trackedEntities.b(entity.getId())) {
+                throw new IllegalStateException("Entity is already tracked!");
+            }
+
+            EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, j, flag);
+
+            this.c.add(entitytrackerentry);
+            this.trackedEntities.a(entity.getId(), entitytrackerentry);
+            entitytrackerentry.scanPlayers(this.world.players);
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity To Track");
+
+            crashreportsystemdetails.a("Tracking range", (Object) (i + " blocks"));
+            final int finalI = i; // CraftBukkit - fix decompile error
+            crashreportsystemdetails.a("Update interval", new Callable() {
+                public String a() throws Exception {
+                    String s = "Once per " + finalI + " ticks"; // CraftBukkit
+
+                    if (finalI == Integer.MAX_VALUE) { // CraftBukkit
+                        s = "Maximum (" + s + ")";
+                    }
+
+                    return s;
+                }
+
+                public Object call() throws Exception {
+                    return this.a();
+                }
+            });
+            entity.appendEntityCrashDetails(crashreportsystemdetails);
+            CrashReportSystemDetails crashreportsystemdetails1 = crashreport.a("Entity That Is Already Tracked");
+
+            ((EntityTrackerEntry) this.trackedEntities.get(entity.getId())).tracker.appendEntityCrashDetails(crashreportsystemdetails1);
+
+            try {
+                throw new ReportedException(crashreport);
+            } catch (ReportedException reportedexception) {
+                EntityTracker.a.error("\"Silently\" catching entity tracking error.", reportedexception);
+            }
+        }
+
+    }
+    
+    
     public void untrackEntity(Entity entity) {
         org.spigotmc.AsyncCatcher.catchOp( "entity untrack"); // Spigot
         if (entity instanceof EntityPlayer) {
diff -Naur src_origin/main/java/net/minecraft/server/EntityWither.java src_new/main/java/net/minecraft/server/EntityWither.java
--- src_origin/main/java/net/minecraft/server/EntityWither.java	2016-02-05 01:52:07.464371126 +0800
+++ src_new/main/java/net/minecraft/server/EntityWither.java	2016-02-10 12:21:06.251812435 +0800
@@ -458,7 +458,8 @@
 
     }
 
-    protected void D() {
+    public void D() {
+    //protected void D() {
         this.ticksFarFromPlayer = 0;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src_new/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2016-02-05 01:52:08.748371064 +0800
+++ src_new/main/java/net/minecraft/server/MinecraftServer.java	2016-02-10 12:21:06.512812459 +0800
@@ -43,6 +43,7 @@
 
 import jline.console.ConsoleReader;
 import joptsimple.OptionSet;
+import net.openhft.affinity.AffinityLock;
 
 import org.bukkit.craftbukkit.Main;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
@@ -652,6 +653,7 @@
 
         this.methodProfiler.a("root");
         this.B();
+        //SpigotWorldConfig.mspool_executor.submit(new MSPool(this));
         if (i - this.X >= 5000000000L) {
             this.X = i;
             this.r.setPlayerSample(new ServerPing.ServerPingPlayerSample(this.J(), this.I()));
@@ -713,7 +715,7 @@
         int count = this.j.size();
         while (count-- > 0 && (entry = this.j.poll()) != null) {
             SystemUtils.a(entry, MinecraftServer.LOGGER);
-         }
+        }
         // Spigot end
 
         this.methodProfiler.c("levels");
@@ -768,6 +770,13 @@
                 try {
                     worldserver.timings.doTick.startTiming(); // Spigot
                     worldserver.doTick();
+                    /*
+                    try {
+                        SpigotWorldConfig.WSTask = new FutureTask(new MSPool(worldserver));
+                        SpigotWorldConfig.mspool_executor.submit(SpigotWorldConfig.WSTask);
+                    } catch (Exception ex){
+                        
+                    }*/
                     worldserver.timings.doTick.stopTiming(); // Spigot
                 } catch (Throwable throwable) {
                     // Spigot Start
@@ -936,8 +945,13 @@
             if (options.has("world")) {
                 dedicatedserver.setWorld((String) options.valueOf("world"));
             }
-
-            dedicatedserver.primaryThread.start();
+            //
+            AffinityLock al = AffinityLock.acquireLock();
+            try {
+                dedicatedserver.primaryThread.start();
+            } finally {
+                al.release();
+            }
             // CraftBukkit end
         } catch (Exception exception) {
             MinecraftServer.LOGGER.fatal("Failed to start the minecraft server", exception);
@@ -1023,7 +1037,7 @@
     }
 
     public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "HOSE"; // HOSE -> Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
diff -Naur src_origin/main/java/net/minecraft/server/SpawnerCreature.java src_new/main/java/net/minecraft/server/SpawnerCreature.java
--- src_origin/main/java/net/minecraft/server/SpawnerCreature.java	2016-02-05 01:52:11.035370953 +0800
+++ src_new/main/java/net/minecraft/server/SpawnerCreature.java	2016-02-10 12:21:06.919812497 +0800
@@ -4,7 +4,6 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
-import java.util.Set;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.util.LongHash;
@@ -180,6 +179,17 @@
                                                             if (entityinsentient.canSpawn()) {
                                                                 ++l2;
                                                                 worldserver.addEntity(entityinsentient, SpawnReason.NATURAL); // CraftBukkit - Added a reason for spawning this creature
+                                                                /*
+                                                                try {
+                                                                    SpigotWorldConfig.SpawnTask = new FutureTask(new SpawnerPool(worldserver, entityinsentient));
+                                                                    SpigotWorldConfig.spawnerpool_executor.submit(SpigotWorldConfig.SpawnTask);
+                                                                
+                                                                    SpigotWorldConfig.SpawnTask.get();
+                                                                } catch (InterruptedException ex) {
+                                                                    Logger.getLogger(SpawnerCreature.class.getName()).log(Level.SEVERE, null, ex);
+                                                                } catch (ExecutionException ex) {
+                                                                    Logger.getLogger(SpawnerCreature.class.getName()).log(Level.SEVERE, null, ex);
+                                                                }*/
                                                             }
 
                                                             // Spigot start
diff -Naur src_origin/main/java/net/minecraft/server/World.java src_new/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2016-02-05 01:52:11.643370923 +0800
+++ src_new/main/java/net/minecraft/server/World.java	2016-02-10 12:21:07.030812507 +0800
@@ -2,14 +2,12 @@
 
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
-import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.Callable;
 
@@ -20,7 +18,6 @@
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.craftbukkit.util.LongHashSet;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
 import org.bukkit.generator.ChunkGenerator;
 import org.bukkit.craftbukkit.CraftServer;
@@ -29,8 +26,6 @@
 import org.bukkit.event.block.BlockCanBuildEvent;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
-import org.bukkit.event.weather.WeatherChangeEvent;
-import org.bukkit.event.weather.ThunderChangeEvent;
 // CraftBukkit end
 
 public abstract class World implements IBlockAccess {
@@ -474,12 +469,14 @@
     public boolean setTypeUpdate(BlockPosition blockposition, IBlockData iblockdata) {
         return this.setTypeAndData(blockposition, iblockdata, 3);
     }
-
+    
+    ChunkProviderServer cps;
     public void notify(BlockPosition blockposition) {
+        //System.out.println(cps.getChunkAt(blockposition).toString()+"!");
         for (int i = 0; i < this.u.size(); ++i) {
             ((IWorldAccess) this.u.get(i)).a(blockposition);
+            //get player who use xray-like cheat
         }
-
     }
 
     public void update(BlockPosition blockposition, Block block) {
@@ -987,8 +984,102 @@
         return addEntity(entity, SpawnReason.DEFAULT);
     }
 
+    
     public boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
         org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
+        
+        /*
+        SpigotWorldConfig.AddEntityTask = new FutureTask(new AddEntityPool(this, entity, spawnReason));
+        SpigotWorldConfig.addentitypool_executor.submit(SpigotWorldConfig.AddEntityTask);
+        boolean aeb = false;
+        
+        try {
+            aeb = (boolean) SpigotWorldConfig.AddEntityTask.get();
+        } catch (InterruptedException ex) {
+            Logger.getLogger(World.class.getName()).log(Level.SEVERE, null, ex);
+        } catch (ExecutionException ex) {
+            Logger.getLogger(World.class.getName()).log(Level.SEVERE, null, ex);
+        }    
+        return aeb;*/
+            
+            
+            
+            if (entity == null) return false;
+            // CraftBukkit end
+            int i = MathHelper.floor(entity.locX / 16.0D);
+            int j = MathHelper.floor(entity.locZ / 16.0D);
+            boolean flag = entity.attachedToPlayer;
+            
+            if (entity instanceof EntityHuman) {
+            flag = true;
+            }
+            
+            // CraftBukkit start
+            org.bukkit.event.Cancellable event = null;
+            if (entity instanceof EntityLiving && !(entity instanceof EntityPlayer)) {
+            boolean isAnimal = entity instanceof EntityAnimal || entity instanceof EntityWaterAnimal || entity instanceof EntityGolem;
+            boolean isMonster = entity instanceof EntityMonster || entity instanceof EntityGhast || entity instanceof EntitySlime;
+
+            if (spawnReason != SpawnReason.CUSTOM) {
+            if (isAnimal && !allowAnimals || isMonster && !allowMonsters) {
+            entity.dead = true;
+            return false;
+            }
+            }
+            
+            event = CraftEventFactory.callCreatureSpawnEvent((EntityLiving) entity, spawnReason);
+            } else if (entity instanceof EntityItem) {
+            event = CraftEventFactory.callItemSpawnEvent((EntityItem) entity);
+            } else if (entity.getBukkitEntity() instanceof org.bukkit.entity.Projectile) {
+            // Not all projectiles extend EntityProjectile, so check for Bukkit interface instead
+            event = CraftEventFactory.callProjectileLaunchEvent(entity);
+            }
+            // Spigot start
+            else if (entity instanceof EntityExperienceOrb) {
+            EntityExperienceOrb xp = (EntityExperienceOrb) entity;
+            double radius = spigotConfig.expMerge;
+            if (radius > 0) {
+            List<Entity> entities = this.getEntities(entity, entity.getBoundingBox().grow(radius, radius, radius));
+            for (Entity e : entities) {
+            if (e instanceof EntityExperienceOrb) {
+            EntityExperienceOrb loopItem = (EntityExperienceOrb) e;
+            if (!loopItem.dead) {
+            xp.value += loopItem.value;
+            loopItem.die();
+            }
+            }
+            }
+            }
+            } // Spigot end
+            
+            if (event != null && (event.isCancelled() || entity.dead)) {
+            entity.dead = true;
+            return false;
+            }
+            // CraftBukkit end
+            
+            if (!flag && !this.isChunkLoaded(i, j, true)) {
+            entity.dead = true;
+            return false;
+            } else {
+            if (entity instanceof EntityHuman) {
+            EntityHuman entityhuman = (EntityHuman) entity;
+            
+            this.players.add(entityhuman);
+            this.everyoneSleeping();
+            }
+
+            this.getChunkAt(i, j).a(entity);
+            this.entityList.add(entity);
+            this.a(entity);
+            return true;
+            }
+        
+        
+    }
+    
+    public boolean addEntity_run(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
+        
         if (entity == null) return false;
         // CraftBukkit end
         int i = MathHelper.floor(entity.locX / 16.0D);
@@ -1060,6 +1151,7 @@
             return true;
         }
     }
+    
 
     protected void a(Entity entity) {
         for (int i = 0; i < this.u.size(); ++i) {
@@ -1338,7 +1430,7 @@
 
     public void b(BlockPosition blockposition, Block block, int i, int j) {}
 
-    public void tickEntities() {
+    public void tickEntities() throws InterruptedException {
         this.methodProfiler.a("entities");
         this.methodProfiler.a("global");
 
@@ -1357,7 +1449,8 @@
 
             try {
                 ++entity.ticksLived;
-                entity.t_();
+                //entity.t_();
+                
             } catch (Throwable throwable) {
                 crashreport = CrashReport.a(throwable, "Ticking entity");
                 crashreportsystemdetails = crashreport.a("Entity being ticked");
@@ -1403,9 +1496,7 @@
         // CraftBukkit start - Use field for loop variable
         int entitiesThisCycle = 0;
         if (tickPosition < 0) tickPosition = 0;
-        for (entityLimiter.initTick();
-                entitiesThisCycle < entityList.size() && (entitiesThisCycle % 10 != 0 || entityLimiter.shouldContinue());
-                tickPosition++, entitiesThisCycle++) {
+        for (entityLimiter.initTick();entitiesThisCycle < entityList.size() && (entitiesThisCycle % 10 != 0 || entityLimiter.shouldContinue());tickPosition++, entitiesThisCycle++) {
             tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
             entity = (Entity) this.entityList.get(this.tickPosition);
             // CraftBukkit end
@@ -1449,8 +1540,16 @@
 
             this.methodProfiler.b();
         }
+        /*
+        try {
+            SpigotWorldConfig.dotickpool_executor.submit(SpigotWorldConfig.futureTask);
+        } catch(Exception ex){
+            System.out.println(ex);
+        }*/
+        //
+        //SpigotWorldConfig.movepool_executor.awaitTermination(5, TimeUnit.MILLISECONDS);
         guardEntityList = false; // Spigot
-
+        
         timings.entityTick.stopTiming(); // Spigot
         this.methodProfiler.c("blockEntities");
         timings.tileEntityTick.startTiming(); // Spigot
@@ -1465,9 +1564,7 @@
 
         // Spigot start
         int tilesThisCycle = 0;
-        for (tileLimiter.initTick();
-                tilesThisCycle < tileEntityList.size() && (tilesThisCycle % 10 != 0 || tileLimiter.shouldContinue());
-                tileTickPosition++, tilesThisCycle++) {
+        for (tileLimiter.initTick();tilesThisCycle < tileEntityList.size() && (tilesThisCycle % 10 != 0 || tileLimiter.shouldContinue());tileTickPosition++, tilesThisCycle++) {
             tileTickPosition = (tileTickPosition < tileEntityList.size()) ? tileTickPosition : 0;
             TileEntity tileentity = (TileEntity) this.tileEntityList.get(tileTickPosition);
             // Spigot start
@@ -1485,6 +1582,7 @@
                 if (this.isLoaded(blockposition) && this.N.a(blockposition)) {
                     try {
                         tileentity.tickTimer.startTiming(); // Spigot
+                        //((IUpdatePlayerListBox) tileentity).c();
                         ((IUpdatePlayerListBox) tileentity).c();
                     } catch (Throwable throwable2) {
                         CrashReport crashreport1 = CrashReport.a(throwable2, "Ticking block entity");
@@ -1548,6 +1646,7 @@
         timings.tileEntityPending.stopTiming(); // Spigot
         this.methodProfiler.b();
         this.methodProfiler.b();
+        //SpigotWorldConfig.dotickpool_executor.awaitTermination(5, TimeUnit.MILLISECONDS);
     }
 
     public boolean a(TileEntity tileentity) {
diff -Naur src_origin/main/java/net/minecraft/server/WorldServer.java src_new/main/java/net/minecraft/server/WorldServer.java
--- src_origin/main/java/net/minecraft/server/WorldServer.java	2016-02-05 01:52:12.055370903 +0800
+++ src_new/main/java/net/minecraft/server/WorldServer.java	2016-02-10 12:21:07.125812516 +0800
@@ -18,6 +18,7 @@
 
 // CraftBukkit start
 import java.util.*;
+import java.util.concurrent.FutureTask;
 import java.util.logging.Level;
 
 import org.bukkit.WeatherType;
@@ -27,6 +28,9 @@
 
 import org.bukkit.event.block.BlockFormEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
+import org.hose.TickPendingPool;
+import org.hose.TimeUpdateThread;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public class WorldServer extends World implements IAsyncTaskHandler {
@@ -48,7 +52,8 @@
     private WorldServer.BlockActionDataList[] S = new WorldServer.BlockActionDataList[] { new WorldServer.BlockActionDataList(null), new WorldServer.BlockActionDataList(null)};
     private int T;
     private static final List<StructurePieceTreasure> U = Lists.newArrayList(new StructurePieceTreasure[] { new StructurePieceTreasure(Items.STICK, 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.PLANKS), 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG), 0, 1, 3, 10), new StructurePieceTreasure(Items.STONE_AXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_AXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.STONE_PICKAXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_PICKAXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.APPLE, 0, 2, 3, 5), new StructurePieceTreasure(Items.BREAD, 0, 2, 3, 3), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG2), 0, 1, 3, 10)});
-    private List<NextTickListEntry> V = Lists.newArrayList();
+    //private List<NextTickListEntry> V = Lists.newArrayList();
+    public List<NextTickListEntry> V = Lists.newArrayList();
 
     // CraftBukkit start
     public final int dimension;
@@ -237,13 +242,16 @@
         if (j != this.ab()) {
             this.c(j);
         }
-
+        
+        //SpigotWorldConfig.timeupdatethread_executor.execute(new TimeUpdateThread(this));
+        
         this.worldData.setTime(this.worldData.getTime() + 1L);
         if (this.getGameRules().getBoolean("doDaylightCycle")) {
             this.worldData.setDayTime(this.worldData.getDayTime() + 1L);
         }
 
         timings.doChunkUnload.stopTiming(); // Spigot
+        //HOSE
         this.methodProfiler.c("tickPending");
         timings.doTickPending.startTiming(); // Spigot
         this.a(false);
@@ -585,7 +593,7 @@
 
     }
 
-    public void tickEntities() {
+    public void tickEntities() throws InterruptedException {
         if (false && this.players.isEmpty()) { // CraftBukkit - this prevents entity cleanup, other issues on servers with no players
             if (this.emptyTime++ >= 1200) {
                 return;
@@ -624,33 +632,39 @@
                 this.methodProfiler.a("cleaning");
 
                 NextTickListEntry nextticklistentry;
+                try{
+                    for (int j = 0; j < i; ++j) {
+                        nextticklistentry = (NextTickListEntry) this.M.first();
+                        if (!flag && nextticklistentry.b > this.worldData.getTime()) {
+                            break;
+                        }
 
-                for (int j = 0; j < i; ++j) {
-                    nextticklistentry = (NextTickListEntry) this.M.first();
-                    if (!flag && nextticklistentry.b > this.worldData.getTime()) {
-                        break;
+                        // CraftBukkit - use M, PAIL: Rename nextTickList
+                        this.M.remove(nextticklistentry);
+                        this.V.add(nextticklistentry);
                     }
-
-                    // CraftBukkit - use M, PAIL: Rename nextTickList
-                    this.M.remove(nextticklistentry);
-                    this.V.add(nextticklistentry);
+                }catch (Exception ex){
+                        
                 }
 
                 this.methodProfiler.b();
                 this.methodProfiler.a("ticking");
                 Iterator iterator = this.V.iterator();
-
                 while (iterator.hasNext()) {
                     nextticklistentry = (NextTickListEntry) iterator.next();
                     iterator.remove();
                     byte b0 = 0;
-
                     if (this.areChunksLoadedBetween(nextticklistentry.a.a(-b0, -b0, -b0), nextticklistentry.a.a(b0, b0, b0))) {
                         IBlockData iblockdata = this.getType(nextticklistentry.a);
 
                         if (iblockdata.getBlock().getMaterial() != Material.AIR && Block.a(iblockdata.getBlock(), nextticklistentry.a())) {
                             try {
                                 iblockdata.getBlock().b((World) this, nextticklistentry.a, iblockdata, this.random);
+                                //HOSE
+                                //SpigotWorldConfig.TickPendingTask = new FutureTask(new TickPendingPool(this, iblockdata, nextticklistentry, true));
+                                //SpigotWorldConfig.tickpendingpool_executor.submit(SpigotWorldConfig.TickPendingTask);
+                
+                                
                             } catch (Throwable throwable) {
                                 CrashReport crashreport = CrashReport.a(throwable, "Exception while ticking a block");
                                 CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being ticked");
@@ -660,7 +674,10 @@
                             }
                         }
                     } else {
-                        this.a(nextticklistentry.a, nextticklistentry.a(), 0);
+                        //this.a(nextticklistentry.a, nextticklistentry.a(), 0);
+                        //HOSE
+                        SpigotWorldConfig.TickPendingTask = new FutureTask(new TickPendingPool(this, null, nextticklistentry, false));
+                        SpigotWorldConfig.tickpendingpool_executor.submit(SpigotWorldConfig.TickPendingTask);
                     }
                 }
 
@@ -692,24 +709,27 @@
             } else {
                 iterator = this.V.iterator();
             }
+            try{
+                while (iterator.hasNext()) {
+                    NextTickListEntry nextticklistentry = (NextTickListEntry) iterator.next();
+                    BlockPosition blockposition = nextticklistentry.a;
 
-            while (iterator.hasNext()) {
-                NextTickListEntry nextticklistentry = (NextTickListEntry) iterator.next();
-                BlockPosition blockposition = nextticklistentry.a;
+                    if (blockposition.getX() >= structureboundingbox.a && blockposition.getX() < structureboundingbox.d && blockposition.getZ() >= structureboundingbox.c && blockposition.getZ() < structureboundingbox.f) {
+                        if (flag) {
+                            // CraftBukkit - use M
+                            iterator.remove();
+                        }
 
-                if (blockposition.getX() >= structureboundingbox.a && blockposition.getX() < structureboundingbox.d && blockposition.getZ() >= structureboundingbox.c && blockposition.getZ() < structureboundingbox.f) {
-                    if (flag) {
-                        // CraftBukkit - use M
-                        iterator.remove();
-                    }
+                        if (arraylist == null) {
+                            arraylist = Lists.newArrayList();
+                        }
 
-                    if (arraylist == null) {
-                        arraylist = Lists.newArrayList();
+                        arraylist.add(nextticklistentry);
                     }
-
-                    arraylist.add(nextticklistentry);
                 }
-            }
+            } catch(Exception ex) {
+            
+            }    
         }
 
         return arraylist;
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java src_new/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java
--- src_origin/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java	2016-02-05 01:52:19.515370541 +0800
+++ src_new/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java	2016-02-10 12:21:08.476812643 +0800
@@ -117,7 +117,7 @@
     }
 
     public boolean hasOwner() {
-        return profile != null && profile.getName() != null;
+        return profile != null;
     }
 
     public String getOwner() {
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/Main.java src_new/main/java/org/bukkit/craftbukkit/Main.java
--- src_origin/main/java/org/bukkit/craftbukkit/Main.java	2016-02-05 01:52:12.823370866 +0800
+++ src_new/main/java/org/bukkit/craftbukkit/Main.java	2016-02-10 12:21:07.254812528 +0800
@@ -2,8 +2,10 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.Arrays;
+import java.util.Date;
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -18,6 +20,22 @@
 
     public static void main(String[] args) {
         // Todo: Installation script
+        /*
+        //trial for 7 days
+        try {
+            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
+            Date date_now = new Date();
+            Date date1 = sdf.parse(sdf.format(date_now));
+            Date expdate = sdf.parse("2016-02-16");
+            if(date1.compareTo(expdate)>0){
+                System.out.println("Trial has expired.");
+                System.exit(0);
+            }
+        } catch (ParseException ex) {
+            Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
+        }*/
+        
+        
         OptionParser parser = new OptionParser() {
             {
                 acceptsAll(asList("?", "help"), "Show the help");
diff -Naur src_origin/main/java/org/hose/AddEntityPool.java src_new/main/java/org/hose/AddEntityPool.java
--- src_origin/main/java/org/hose/AddEntityPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/AddEntityPool.java	2016-02-10 12:21:04.997812317 +0800
@@ -0,0 +1,49 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.World;
+import net.minecraft.server.WorldServer;
+import org.bukkit.Bukkit;
+import org.bukkit.event.entity.CreatureSpawnEvent;
+import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
+
+/**
+ *
+ * @author you
+ */
+public class AddEntityPool implements Callable<Boolean>{
+    private Entity en;
+    private World w;
+    private SpawnReason sR;
+    
+    public AddEntityPool(World w, Entity en, SpawnReason sR){
+        this.w = w;
+        this.en = en;
+        this.sR = sR;
+    }
+    /*
+    @Override
+    public void run() {
+        try {
+            synchronized(this) {
+                //this.R.a(this, this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldData.getTime() % 400L == 0L);
+                //ws.R.a(ws, flag, flag1, flag2);
+            }
+        } catch(Exception ex) {
+            //Bukkit.getLogger().warning("An entity is missing in MobSpawnerPool!");
+        }
+    }*/
+
+    @Override
+    public Boolean call() throws Exception {
+        //worldserver.addEntity(entityinsentient, SpawnReason.NATURAL); // CraftBukkit - Added a reason for spawning this creature
+        return w.addEntity_run(en, SpawnReason.NATURAL);
+    }
+}
diff -Naur src_origin/main/java/org/hose/AddEntityTrackPool.java src_new/main/java/org/hose/AddEntityTrackPool.java
--- src_origin/main/java/org/hose/AddEntityTrackPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/AddEntityTrackPool.java	2016-02-10 12:21:05.001812318 +0800
@@ -0,0 +1,51 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityTracker;
+import net.minecraft.server.World;
+
+/**
+ *
+ * @author you
+ */
+public class AddEntityTrackPool implements Callable{
+    private Entity en;
+    private World w;
+    private EntityTracker et;
+    private int i;
+    private int j;
+    boolean flag;
+    
+    public AddEntityTrackPool(EntityTracker et, Entity en, int i, final int j, boolean flag){
+        this.et = et;
+        this.en = en;
+        this.i = i;
+        this.j = j;
+        this.flag = flag;
+    }
+    /*
+    @Override
+    public void run() {
+        try {
+            synchronized(this) {
+                //this.R.a(this, this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldData.getTime() % 400L == 0L);
+                //ws.R.a(ws, flag, flag1, flag2);
+            }
+        } catch(Exception ex) {
+            //Bukkit.getLogger().warning("An entity is missing in MobSpawnerPool!");
+        }
+    }*/
+
+    @Override
+    public Object call() throws Exception {
+        //
+        et.addEntity_run(en, i, j, flag);
+        return null;
+    }
+}
diff -Naur src_origin/main/java/org/hose/AntiXrayPool.java src_new/main/java/org/hose/AntiXrayPool.java
--- src_origin/main/java/org/hose/AntiXrayPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/AntiXrayPool.java	2016-02-10 12:21:05.010812318 +0800
@@ -0,0 +1,32 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.World;
+/**
+ *
+ * @author you
+ */
+public class AntiXrayPool implements Callable{
+    private BlockPosition p;
+    private World w;
+   
+    public AntiXrayPool(World w, BlockPosition p){
+        this.w = w;
+        this.p = p;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+
+        w.notify(p);
+        return null;
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/BreakException.java src_new/main/java/org/hose/BreakException.java
--- src_origin/main/java/org/hose/BreakException.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/BreakException.java	2016-02-10 12:21:05.013812319 +0800
@@ -0,0 +1,16 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+/**
+ *
+ * @author you
+ */
+public class BreakException extends RuntimeException {
+    
+    public BreakException() {
+    }
+}
diff -Naur src_origin/main/java/org/hose/ChunkPool.java src_new/main/java/org/hose/ChunkPool.java
--- src_origin/main/java/org/hose/ChunkPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/ChunkPool.java	2016-02-10 12:21:05.028812320 +0800
@@ -0,0 +1,42 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkProviderServer;
+
+/**
+ *
+ * @author you
+ */
+public class ChunkPool implements Callable{
+
+    private ChunkProviderServer cps;
+    private Chunk c;
+    private int i;
+    private int j;
+    
+    public ChunkPool(ChunkProviderServer cps, Chunk c, int i, int j){
+        this.cps = cps;
+        this.c = c;
+        this.i = i;
+        this.j = j;
+    }
+
+
+    @Override
+    public Chunk call(){
+        try {
+            //chunk = this.chunkProvider.getOrCreateChunk(i, j);
+            c = cps.chunkProvider.getOrCreateChunk(i, i);
+        } catch(Exception ex) {
+            //Bukkit.getLogger().warning("An entity is missing in MovePool!");
+        }
+        return c;
+    }
+    
+}
diff -Naur src_origin/main/java/org/hose/DeSpawnPool.java src_new/main/java/org/hose/DeSpawnPool.java
--- src_origin/main/java/org/hose/DeSpawnPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/DeSpawnPool.java	2016-02-10 12:21:05.037812321 +0800
@@ -0,0 +1,38 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.World;
+
+/**
+ *
+ * @author you
+ */
+public class DeSpawnPool  implements Runnable{
+    private EntityInsentient ei;
+
+    public DeSpawnPool(EntityInsentient ei) {
+        this.ei = ei;
+    }
+    
+    @Override
+    public void run() {
+        try {
+            ei.D();
+            //synchronized(this) {
+                //SpigotWorldConfig.itemDespawnCount = 0;
+            //}
+            //System.out.println(SpigotWorldConfig.itemDespawnCount);
+        } catch (Exception ex) {
+            
+        }
+        
+    }
+    
+}
diff -Naur src_origin/main/java/org/hose/MovePool.java src_new/main/java/org/hose/MovePool.java
--- src_origin/main/java/org/hose/MovePool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/MovePool.java	2016-02-10 12:21:05.039812321 +0800
@@ -0,0 +1,47 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import net.minecraft.server.EntityLiving;
+/**
+ *
+ * @author you
+ */
+//public class MovePool extends RecursiveAction{
+public class MovePool implements Runnable{
+    private EntityLiving el;
+    private float aZ;
+    private float ba;
+    
+    public MovePool(EntityLiving el, float aZ, float ba){
+        this.el = el;
+        this.aZ = aZ;
+        this.ba = ba;
+    }
+    /*
+    @Override
+    protected void compute() {
+        try {
+            //synchronized(this) {
+                //this.g(this.aZ, this.ba);
+                el.g(aZ, ba);
+                fork();
+            //}
+        } catch(Exception ex) {
+            //Bukkit.getLogger().warning("An entity is missing in MovePool!");
+        }
+    }*/
+
+    @Override
+    public void run() {
+        try {
+            //this.g(this.aZ, this.ba);
+            el.g(aZ, ba);
+        } catch(Exception ex) {
+            //Bukkit.getLogger().warning("An entity is missing in MovePool!");
+        }
+    }
+}
diff -Naur src_origin/main/java/org/hose/MSPool.java src_new/main/java/org/hose/MSPool.java
--- src_origin/main/java/org/hose/MSPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/MSPool.java	2016-02-10 12:21:05.053812322 +0800
@@ -0,0 +1,27 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.WorldServer;
+/**
+ *
+ * @author you
+ */
+public class MSPool implements Callable{
+    private WorldServer ws;
+    public MSPool(WorldServer ws){
+        //this.el = el;
+        this.ws = ws;
+    }
+   
+    @Override
+    public Object call() throws Exception {
+        ws.doTick();
+        return null;
+    }
+}
diff -Naur src_origin/main/java/org/hose/TickEntityPool.java src_new/main/java/org/hose/TickEntityPool.java
--- src_origin/main/java/org/hose/TickEntityPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/TickEntityPool.java	2016-02-10 12:21:05.060812323 +0800
@@ -0,0 +1,122 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+//import java.util.concurrent.RecursiveAction;
+import java.util.concurrent.Callable;
+import net.minecraft.server.EntityInsentient;
+
+
+/**
+ *
+ * @author you
+ */
+public class TickEntityPool implements Callable{
+    private EntityInsentient ei;
+        
+    
+    public TickEntityPool(EntityInsentient ei){
+        this.ei = ei;
+    }
+    /*
+    @Override
+    public void run() {
+        try {
+            ei.world.methodProfiler.a("checkDespawn");
+            ei.D();
+            //SpigotWorldConfig.despawnpool_executor.execute(new DeSpawnPool(ei));
+            ei.world.methodProfiler.b();
+            // Spigot Start
+            if ( ei.fromMobSpawner )
+            {
+                return;
+            }
+            // Spigot End
+            ei.world.methodProfiler.a("sensing");
+            ei.bk.a();
+            ei.world.methodProfiler.b();
+            ei.world.methodProfiler.a("targetSelector");
+            ei.targetSelector.a();
+            ei.world.methodProfiler.b();
+            //ei.world.methodProfiler.a("goalSelector");
+            //ei.goalSelector.a();
+            ei.world.methodProfiler.b();
+            //ei.world.methodProfiler.a("navigation");
+            //ei.navigation.k();
+            //ei.world.methodProfiler.b();
+            //ei.world.methodProfiler.a("mob tick");
+            //ei.E();
+            ei.world.methodProfiler.b();
+            ei.world.methodProfiler.a("controls");
+            
+            ei.world.methodProfiler.a("move");
+            ei.moveController.c();
+            ei.world.methodProfiler.c("look");
+            ei.lookController.a();
+            ei.world.methodProfiler.c("jump");
+            ei.g.b();
+            ei.world.methodProfiler.b();
+            ei.world.methodProfiler.b();
+        } catch(Exception ex) {
+            //Bukkit.getLogger().warning("An entity is missing in TickEntityPool!");
+        }
+    }*/
+    /*
+    @Override
+    protected void compute() {
+        try {
+            //w.runtick(entity);
+        } catch(Exception ex) {
+            //Bukkit.getLogger().warning("An entity is missing in TickEntityPool!");
+        }
+    }*/
+
+    @Override
+    public Object call() throws Exception {
+        try {
+            ei.world.methodProfiler.a("checkDespawn");
+            ei.D();
+            //SpigotWorldConfig.despawnpool_executor.execute(new DeSpawnPool(ei));
+            ei.world.methodProfiler.b();
+            // Spigot Start
+            if ( ei.fromMobSpawner )
+            {
+                return null;
+            }
+            // Spigot End
+            ei.world.methodProfiler.a("sensing");
+            ei.bk.a();
+            ei.world.methodProfiler.b();
+            ei.world.methodProfiler.a("targetSelector");
+            ei.targetSelector.a();
+            ei.world.methodProfiler.b();
+            /*ei.world.methodProfiler.a("goalSelector");
+            ei.goalSelector.a();*/
+            ei.world.methodProfiler.b();
+            /*ei.world.methodProfiler.a("navigation");
+            ei.navigation.k();
+            ei.world.methodProfiler.b();
+            ei.world.methodProfiler.a("mob tick");
+            ei.E();*/
+            ei.world.methodProfiler.b();
+            ei.world.methodProfiler.a("controls");
+            
+            ei.world.methodProfiler.a("move");
+            ei.moveController.c();
+            ei.world.methodProfiler.c("look");
+            ei.lookController.a();
+            ei.world.methodProfiler.c("jump");
+            ei.g.b();
+            ei.world.methodProfiler.b();
+            ei.world.methodProfiler.b();
+        } catch(Exception ex) {
+            //Bukkit.getLogger().warning("An entity is missing in TickEntityPool!");
+        }
+        return null;
+    }
+
+
+}
diff -Naur src_origin/main/java/org/hose/TickPendingPool.java src_new/main/java/org/hose/TickPendingPool.java
--- src_origin/main/java/org/hose/TickPendingPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/TickPendingPool.java	2016-02-10 12:21:05.067812324 +0800
@@ -0,0 +1,51 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.Callable;
+import net.minecraft.server.Block;
+import net.minecraft.server.CrashReport;
+import net.minecraft.server.CrashReportSystemDetails;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.Material;
+import net.minecraft.server.NextTickListEntry;
+import net.minecraft.server.ReportedException;
+import net.minecraft.server.World;
+import net.minecraft.server.WorldServer;
+/**
+ *
+ * @author you
+ */
+public class TickPendingPool implements Callable{
+    private WorldServer ws;
+    private NextTickListEntry ntle;
+    private IBlockData ibd;
+    private boolean bool;
+    
+    public TickPendingPool(WorldServer w, IBlockData ibd, NextTickListEntry ntle, boolean bool){
+        this.ws = ws;
+        this.ibd = ibd;
+        this.ntle = ntle;
+        this.bool = bool;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+        if (bool){
+            //iblockdata.getBlock().b((World) this, nextticklistentry.a, iblockdata, this.random);
+            ibd.getBlock().b((World) ws, ntle.a, ibd, ws.random);
+        } else {
+            //this.a(nextticklistentry.a, nextticklistentry.a(), 0);
+            ws.a(ntle.a, ntle.a(), 0);
+        }
+        
+        return null;
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/TimeUpdateThread.java src_new/main/java/org/hose/TimeUpdateThread.java
--- src_origin/main/java/org/hose/TimeUpdateThread.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/TimeUpdateThread.java	2016-02-10 12:21:05.070812324 +0800
@@ -0,0 +1,38 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import net.minecraft.server.WorldServer;
+import net.openhft.affinity.AffinityLock;
+
+/**
+ *
+ * @author softpak
+ */
+public class TimeUpdateThread implements Runnable{
+    private WorldServer ws;
+
+    
+    public TimeUpdateThread(WorldServer ws){
+        this.ws = ws;
+    }
+    
+    @Override
+    public void run() {
+        AffinityLock al = AffinityLock.acquireLock();
+        try {
+            ws.worldData.setTime(ws.worldData.getTime() + 1L);
+            if (ws.getGameRules().getBoolean("doDaylightCycle")) {
+                ws.worldData.setDayTime(ws.worldData.getDayTime() + 1L);
+            }
+        }catch(Exception ex){
+            
+        }finally{
+            al.release();
+        }
+    }
+    
+}
diff -Naur src_origin/main/java/org/hose/WorldTickEntityPool.java src_new/main/java/org/hose/WorldTickEntityPool.java
--- src_origin/main/java/org/hose/WorldTickEntityPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/WorldTickEntityPool.java	2016-02-10 12:21:05.079812325 +0800
@@ -0,0 +1,44 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+//import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityInsentient;
+
+
+/**
+ *
+ * @author you
+ */
+public class WorldTickEntityPool implements Runnable{
+    private Entity en;
+        
+    
+    public WorldTickEntityPool(Entity en){
+        this.en = en;
+    }
+    
+    @Override
+    public void run() {
+        try {
+            en.t_();
+        } catch(Exception ex) {
+            //Bukkit.getLogger().warning("An entity is missing in TickEntityPool!");
+        }
+    }
+    /*
+    @Override
+    protected void compute() {
+        try {
+            //w.runtick(entity);
+        } catch(Exception ex) {
+            //Bukkit.getLogger().warning("An entity is missing in TickEntityPool!");
+        }
+    }*/
+
+
+}
diff -Naur src_origin/main/java/org/spigotmc/AntiXray.java src_new/main/java/org/spigotmc/AntiXray.java
--- src_origin/main/java/org/spigotmc/AntiXray.java	2016-02-05 01:52:00.808371449 +0800
+++ src_new/main/java/org/spigotmc/AntiXray.java	2016-02-10 12:21:05.125812329 +0800
@@ -2,11 +2,13 @@
 
 import gnu.trove.set.TByteSet;
 import gnu.trove.set.hash.TByteHashSet;
+import java.util.concurrent.FutureTask;
 import net.minecraft.server.Block;
 import net.minecraft.server.BlockPosition;
 import net.minecraft.server.Blocks;
 import net.minecraft.server.World;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.hose.AntiXrayPool;
 
 public class AntiXray
 {
@@ -183,7 +185,10 @@
             if ( updateSelf && obfuscateBlocks[Block.getId( block )] )
             {
                 // Send the update
-                world.notify( position );
+                //world.notify( position );
+                //HOSE
+                SpigotWorldConfig.AntiXrayTask = new FutureTask(new AntiXrayPool(world, position));
+                SpigotWorldConfig.antixraypool_executor.submit(SpigotWorldConfig.AntiXrayTask);
             }
 
             // Check other blocks for updates
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src_new/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2016-02-05 01:52:00.859371447 +0800
+++ src_new/main/java/org/spigotmc/AsyncCatcher.java	2016-02-10 12:21:05.121812329 +0800
@@ -9,6 +9,7 @@
 
     public static void catchOp(String reason)
     {
+        
         if ( enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread )
         {
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
diff -Naur src_origin/main/java/org/spigotmc/SpigotWorldConfig.java src_new/main/java/org/spigotmc/SpigotWorldConfig.java
--- src_origin/main/java/org/spigotmc/SpigotWorldConfig.java	2016-02-05 01:52:01.120371434 +0800
+++ src_new/main/java/org/spigotmc/SpigotWorldConfig.java	2016-02-10 12:21:05.174812334 +0800
@@ -1,13 +1,81 @@
 package org.spigotmc;
 
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import java.util.Arrays;
 import java.util.List;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.ThreadFactory;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
+
 public class SpigotWorldConfig
 {
+    /*
+    static final ThreadFactory tfmp = new ThreadFactoryBuilder().setNameFormat("MovePool-%d").build();
+    static public final ExecutorService movepool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tfmp);*/
+    
+    static public FutureTask TickEntityTask;
+    static public FutureTask TickPendingTask;
+    static public FutureTask WSTask;
+    static public FutureTask AddEntityTask;
+    static public FutureTask AddEntityTrackTask;
+    static public FutureTask AntiXrayTask;
+    
+    
+    static final ThreadFactory tpaxt = new ThreadFactoryBuilder().setNameFormat("AntiXrayTask-%d").build();
+    static public final ExecutorService antixraypool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tpaxt);
+            
+    static final ThreadFactory tptpt = new ThreadFactoryBuilder().setNameFormat("TickPendingTask-%d").build();
+    static public final ExecutorService tickpendingpool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tptpt);
+    
+    
+    static final ThreadFactory tpaep = new ThreadFactoryBuilder().setNameFormat("AddEntityTask-%d").build();
+    static public final ExecutorService addentitypool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tpaep);
+    
+    static final ThreadFactory tpaetp = new ThreadFactoryBuilder().setNameFormat("AddEntityTrackTask-%d").build();
+    static public final ExecutorService addentitytrackpool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tpaetp);
+    
+    static final ThreadFactory tftut = new ThreadFactoryBuilder().setNameFormat("TimeUpdateThread-%d").build();
+    static public final Executor timeupdatethread_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tftut);
+    
+    static final ThreadFactory tfms = new ThreadFactoryBuilder().setNameFormat("MSPool-%d").build();
+    static public final ExecutorService mspool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tfms);
+    
+    //static final ThreadFactory tfmsp = new ThreadFactoryBuilder().setNameFormat("MSPool-%d").build();
+    //static public final Executor mspool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tfmsp);
+    //static public final ForkJoinPool mspool_executor = new ForkJoinPool(Runtime.getRuntime().availableProcessors());
+    
+    static int worldtickentitypool_core_multiple;
+    private void wetp_core_multiple()
+    {
+        worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 1);
+        dotickpool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()*worldtickentitypool_core_multiple, tfdsp);
+        log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
+        
+    }
+    
+    static final ThreadFactory tfdsp = new ThreadFactoryBuilder().setNameFormat("DoTickPool-%d").build();
+    static public ExecutorService dotickpool_executor;// = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tfdsp);
+    
+    /*
+    static final ThreadFactory tptep = new ThreadFactoryBuilder().setNameFormat("TickEntityPool-%d").build();
+    static public final ExecutorService tickentitypool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tptep);
+    */
+    //static public final ForkJoinPool tickentitypool = new ForkJoinPool(Runtime.getRuntime().availableProcessors());
+    
+    
+    
+    /*
+    static final ThreadFactory tpcps = new ThreadFactoryBuilder().setNameFormat("ChunkPool-%d").build();
+    static public final ExecutorService chunkpool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tpcps);
+    */
 
+    
+    
     private final String worldName;
     private final YamlConfiguration config;
     private boolean verbose;
@@ -341,4 +409,10 @@
         entityMaxTickTime = getInt("max-tick-time.entity", 50);
         log("Tile Max Tick Time: " + tileMaxTickTime + "ms Entity max Tick Time: " + entityMaxTickTime + "ms");
     }
+    
+    
+    /*
+    static final ThreadFactory tfwtep = new ThreadFactoryBuilder().setNameFormat("WorldTickEntityPool-%d").build();
+    static public ExecutorService wtepool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()*6, tfwtep);*/
+    
 }
