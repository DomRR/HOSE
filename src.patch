diff -Naur src_origin/main/java/net/minecraft/server/BlockButtonAbstract.java src/main/java/net/minecraft/server/BlockButtonAbstract.java
--- src_origin/main/java/net/minecraft/server/BlockButtonAbstract.java	2016-05-29 15:00:13.700641645 +0800
+++ src/main/java/net/minecraft/server/BlockButtonAbstract.java	2016-06-08 13:02:33.518102585 +0800
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import java.util.List;
+import java.util.Queue;
 import java.util.Random;
 import javax.annotation.Nullable;
 
@@ -214,6 +215,7 @@
 
     private void e(IBlockData iblockdata, World world, BlockPosition blockposition) {
         List list = world.a(EntityArrow.class, iblockdata.c(world, blockposition).a(blockposition));
+        //Queue list = world.a(EntityArrow.class, iblockdata.c(world, blockposition).a(blockposition));
         boolean flag = !list.isEmpty();
         boolean flag1 = ((Boolean) iblockdata.get(BlockButtonAbstract.POWERED)).booleanValue();
 
diff -Naur src_origin/main/java/net/minecraft/server/BlockCactus.java src/main/java/net/minecraft/server/BlockCactus.java
--- src_origin/main/java/net/minecraft/server/BlockCactus.java	2016-05-29 15:00:13.729641642 +0800
+++ src/main/java/net/minecraft/server/BlockCactus.java	2016-06-08 13:02:33.542102583 +0800
@@ -89,7 +89,8 @@
         return false;
     }
 
-    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, Entity entity) {
+    //public void a(World world, BlockPosition blockposition, IBlockData iblockdata, Entity entity) {
+    public synchronized void a(World world, BlockPosition blockposition, IBlockData iblockdata, Entity entity) {
         CraftEventFactory.blockDamage = world.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()); // CraftBukkit
         entity.damageEntity(DamageSource.CACTUS, 1.0F);
         CraftEventFactory.blockDamage = null; // CraftBukkit
diff -Naur src_origin/main/java/net/minecraft/server/BlockChest.java src/main/java/net/minecraft/server/BlockChest.java
--- src_origin/main/java/net/minecraft/server/BlockChest.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/BlockChest.java	2016-06-08 13:02:33.583102579 +0800
@@ -0,0 +1,459 @@
+package net.minecraft.server;
+
+import java.util.Iterator;
+import javax.annotation.Nullable;
+
+public class BlockChest extends BlockTileEntity {
+
+    public static final BlockStateDirection FACING = BlockFacingHorizontal.FACING;
+    protected static final AxisAlignedBB b = new AxisAlignedBB(0.0625D, 0.0D, 0.0D, 0.9375D, 0.875D, 0.9375D);
+    protected static final AxisAlignedBB c = new AxisAlignedBB(0.0625D, 0.0D, 0.0625D, 0.9375D, 0.875D, 1.0D);
+    protected static final AxisAlignedBB d = new AxisAlignedBB(0.0D, 0.0D, 0.0625D, 0.9375D, 0.875D, 0.9375D);
+    protected static final AxisAlignedBB e = new AxisAlignedBB(0.0625D, 0.0D, 0.0625D, 1.0D, 0.875D, 0.9375D);
+    protected static final AxisAlignedBB f = new AxisAlignedBB(0.0625D, 0.0D, 0.0625D, 0.9375D, 0.875D, 0.9375D);
+    public final BlockChest.Type g;
+
+    protected BlockChest(BlockChest.Type blockchest_type) {
+        super(Material.WOOD);
+        this.w(this.blockStateList.getBlockData().set(BlockChest.FACING, EnumDirection.NORTH));
+        this.g = blockchest_type;
+        this.a(blockchest_type == BlockChest.Type.TRAP ? CreativeModeTab.d : CreativeModeTab.c);
+    }
+
+    public boolean b(IBlockData iblockdata) {
+        return false;
+    }
+
+    public boolean c(IBlockData iblockdata) {
+        return false;
+    }
+
+    public EnumRenderType a(IBlockData iblockdata) {
+        return EnumRenderType.ENTITYBLOCK_ANIMATED;
+    }
+
+    public AxisAlignedBB a(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
+        return iblockaccess.getType(blockposition.north()).getBlock() == this ? BlockChest.b : (iblockaccess.getType(blockposition.south()).getBlock() == this ? BlockChest.c : (iblockaccess.getType(blockposition.west()).getBlock() == this ? BlockChest.d : (iblockaccess.getType(blockposition.east()).getBlock() == this ? BlockChest.e : BlockChest.f)));
+    }
+
+    public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        this.e(world, blockposition, iblockdata);
+        Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+        while (iterator.hasNext()) {
+            EnumDirection enumdirection = (EnumDirection) iterator.next();
+            BlockPosition blockposition1 = blockposition.shift(enumdirection);
+            IBlockData iblockdata1 = world.getType(blockposition1);
+
+            if (iblockdata1.getBlock() == this) {
+                this.e(world, blockposition1, iblockdata1);
+            }
+        }
+
+    }
+
+    public IBlockData getPlacedState(World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2, int i, EntityLiving entityliving) {
+        return this.getBlockData().set(BlockChest.FACING, entityliving.getDirection());
+    }
+
+    public void postPlace(World world, BlockPosition blockposition, IBlockData iblockdata, EntityLiving entityliving, ItemStack itemstack) {
+        EnumDirection enumdirection = EnumDirection.fromType2(MathHelper.floor((double) (entityliving.yaw * 4.0F / 360.0F) + 0.5D) & 3).opposite();
+
+        iblockdata = iblockdata.set(BlockChest.FACING, enumdirection);
+        BlockPosition blockposition1 = blockposition.north();
+        BlockPosition blockposition2 = blockposition.south();
+        BlockPosition blockposition3 = blockposition.west();
+        BlockPosition blockposition4 = blockposition.east();
+        boolean flag = this == world.getType(blockposition1).getBlock();
+        boolean flag1 = this == world.getType(blockposition2).getBlock();
+        boolean flag2 = this == world.getType(blockposition3).getBlock();
+        boolean flag3 = this == world.getType(blockposition4).getBlock();
+
+        if (!flag && !flag1 && !flag2 && !flag3) {
+            world.setTypeAndData(blockposition, iblockdata, 3);
+        } else if (enumdirection.k() == EnumDirection.EnumAxis.X && (flag || flag1)) {
+            if (flag) {
+                world.setTypeAndData(blockposition1, iblockdata, 3);
+            } else {
+                world.setTypeAndData(blockposition2, iblockdata, 3);
+            }
+
+            world.setTypeAndData(blockposition, iblockdata, 3);
+        } else if (enumdirection.k() == EnumDirection.EnumAxis.Z && (flag2 || flag3)) {
+            if (flag2) {
+                world.setTypeAndData(blockposition3, iblockdata, 3);
+            } else {
+                world.setTypeAndData(blockposition4, iblockdata, 3);
+            }
+
+            world.setTypeAndData(blockposition, iblockdata, 3);
+        }
+
+        if (itemstack.hasName()) {
+            TileEntity tileentity = world.getTileEntity(blockposition);
+
+            if (tileentity instanceof TileEntityChest) {
+                ((TileEntityChest) tileentity).a(itemstack.getName());
+            }
+        }
+
+    }
+
+    public IBlockData e(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        if (world.isClientSide) {
+            return iblockdata;
+        } else {
+            IBlockData iblockdata1 = world.getType(blockposition.north());
+            IBlockData iblockdata2 = world.getType(blockposition.south());
+            IBlockData iblockdata3 = world.getType(blockposition.west());
+            IBlockData iblockdata4 = world.getType(blockposition.east());
+            EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockChest.FACING);
+
+            if (iblockdata1.getBlock() != this && iblockdata2.getBlock() != this) {
+                boolean flag = iblockdata1.b();
+                boolean flag1 = iblockdata2.b();
+
+                if (iblockdata3.getBlock() == this || iblockdata4.getBlock() == this) {
+                    BlockPosition blockposition1 = iblockdata3.getBlock() == this ? blockposition.west() : blockposition.east();
+                    IBlockData iblockdata5 = world.getType(blockposition1.north());
+                    IBlockData iblockdata6 = world.getType(blockposition1.south());
+
+                    enumdirection = EnumDirection.SOUTH;
+                    EnumDirection enumdirection1;
+
+                    if (iblockdata3.getBlock() == this) {
+                        enumdirection1 = (EnumDirection) iblockdata3.get(BlockChest.FACING);
+                    } else {
+                        enumdirection1 = (EnumDirection) iblockdata4.get(BlockChest.FACING);
+                    }
+
+                    if (enumdirection1 == EnumDirection.NORTH) {
+                        enumdirection = EnumDirection.NORTH;
+                    }
+
+                    if ((flag || iblockdata5.b()) && !flag1 && !iblockdata6.b()) {
+                        enumdirection = EnumDirection.SOUTH;
+                    }
+
+                    if ((flag1 || iblockdata6.b()) && !flag && !iblockdata5.b()) {
+                        enumdirection = EnumDirection.NORTH;
+                    }
+                }
+            } else {
+                BlockPosition blockposition2 = iblockdata1.getBlock() == this ? blockposition.north() : blockposition.south();
+                IBlockData iblockdata7 = world.getType(blockposition2.west());
+                IBlockData iblockdata8 = world.getType(blockposition2.east());
+
+                enumdirection = EnumDirection.EAST;
+                EnumDirection enumdirection2;
+
+                if (iblockdata1.getBlock() == this) {
+                    enumdirection2 = (EnumDirection) iblockdata1.get(BlockChest.FACING);
+                } else {
+                    enumdirection2 = (EnumDirection) iblockdata2.get(BlockChest.FACING);
+                }
+
+                if (enumdirection2 == EnumDirection.WEST) {
+                    enumdirection = EnumDirection.WEST;
+                }
+
+                if ((iblockdata3.b() || iblockdata7.b()) && !iblockdata4.b() && !iblockdata8.b()) {
+                    enumdirection = EnumDirection.EAST;
+                }
+
+                if ((iblockdata4.b() || iblockdata8.b()) && !iblockdata3.b() && !iblockdata7.b()) {
+                    enumdirection = EnumDirection.WEST;
+                }
+            }
+
+            iblockdata = iblockdata.set(BlockChest.FACING, enumdirection);
+            world.setTypeAndData(blockposition, iblockdata, 3);
+            return iblockdata;
+        }
+    }
+
+    public IBlockData f(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        EnumDirection enumdirection = null;
+        Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+        while (iterator.hasNext()) {
+            EnumDirection enumdirection1 = (EnumDirection) iterator.next();
+            IBlockData iblockdata1 = world.getType(blockposition.shift(enumdirection1));
+
+            if (iblockdata1.getBlock() == this) {
+                return iblockdata;
+            }
+
+            if (iblockdata1.b()) {
+                if (enumdirection != null) {
+                    enumdirection = null;
+                    break;
+                }
+
+                enumdirection = enumdirection1;
+            }
+        }
+
+        if (enumdirection != null) {
+            return iblockdata.set(BlockChest.FACING, enumdirection.opposite());
+        } else {
+            EnumDirection enumdirection2 = (EnumDirection) iblockdata.get(BlockChest.FACING);
+
+            if (world.getType(blockposition.shift(enumdirection2)).b()) {
+                enumdirection2 = enumdirection2.opposite();
+            }
+
+            if (world.getType(blockposition.shift(enumdirection2)).b()) {
+                enumdirection2 = enumdirection2.e();
+            }
+
+            if (world.getType(blockposition.shift(enumdirection2)).b()) {
+                enumdirection2 = enumdirection2.opposite();
+            }
+
+            return iblockdata.set(BlockChest.FACING, enumdirection2);
+        }
+    }
+
+    public boolean canPlace(World world, BlockPosition blockposition) {
+        int i = 0;
+        BlockPosition blockposition1 = blockposition.west();
+        BlockPosition blockposition2 = blockposition.east();
+        BlockPosition blockposition3 = blockposition.north();
+        BlockPosition blockposition4 = blockposition.south();
+
+        if (world.getType(blockposition1).getBlock() == this) {
+            if (this.d(world, blockposition1)) {
+                return false;
+            }
+
+            ++i;
+        }
+
+        if (world.getType(blockposition2).getBlock() == this) {
+            if (this.d(world, blockposition2)) {
+                return false;
+            }
+
+            ++i;
+        }
+
+        if (world.getType(blockposition3).getBlock() == this) {
+            if (this.d(world, blockposition3)) {
+                return false;
+            }
+
+            ++i;
+        }
+
+        if (world.getType(blockposition4).getBlock() == this) {
+            if (this.d(world, blockposition4)) {
+                return false;
+            }
+
+            ++i;
+        }
+
+        return i <= 1;
+    }
+
+    private boolean d(World world, BlockPosition blockposition) {
+        if (world.getType(blockposition).getBlock() != this) {
+            return false;
+        } else {
+            Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+            EnumDirection enumdirection;
+
+            do {
+                if (!iterator.hasNext()) {
+                    return false;
+                }
+
+                enumdirection = (EnumDirection) iterator.next();
+            } while (world.getType(blockposition.shift(enumdirection)).getBlock() != this);
+
+            return true;
+        }
+    }
+
+    public void a(IBlockData iblockdata, World world, BlockPosition blockposition, Block block) {
+        super.a(iblockdata, world, blockposition, block);
+        TileEntity tileentity = world.getTileEntity(blockposition);
+
+        if (tileentity instanceof TileEntityChest) {
+            tileentity.invalidateBlockCache();
+        }
+
+    }
+
+    public void remove(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        TileEntity tileentity = world.getTileEntity(blockposition);
+
+        if (tileentity instanceof IInventory) {
+            InventoryUtils.dropInventory(world, blockposition, (IInventory) tileentity);
+            world.updateAdjacentComparators(blockposition, this);
+        }
+
+        super.remove(world, blockposition, iblockdata);
+    }
+
+    public boolean interact(World world, BlockPosition blockposition, IBlockData iblockdata, EntityHuman entityhuman, EnumHand enumhand, @Nullable ItemStack itemstack, EnumDirection enumdirection, float f, float f1, float f2) {
+        if (world.isClientSide) {
+            return true;
+        } else {
+            ITileInventory itileinventory = this.c(world, blockposition);
+
+            if (itileinventory != null) {
+                entityhuman.openContainer(itileinventory);
+                if (this.g == BlockChest.Type.BASIC) {
+                    entityhuman.b(StatisticList.ac);
+                } else if (this.g == BlockChest.Type.TRAP) {
+                    entityhuman.b(StatisticList.W);
+                }
+            }
+
+            return true;
+        }
+    }
+
+    @Nullable
+    public ITileInventory c(World world, BlockPosition blockposition) {
+        return this.a(world, blockposition, false);
+    }
+
+    @Nullable
+    public ITileInventory a(World world, BlockPosition blockposition, boolean flag) {
+        TileEntity tileentity = world.getTileEntity(blockposition);
+
+        if (!(tileentity instanceof TileEntityChest)) {
+            return null;
+        } else {
+            Object object = (TileEntityChest) tileentity;
+
+            if (!flag && this.e(world, blockposition)) {
+                return null;
+            } else {
+                Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+                while (iterator.hasNext()) {
+                    EnumDirection enumdirection = (EnumDirection) iterator.next();
+                    BlockPosition blockposition1 = blockposition.shift(enumdirection);
+                    Block block = world.getType(blockposition1).getBlock();
+
+                    if (block == this) {
+                        if (this.e(world, blockposition1)) {
+                            return null;
+                        }
+
+                        TileEntity tileentity1 = world.getTileEntity(blockposition1);
+
+                        if (tileentity1 instanceof TileEntityChest) {
+                            if (enumdirection != EnumDirection.WEST && enumdirection != EnumDirection.NORTH) {
+                                object = new InventoryLargeChest("container.chestDouble", (ITileInventory) object, (TileEntityChest) tileentity1);
+                            } else {
+                                object = new InventoryLargeChest("container.chestDouble", (TileEntityChest) tileentity1, (ITileInventory) object);
+                            }
+                        }
+                    }
+                }
+
+                return (ITileInventory) object;
+            }
+        }
+    }
+
+    public TileEntity a(World world, int i) {
+        return new TileEntityChest();
+    }
+
+    public boolean isPowerSource(IBlockData iblockdata) {
+        return this.g == BlockChest.Type.TRAP;
+    }
+
+    public int b(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
+        if (!iblockdata.m()) {
+            return 0;
+        } else {
+            int i = 0;
+            TileEntity tileentity = iblockaccess.getTileEntity(blockposition);
+
+            if (tileentity instanceof TileEntityChest) {
+                i = ((TileEntityChest) tileentity).l;
+            }
+
+            return MathHelper.clamp(i, 0, 15);
+        }
+    }
+
+    public int c(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
+        return enumdirection == EnumDirection.UP ? iblockdata.a(iblockaccess, blockposition, enumdirection) : 0;
+    }
+
+    private boolean e(World world, BlockPosition blockposition) {
+        return this.i(world, blockposition) || this.j(world, blockposition);
+    }
+
+    private boolean i(World world, BlockPosition blockposition) {
+        return world.getType(blockposition.up()).l();
+    }
+
+    private boolean j(World world, BlockPosition blockposition) {
+        Iterator iterator = world.a(EntityOcelot.class, new AxisAlignedBB((double) blockposition.getX(), (double) (blockposition.getY() + 1), (double) blockposition.getZ(), (double) (blockposition.getX() + 1), (double) (blockposition.getY() + 2), (double) (blockposition.getZ() + 1))).iterator();
+
+        EntityOcelot entityocelot;
+
+        do {
+            if (!iterator.hasNext()) {
+                return false;
+            }
+
+            Entity entity = (Entity) iterator.next();
+
+            entityocelot = (EntityOcelot) entity;
+        } while (!entityocelot.isSitting());
+
+        return true;
+    }
+
+    public boolean isComplexRedstone(IBlockData iblockdata) {
+        return true;
+    }
+
+    public int d(IBlockData iblockdata, World world, BlockPosition blockposition) {
+        return Container.b((IInventory) this.c(world, blockposition));
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        EnumDirection enumdirection = EnumDirection.fromType1(i);
+
+        if (enumdirection.k() == EnumDirection.EnumAxis.Y) {
+            enumdirection = EnumDirection.NORTH;
+        }
+
+        return this.getBlockData().set(BlockChest.FACING, enumdirection);
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        return ((EnumDirection) iblockdata.get(BlockChest.FACING)).a();
+    }
+
+    public IBlockData a(IBlockData iblockdata, EnumBlockRotation enumblockrotation) {
+        return iblockdata.set(BlockChest.FACING, enumblockrotation.a((EnumDirection) iblockdata.get(BlockChest.FACING)));
+    }
+
+    public IBlockData a(IBlockData iblockdata, EnumBlockMirror enumblockmirror) {
+        return iblockdata.a(enumblockmirror.a((EnumDirection) iblockdata.get(BlockChest.FACING)));
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockChest.FACING});
+    }
+
+    public static enum Type {
+
+        BASIC, TRAP;
+
+        private Type() {}
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/Block.java src/main/java/net/minecraft/server/Block.java
--- src_origin/main/java/net/minecraft/server/Block.java	2016-05-29 15:00:13.631641651 +0800
+++ src/main/java/net/minecraft/server/Block.java	2016-06-08 13:02:33.469102589 +0800
@@ -299,11 +299,18 @@
     }
 
     public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        org.spigotmc.AsyncCatcher.catchOp( "block onPlace"); // Spigot
+        //org.spigotmc.AsyncCatcher.catchOp( "block onPlace"); // Spigot
+        if (org.spigotmc.AsyncCatcher.catchOp_flag()) { // HOSE
+            System.out.println("AsyncCatcher: block onPlace " + this.getName());
+        }
     }
 
     public void remove(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        org.spigotmc.AsyncCatcher.catchOp( "block remove"); // Spigot
+        //org.spigotmc.AsyncCatcher.catchOp( "block remove"); // Spigot
+        if (org.spigotmc.AsyncCatcher.catchOp_flag()) { // HOSE
+            System.out.println("AsyncCatcher: block remove " + this.getName());
+            //world.addEntity(new EntityExperienceOrb(world, (double) blockposition.getX() + 0.5D, (double) blockposition.getY() + 0.5D, (double) blockposition.getZ() + 0.5D, 1));
+        }
     }
 
     public int a(Random random) {
diff -Naur src_origin/main/java/net/minecraft/server/BlockMinecartDetector.java src/main/java/net/minecraft/server/BlockMinecartDetector.java
--- src_origin/main/java/net/minecraft/server/BlockMinecartDetector.java	2016-05-29 15:00:13.838641632 +0800
+++ src/main/java/net/minecraft/server/BlockMinecartDetector.java	2016-06-08 13:02:33.646102573 +0800
@@ -3,6 +3,7 @@
 import com.google.common.base.Predicate;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.Random;
 import javax.annotation.Nullable;
 
@@ -63,6 +64,7 @@
         boolean flag = ((Boolean) iblockdata.get(BlockMinecartDetector.POWERED)).booleanValue();
         boolean flag1 = false;
         List list = this.a(world, blockposition, EntityMinecartAbstract.class, new Predicate[0]);
+        //Queue list = this.a(world, blockposition, EntityMinecartAbstract.class, new Predicate[0]);
 
         if (!list.isEmpty()) {
             flag1 = true;
@@ -134,15 +136,21 @@
     public int d(IBlockData iblockdata, World world, BlockPosition blockposition) {
         if (((Boolean) iblockdata.get(BlockMinecartDetector.POWERED)).booleanValue()) {
             List list = this.a(world, blockposition, EntityMinecartCommandBlock.class, new Predicate[0]);
+            //Queue list = this.a(world, blockposition, EntityMinecartCommandBlock.class, new Predicate[0]);
 
             if (!list.isEmpty()) {
-                return ((EntityMinecartCommandBlock) list.get(0)).getCommandBlock().k();
+                //return ((EntityMinecartCommandBlock) list.get(0)).getCommandBlock().k();
+                Iterator it = list.iterator();
+                return ((EntityMinecartCommandBlock) it.next()).getCommandBlock().k();
             }
 
             List list1 = this.a(world, blockposition, EntityMinecartAbstract.class, new Predicate[] { IEntitySelector.c});
+            //Queue list1 = this.a(world, blockposition, EntityMinecartAbstract.class, new Predicate[] { IEntitySelector.c});
 
             if (!list1.isEmpty()) {
-                return Container.b((IInventory) list1.get(0));
+                //return Container.b((IInventory) list1.get(0));
+                Iterator it1 = list1.iterator();
+                return Container.b((IInventory) it1.next());
             }
         }
 
@@ -150,6 +158,7 @@
     }
 
     protected <T extends EntityMinecartAbstract> List<T> a(World world, BlockPosition blockposition, Class<T> oclass, Predicate<Entity>... apredicate) {
+    //protected <T extends EntityMinecartAbstract> Queue<T> a(World world, BlockPosition blockposition, Class<T> oclass, Predicate<Entity>... apredicate) {
         AxisAlignedBB axisalignedbb = this.a(blockposition);
 
         return apredicate.length != 1 ? world.a(oclass, axisalignedbb) : world.a(oclass, axisalignedbb, apredicate[0]);
diff -Naur src_origin/main/java/net/minecraft/server/BlockPressurePlateBinary.java src/main/java/net/minecraft/server/BlockPressurePlateBinary.java
--- src_origin/main/java/net/minecraft/server/BlockPressurePlateBinary.java	2016-05-29 15:00:13.898641627 +0800
+++ src/main/java/net/minecraft/server/BlockPressurePlateBinary.java	2016-06-08 13:02:33.707102568 +0800
@@ -2,6 +2,7 @@
 
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 
 import org.bukkit.event.entity.EntityInteractEvent; // CraftBukkit
 
@@ -45,6 +46,7 @@
     protected int e(World world, BlockPosition blockposition) {
         AxisAlignedBB axisalignedbb = BlockPressurePlateBinary.c.a(blockposition);
         List list;
+        //Queue list;
 
         switch (BlockPressurePlateBinary.SyntheticClass_1.a[this.e.ordinal()]) {
         case 1:
diff -Naur src_origin/main/java/net/minecraft/server/BlockTripwire.java src/main/java/net/minecraft/server/BlockTripwire.java
--- src_origin/main/java/net/minecraft/server/BlockTripwire.java	2016-05-29 15:00:13.974641620 +0800
+++ src/main/java/net/minecraft/server/BlockTripwire.java	2016-06-08 13:02:33.785102561 +0800
@@ -2,6 +2,7 @@
 
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.Random;
 import javax.annotation.Nullable;
 
diff -Naur src_origin/main/java/net/minecraft/server/Chunk.java src/main/java/net/minecraft/server/Chunk.java
--- src_origin/main/java/net/minecraft/server/Chunk.java	2016-05-29 15:00:14.024641615 +0800
+++ src/main/java/net/minecraft/server/Chunk.java	2016-06-08 13:02:33.827102557 +0800
@@ -15,7 +15,10 @@
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists; // CraftBukkit
+import java.util.Queue;
 import org.bukkit.Bukkit; // CraftBukkit
+import org.hose.ChunkPopulate_Pool;
+import org.spigotmc.SpigotWorldConfig;
 
 public class Chunk {
 
@@ -32,7 +35,8 @@
     public final int locZ;
     private boolean m;
     public final Map<BlockPosition, TileEntity> tileEntities;
-    public final List<Entity>[] entitySlices; // Spigot
+    //public final List<Entity>[] entitySlices; // Spigot
+    public final Queue<Entity>[] entitySlices; // Spigot
     private boolean done;
     private boolean lit;
     private boolean r;
@@ -82,14 +86,16 @@
         this.tileEntities = Maps.newHashMap();
         this.x = 4096;
         this.y = Queues.newConcurrentLinkedQueue();
-        this.entitySlices = (List[]) (new List[16]); // Spigot
+        //this.entitySlices = (List[]) (new List[16]); // Spigot
+        this.entitySlices = (Queue[]) (new ConcurrentLinkedQueue[16]); // Spigot
         this.world = world;
         this.locX = i;
         this.locZ = j;
         this.heightMap = new int[256];
 
         for (int k = 0; k < this.entitySlices.length; ++k) {
-            this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            //this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[k] = new ConcurrentLinkedQueue(); // Spigot
         }
 
         Arrays.fill(this.h, -999);
@@ -467,7 +473,9 @@
             chunksection.setType(i, j & 15, k, iblockdata);
             if (block1 != block) {
                 if (!this.world.isClientSide) {
+                    //hose
                     block1.remove(this.world, blockposition, iblockdata1);
+                    //if return true, add a new entity
                 } else if (block1 instanceof ITileEntity) {
                     this.world.s(blockposition);
                 }
@@ -945,9 +953,13 @@
             if (world != null) {
                 this.world.populating = true;
                 try {
+                    //fork join
                     for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
-                        populator.populate(world, random, bukkitChunk);
+                        //populator.populate(world, random, bukkitChunk);
+                        ChunkPopulate_Pool task = new ChunkPopulate_Pool(world, random, bukkitChunk, populator);
+                        task.fork();
                     }
+                    
                 } finally {
                     this.world.populating = false;
                 }
@@ -1264,7 +1276,8 @@
         return this.tileEntities;
     }
 
-    public List<Entity>[] getEntitySlices() {
+    //public List<Entity>[] getEntitySlices() {
+    public Queue<Entity>[] getEntitySlices() {
         return this.entitySlices;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderGenerate.java src/main/java/net/minecraft/server/ChunkProviderGenerate.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderGenerate.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderGenerate.java	2016-06-08 13:02:33.831102556 +0800
@@ -0,0 +1,451 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+import javax.annotation.Nullable;
+
+public class ChunkProviderGenerate implements ChunkGenerator {
+
+    protected static final IBlockData a = Blocks.STONE.getBlockData();
+    private final Random i;
+    private final NoiseGeneratorOctaves j;
+    private final NoiseGeneratorOctaves k;
+    private final NoiseGeneratorOctaves l;
+    private final NoiseGenerator3 m;
+    public NoiseGeneratorOctaves b;
+    public NoiseGeneratorOctaves c;
+    public NoiseGeneratorOctaves d;
+    private final World n;
+    private final boolean o;
+    private final WorldType p;
+    private final double[] q;
+    private final float[] r;
+    private CustomWorldSettingsFinal s;
+    private IBlockData t;
+    private double[] u;
+    private final WorldGenBase v;
+    private final WorldGenStronghold w;
+    private final WorldGenVillage x;
+    private final WorldGenMineshaft y;
+    private final WorldGenLargeFeature z;
+    private final WorldGenBase A;
+    private final WorldGenMonument B;
+    private BiomeBase[] C;
+    double[] e;
+    double[] f;
+    double[] g;
+    double[] h;
+
+    public ChunkProviderGenerate(World world, long i, boolean flag, String s) {
+        this.t = Blocks.WATER.getBlockData();
+        this.u = new double[256];
+        this.v = new WorldGenCaves();
+        this.w = new WorldGenStronghold();
+        this.x = new WorldGenVillage();
+        this.y = new WorldGenMineshaft();
+        this.z = new WorldGenLargeFeature();
+        this.A = new WorldGenCanyon();
+        this.B = new WorldGenMonument();
+        this.n = world;
+        this.o = flag;
+        this.p = world.getWorldData().getType();
+        this.i = new Random(i);
+        this.j = new NoiseGeneratorOctaves(this.i, 16);
+        this.k = new NoiseGeneratorOctaves(this.i, 16);
+        this.l = new NoiseGeneratorOctaves(this.i, 8);
+        this.m = new NoiseGenerator3(this.i, 4);
+        this.b = new NoiseGeneratorOctaves(this.i, 10);
+        this.c = new NoiseGeneratorOctaves(this.i, 16);
+        this.d = new NoiseGeneratorOctaves(this.i, 8);
+        this.q = new double[825];
+        this.r = new float[25];
+
+        for (int j = -2; j <= 2; ++j) {
+            for (int k = -2; k <= 2; ++k) {
+                float f = 10.0F / MathHelper.c((float) (j * j + k * k) + 0.2F);
+
+                this.r[j + 2 + (k + 2) * 5] = f;
+            }
+        }
+
+        if (s != null) {
+            this.s = CustomWorldSettingsFinal.CustomWorldSettings.a(s).b();
+            this.t = this.s.E ? Blocks.LAVA.getBlockData() : Blocks.WATER.getBlockData();
+            world.b(this.s.q);
+        }
+
+    }
+
+    public void a(int i, int j, ChunkSnapshot chunksnapshot) {
+        this.C = this.n.getWorldChunkManager().getBiomes(this.C, i * 4 - 2, j * 4 - 2, 10, 10);
+        this.a(i * 4, 0, j * 4);
+
+        for (int k = 0; k < 4; ++k) {
+            int l = k * 5;
+            int i1 = (k + 1) * 5;
+
+            for (int j1 = 0; j1 < 4; ++j1) {
+                int k1 = (l + j1) * 33;
+                int l1 = (l + j1 + 1) * 33;
+                int i2 = (i1 + j1) * 33;
+                int j2 = (i1 + j1 + 1) * 33;
+
+                for (int k2 = 0; k2 < 32; ++k2) {
+                    double d0 = 0.125D;
+                    double d1 = this.q[k1 + k2];
+                    double d2 = this.q[l1 + k2];
+                    double d3 = this.q[i2 + k2];
+                    double d4 = this.q[j2 + k2];
+                    double d5 = (this.q[k1 + k2 + 1] - d1) * d0;
+                    double d6 = (this.q[l1 + k2 + 1] - d2) * d0;
+                    double d7 = (this.q[i2 + k2 + 1] - d3) * d0;
+                    double d8 = (this.q[j2 + k2 + 1] - d4) * d0;
+
+                    for (int l2 = 0; l2 < 8; ++l2) {
+                        double d9 = 0.25D;
+                        double d10 = d1;
+                        double d11 = d2;
+                        double d12 = (d3 - d1) * d9;
+                        double d13 = (d4 - d2) * d9;
+
+                        for (int i3 = 0; i3 < 4; ++i3) {
+                            double d14 = 0.25D;
+                            double d15 = (d11 - d10) * d14;
+                            double d16 = d10 - d15;
+
+                            for (int j3 = 0; j3 < 4; ++j3) {
+                                if ((d16 += d15) > 0.0D) {
+                                    chunksnapshot.a(k * 4 + i3, k2 * 8 + l2, j1 * 4 + j3, ChunkProviderGenerate.a);
+                                } else if (k2 * 8 + l2 < this.s.q) {
+                                    chunksnapshot.a(k * 4 + i3, k2 * 8 + l2, j1 * 4 + j3, this.t);
+                                }
+                            }
+
+                            d10 += d12;
+                            d11 += d13;
+                        }
+
+                        d1 += d5;
+                        d2 += d6;
+                        d3 += d7;
+                        d4 += d8;
+                    }
+                }
+            }
+        }
+
+    }
+
+    public void a(int i, int j, ChunkSnapshot chunksnapshot, BiomeBase[] abiomebase) {
+        double d0 = 0.03125D;
+
+        this.u = this.m.a(this.u, (double) (i * 16), (double) (j * 16), 16, 16, d0 * 2.0D, d0 * 2.0D, 1.0D);
+
+        for (int k = 0; k < 16; ++k) {
+            for (int l = 0; l < 16; ++l) {
+                BiomeBase biomebase = abiomebase[l + k * 16];
+
+                biomebase.a(this.n, this.i, chunksnapshot, i * 16 + k, j * 16 + l, this.u[l + k * 16]);
+            }
+        }
+
+    }
+
+    public Chunk getOrCreateChunk(int i, int j) {
+        this.i.setSeed((long) i * 341873128712L + (long) j * 132897987541L);
+        ChunkSnapshot chunksnapshot = new ChunkSnapshot();
+
+        this.a(i, j, chunksnapshot);
+        this.C = this.n.getWorldChunkManager().getBiomeBlock(this.C, i * 16, j * 16, 16, 16);
+        this.a(i, j, chunksnapshot, this.C);
+        if (this.s.r) {
+            this.v.a(this.n, i, j, chunksnapshot);
+        }
+
+        if (this.s.z) {
+            this.A.a(this.n, i, j, chunksnapshot);
+        }
+
+        if (this.o) {
+            if (this.s.w) {
+                this.y.a(this.n, i, j, chunksnapshot);
+            }
+
+            if (this.s.v) {
+                this.x.a(this.n, i, j, chunksnapshot);
+            }
+
+            if (this.s.u) {
+                this.w.a(this.n, i, j, chunksnapshot);
+            }
+
+            if (this.s.x) {
+                this.z.a(this.n, i, j, chunksnapshot);
+            }
+
+            if (this.s.y) {
+                this.B.a(this.n, i, j, chunksnapshot);
+            }
+        }
+
+        Chunk chunk = new Chunk(this.n, chunksnapshot, i, j);
+        byte[] abyte = chunk.getBiomeIndex();
+
+        for (int k = 0; k < abyte.length; ++k) {
+            abyte[k] = (byte) BiomeBase.a(this.C[k]);
+        }
+
+        chunk.initLighting();
+        return chunk;
+    }
+
+    private void a(int i, int j, int k) {
+        this.h = this.c.a(this.h, i, k, 5, 5, (double) this.s.e, (double) this.s.f, (double) this.s.g);
+        float f = this.s.a;
+        float f1 = this.s.b;
+
+        this.e = this.l.a(this.e, i, j, k, 5, 33, 5, (double) (f / this.s.h), (double) (f1 / this.s.i), (double) (f / this.s.j));
+        this.f = this.j.a(this.f, i, j, k, 5, 33, 5, (double) f, (double) f1, (double) f);
+        this.g = this.k.a(this.g, i, j, k, 5, 33, 5, (double) f, (double) f1, (double) f);
+        boolean flag = false;
+        boolean flag1 = false;
+        int l = 0;
+        int i1 = 0;
+
+        for (int j1 = 0; j1 < 5; ++j1) {
+            for (int k1 = 0; k1 < 5; ++k1) {
+                float f2 = 0.0F;
+                float f3 = 0.0F;
+                float f4 = 0.0F;
+                byte b0 = 2;
+                BiomeBase biomebase = this.C[j1 + 2 + (k1 + 2) * 10];
+
+                for (int l1 = -b0; l1 <= b0; ++l1) {
+                    for (int i2 = -b0; i2 <= b0; ++i2) {
+                        BiomeBase biomebase1 = this.C[j1 + l1 + 2 + (k1 + i2 + 2) * 10];
+                        float f5 = this.s.n + biomebase1.j() * this.s.m;
+                        float f6 = this.s.p + biomebase1.m() * this.s.o;
+
+                        if (this.p == WorldType.AMPLIFIED && f5 > 0.0F) {
+                            f5 = 1.0F + f5 * 2.0F;
+                            f6 = 1.0F + f6 * 4.0F;
+                        }
+
+                        float f7 = this.r[l1 + 2 + (i2 + 2) * 5] / (f5 + 2.0F);
+
+                        if (biomebase1.j() > biomebase.j()) {
+                            f7 /= 2.0F;
+                        }
+
+                        f2 += f6 * f7;
+                        f3 += f5 * f7;
+                        f4 += f7;
+                    }
+                }
+
+                f2 /= f4;
+                f3 /= f4;
+                f2 = f2 * 0.9F + 0.1F;
+                f3 = (f3 * 4.0F - 1.0F) / 8.0F;
+                double d0 = this.h[i1] / 8000.0D;
+
+                if (d0 < 0.0D) {
+                    d0 = -d0 * 0.3D;
+                }
+
+                d0 = d0 * 3.0D - 2.0D;
+                if (d0 < 0.0D) {
+                    d0 /= 2.0D;
+                    if (d0 < -1.0D) {
+                        d0 = -1.0D;
+                    }
+
+                    d0 /= 1.4D;
+                    d0 /= 2.0D;
+                } else {
+                    if (d0 > 1.0D) {
+                        d0 = 1.0D;
+                    }
+
+                    d0 /= 8.0D;
+                }
+
+                ++i1;
+                double d1 = (double) f3;
+                double d2 = (double) f2;
+
+                d1 += d0 * 0.2D;
+                d1 = d1 * (double) this.s.k / 8.0D;
+                double d3 = (double) this.s.k + d1 * 4.0D;
+
+                for (int j2 = 0; j2 < 33; ++j2) {
+                    double d4 = ((double) j2 - d3) * (double) this.s.l * 128.0D / 256.0D / d2;
+
+                    if (d4 < 0.0D) {
+                        d4 *= 4.0D;
+                    }
+
+                    double d5 = this.f[l] / (double) this.s.d;
+                    double d6 = this.g[l] / (double) this.s.c;
+                    double d7 = (this.e[l] / 10.0D + 1.0D) / 2.0D;
+                    double d8 = MathHelper.b(d5, d6, d7) - d4;
+
+                    if (j2 > 29) {
+                        double d9 = (double) ((float) (j2 - 29) / 3.0F);
+
+                        d8 = d8 * (1.0D - d9) + -10.0D * d9;
+                    }
+
+                    this.q[l] = d8;
+                    ++l;
+                }
+            }
+        }
+
+    }
+
+    public void recreateStructures(int i, int j) {
+        BlockFalling.instaFall = true;
+        int k = i * 16;
+        int l = j * 16;
+        BlockPosition blockposition = new BlockPosition(k, 0, l);
+        BiomeBase biomebase = this.n.getBiome(blockposition.a(16, 0, 16));
+
+        this.i.setSeed(this.n.getSeed());
+        long i1 = this.i.nextLong() / 2L * 2L + 1L;
+        long j1 = this.i.nextLong() / 2L * 2L + 1L;
+
+        this.i.setSeed((long) i * i1 + (long) j * j1 ^ this.n.getSeed());
+        boolean flag = false;
+        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
+
+        if (this.o) {
+            if (this.s.w) {
+                this.y.a(this.n, this.i, chunkcoordintpair);
+            }
+
+            if (this.s.v) {
+                flag = this.x.a(this.n, this.i, chunkcoordintpair);
+            }
+
+            if (this.s.u) {
+                this.w.a(this.n, this.i, chunkcoordintpair);
+            }
+
+            if (this.s.x) {
+                this.z.a(this.n, this.i, chunkcoordintpair);
+            }
+
+            if (this.s.y) {
+                this.B.a(this.n, this.i, chunkcoordintpair);
+            }
+        }
+
+        int k1;
+        int l1;
+        int i2;
+
+        if (biomebase != Biomes.d && biomebase != Biomes.s && this.s.A && !flag && this.i.nextInt(this.s.B) == 0) {
+            k1 = this.i.nextInt(16) + 8;
+            l1 = this.i.nextInt(256);
+            i2 = this.i.nextInt(16) + 8;
+            (new WorldGenLakes(Blocks.WATER)).generate(this.n, this.i, blockposition.a(k1, l1, i2));
+        }
+
+        if (!flag && this.i.nextInt(this.s.D / 10) == 0 && this.s.C) {
+            k1 = this.i.nextInt(16) + 8;
+            l1 = this.i.nextInt(this.i.nextInt(248) + 8);
+            i2 = this.i.nextInt(16) + 8;
+            if (l1 < this.n.K() || this.i.nextInt(this.s.D / 8) == 0) {
+                (new WorldGenLakes(Blocks.LAVA)).generate(this.n, this.i, blockposition.a(k1, l1, i2));
+            }
+        }
+
+        if (this.s.s) {
+            for (k1 = 0; k1 < this.s.t; ++k1) {
+                l1 = this.i.nextInt(16) + 8;
+                i2 = this.i.nextInt(256);
+                int j2 = this.i.nextInt(16) + 8;
+
+                (new WorldGenDungeons()).generate(this.n, this.i, blockposition.a(l1, i2, j2));
+            }
+        }
+
+        biomebase.a(this.n, this.i, new BlockPosition(k, 0, l));
+        SpawnerCreature.a(this.n, biomebase, k + 8, l + 8, 16, 16, this.i);
+        blockposition = blockposition.a(8, 0, 8);
+
+        for (k1 = 0; k1 < 16; ++k1) {
+            for (l1 = 0; l1 < 16; ++l1) {
+                BlockPosition blockposition1 = this.n.p(blockposition.a(k1, 0, l1));
+                BlockPosition blockposition2 = blockposition1.down();
+
+                if (this.n.u(blockposition2)) {
+                    this.n.setTypeAndData(blockposition2, Blocks.ICE.getBlockData(), 2);
+                }
+
+                if (this.n.f(blockposition1, true)) {
+                    this.n.setTypeAndData(blockposition1, Blocks.SNOW_LAYER.getBlockData(), 2);
+                }
+            }
+        }
+
+        BlockFalling.instaFall = false;
+    }
+
+    public boolean a(Chunk chunk, int i, int j) {
+        boolean flag = false;
+
+        if (this.s.y && this.o && chunk.x() < 3600L) {
+            flag |= this.B.a(this.n, this.i, new ChunkCoordIntPair(i, j));
+        }
+
+        return flag;
+    }
+
+    public List<BiomeBase.BiomeMeta> getMobsFor(EnumCreatureType enumcreaturetype, BlockPosition blockposition) {
+        BiomeBase biomebase = this.n.getBiome(blockposition);
+
+        if (this.o) {
+            if (enumcreaturetype == EnumCreatureType.MONSTER && this.z.a(blockposition)) {
+                return this.z.b();
+            }
+
+            if (enumcreaturetype == EnumCreatureType.MONSTER && this.s.y && this.B.b(this.n, blockposition)) {
+                return this.B.b();
+            }
+        }
+
+        return biomebase.getMobs(enumcreaturetype);
+    }
+
+    @Nullable
+    public BlockPosition findNearestMapFeature(World world, String s, BlockPosition blockposition) {
+        return "Stronghold".equals(s) && this.w != null ? this.w.getNearestGeneratedFeature(world, blockposition) : null;
+    }
+
+    public void recreateStructures(Chunk chunk, int i, int j) {
+        if (this.o) {
+            if (this.s.w) {
+                this.y.a(this.n, i, j, (ChunkSnapshot) null);
+            }
+
+            if (this.s.v) {
+                this.x.a(this.n, i, j, (ChunkSnapshot) null);
+            }
+
+            if (this.s.u) {
+                this.w.a(this.n, i, j, (ChunkSnapshot) null);
+            }
+
+            if (this.s.x) {
+                this.z.a(this.n, i, j, (ChunkSnapshot) null);
+            }
+
+            if (this.s.y) {
+                this.B.a(this.n, i, j, (ChunkSnapshot) null);
+            }
+        }
+
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderHell.java src/main/java/net/minecraft/server/ChunkProviderHell.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderHell.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderHell.java	2016-06-08 13:02:33.853102554 +0800
@@ -0,0 +1,371 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+import javax.annotation.Nullable;
+
+public class ChunkProviderHell implements ChunkGenerator {
+
+    protected static final IBlockData a = Blocks.AIR.getBlockData();
+    protected static final IBlockData b = Blocks.NETHERRACK.getBlockData();
+    protected static final IBlockData c = Blocks.BEDROCK.getBlockData();
+    protected static final IBlockData d = Blocks.LAVA.getBlockData();
+    protected static final IBlockData e = Blocks.GRAVEL.getBlockData();
+    protected static final IBlockData f = Blocks.SOUL_SAND.getBlockData();
+    private final World n;
+    private final boolean o;
+    private final Random p;
+    private double[] q = new double[256];
+    private double[] r = new double[256];
+    private double[] s = new double[256];
+    private double[] t;
+    private final NoiseGeneratorOctaves u;
+    private final NoiseGeneratorOctaves v;
+    private final NoiseGeneratorOctaves w;
+    private final NoiseGeneratorOctaves x;
+    private final NoiseGeneratorOctaves y;
+    public final NoiseGeneratorOctaves g;
+    public final NoiseGeneratorOctaves h;
+    private final WorldGenFire z = new WorldGenFire();
+    private final WorldGenLightStone1 A = new WorldGenLightStone1();
+    private final WorldGenLightStone2 B = new WorldGenLightStone2();
+    private final WorldGenerator C;
+    private final WorldGenHellLava D;
+    private final WorldGenHellLava E;
+    private final WorldGenMushrooms F;
+    private final WorldGenMushrooms G;
+    private final WorldGenNether H;
+    private final WorldGenBase I;
+    double[] i;
+    double[] j;
+    double[] k;
+    double[] l;
+    double[] m;
+
+    public ChunkProviderHell(World world, boolean flag, long i) {
+        this.C = new WorldGenMinable(Blocks.QUARTZ_ORE.getBlockData(), 14, BlockPredicate.a(Blocks.NETHERRACK));
+        this.D = new WorldGenHellLava(Blocks.FLOWING_LAVA, true);
+        this.E = new WorldGenHellLava(Blocks.FLOWING_LAVA, false);
+        this.F = new WorldGenMushrooms(Blocks.BROWN_MUSHROOM);
+        this.G = new WorldGenMushrooms(Blocks.RED_MUSHROOM);
+        this.H = new WorldGenNether();
+        this.I = new WorldGenCavesHell();
+        this.n = world;
+        this.o = flag;
+        this.p = new Random(i);
+        this.u = new NoiseGeneratorOctaves(this.p, 16);
+        this.v = new NoiseGeneratorOctaves(this.p, 16);
+        this.w = new NoiseGeneratorOctaves(this.p, 8);
+        this.x = new NoiseGeneratorOctaves(this.p, 4);
+        this.y = new NoiseGeneratorOctaves(this.p, 4);
+        this.g = new NoiseGeneratorOctaves(this.p, 10);
+        this.h = new NoiseGeneratorOctaves(this.p, 16);
+        world.b(63);
+    }
+
+    public void a(int i, int j, ChunkSnapshot chunksnapshot) {
+        byte b0 = 4;
+        int k = this.n.K() / 2 + 1;
+        int l = b0 + 1;
+        byte b1 = 17;
+        int i1 = b0 + 1;
+
+        this.t = this.a(this.t, i * b0, 0, j * b0, l, b1, i1);
+
+        for (int j1 = 0; j1 < b0; ++j1) {
+            for (int k1 = 0; k1 < b0; ++k1) {
+                for (int l1 = 0; l1 < 16; ++l1) {
+                    double d0 = 0.125D;
+                    double d1 = this.t[((j1 + 0) * i1 + k1 + 0) * b1 + l1 + 0];
+                    double d2 = this.t[((j1 + 0) * i1 + k1 + 1) * b1 + l1 + 0];
+                    double d3 = this.t[((j1 + 1) * i1 + k1 + 0) * b1 + l1 + 0];
+                    double d4 = this.t[((j1 + 1) * i1 + k1 + 1) * b1 + l1 + 0];
+                    double d5 = (this.t[((j1 + 0) * i1 + k1 + 0) * b1 + l1 + 1] - d1) * d0;
+                    double d6 = (this.t[((j1 + 0) * i1 + k1 + 1) * b1 + l1 + 1] - d2) * d0;
+                    double d7 = (this.t[((j1 + 1) * i1 + k1 + 0) * b1 + l1 + 1] - d3) * d0;
+                    double d8 = (this.t[((j1 + 1) * i1 + k1 + 1) * b1 + l1 + 1] - d4) * d0;
+
+                    for (int i2 = 0; i2 < 8; ++i2) {
+                        double d9 = 0.25D;
+                        double d10 = d1;
+                        double d11 = d2;
+                        double d12 = (d3 - d1) * d9;
+                        double d13 = (d4 - d2) * d9;
+
+                        for (int j2 = 0; j2 < 4; ++j2) {
+                            double d14 = 0.25D;
+                            double d15 = d10;
+                            double d16 = (d11 - d10) * d14;
+
+                            for (int k2 = 0; k2 < 4; ++k2) {
+                                IBlockData iblockdata = null;
+
+                                if (l1 * 8 + i2 < k) {
+                                    iblockdata = ChunkProviderHell.d;
+                                }
+
+                                if (d15 > 0.0D) {
+                                    iblockdata = ChunkProviderHell.b;
+                                }
+
+                                int l2 = j2 + j1 * 4;
+                                int i3 = i2 + l1 * 8;
+                                int j3 = k2 + k1 * 4;
+
+                                chunksnapshot.a(l2, i3, j3, iblockdata);
+                                d15 += d16;
+                            }
+
+                            d10 += d12;
+                            d11 += d13;
+                        }
+
+                        d1 += d5;
+                        d2 += d6;
+                        d3 += d7;
+                        d4 += d8;
+                    }
+                }
+            }
+        }
+
+    }
+
+    public void b(int i, int j, ChunkSnapshot chunksnapshot) {
+        int k = this.n.K() + 1;
+        double d0 = 0.03125D;
+
+        this.q = this.x.a(this.q, i * 16, j * 16, 0, 16, 16, 1, d0, d0, 1.0D);
+        this.r = this.x.a(this.r, i * 16, 109, j * 16, 16, 1, 16, d0, 1.0D, d0);
+        this.s = this.y.a(this.s, i * 16, j * 16, 0, 16, 16, 1, d0 * 2.0D, d0 * 2.0D, d0 * 2.0D);
+
+        for (int l = 0; l < 16; ++l) {
+            for (int i1 = 0; i1 < 16; ++i1) {
+                boolean flag = this.q[l + i1 * 16] + this.p.nextDouble() * 0.2D > 0.0D;
+                boolean flag1 = this.r[l + i1 * 16] + this.p.nextDouble() * 0.2D > 0.0D;
+                int j1 = (int) (this.s[l + i1 * 16] / 3.0D + 3.0D + this.p.nextDouble() * 0.25D);
+                int k1 = -1;
+                IBlockData iblockdata = ChunkProviderHell.b;
+                IBlockData iblockdata1 = ChunkProviderHell.b;
+
+                for (int l1 = 127; l1 >= 0; --l1) {
+                    if (l1 < 127 - this.p.nextInt(5) && l1 > this.p.nextInt(5)) {
+                        IBlockData iblockdata2 = chunksnapshot.a(i1, l1, l);
+
+                        if (iblockdata2.getBlock() != null && iblockdata2.getMaterial() != Material.AIR) {
+                            if (iblockdata2.getBlock() == Blocks.NETHERRACK) {
+                                if (k1 == -1) {
+                                    if (j1 <= 0) {
+                                        iblockdata = ChunkProviderHell.a;
+                                        iblockdata1 = ChunkProviderHell.b;
+                                    } else if (l1 >= k - 4 && l1 <= k + 1) {
+                                        iblockdata = ChunkProviderHell.b;
+                                        iblockdata1 = ChunkProviderHell.b;
+                                        if (flag1) {
+                                            iblockdata = ChunkProviderHell.e;
+                                            iblockdata1 = ChunkProviderHell.b;
+                                        }
+
+                                        if (flag) {
+                                            iblockdata = ChunkProviderHell.f;
+                                            iblockdata1 = ChunkProviderHell.f;
+                                        }
+                                    }
+
+                                    if (l1 < k && (iblockdata == null || iblockdata.getMaterial() == Material.AIR)) {
+                                        iblockdata = ChunkProviderHell.d;
+                                    }
+
+                                    k1 = j1;
+                                    if (l1 >= k - 1) {
+                                        chunksnapshot.a(i1, l1, l, iblockdata);
+                                    } else {
+                                        chunksnapshot.a(i1, l1, l, iblockdata1);
+                                    }
+                                } else if (k1 > 0) {
+                                    --k1;
+                                    chunksnapshot.a(i1, l1, l, iblockdata1);
+                                }
+                            }
+                        } else {
+                            k1 = -1;
+                        }
+                    } else {
+                        chunksnapshot.a(i1, l1, l, ChunkProviderHell.c);
+                    }
+                }
+            }
+        }
+
+    }
+
+    public Chunk getOrCreateChunk(int i, int j) {
+        this.p.setSeed((long) i * 341873128712L + (long) j * 132897987541L);
+        ChunkSnapshot chunksnapshot = new ChunkSnapshot();
+
+        this.a(i, j, chunksnapshot);
+        this.b(i, j, chunksnapshot);
+        this.I.a(this.n, i, j, chunksnapshot);
+        if (this.o) {
+            this.H.a(this.n, i, j, chunksnapshot);
+        }
+
+        Chunk chunk = new Chunk(this.n, chunksnapshot, i, j);
+        BiomeBase[] abiomebase = this.n.getWorldChunkManager().getBiomeBlock((BiomeBase[]) null, i * 16, j * 16, 16, 16);
+        byte[] abyte = chunk.getBiomeIndex();
+
+        for (int k = 0; k < abyte.length; ++k) {
+            abyte[k] = (byte) BiomeBase.a(abiomebase[k]);
+        }
+
+        chunk.m();
+        return chunk;
+    }
+
+    private double[] a(double[] adouble, int i, int j, int k, int l, int i1, int j1) {
+        if (adouble == null) {
+            adouble = new double[l * i1 * j1];
+        }
+
+        double d0 = 684.412D;
+        double d1 = 2053.236D;
+
+        this.l = this.g.a(this.l, i, j, k, l, 1, j1, 1.0D, 0.0D, 1.0D);
+        this.m = this.h.a(this.m, i, j, k, l, 1, j1, 100.0D, 0.0D, 100.0D);
+        this.i = this.w.a(this.i, i, j, k, l, i1, j1, d0 / 80.0D, d1 / 60.0D, d0 / 80.0D);
+        this.j = this.u.a(this.j, i, j, k, l, i1, j1, d0, d1, d0);
+        this.k = this.v.a(this.k, i, j, k, l, i1, j1, d0, d1, d0);
+        int k1 = 0;
+        double[] adouble1 = new double[i1];
+
+        int l1;
+
+        for (l1 = 0; l1 < i1; ++l1) {
+            adouble1[l1] = Math.cos((double) l1 * 3.141592653589793D * 6.0D / (double) i1) * 2.0D;
+            double d2 = (double) l1;
+
+            if (l1 > i1 / 2) {
+                d2 = (double) (i1 - 1 - l1);
+            }
+
+            if (d2 < 4.0D) {
+                d2 = 4.0D - d2;
+                adouble1[l1] -= d2 * d2 * d2 * 10.0D;
+            }
+        }
+
+        for (l1 = 0; l1 < l; ++l1) {
+            for (int i2 = 0; i2 < j1; ++i2) {
+                double d3 = 0.0D;
+
+                for (int j2 = 0; j2 < i1; ++j2) {
+                    double d4 = 0.0D;
+                    double d5 = adouble1[j2];
+                    double d6 = this.j[k1] / 512.0D;
+                    double d7 = this.k[k1] / 512.0D;
+                    double d8 = (this.i[k1] / 10.0D + 1.0D) / 2.0D;
+
+                    if (d8 < 0.0D) {
+                        d4 = d6;
+                    } else if (d8 > 1.0D) {
+                        d4 = d7;
+                    } else {
+                        d4 = d6 + (d7 - d6) * d8;
+                    }
+
+                    d4 -= d5;
+                    double d9;
+
+                    if (j2 > i1 - 4) {
+                        d9 = (double) ((float) (j2 - (i1 - 4)) / 3.0F);
+                        d4 = d4 * (1.0D - d9) + -10.0D * d9;
+                    }
+
+                    if ((double) j2 < d3) {
+                        d9 = (d3 - (double) j2) / 4.0D;
+                        d9 = MathHelper.a(d9, 0.0D, 1.0D);
+                        d4 = d4 * (1.0D - d9) + -10.0D * d9;
+                    }
+
+                    adouble[k1] = d4;
+                    ++k1;
+                }
+            }
+        }
+
+        return adouble;
+    }
+
+    public void recreateStructures(int i, int j) {
+        BlockFalling.instaFall = true;
+        BlockPosition blockposition = new BlockPosition(i * 16, 0, j * 16);
+        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
+
+        this.H.a(this.n, this.p, chunkcoordintpair);
+
+        int k;
+
+        for (k = 0; k < 8; ++k) {
+            this.E.generate(this.n, this.p, blockposition.a(this.p.nextInt(16) + 8, this.p.nextInt(120) + 4, this.p.nextInt(16) + 8));
+        }
+
+        for (k = 0; k < this.p.nextInt(this.p.nextInt(10) + 1) + 1; ++k) {
+            this.z.generate(this.n, this.p, blockposition.a(this.p.nextInt(16) + 8, this.p.nextInt(120) + 4, this.p.nextInt(16) + 8));
+        }
+
+        for (k = 0; k < this.p.nextInt(this.p.nextInt(10) + 1); ++k) {
+            this.A.generate(this.n, this.p, blockposition.a(this.p.nextInt(16) + 8, this.p.nextInt(120) + 4, this.p.nextInt(16) + 8));
+        }
+
+        for (k = 0; k < 10; ++k) {
+            this.B.generate(this.n, this.p, blockposition.a(this.p.nextInt(16) + 8, this.p.nextInt(128), this.p.nextInt(16) + 8));
+        }
+
+        if (this.p.nextBoolean()) {
+            this.F.generate(this.n, this.p, blockposition.a(this.p.nextInt(16) + 8, this.p.nextInt(128), this.p.nextInt(16) + 8));
+        }
+
+        if (this.p.nextBoolean()) {
+            this.G.generate(this.n, this.p, blockposition.a(this.p.nextInt(16) + 8, this.p.nextInt(128), this.p.nextInt(16) + 8));
+        }
+
+        for (k = 0; k < 16; ++k) {
+            this.C.generate(this.n, this.p, blockposition.a(this.p.nextInt(16), this.p.nextInt(108) + 10, this.p.nextInt(16)));
+        }
+
+        for (k = 0; k < 16; ++k) {
+            this.D.generate(this.n, this.p, blockposition.a(this.p.nextInt(16), this.p.nextInt(108) + 10, this.p.nextInt(16)));
+        }
+
+        BlockFalling.instaFall = false;
+    }
+
+    public boolean a(Chunk chunk, int i, int j) {
+        return false;
+    }
+
+    public List<BiomeBase.BiomeMeta> getMobsFor(EnumCreatureType enumcreaturetype, BlockPosition blockposition) {
+        if (enumcreaturetype == EnumCreatureType.MONSTER) {
+            if (this.H.b(blockposition)) {
+                return this.H.b();
+            }
+
+            if (this.H.b(this.n, blockposition) && this.n.getType(blockposition.down()).getBlock() == Blocks.NETHER_BRICK) {
+                return this.H.b();
+            }
+        }
+
+        BiomeBase biomebase = this.n.getBiome(blockposition);
+
+        return biomebase.getMobs(enumcreaturetype);
+    }
+
+    @Nullable
+    public BlockPosition findNearestMapFeature(World world, String s, BlockPosition blockposition) {
+        return null;
+    }
+
+    public void recreateStructures(Chunk chunk, int i, int j) {
+        this.H.a(this.n, i, j, (ChunkSnapshot) null);
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderServer.java src/main/java/net/minecraft/server/ChunkProviderServer.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderServer.java	2016-05-29 15:00:14.015641616 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderServer.java	2016-06-08 13:02:33.833102556 +0800
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
@@ -9,7 +10,11 @@
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.RecursiveTask;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -23,10 +28,14 @@
 public class ChunkProviderServer implements IChunkProvider {
 
     private static final Logger a = LogManager.getLogger();
-    public final Set<Long> unloadQueue = Sets.newHashSet(); // PAIL: private -> public
+    //public final Set<Long> unloadQueue = Sets.newHashSet(); // PAIL: private -> public
+    public final Set<Long> unloadQueue = Sets.newConcurrentHashSet(); // PAIL: private -> public
     public final ChunkGenerator chunkGenerator;
     private final IChunkLoader chunkLoader;
-    public final Long2ObjectMap<Chunk> chunks = new Long2ObjectOpenHashMap(8192);
+    //public final Long2ObjectMap<Chunk> chunks = new Long2ObjectOpenHashMap(8192);
+    public Map<Long, Chunk> chunks = new ConcurrentHashMap<Long, Chunk>(); // CraftBukkit
+    //need to paste some copies according to cpu-cores and read from them
+    //public ConcurrentMap<Long2ObjectMap<Chunk>, Boolean> chunks_clus = Maps.newConcurrentMap();
     public final WorldServer world;
 
     public ChunkProviderServer(WorldServer worldserver, IChunkLoader ichunkloader, ChunkGenerator chunkgenerator) {
@@ -337,4 +346,38 @@
     public boolean isLoaded(int i, int j) {
         return this.chunks.containsKey(ChunkCoordIntPair.a(i, j));
     }
+    /*
+    class getChunkIL extends RecursiveTask<Chunk> {
+        //Map<Long, Chunk> chunks;
+        int x, z;
+                
+        getChunkIL (int x, int z) {
+            //this.chunks = chunks;
+            this.x = x;
+            this.z = z;
+        }
+        
+        @Override
+        protected Chunk compute() {
+            return chunks.get(ChunkCoordIntPair.a(x, z));
+        }
+                 
+    }*/
+    /*
+    class isL extends RecursiveTask<Boolean> {
+        //Map<Long, Chunk> chunks;
+        int i, j;
+                
+        isL (int i, int j) {
+            //this.chunks = chunks;
+            this.i = i;
+            this.j = j;
+        }
+        
+        @Override
+        protected Boolean compute() {
+            return chunks.containsKey(ChunkCoordIntPair.a(i, j));
+        }
+                 
+    }*/
 }
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderTheEnd.java src/main/java/net/minecraft/server/ChunkProviderTheEnd.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderTheEnd.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderTheEnd.java	2016-06-08 13:02:33.858102554 +0800
@@ -0,0 +1,326 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+import javax.annotation.Nullable;
+
+public class ChunkProviderTheEnd implements ChunkGenerator {
+
+    private Random h;
+    protected static final IBlockData a = Blocks.END_STONE.getBlockData();
+    protected static final IBlockData b = Blocks.AIR.getBlockData();
+    private final NoiseGeneratorOctaves i;
+    private final NoiseGeneratorOctaves j;
+    private final NoiseGeneratorOctaves k;
+    public NoiseGeneratorOctaves c;
+    public NoiseGeneratorOctaves d;
+    private final World l;
+    private final boolean m;
+    private final WorldGenEndCity n = new WorldGenEndCity(this);
+    private final NoiseGenerator3Handler o;
+    private double[] p;
+    private BiomeBase[] q;
+    double[] e;
+    double[] f;
+    double[] g;
+    private final WorldGenEndIsland r = new WorldGenEndIsland();
+
+    public ChunkProviderTheEnd(World world, boolean flag, long i) {
+        this.l = world;
+        this.m = flag;
+        this.h = new Random(i);
+        this.i = new NoiseGeneratorOctaves(this.h, 16);
+        this.j = new NoiseGeneratorOctaves(this.h, 16);
+        this.k = new NoiseGeneratorOctaves(this.h, 8);
+        this.c = new NoiseGeneratorOctaves(this.h, 10);
+        this.d = new NoiseGeneratorOctaves(this.h, 16);
+        this.o = new NoiseGenerator3Handler(this.h);
+    }
+
+    public void a(int i, int j, ChunkSnapshot chunksnapshot) {
+        byte b0 = 2;
+        int k = b0 + 1;
+        byte b1 = 33;
+        int l = b0 + 1;
+
+        this.p = this.a(this.p, i * b0, 0, j * b0, k, b1, l);
+
+        for (int i1 = 0; i1 < b0; ++i1) {
+            for (int j1 = 0; j1 < b0; ++j1) {
+                for (int k1 = 0; k1 < 32; ++k1) {
+                    double d0 = 0.25D;
+                    double d1 = this.p[((i1 + 0) * l + j1 + 0) * b1 + k1 + 0];
+                    double d2 = this.p[((i1 + 0) * l + j1 + 1) * b1 + k1 + 0];
+                    double d3 = this.p[((i1 + 1) * l + j1 + 0) * b1 + k1 + 0];
+                    double d4 = this.p[((i1 + 1) * l + j1 + 1) * b1 + k1 + 0];
+                    double d5 = (this.p[((i1 + 0) * l + j1 + 0) * b1 + k1 + 1] - d1) * d0;
+                    double d6 = (this.p[((i1 + 0) * l + j1 + 1) * b1 + k1 + 1] - d2) * d0;
+                    double d7 = (this.p[((i1 + 1) * l + j1 + 0) * b1 + k1 + 1] - d3) * d0;
+                    double d8 = (this.p[((i1 + 1) * l + j1 + 1) * b1 + k1 + 1] - d4) * d0;
+
+                    for (int l1 = 0; l1 < 4; ++l1) {
+                        double d9 = 0.125D;
+                        double d10 = d1;
+                        double d11 = d2;
+                        double d12 = (d3 - d1) * d9;
+                        double d13 = (d4 - d2) * d9;
+
+                        for (int i2 = 0; i2 < 8; ++i2) {
+                            double d14 = 0.125D;
+                            double d15 = d10;
+                            double d16 = (d11 - d10) * d14;
+
+                            for (int j2 = 0; j2 < 8; ++j2) {
+                                IBlockData iblockdata = ChunkProviderTheEnd.b;
+
+                                if (d15 > 0.0D) {
+                                    iblockdata = ChunkProviderTheEnd.a;
+                                }
+
+                                int k2 = i2 + i1 * 8;
+                                int l2 = l1 + k1 * 4;
+                                int i3 = j2 + j1 * 8;
+
+                                chunksnapshot.a(k2, l2, i3, iblockdata);
+                                d15 += d16;
+                            }
+
+                            d10 += d12;
+                            d11 += d13;
+                        }
+
+                        d1 += d5;
+                        d2 += d6;
+                        d3 += d7;
+                        d4 += d8;
+                    }
+                }
+            }
+        }
+
+    }
+
+    public void a(ChunkSnapshot chunksnapshot) {
+        for (int i = 0; i < 16; ++i) {
+            for (int j = 0; j < 16; ++j) {
+                byte b0 = 1;
+                int k = -1;
+                IBlockData iblockdata = ChunkProviderTheEnd.a;
+                IBlockData iblockdata1 = ChunkProviderTheEnd.a;
+
+                for (int l = 127; l >= 0; --l) {
+                    IBlockData iblockdata2 = chunksnapshot.a(i, l, j);
+
+                    if (iblockdata2.getMaterial() == Material.AIR) {
+                        k = -1;
+                    } else if (iblockdata2.getBlock() == Blocks.STONE) {
+                        if (k == -1) {
+                            if (b0 <= 0) {
+                                iblockdata = ChunkProviderTheEnd.b;
+                                iblockdata1 = ChunkProviderTheEnd.a;
+                            }
+
+                            k = b0;
+                            if (l >= 0) {
+                                chunksnapshot.a(i, l, j, iblockdata);
+                            } else {
+                                chunksnapshot.a(i, l, j, iblockdata1);
+                            }
+                        } else if (k > 0) {
+                            --k;
+                            chunksnapshot.a(i, l, j, iblockdata1);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    public Chunk getOrCreateChunk(int i, int j) {
+        this.h.setSeed((long) i * 341873128712L + (long) j * 132897987541L);
+        ChunkSnapshot chunksnapshot = new ChunkSnapshot();
+
+        this.q = this.l.getWorldChunkManager().getBiomeBlock(this.q, i * 16, j * 16, 16, 16);
+        this.a(i, j, chunksnapshot);
+        this.a(chunksnapshot);
+        if (this.m) {
+            this.n.a(this.l, i, j, chunksnapshot);
+        }
+
+        Chunk chunk = new Chunk(this.l, chunksnapshot, i, j);
+        byte[] abyte = chunk.getBiomeIndex();
+
+        for (int k = 0; k < abyte.length; ++k) {
+            abyte[k] = (byte) BiomeBase.a(this.q[k]);
+        }
+
+        chunk.initLighting();
+        return chunk;
+    }
+
+    private float a(int i, int j, int k, int l) {
+        float f = (float) (i * 2 + k);
+        float f1 = (float) (j * 2 + l);
+        float f2 = 100.0F - MathHelper.c(f * f + f1 * f1) * 8.0F;
+
+        if (f2 > 80.0F) {
+            f2 = 80.0F;
+        }
+
+        if (f2 < -100.0F) {
+            f2 = -100.0F;
+        }
+
+        for (int i1 = -12; i1 <= 12; ++i1) {
+            for (int j1 = -12; j1 <= 12; ++j1) {
+                long k1 = (long) (i + i1);
+                long l1 = (long) (j + j1);
+
+                if (k1 * k1 + l1 * l1 > 4096L && this.o.a((double) k1, (double) l1) < -0.8999999761581421D) {
+                    float f3 = (MathHelper.e((float) k1) * 3439.0F + MathHelper.e((float) l1) * 147.0F) % 13.0F + 9.0F;
+
+                    f = (float) (k - i1 * 2);
+                    f1 = (float) (l - j1 * 2);
+                    float f4 = 100.0F - MathHelper.c(f * f + f1 * f1) * f3;
+
+                    if (f4 > 80.0F) {
+                        f4 = 80.0F;
+                    }
+
+                    if (f4 < -100.0F) {
+                        f4 = -100.0F;
+                    }
+
+                    if (f4 > f2) {
+                        f2 = f4;
+                    }
+                }
+            }
+        }
+
+        return f2;
+    }
+
+    public boolean c(int i, int j) {
+        return (long) i * (long) i + (long) j * (long) j > 4096L && this.a(i, j, 1, 1) >= 0.0F;
+    }
+
+    private double[] a(double[] adouble, int i, int j, int k, int l, int i1, int j1) {
+        if (adouble == null) {
+            adouble = new double[l * i1 * j1];
+        }
+
+        double d0 = 684.412D;
+        double d1 = 684.412D;
+
+        d0 *= 2.0D;
+        this.e = this.k.a(this.e, i, j, k, l, i1, j1, d0 / 80.0D, d1 / 160.0D, d0 / 80.0D);
+        this.f = this.i.a(this.f, i, j, k, l, i1, j1, d0, d1, d0);
+        this.g = this.j.a(this.g, i, j, k, l, i1, j1, d0, d1, d0);
+        int k1 = i / 2;
+        int l1 = k / 2;
+        int i2 = 0;
+
+        for (int j2 = 0; j2 < l; ++j2) {
+            for (int k2 = 0; k2 < j1; ++k2) {
+                float f = this.a(k1, l1, j2, k2);
+
+                for (int l2 = 0; l2 < i1; ++l2) {
+                    double d2 = 0.0D;
+                    double d3 = this.f[i2] / 512.0D;
+                    double d4 = this.g[i2] / 512.0D;
+                    double d5 = (this.e[i2] / 10.0D + 1.0D) / 2.0D;
+
+                    if (d5 < 0.0D) {
+                        d2 = d3;
+                    } else if (d5 > 1.0D) {
+                        d2 = d4;
+                    } else {
+                        d2 = d3 + (d4 - d3) * d5;
+                    }
+
+                    d2 -= 8.0D;
+                    d2 += (double) f;
+                    byte b0 = 2;
+                    double d6;
+
+                    if (l2 > i1 / 2 - b0) {
+                        d6 = (double) ((float) (l2 - (i1 / 2 - b0)) / 64.0F);
+                        d6 = MathHelper.a(d6, 0.0D, 1.0D);
+                        d2 = d2 * (1.0D - d6) + -3000.0D * d6;
+                    }
+
+                    b0 = 8;
+                    if (l2 < b0) {
+                        d6 = (double) ((float) (b0 - l2) / ((float) b0 - 1.0F));
+                        d2 = d2 * (1.0D - d6) + -30.0D * d6;
+                    }
+
+                    adouble[i2] = d2;
+                    ++i2;
+                }
+            }
+        }
+
+        return adouble;
+    }
+
+    public void recreateStructures(int i, int j) {
+        BlockFalling.instaFall = true;
+        BlockPosition blockposition = new BlockPosition(i * 16, 0, j * 16);
+
+        if (this.m) {
+            this.n.a(this.l, this.h, new ChunkCoordIntPair(i, j));
+        }
+
+        this.l.getBiome(blockposition.a(16, 0, 16)).a(this.l, this.l.random, blockposition);
+        long k = (long) i * (long) i + (long) j * (long) j;
+
+        if (k > 4096L) {
+            float f = this.a(i, j, 1, 1);
+
+            if (f < -20.0F && this.h.nextInt(14) == 0) {
+                this.r.generate(this.l, this.h, blockposition.a(this.h.nextInt(16) + 8, 55 + this.h.nextInt(16), this.h.nextInt(16) + 8));
+                if (this.h.nextInt(4) == 0) {
+                    this.r.generate(this.l, this.h, blockposition.a(this.h.nextInt(16) + 8, 55 + this.h.nextInt(16), this.h.nextInt(16) + 8));
+                }
+            }
+
+            if (this.a(i, j, 1, 1) > 40.0F) {
+                int l = this.h.nextInt(5);
+
+                for (int i1 = 0; i1 < l; ++i1) {
+                    int j1 = this.h.nextInt(16) + 8;
+                    int k1 = this.h.nextInt(16) + 8;
+                    int l1 = this.l.getHighestBlockYAt(blockposition.a(j1, 0, k1)).getY();
+
+                    if (l1 > 0) {
+                        int i2 = l1 - 1;
+
+                        if (this.l.isEmpty(blockposition.a(j1, i2 + 1, k1)) && this.l.getType(blockposition.a(j1, i2, k1)).getBlock() == Blocks.END_STONE) {
+                            BlockChorusFlower.a(this.l, blockposition.a(j1, i2 + 1, k1), this.h, 8);
+                        }
+                    }
+                }
+            }
+        }
+
+        BlockFalling.instaFall = false;
+    }
+
+    public boolean a(Chunk chunk, int i, int j) {
+        return false;
+    }
+
+    public List<BiomeBase.BiomeMeta> getMobsFor(EnumCreatureType enumcreaturetype, BlockPosition blockposition) {
+        return this.l.getBiome(blockposition).getMobs(enumcreaturetype);
+    }
+
+    @Nullable
+    public BlockPosition findNearestMapFeature(World world, String s, BlockPosition blockposition) {
+        return null;
+    }
+
+    public void recreateStructures(Chunk chunk, int i, int j) {}
+}
diff -Naur src_origin/main/java/net/minecraft/server/ChunkRegionLoader.java src/main/java/net/minecraft/server/ChunkRegionLoader.java
--- src_origin/main/java/net/minecraft/server/ChunkRegionLoader.java	2016-05-29 15:00:14.031641615 +0800
+++ src/main/java/net/minecraft/server/ChunkRegionLoader.java	2016-06-08 13:02:33.846102555 +0800
@@ -348,7 +348,8 @@
         return chunk;
     }
 
-    public void loadEntities(Chunk chunk, NBTTagCompound nbttagcompound, World world) {
+    //public void loadEntities(Chunk chunk, NBTTagCompound nbttagcompound, World world) {
+    public synchronized void loadEntities(Chunk chunk, NBTTagCompound nbttagcompound, World world) {
         // CraftBukkit end
         world.timings.syncChunkLoadEntitiesTimer.startTiming(); // Spigot
         NBTTagList nbttaglist1 = nbttagcompound.getList("Entities", 10);
diff -Naur src_origin/main/java/net/minecraft/server/DataWatcher.java src/main/java/net/minecraft/server/DataWatcher.java
--- src_origin/main/java/net/minecraft/server/DataWatcher.java	2016-05-29 15:00:14.146641604 +0800
+++ src/main/java/net/minecraft/server/DataWatcher.java	2016-06-08 13:02:33.972102543 +0800
@@ -1,5 +1,6 @@
 package net.minecraft.server;
 
+import com.google.common.base.Optional;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import io.netty.handler.codec.DecoderException;
@@ -16,9 +17,11 @@
 
 public class DataWatcher {
 
-    private static final Map<Class<? extends Entity>, Integer> a = Maps.newHashMap();
+    //private static final Map<Class<? extends Entity>, Integer> a = Maps.newHashMap();
+    private static final Map<Class<? extends Entity>, Integer> a = Maps.newConcurrentMap();
     private final Entity b;
-    private final Map<Integer, DataWatcher.Item<?>> c = Maps.newHashMap();
+    //private final Map<Integer, DataWatcher.Item<?>> c = Maps.newHashMap();
+    private final Map<Integer, DataWatcher.Item<?>> c = Maps.newConcurrentMap();
     private final ReadWriteLock d = new ReentrantReadWriteLock();
     private boolean e = true;
     private boolean f;
@@ -112,7 +115,7 @@
         }
 
     }
-
+    
     public <T> void markDirty(DataWatcherObject<T> datawatcherobject) {
         this.c(datawatcherobject).c = true;
         this.f = true;
diff -Naur src_origin/main/java/net/minecraft/server/EnderDragonBattle.java src/main/java/net/minecraft/server/EnderDragonBattle.java
--- src_origin/main/java/net/minecraft/server/EnderDragonBattle.java	2016-05-29 15:00:14.207641599 +0800
+++ src/main/java/net/minecraft/server/EnderDragonBattle.java	2016-06-08 13:02:34.014102540 +0800
@@ -12,6 +12,7 @@
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.Random;
 import java.util.UUID;
 import javax.annotation.Nullable;
diff -Naur src_origin/main/java/net/minecraft/server/EntityAreaEffectCloud.java src/main/java/net/minecraft/server/EntityAreaEffectCloud.java
--- src_origin/main/java/net/minecraft/server/EntityAreaEffectCloud.java	2016-05-29 15:00:14.235641596 +0800
+++ src/main/java/net/minecraft/server/EntityAreaEffectCloud.java	2016-06-08 13:02:34.047102536 +0800
@@ -13,6 +13,7 @@
 import org.bukkit.entity.LivingEntity; // CraftBukkit
 
 import java.util.Map.Entry;
+import java.util.Queue;
 import javax.annotation.Nullable;
 
 public class EntityAreaEffectCloud extends Entity {
diff -Naur src_origin/main/java/net/minecraft/server/EntityArmorStand.java src/main/java/net/minecraft/server/EntityArmorStand.java
--- src_origin/main/java/net/minecraft/server/EntityArmorStand.java	2016-05-29 15:00:14.251641595 +0800
+++ src/main/java/net/minecraft/server/EntityArmorStand.java	2016-06-08 13:02:34.064102535 +0800
@@ -2,7 +2,9 @@
 
 import com.google.common.base.Predicate;
 import java.util.Arrays;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import javax.annotation.Nullable;
 
 // CraftBukkit start
@@ -291,14 +293,22 @@
 
     protected void co() {
         List list = this.world.getEntities(this, this.getBoundingBox(), EntityArmorStand.bw);
+        Iterator it = list.iterator();
+        while (it.hasNext()) {
+            Entity entity = (Entity) it.next();
 
+            if (this.h(entity) <= 0.2D) {
+                entity.collide(this);
+            }
+        }
+        /*
         for (int i = 0; i < list.size(); ++i) {
             Entity entity = (Entity) list.get(i);
 
             if (this.h(entity) <= 0.2D) {
                 entity.collide(this);
             }
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityArrow.java src/main/java/net/minecraft/server/EntityArrow.java
--- src_origin/main/java/net/minecraft/server/EntityArrow.java	2016-05-29 15:00:14.255641594 +0800
+++ src/main/java/net/minecraft/server/EntityArrow.java	2016-06-08 13:02:34.062102535 +0800
@@ -2,7 +2,9 @@
 
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import javax.annotation.Nullable;
 
 // CraftBukkit start
@@ -358,7 +360,26 @@
         Entity entity = null;
         List list = this.world.getEntities(this, this.getBoundingBox().a(this.motX, this.motY, this.motZ).g(1.0D), EntityArrow.f);
         double d0 = 0.0D;
+        
+        Iterator it = list.iterator();
+        while (it.hasNext()) {
+            Entity entity1 = (Entity) it.next();
 
+            if (entity1 != this.shooter || this.ay >= 5) {
+                AxisAlignedBB axisalignedbb = entity1.getBoundingBox().g(0.30000001192092896D);
+                MovingObjectPosition movingobjectposition = axisalignedbb.a(vec3d, vec3d1);
+
+                if (movingobjectposition != null) {
+                    double d1 = vec3d.distanceSquared(movingobjectposition.pos);
+
+                    if (d1 < d0 || d0 == 0.0D) {
+                        entity = entity1;
+                        d0 = d1;
+                    }
+                }
+            }
+        }
+        /*
         for (int i = 0; i < list.size(); ++i) {
             Entity entity1 = (Entity) list.get(i);
 
@@ -375,7 +396,7 @@
                     }
                 }
             }
-        }
+        }*/
 
         return entity;
     }
diff -Naur src_origin/main/java/net/minecraft/server/EntityBoat.java src/main/java/net/minecraft/server/EntityBoat.java
--- src_origin/main/java/net/minecraft/server/EntityBoat.java	2016-05-29 15:00:14.266641593 +0800
+++ src/main/java/net/minecraft/server/EntityBoat.java	2016-06-08 13:02:34.071102534 +0800
@@ -2,7 +2,9 @@
 
 import com.google.common.collect.Lists;
 import java.util.ArrayList;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import javax.annotation.Nullable;
 
 // CraftBukkit start
@@ -284,7 +286,19 @@
 
         if (!list.isEmpty()) {
             boolean flag = !this.world.isClientSide && !(this.bu() instanceof EntityHuman);
+            Iterator it = list.iterator();
+            while (it.hasNext()) {
+                Entity entity = (Entity) it.next();
 
+                if (!entity.w(this)) {
+                    if (flag && this.bv().size() < 2 && !entity.isPassenger() && entity.width < this.width && entity instanceof EntityLiving && !(entity instanceof EntityWaterAnimal) && !(entity instanceof EntityHuman)) {
+                        entity.startRiding(this);
+                    } else {
+                        this.collide(entity);
+                    }
+                }
+            }
+            /*
             for (int j = 0; j < list.size(); ++j) {
                 Entity entity = (Entity) list.get(j);
 
@@ -295,7 +309,7 @@
                         this.collide(entity);
                     }
                 }
-            }
+            }*/
         }
 
     }
diff -Naur src_origin/main/java/net/minecraft/server/EntityEnderDragon.java src/main/java/net/minecraft/server/EntityEnderDragon.java
--- src_origin/main/java/net/minecraft/server/EntityEnderDragon.java	2016-05-29 15:00:14.308641589 +0800
+++ src/main/java/net/minecraft/server/EntityEnderDragon.java	2016-06-08 13:02:34.117102530 +0800
@@ -2,6 +2,7 @@
 
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -371,6 +372,16 @@
     }
 
     private void b(List<Entity> list) {
+        Iterator it = list.iterator();
+        while (it.hasNext()) {
+            Entity entity = (Entity) it.next();
+
+            if (entity instanceof EntityLiving) {
+                entity.damageEntity(DamageSource.mobAttack(this), 10.0F);
+                this.a((EntityLiving) this, entity);
+            }
+        }
+        /*
         for (int i = 0; i < list.size(); ++i) {
             Entity entity = (Entity) list.get(i);
 
@@ -378,7 +389,7 @@
                 entity.damageEntity(DamageSource.mobAttack(this), 10.0F);
                 this.a((EntityLiving) this, entity);
             }
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityFishingHook.java src/main/java/net/minecraft/server/EntityFishingHook.java
--- src_origin/main/java/net/minecraft/server/EntityFishingHook.java	2016-05-29 15:00:14.341641586 +0800
+++ src/main/java/net/minecraft/server/EntityFishingHook.java	2016-06-08 13:02:34.147102527 +0800
@@ -2,6 +2,7 @@
 
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 
 // CraftBukkit start
 import org.bukkit.entity.Player;
@@ -177,6 +178,24 @@
 
                 d5 = 0.0D;
 
+                Iterator it = list.iterator();
+                while (it.hasNext()) {
+                    Entity entity1 = (Entity) it.next();
+
+                    if (entity1.isInteractable() && (entity1 != this.owner || this.au >= 5)) {
+                        AxisAlignedBB axisalignedbb = entity1.getBoundingBox().g(0.30000001192092896D);
+                        MovingObjectPosition movingobjectposition1 = axisalignedbb.a(vec3d, vec3d1);
+
+                        if (movingobjectposition1 != null) {
+                            d6 = vec3d.distanceSquared(movingobjectposition1.pos);
+                            if (d6 < d5 || d5 == 0.0D) {
+                                entity = entity1;
+                                d5 = d6;
+                            }
+                        }
+                    }
+                }
+                /*
                 for (int j = 0; j < list.size(); ++j) {
                     Entity entity1 = (Entity) list.get(j);
 
@@ -192,7 +211,7 @@
                             }
                         }
                     }
-                }
+                }*/
 
                 if (entity != null) {
                     movingobjectposition = new MovingObjectPosition(entity);
diff -Naur src_origin/main/java/net/minecraft/server/EntityHorse.java src/main/java/net/minecraft/server/EntityHorse.java
--- src_origin/main/java/net/minecraft/server/EntityHorse.java	2016-05-29 15:00:14.366641584 +0800
+++ src/main/java/net/minecraft/server/EntityHorse.java	2016-06-08 13:02:34.186102524 +0800
@@ -4,6 +4,7 @@
 import com.google.common.base.Predicate;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.UUID;
 import javax.annotation.Nullable;
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityHuman.java src/main/java/net/minecraft/server/EntityHuman.java
--- src_origin/main/java/net/minecraft/server/EntityHuman.java	2016-05-29 15:00:14.389641582 +0800
+++ src/main/java/net/minecraft/server/EntityHuman.java	2016-06-08 13:02:34.197102523 +0800
@@ -7,6 +7,7 @@
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.UUID;
 import javax.annotation.Nullable;
 
@@ -377,14 +378,23 @@
             }
 
             List list = this.world.getEntities(this, axisalignedbb);
+            Iterator it = list.iterator();
+            
+            while (it.hasNext()) {
+                Entity entity = (Entity) it.next();
 
+                if (!entity.dead) {
+                    this.c(entity);
+                }
+            }
+            /*
             for (int i = 0; i < list.size(); ++i) {
                 Entity entity = (Entity) list.get(i);
 
                 if (!entity.dead) {
                     this.c(entity);
                 }
-            }
+            }*/
         }
 
     }
diff -Naur src_origin/main/java/net/minecraft/server/EntityInsentient.java src/main/java/net/minecraft/server/EntityInsentient.java
--- src_origin/main/java/net/minecraft/server/EntityInsentient.java	2016-05-29 15:00:14.388641582 +0800
+++ src/main/java/net/minecraft/server/EntityInsentient.java	2016-06-08 13:02:34.184102524 +0800
@@ -5,6 +5,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
 import java.util.Random;
 import java.util.UUID;
 import javax.annotation.Nullable;
diff -Naur src_origin/main/java/net/minecraft/server/Entity.java src/main/java/net/minecraft/server/Entity.java
--- src_origin/main/java/net/minecraft/server/Entity.java	2016-05-29 15:00:14.224641597 +0800
+++ src/main/java/net/minecraft/server/Entity.java	2016-06-08 13:02:34.044102537 +0800
@@ -11,6 +11,7 @@
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.RecursiveAction;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -301,7 +302,7 @@
         this.U();
     }
 
-    public void U() {
+    public void U_hose() {
         this.world.methodProfiler.a("entityBaseTick");
         if (this.isPassenger() && this.bz().dead) {
             this.stopRiding();
@@ -392,6 +393,102 @@
         this.justCreated = false;
         this.world.methodProfiler.b();
     }
+    
+    public void U() {
+        U u_task = new U();
+        u_task.fork();
+        //u_task.join();
+        /*
+        this.world.methodProfiler.a("entityBaseTick");
+        if (this.isPassenger() && this.bz().dead) {
+            this.stopRiding();
+        }
+
+        if (this.j > 0) {
+            --this.j;
+        }
+
+        this.I = this.J;
+        this.lastX = this.locX;
+        this.lastY = this.locY;
+        this.lastZ = this.locZ;
+        this.lastPitch = this.pitch;
+        this.lastYaw = this.yaw;
+        if (!this.world.isClientSide && this.world instanceof WorldServer) {
+            this.world.methodProfiler.a("portal");
+            if (this.ak) {
+                MinecraftServer minecraftserver = this.world.getMinecraftServer();
+
+                if (true || minecraftserver.getAllowNether()) { // CraftBukkit
+                    if (!this.isPassenger()) {
+                        int i = this.V();
+
+                        if (this.al++ >= i) {
+                            this.al = i;
+                            this.portalCooldown = this.aC();
+                            byte b0;
+
+                            if (this.world.worldProvider.getDimensionManager().getDimensionID() == -1) {
+                                b0 = 0;
+                            } else {
+                                b0 = -1;
+                            }
+
+                            this.c(b0);
+                        }
+                    }
+
+                    this.ak = false;
+                }
+            } else {
+                if (this.al > 0) {
+                    this.al -= 4;
+                }
+
+                if (this.al < 0) {
+                    this.al = 0;
+                }
+            }
+
+            this.H();
+            this.world.methodProfiler.b();
+        }
+
+        this.al();
+        this.aj();
+        if (this.world.isClientSide) {
+            this.fireTicks = 0;
+        } else if (this.fireTicks > 0) {
+            if (this.fireProof) {
+                this.fireTicks -= 4;
+                if (this.fireTicks < 0) {
+                    this.fireTicks = 0;
+                }
+            } else {
+                if (this.fireTicks % 20 == 0) {
+                    this.damageEntity(DamageSource.BURN, 1.0F);
+                }
+
+                --this.fireTicks;
+            }
+        }
+
+        if (this.an()) {
+            this.burnFromLava();
+            this.fallDistance *= 0.5F;
+        }
+
+        if (this.locY < -64.0D) {
+            this.Y();
+        }
+
+        if (!this.world.isClientSide) {
+            this.setFlag(0, this.fireTicks > 0);
+        }
+
+        this.justCreated = false;
+        this.world.methodProfiler.b();*/
+    }
 
     protected void H() {
         if (this.portalCooldown > 0) {
@@ -1572,7 +1669,7 @@
             return false;
         } else {
             BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
-
+            bp bp_task = new bp(blockposition_pooledblockposition);
             for (int i = 0; i < 8; ++i) {
                 int j = MathHelper.floor(this.locY + (double) (((float) ((i >> 0) % 2) - 0.5F) * 0.1F) + (double) this.getHeadHeight());
                 int k = MathHelper.floor(this.locX + (double) (((float) ((i >> 1) % 2) - 0.5F) * this.width * 0.8F));
@@ -1581,13 +1678,17 @@
                 if (blockposition_pooledblockposition.getX() != k || blockposition_pooledblockposition.getY() != j || blockposition_pooledblockposition.getZ() != l) {
                     blockposition_pooledblockposition.f(k, j, l);
                     if (this.world.getType(blockposition_pooledblockposition).getBlock().j()) {
-                        blockposition_pooledblockposition.t();
+                        //blockposition_pooledblockposition.t();
+                        //fork
+                        bp_task.fork();
                         return true;
                     }
                 }
             }
 
-            blockposition_pooledblockposition.t();
+            //blockposition_pooledblockposition.t();
+            //fork
+            bp_task.fork();
             return false;
         }
     }
@@ -2625,4 +2726,31 @@
 
         }
     }
+    
+    class U extends RecursiveAction {
+                
+        U() {
+
+        }
+        
+        @Override
+        protected void compute() {
+            U_hose();
+        }
+                 
+    }
+    
+    class bp extends RecursiveAction {
+        BlockPosition.PooledBlockPosition blockposition_pooledblockposition;
+        bp(BlockPosition.PooledBlockPosition blockposition_pooledblockposition) {
+            this.blockposition_pooledblockposition = blockposition_pooledblockposition;
+        }
+        
+        @Override
+        protected void compute() {
+            blockposition_pooledblockposition.t();
+        }
+                 
+    }
+    
 }
diff -Naur src_origin/main/java/net/minecraft/server/EntityLeash.java src/main/java/net/minecraft/server/EntityLeash.java
--- src_origin/main/java/net/minecraft/server/EntityLeash.java	2016-05-29 15:00:14.405641580 +0800
+++ src/main/java/net/minecraft/server/EntityLeash.java	2016-06-08 13:02:34.223102520 +0800
@@ -4,6 +4,7 @@
 
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import javax.annotation.Nullable;
 
 public class EntityLeash extends EntityHanging {
diff -Naur src_origin/main/java/net/minecraft/server/EntityLightning.java src/main/java/net/minecraft/server/EntityLightning.java
--- src_origin/main/java/net/minecraft/server/EntityLightning.java	2016-05-29 15:00:14.413641580 +0800
+++ src/main/java/net/minecraft/server/EntityLightning.java	2016-06-08 13:02:34.227102520 +0800
@@ -1,6 +1,8 @@
 package net.minecraft.server;
 
+import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 
 import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
 
@@ -112,11 +114,18 @@
                 double d0 = 3.0D;
                 List list = this.world.getEntities(this, new AxisAlignedBB(this.locX - d0, this.locY - d0, this.locZ - d0, this.locX + d0, this.locY + 6.0D + d0, this.locZ + d0));
 
+                Iterator it = list.iterator();
+                while (it.hasNext()) {
+                    Entity entity = (Entity) it.next();
+
+                    entity.onLightningStrike(this);
+                }
+                /*
                 for (int i = 0; i < list.size(); ++i) {
                     Entity entity = (Entity) list.get(i);
 
                     entity.onLightningStrike(this);
-                }
+                }*/
             }
         }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityLiving.java src/main/java/net/minecraft/server/EntityLiving.java
--- src_origin/main/java/net/minecraft/server/EntityLiving.java	2016-05-29 15:00:14.431641578 +0800
+++ src/main/java/net/minecraft/server/EntityLiving.java	2016-06-08 13:02:34.265102517 +0800
@@ -14,6 +14,8 @@
 import java.util.ArrayList;
 import com.google.common.base.Function;
 import com.google.common.collect.Lists;
+import java.util.Queue;
+import java.util.concurrent.RecursiveAction;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.attribute.CraftAttributeMap;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
@@ -638,7 +640,11 @@
     }
 
     public void addEffect(MobEffect mobeffect) {
-        org.spigotmc.AsyncCatcher.catchOp( "effect add"); // Spigot
+        //org.spigotmc.AsyncCatcher.catchOp( "effect add"); // Spigot
+        if (org.spigotmc.AsyncCatcher.catchOp_flag()) { // HOSE
+            System.out.println("AsyncCatcher: effect add.");
+            return;
+        }
         // CraftBukkit start
         if (isTickingEffects) {
             effectsToProcess.add(mobeffect);
@@ -1540,6 +1546,8 @@
 
                 this.a(f, f1, f3);
                 this.move(this.motX, this.motY, this.motZ);
+                /*move move_task = new move(this, this.motX, this.motY, this.motZ);
+                move_task.fork();*/
                 this.motX *= (double) f4;
                 this.motY *= 0.800000011920929D;
                 this.motZ *= (double) f4;
@@ -1551,6 +1559,8 @@
                 d1 = this.locY;
                 this.a(f, f1, 0.02F);
                 this.move(this.motX, this.motY, this.motZ);
+                /*move move_task = new move(this, this.motX, this.motY, this.motZ);
+                move_task.fork();*/
                 this.motX *= 0.5D;
                 this.motY *= 0.5D;
                 this.motZ *= 0.5D;
@@ -1598,6 +1608,9 @@
                 this.motY *= 0.9800000190734863D;
                 this.motZ *= 0.9900000095367432D;
                 this.move(this.motX, this.motY, this.motZ);
+                /*move move_task = new move(this, this.motX, this.motY, this.motZ);
+                move_task.fork();*/
+                
                 if (this.positionChanged && !this.world.isClientSide) {
                     d4 = Math.sqrt(this.motX * this.motX + this.motZ * this.motZ);
                     double d5 = d2 - d4;
@@ -1651,6 +1664,10 @@
                 }
 
                 this.move(this.motX, this.motY, this.motZ);
+                /*move move_task = new move(this, this.motX, this.motY, this.motZ);
+                move_task.fork();
+                move_task.join();//must have
+                */
                 if (this.positionChanged && this.n_()) {
                     this.motY = 0.2D;
                 }
@@ -1782,6 +1799,9 @@
 
         SpigotTimings.timerEntityBaseTick.stopTiming(); // Spigot
         this.n();
+        //fork join
+        /*n n_task = new n(this);
+        n_task.fork();*/
         SpigotTimings.timerEntityTickRest.startTiming(); // Spigot
         double d0 = this.locX - this.lastX;
         double d1 = this.locZ - this.lastZ;
@@ -1953,11 +1973,16 @@
         this.r();
         SpigotTimings.timerEntityAIMove.startTiming(); // Spigot
         this.g(this.be, this.bf);
+        //fork join
+        /*g g_task = new g(this, this.be, this.bf);
+        g_task.fork();*/
         SpigotTimings.timerEntityAIMove.stopTiming(); // Spigot
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("push");
         SpigotTimings.timerEntityAICollision.startTiming(); // Spigot
-        this.co();
+        //this.co();
+        co co_task = new co(this);
+        co_task.fork();
         SpigotTimings.timerEntityAICollision.stopTiming(); // Spigot
         this.world.methodProfiler.b();
     }
@@ -1993,9 +2018,10 @@
         List list = this.world.getEntities(this, this.getBoundingBox(), IEntitySelector.a(this));
 
         if (!list.isEmpty()) {
-                numCollisions = Math.max(0, numCollisions - world.spigotConfig.maxCollisionsPerEntity); // Spigot
-                for (int i = 0; i < list.size() && numCollisions < world.spigotConfig.maxCollisionsPerEntity; ++i) {
-                Entity entity = (Entity) list.get(i);
+            numCollisions = Math.max(0, numCollisions - world.spigotConfig.maxCollisionsPerEntity); // Spigot
+            Iterator it = list.iterator();
+            while (it.hasNext()) {
+                Entity entity = (Entity) it.next();
                 // TODO better check now?
                 // CraftBukkit start - Only handle mob (non-player) collisions every other tick
                 if (entity instanceof EntityLiving && !(this instanceof EntityPlayer) && this.ticksLived % 2 == 0) {
@@ -2007,6 +2033,20 @@
                 numCollisions++; // Spigot
                 this.C(entity);
             }
+            /*
+            for (int i = 0; i < list.size() && numCollisions < world.spigotConfig.maxCollisionsPerEntity; ++i) {
+                Entity entity = (Entity) list.get(i);
+                // TODO better check now?
+                // CraftBukkit start - Only handle mob (non-player) collisions every other tick
+                if (entity instanceof EntityLiving && !(this instanceof EntityPlayer) && this.ticksLived % 2 == 0) {
+                    continue;
+                }
+                // CraftBukkit end
+
+                entity.numCollisions++; // Spigot
+                numCollisions++; // Spigot
+                this.C(entity);
+            }*/
         }
 
     }
@@ -2386,4 +2426,67 @@
 
         }
     }
+    /*
+    class move extends RecursiveAction {
+        double d0, d1, d2;
+        EntityLiving el;
+                
+        move(EntityLiving el, double d0, double d1, double d2) {
+            this.d0 = d0;
+            this.d1 = d1;
+            this.d2 = d2;
+            this.el = el;
+        }
+        
+        @Override
+        protected void compute() {
+            el.move(d0, d1, d2);
+        }
+                 
+    }*/
+    /*
+    class n extends RecursiveAction {
+        EntityLiving el;
+                
+        n(EntityLiving el) {
+            this.el = el;
+        }
+        
+        @Override
+        protected void compute() {
+            el.n();
+        }
+                 
+    }*/
+    
+    class co extends RecursiveAction {
+        EntityLiving el;
+                
+        co(EntityLiving el) {
+            this.el = el;
+        }
+        
+        @Override
+        protected void compute() {
+            el.co();
+        }
+                 
+    }
+    
+    class g extends RecursiveAction {
+        EntityLiving el;
+        float be, bf;
+                
+        g(EntityLiving el, float be, float bf) {
+            this.el = el;
+            this.be = be;
+            this.bf = bf;
+        }
+        
+        @Override
+        protected void compute() {
+            el.g(be, bf);
+        }
+                 
+    }
 }
diff -Naur src_origin/main/java/net/minecraft/server/EntityPotion.java src/main/java/net/minecraft/server/EntityPotion.java
--- src_origin/main/java/net/minecraft/server/EntityPotion.java	2016-05-29 15:00:14.498641572 +0800
+++ src/main/java/net/minecraft/server/EntityPotion.java	2016-06-08 13:02:34.312102512 +0800
@@ -9,6 +9,7 @@
 
 // CraftBukkit start
 import java.util.HashMap;
+import java.util.Queue;
 
 import org.bukkit.craftbukkit.entity.CraftLivingEntity;
 import org.bukkit.entity.LivingEntity;
diff -Naur src_origin/main/java/net/minecraft/server/EntityProjectile.java src/main/java/net/minecraft/server/EntityProjectile.java
--- src_origin/main/java/net/minecraft/server/EntityProjectile.java	2016-05-29 15:00:14.500641572 +0800
+++ src/main/java/net/minecraft/server/EntityProjectile.java	2016-06-08 13:02:34.314102512 +0800
@@ -1,6 +1,8 @@
 package net.minecraft.server;
 
+import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.UUID;
 import javax.annotation.Nullable;
 
@@ -119,7 +121,34 @@
         List list = this.world.getEntities(this, this.getBoundingBox().a(this.motX, this.motY, this.motZ).g(1.0D));
         double d0 = 0.0D;
         boolean flag = false;
+        
+        Iterator it = list.iterator();
+        while (it.hasNext()) {
+            Entity entity1 = (Entity) it.next();
 
+            if (entity1.isInteractable()) {
+                if (entity1 == this.c) {
+                    flag = true;
+                } else if (this.ticksLived < 2 && this.c == null) {
+                    this.c = entity1;
+                    flag = true;
+                } else {
+                    flag = false;
+                    AxisAlignedBB axisalignedbb = entity1.getBoundingBox().g(0.30000001192092896D);
+                    MovingObjectPosition movingobjectposition1 = axisalignedbb.a(vec3d, vec3d1);
+
+                    if (movingobjectposition1 != null) {
+                        double d1 = vec3d.distanceSquared(movingobjectposition1.pos);
+
+                        if (d1 < d0 || d0 == 0.0D) {
+                            entity = entity1;
+                            d0 = d1;
+                        }
+                    }
+                }
+            }
+        }
+        /*
         for (int i = 0; i < list.size(); ++i) {
             Entity entity1 = (Entity) list.get(i);
 
@@ -144,7 +173,7 @@
                     }
                 }
             }
-        }
+        }*/
 
         if (this.c != null) {
             if (flag) {
diff -Naur src_origin/main/java/net/minecraft/server/EntityShulkerBullet.java src/main/java/net/minecraft/server/EntityShulkerBullet.java
--- src_origin/main/java/net/minecraft/server/EntityShulkerBullet.java	2016-05-29 15:00:14.519641570 +0800
+++ src/main/java/net/minecraft/server/EntityShulkerBullet.java	2016-06-08 13:02:34.327102511 +0800
@@ -4,6 +4,7 @@
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.UUID;
 import javax.annotation.Nullable;
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityTracker.java src/main/java/net/minecraft/server/EntityTracker.java
--- src_origin/main/java/net/minecraft/server/EntityTracker.java	2016-05-29 15:00:14.567641566 +0800
+++ src/main/java/net/minecraft/server/EntityTracker.java	2016-06-08 13:02:34.376102506 +0800
@@ -101,7 +101,11 @@
     }
 
     public void addEntity(Entity entity, int i, final int j, boolean flag) {
-        org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
+        //org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
+        if (org.spigotmc.AsyncCatcher.catchOp_flag()) { // HOSE
+            System.out.println("AsyncCatcher: entity track.");
+            return;
+        }
         i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
         try {
             if (this.trackedEntities.b(entity.getId())) {
diff -Naur src_origin/main/java/net/minecraft/server/EntityWither.java src/main/java/net/minecraft/server/EntityWither.java
--- src_origin/main/java/net/minecraft/server/EntityWither.java	2016-05-29 15:00:14.594641563 +0800
+++ src/main/java/net/minecraft/server/EntityWither.java	2016-06-08 13:02:34.395102505 +0800
@@ -2,8 +2,10 @@
 
 import com.google.common.base.Predicate;
 import com.google.common.base.Predicates;
+import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import javax.annotation.Nullable;
 
 // CraftBukkit start
@@ -263,7 +265,7 @@
                         }
                     } else {
                         List list = this.world.a(EntityLiving.class, this.getBoundingBox().grow(20.0D, 8.0D, 20.0D), Predicates.and(EntityWither.bG, IEntitySelector.e));
-
+                        
                         for (int i1 = 0; i1 < 10 && !list.isEmpty(); ++i1) {
                             EntityLiving entityliving = (EntityLiving) list.get(this.random.nextInt(list.size()));
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityZombie.java src/main/java/net/minecraft/server/EntityZombie.java
--- src_origin/main/java/net/minecraft/server/EntityZombie.java	2016-05-29 15:00:14.626641560 +0800
+++ src/main/java/net/minecraft/server/EntityZombie.java	2016-06-08 13:02:34.422102502 +0800
@@ -1,7 +1,9 @@
 package net.minecraft.server;
 
 import java.util.Calendar;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.UUID;
 import javax.annotation.Nullable;
 
@@ -392,8 +394,10 @@
                 if ((double) this.world.random.nextFloat() < 0.05D) {
                     List list = this.world.a(EntityChicken.class, this.getBoundingBox().grow(5.0D, 3.0D, 5.0D), IEntitySelector.b);
 
+                    Iterator it = list.iterator();
                     if (!list.isEmpty()) {
-                        EntityChicken entitychicken = (EntityChicken) list.get(0);
+                        //EntityChicken entitychicken = (EntityChicken) list.get(0);
+                        EntityChicken entitychicken = (EntityChicken) it.next();
 
                         entitychicken.o(true);
                         this.startRiding(entitychicken);
diff -Naur src_origin/main/java/net/minecraft/server/Explosion.java src/main/java/net/minecraft/server/Explosion.java
--- src_origin/main/java/net/minecraft/server/Explosion.java	2016-05-29 15:00:14.619641561 +0800
+++ src/main/java/net/minecraft/server/Explosion.java	2016-06-08 13:02:34.427102502 +0800
@@ -7,6 +7,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
 import java.util.Random;
 
 // CraftBukkit start
@@ -106,6 +107,57 @@
         List list = this.world.getEntities(this.source, new AxisAlignedBB((double) i, (double) l, (double) j1, (double) j, (double) i1, (double) k1));
         Vec3D vec3d = new Vec3D(this.posX, this.posY, this.posZ);
 
+        Iterator it = list.iterator();
+        while (it.hasNext()) {
+            Entity entity = (Entity) it.next();
+
+            if (!entity.br()) {
+                double d7 = entity.f(this.posX, this.posY, this.posZ) / (double) f3;
+
+                if (d7 <= 1.0D) {
+                    double d8 = entity.locX - this.posX;
+                    double d9 = entity.locY + (double) entity.getHeadHeight() - this.posY;
+                    double d10 = entity.locZ - this.posZ;
+                    double d11 = (double) MathHelper.sqrt(d8 * d8 + d9 * d9 + d10 * d10);
+
+                    if (d11 != 0.0D) {
+                        d8 /= d11;
+                        d9 /= d11;
+                        d10 /= d11;
+                        double d12 = (double) this.world.a(vec3d, entity.getBoundingBox());
+                        double d13 = (1.0D - d7) * d12;
+
+                        // CraftBukkit start
+                        // entity.damageEntity(DamageSource.explosion(this), (float) ((int) ((d13 * d13 + d13) / 2.0D * 7.0D * (double) f3 + 1.0D)));
+                        CraftEventFactory.entityDamage = source;
+                        entity.forceExplosionKnockback = false;
+                        boolean wasDamaged = entity.damageEntity(DamageSource.explosion(this), (float) ((int) ((d13 * d13 + d13) / 2.0D * 7.0D * (double) f3 + 1.0D)));
+                        CraftEventFactory.entityDamage = null;
+                        if (!wasDamaged && !(entity instanceof EntityTNTPrimed || entity instanceof EntityFallingBlock) && !entity.forceExplosionKnockback) {
+                            continue;
+                        }
+                        // CraftBukkit end
+                        double d14 = 1.0D;
+
+                        if (entity instanceof EntityLiving) {
+                            d14 = EnchantmentProtection.a((EntityLiving) entity, d13);
+                        }
+
+                        entity.motX += d8 * d14;
+                        entity.motY += d9 * d14;
+                        entity.motZ += d10 * d14;
+                        if (entity instanceof EntityHuman) {
+                            EntityHuman entityhuman = (EntityHuman) entity;
+
+                            if (!entityhuman.isSpectator() && (!entityhuman.l_() || !entityhuman.abilities.isFlying)) {
+                                this.k.put(entityhuman, new Vec3D(d8 * d13, d9 * d13, d10 * d13));
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        /*
         for (int l1 = 0; l1 < list.size(); ++l1) {
             Entity entity = (Entity) list.get(l1);
 
@@ -154,7 +206,7 @@
                     }
                 }
             }
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/ItemArmor.java src/main/java/net/minecraft/server/ItemArmor.java
--- src_origin/main/java/net/minecraft/server/ItemArmor.java	2016-05-29 15:00:14.695641554 +0800
+++ src/main/java/net/minecraft/server/ItemArmor.java	2016-06-08 13:02:34.500102495 +0800
@@ -2,7 +2,9 @@
 
 import com.google.common.base.Predicates;
 import com.google.common.collect.Multimap;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.UUID;
 
 // CraftBukkit start
@@ -35,11 +37,12 @@
         int k = blockposition.getZ();
         AxisAlignedBB axisalignedbb = new AxisAlignedBB((double) i, (double) j, (double) k, (double) (i + 1), (double) (j + 1), (double) (k + 1));
         List list = isourceblock.getWorld().a(EntityLiving.class, axisalignedbb, Predicates.and(IEntitySelector.e, new IEntitySelector.EntitySelectorEquipable(itemstack)));
-
+        Iterator it = list.iterator();
         if (list.isEmpty()) {
             return null;
         } else {
-            EntityLiving entityliving = (EntityLiving) list.get(0);
+            //EntityLiving entityliving = (EntityLiving) list.get(0);
+            EntityLiving entityliving = (EntityLiving) it.next();
             EnumItemSlot enumitemslot = EntityInsentient.d(itemstack);
             // CraftBukkit start
             ItemStack itemstack1 = itemstack.cloneAndSubtract(1);
diff -Naur src_origin/main/java/net/minecraft/server/ItemBoat.java src/main/java/net/minecraft/server/ItemBoat.java
--- src_origin/main/java/net/minecraft/server/ItemBoat.java	2016-05-29 15:00:14.705641553 +0800
+++ src/main/java/net/minecraft/server/ItemBoat.java	2016-06-08 13:02:34.506102494 +0800
@@ -1,6 +1,8 @@
 package net.minecraft.server;
 
+import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 
 public class ItemBoat extends Item {
 
@@ -38,6 +40,19 @@
             boolean flag = false;
             List list = world.getEntities(entityhuman, entityhuman.getBoundingBox().a(vec3d2.x * d3, vec3d2.y * d3, vec3d2.z * d3).g(1.0D));
 
+            Iterator it = list.iterator();
+            while (it.hasNext()) {
+                 Entity entity = (Entity) it.next();
+
+                if (entity.isInteractable()) {
+                    AxisAlignedBB axisalignedbb = entity.getBoundingBox().g((double) entity.aA());
+
+                    if (axisalignedbb.a(vec3d)) {
+                        flag = true;
+                    }
+                }
+            }
+            /*
             for (int i = 0; i < list.size(); ++i) {
                 Entity entity = (Entity) list.get(i);
 
@@ -48,7 +63,7 @@
                         flag = true;
                     }
                 }
-            }
+            }*/
 
             if (flag) {
                 return new InteractionResultWrapper(EnumInteractionResult.PASS, itemstack);
diff -Naur src_origin/main/java/net/minecraft/server/ItemLeash.java src/main/java/net/minecraft/server/ItemLeash.java
--- src_origin/main/java/net/minecraft/server/ItemLeash.java	2016-05-29 15:00:14.752641549 +0800
+++ src/main/java/net/minecraft/server/ItemLeash.java	2016-06-08 13:02:34.551102490 +0800
@@ -2,6 +2,7 @@
 
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 
 import org.bukkit.event.hanging.HangingPlaceEvent; // CraftBukkit
 
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2016-05-29 15:00:14.828641542 +0800
+++ src/main/java/net/minecraft/server/MinecraftServer.java	2016-06-08 13:02:34.622102484 +0800
@@ -33,6 +33,7 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
 import java.util.Random;
@@ -40,6 +41,7 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
+import java.util.concurrent.RecursiveAction;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
 import org.apache.commons.lang3.Validate;
@@ -51,6 +53,8 @@
 import org.bukkit.craftbukkit.CraftServer;
 // CraftBukkit end
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.hose.ChunkGen_Pool;
+import org.spigotmc.SpigotWorldConfig;
 
 public abstract class MinecraftServer implements Runnable, ICommandListener, IAsyncTaskHandler, IMojangStatistics {
 
@@ -358,7 +362,10 @@
             BlockPosition blockposition = worldserver.getSpawn();
             long j = av();
             i = 0;
-
+            //hose
+            List<int[]> chunkgen_list = new LinkedList();
+            int[] pos = new int[2];
+            
             for (int k = -192; k <= 192 && this.isRunning(); k += 16) {
                 for (int l = -192; l <= 192 && this.isRunning(); l += 16) {
                     long i1 = av();
@@ -369,9 +376,13 @@
                     }
 
                     ++i;
-                    worldserver.getChunkProviderServer().getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    //worldserver.getChunkProviderServer().getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    pos[0] = blockposition.getX() + k >> 4;
+                    pos[1] = blockposition.getZ() + l >> 4;
+                    chunkgen_list.add(pos);
                 }
             }
+            SpigotWorldConfig.ChunkPool.invoke(new ChunkGen_Pool(worldserver, chunkgen_list));
         }
 
         for (WorldServer world : this.worlds) {
@@ -724,7 +735,7 @@
         int count = this.j.size();
         while (count-- > 0 && (entry = this.j.poll()) != null) {
             SystemUtils.a(entry, MinecraftServer.LOGGER);
-         }
+        }
         // Spigot end
 
         this.methodProfiler.c("levels");
@@ -1027,7 +1038,8 @@
     }
 
     public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        //return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "HOSE"; // HOSE -> Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1109,7 +1121,8 @@
     }
 
     public String getName() {
-        return "Server";
+        //return "Server";
+        return org.bukkit.ChatColor.GREEN + "Server";
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
@@ -1537,4 +1550,20 @@
         return (Bukkit.getServer() instanceof CraftServer) ? ((CraftServer) Bukkit.getServer()).getServer() : null;
     }
     // CraftBukkit end
+    
+    class jobs extends RecursiveAction {
+        FutureTask futuretask;
+        Logger logger;
+                
+        <V> jobs(FutureTask<V> futuretask, Logger logger) {
+            this.futuretask = futuretask;
+            this.logger = logger;
+        }
+        
+        @Override
+        protected void compute() {
+            SystemUtils.a(futuretask, MinecraftServer.LOGGER);
+        }
+                 
+    }
 }
diff -Naur src_origin/main/java/net/minecraft/server/NavigationAbstract.java src/main/java/net/minecraft/server/NavigationAbstract.java
--- src_origin/main/java/net/minecraft/server/NavigationAbstract.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/NavigationAbstract.java	2016-06-08 13:02:34.647102481 +0800
@@ -0,0 +1,292 @@
+package net.minecraft.server;
+
+import javax.annotation.Nullable;
+
+public abstract class NavigationAbstract {
+
+    private static int f = 20;
+    protected EntityInsentient a;
+    protected World b;
+    @Nullable
+    protected PathEntity c;
+    protected double d;
+    private final AttributeInstance g;
+    private int h;
+    private int i;
+    private Vec3D j;
+    private Vec3D k;
+    private long l;
+    private long m;
+    private double n;
+    private float o;
+    private boolean p;
+    private long q;
+    protected PathfinderAbstract e;
+    private BlockPosition r;
+    private final Pathfinder s;
+
+    public NavigationAbstract(EntityInsentient entityinsentient, World world) {
+        this.j = Vec3D.a;
+        this.k = Vec3D.a;
+        this.l = 0L;
+        this.m = 0L;
+        this.o = 0.5F;
+        this.a = entityinsentient;
+        this.b = world;
+        this.g = entityinsentient.getAttributeInstance(GenericAttributes.FOLLOW_RANGE);
+        this.s = this.a();
+    }
+
+    protected abstract Pathfinder a();
+
+    public void a(double d0) {
+        this.d = d0;
+    }
+
+    public float h() {
+        return (float) this.g.getValue();
+    }
+
+    public boolean i() {
+        return this.p;
+    }
+
+    public void j() {
+        if (this.b.getTime() - this.q > (long) NavigationAbstract.f) {
+            if (this.r != null) {
+                this.c = null;
+                this.c = this.a(this.r);
+                this.q = this.b.getTime();
+                this.p = false;
+            }
+        } else {
+            this.p = true;
+        }
+
+    }
+
+    @Nullable
+    public final PathEntity a(double d0, double d1, double d2) {
+        return this.a(new BlockPosition(MathHelper.floor(d0), (int) d1, MathHelper.floor(d2)));
+    }
+
+    @Nullable
+    public PathEntity a(BlockPosition blockposition) {
+        if (!this.b()) {
+            return null;
+        } else if (this.c != null && !this.c.b() && blockposition.equals(this.r)) {
+            return this.c;
+        } else {
+            this.r = blockposition;
+            float f = this.h();
+
+            this.b.methodProfiler.a("pathfind");
+            BlockPosition blockposition1 = new BlockPosition(this.a);
+            int i = (int) (f + 8.0F);
+            ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+            PathEntity pathentity = this.s.a(chunkcache, this.a, this.r, f);
+            //fork join
+            
+            
+            this.b.methodProfiler.b();
+            return pathentity;
+        }
+    }
+
+    @Nullable
+    public PathEntity a(Entity entity) {
+        if (!this.b()) {
+            return null;
+        } else {
+            BlockPosition blockposition = new BlockPosition(entity);
+
+            if (this.c != null && !this.c.b() && blockposition.equals(this.r)) {
+                return this.c;
+            } else {
+                this.r = blockposition;
+                float f = this.h();
+
+                this.b.methodProfiler.a("pathfind");
+                BlockPosition blockposition1 = (new BlockPosition(this.a)).up();
+                int i = (int) (f + 16.0F);
+                ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+                PathEntity pathentity = this.s.a(chunkcache, this.a, entity, f);
+
+                this.b.methodProfiler.b();
+                return pathentity;
+            }
+        }
+    }
+
+    public boolean a(double d0, double d1, double d2, double d3) {
+        PathEntity pathentity = this.a((double) MathHelper.floor(d0), (double) ((int) d1), (double) MathHelper.floor(d2));
+
+        return this.a(pathentity, d3);
+    }
+
+    public boolean a(Entity entity, double d0) {
+        PathEntity pathentity = this.a(entity);
+
+        return pathentity != null ? this.a(pathentity, d0) : false;
+    }
+
+    public boolean a(@Nullable PathEntity pathentity, double d0) {
+        if (pathentity == null) {
+            this.c = null;
+            return false;
+        } else {
+            if (!pathentity.a(this.c)) {
+                this.c = pathentity;
+            }
+
+            this.d();
+            if (this.c.d() == 0) {
+                return false;
+            } else {
+                this.d = d0;
+                Vec3D vec3d = this.c();
+
+                this.i = this.h;
+                this.j = vec3d;
+                return true;
+            }
+        }
+    }
+
+    @Nullable
+    public PathEntity k() {
+        return this.c;
+    }
+
+    public void l() {
+        ++this.h;
+        if (this.p) {
+            this.j();
+        }
+
+        if (!this.n()) {
+            Vec3D vec3d;
+
+            if (this.b()) {
+                this.m();
+            } else if (this.c != null && this.c.e() < this.c.d()) {
+                vec3d = this.c();
+                Vec3D vec3d1 = this.c.a(this.a, this.c.e());
+
+                if (vec3d.y > vec3d1.y && !this.a.onGround && MathHelper.floor(vec3d.x) == MathHelper.floor(vec3d1.x) && MathHelper.floor(vec3d.z) == MathHelper.floor(vec3d1.z)) {
+                    this.c.c(this.c.e() + 1);
+                }
+            }
+
+            if (!this.n()) {
+                vec3d = this.c.a((Entity) this.a);
+                if (vec3d != null) {
+                    BlockPosition blockposition = (new BlockPosition(vec3d)).down();
+                    AxisAlignedBB axisalignedbb = this.b.getType(blockposition).c(this.b, blockposition);
+
+                    vec3d = vec3d.a(0.0D, 1.0D - axisalignedbb.e, 0.0D);
+                    this.a.getControllerMove().a(vec3d.x, vec3d.y, vec3d.z, this.d);
+                }
+            }
+        }
+    }
+
+    protected void m() {
+        Vec3D vec3d = this.c();
+        int i = this.c.d();
+
+        for (int j = this.c.e(); j < this.c.d(); ++j) {
+            if ((double) this.c.a(j).b != Math.floor(vec3d.y)) {
+                i = j;
+                break;
+            }
+        }
+
+        this.o = this.a.width > 0.75F ? this.a.width / 2.0F : 0.75F - this.a.width / 2.0F;
+        Vec3D vec3d1 = this.c.f();
+
+        if (MathHelper.e((float) (this.a.locX - (vec3d1.x + 0.5D))) < this.o && MathHelper.e((float) (this.a.locZ - (vec3d1.z + 0.5D))) < this.o) {
+            this.c.c(this.c.e() + 1);
+        }
+
+        int k = MathHelper.f(this.a.width);
+        int l = MathHelper.f(this.a.length);
+        int i1 = k;
+
+        for (int j1 = i - 1; j1 >= this.c.e(); --j1) {
+            if (this.a(vec3d, this.c.a(this.a, j1), k, l, i1)) {
+                //this.c.c(j1);
+                try {
+                    this.c.c(j1);
+                } catch (Exception ex) {
+                    break;
+                }
+                break;
+            }
+        }
+
+        this.a(vec3d);
+    }
+
+    protected void a(Vec3D vec3d) {
+        if (this.h - this.i > 100) {
+            if (vec3d.distanceSquared(this.j) < 2.25D) {
+                this.o();
+            }
+
+            this.i = this.h;
+            this.j = vec3d;
+        }
+
+        if (this.c != null && !this.c.b()) {
+            Vec3D vec3d1 = this.c.f();
+
+            if (!vec3d1.equals(this.k)) {
+                this.k = vec3d1;
+                double d0 = vec3d.f(this.k);
+
+                this.n = this.a.cl() > 0.0F ? d0 / (double) this.a.cl() * 1000.0D : 0.0D;
+            } else {
+                this.l += System.currentTimeMillis() - this.m;
+            }
+
+            if (this.n > 0.0D && (double) this.l > this.n * 3.0D) {
+                this.k = Vec3D.a;
+                this.l = 0L;
+                this.n = 0.0D;
+                this.o();
+            }
+
+            this.m = System.currentTimeMillis();
+        }
+
+    }
+
+    public boolean n() {
+        return this.c == null || this.c.b();
+    }
+
+    public void o() {
+        this.c = null;
+    }
+
+    protected abstract Vec3D c();
+
+    protected abstract boolean b();
+
+    protected boolean p() {
+        return this.a.isInWater() || this.a.an();
+    }
+
+    protected void d() {}
+
+    protected abstract boolean a(Vec3D vec3d, Vec3D vec3d1, int i, int j, int k);
+
+    public boolean b(BlockPosition blockposition) {
+        return this.b.getType(blockposition.down()).b();
+    }
+
+    public PathfinderAbstract q() {
+        return this.e;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/NBTBase.java src/main/java/net/minecraft/server/NBTBase.java
--- src_origin/main/java/net/minecraft/server/NBTBase.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/NBTBase.java	2016-06-08 13:02:34.658102480 +0800
@@ -0,0 +1,104 @@
+package net.minecraft.server;
+
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+
+public abstract class NBTBase {
+
+    public static final String[] a = new String[] { "END", "BYTE", "SHORT", "INT", "LONG", "FLOAT", "DOUBLE", "BYTE[]", "STRING", "LIST", "COMPOUND", "INT[]"};
+
+    abstract void write(DataOutput dataoutput) throws IOException;
+
+    abstract void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException;
+
+    public abstract String toString();
+
+    public abstract byte getTypeId();
+
+    protected NBTBase() {}
+
+    protected static NBTBase createTag(byte b0) {
+        switch (b0) {
+        case 0:
+            return new NBTTagEnd();
+
+        case 1:
+            return new NBTTagByte();
+
+        case 2:
+            return new NBTTagShort();
+
+        case 3:
+            return new NBTTagInt();
+
+        case 4:
+            return new NBTTagLong();
+
+        case 5:
+            return new NBTTagFloat();
+
+        case 6:
+            return new NBTTagDouble();
+
+        case 7:
+            return new NBTTagByteArray();
+
+        case 8:
+            return new NBTTagString();
+
+        case 9:
+            return new NBTTagList();
+
+        case 10:
+            return new NBTTagCompound();
+
+        case 11:
+            return new NBTTagIntArray();
+
+        default:
+            return null;
+        }
+    }
+
+    public abstract NBTBase clone();
+
+    public boolean isEmpty() {
+        return false;
+    }
+
+    public boolean equals(Object object) {
+        if (!(object instanceof NBTBase)) {
+            return false;
+        } else {
+            NBTBase nbtbase = (NBTBase) object;
+
+            return this.getTypeId() == nbtbase.getTypeId();
+        }
+    }
+
+    public int hashCode() {
+        return this.getTypeId();
+    }
+
+    protected String a_() {
+        return this.toString();
+    }
+
+    public abstract static class NBTNumber extends NBTBase {
+
+        protected NBTNumber() {}
+
+        public abstract long c();
+
+        public abstract int d();
+
+        public abstract short e();
+
+        public abstract byte f();
+
+        public abstract double g();
+
+        public abstract float h();
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/NBTTagCompound.java src/main/java/net/minecraft/server/NBTTagCompound.java
--- src_origin/main/java/net/minecraft/server/NBTTagCompound.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/NBTTagCompound.java	2016-06-08 13:02:34.665102480 +0800
@@ -0,0 +1,418 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Maps;
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+import java.util.Map.Entry;
+import javax.annotation.Nullable;
+
+public class NBTTagCompound extends NBTBase {
+
+    //private Map<String, NBTBase> map = Maps.newHashMap();
+    private Map<String, NBTBase> map = Maps.newConcurrentMap();
+
+    public NBTTagCompound() {}
+
+    void write(DataOutput dataoutput) throws IOException {
+        Iterator iterator = this.map.keySet().iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+            NBTBase nbtbase = (NBTBase) this.map.get(s);
+
+            a(s, nbtbase, dataoutput);
+        }
+
+        dataoutput.writeByte(0);
+    }
+
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+        nbtreadlimiter.a(384L);
+        if (i > 512) {
+            throw new RuntimeException("Tried to read NBT tag with too high complexity, depth > 512");
+        } else {
+            this.map.clear();
+
+            byte b0;
+
+            while ((b0 = a(datainput, nbtreadlimiter)) != 0) {
+                String s = b(datainput, nbtreadlimiter);
+
+                nbtreadlimiter.a((long) (224 + 16 * s.length()));
+                NBTBase nbtbase = a(b0, s, datainput, i + 1, nbtreadlimiter);
+
+                if (this.map.put(s, nbtbase) != null) {
+                    nbtreadlimiter.a(288L);
+                }
+            }
+
+        }
+    }
+
+    public Set<String> c() {
+        return this.map.keySet();
+    }
+
+    public byte getTypeId() {
+        return (byte) 10;
+    }
+
+    public int d() {
+        return this.map.size();
+    }
+
+    public void set(String s, NBTBase nbtbase) {
+        this.map.put(s, nbtbase);
+    }
+
+    public void setByte(String s, byte b0) {
+        this.map.put(s, new NBTTagByte(b0));
+    }
+
+    public void setShort(String s, short short0) {
+        this.map.put(s, new NBTTagShort(short0));
+    }
+
+    public void setInt(String s, int i) {
+        this.map.put(s, new NBTTagInt(i));
+    }
+
+    public void setLong(String s, long i) {
+        this.map.put(s, new NBTTagLong(i));
+    }
+
+    public void a(String s, UUID uuid) {
+        this.setLong(s + "Most", uuid.getMostSignificantBits());
+        this.setLong(s + "Least", uuid.getLeastSignificantBits());
+    }
+
+    @Nullable
+    public UUID a(String s) {
+        return new UUID(this.getLong(s + "Most"), this.getLong(s + "Least"));
+    }
+
+    public boolean b(String s) {
+        return this.hasKeyOfType(s + "Most", 99) && this.hasKeyOfType(s + "Least", 99);
+    }
+
+    public void setFloat(String s, float f) {
+        this.map.put(s, new NBTTagFloat(f));
+    }
+
+    public void setDouble(String s, double d0) {
+        this.map.put(s, new NBTTagDouble(d0));
+    }
+
+    public void setString(String s, String s1) {
+        this.map.put(s, new NBTTagString(s1));
+    }
+
+    public void setByteArray(String s, byte[] abyte) {
+        this.map.put(s, new NBTTagByteArray(abyte));
+    }
+
+    public void setIntArray(String s, int[] aint) {
+        this.map.put(s, new NBTTagIntArray(aint));
+    }
+
+    public void setBoolean(String s, boolean flag) {
+        this.setByte(s, (byte) (flag ? 1 : 0));
+    }
+
+    public NBTBase get(String s) {
+        return (NBTBase) this.map.get(s);
+    }
+
+    public byte d(String s) {
+        NBTBase nbtbase = (NBTBase) this.map.get(s);
+
+        return nbtbase == null ? 0 : nbtbase.getTypeId();
+    }
+
+    public boolean hasKey(String s) {
+        return this.map.containsKey(s);
+    }
+
+    public boolean hasKeyOfType(String s, int i) {
+        byte b0 = this.d(s);
+
+        return b0 == i ? true : (i != 99 ? false : b0 == 1 || b0 == 2 || b0 == 3 || b0 == 4 || b0 == 5 || b0 == 6);
+    }
+
+    public byte getByte(String s) {
+        try {
+            if (this.hasKeyOfType(s, 99)) {
+                return ((NBTBase.NBTNumber) this.map.get(s)).f();
+            }
+        } catch (ClassCastException classcastexception) {
+            ;
+        }
+
+        return (byte) 0;
+    }
+
+    public short getShort(String s) {
+        try {
+            if (this.hasKeyOfType(s, 99)) {
+                return ((NBTBase.NBTNumber) this.map.get(s)).e();
+            }
+        } catch (ClassCastException classcastexception) {
+            ;
+        }
+
+        return (short) 0;
+    }
+
+    public int getInt(String s) {
+        try {
+            if (this.hasKeyOfType(s, 99)) {
+                return ((NBTBase.NBTNumber) this.map.get(s)).d();
+            }
+        } catch (ClassCastException classcastexception) {
+            ;
+        }
+
+        return 0;
+    }
+
+    public long getLong(String s) {
+        try {
+            if (this.hasKeyOfType(s, 99)) {
+                return ((NBTBase.NBTNumber) this.map.get(s)).c();
+            }
+        } catch (ClassCastException classcastexception) {
+            ;
+        }
+
+        return 0L;
+    }
+
+    public float getFloat(String s) {
+        try {
+            if (this.hasKeyOfType(s, 99)) {
+                return ((NBTBase.NBTNumber) this.map.get(s)).h();
+            }
+        } catch (ClassCastException classcastexception) {
+            ;
+        }
+
+        return 0.0F;
+    }
+
+    public double getDouble(String s) {
+        try {
+            if (this.hasKeyOfType(s, 99)) {
+                return ((NBTBase.NBTNumber) this.map.get(s)).g();
+            }
+        } catch (ClassCastException classcastexception) {
+            ;
+        }
+
+        return 0.0D;
+    }
+
+    public String getString(String s) {
+        try {
+            if (this.hasKeyOfType(s, 8)) {
+                return ((NBTBase) this.map.get(s)).a_();
+            }
+        } catch (ClassCastException classcastexception) {
+            ;
+        }
+
+        return "";
+    }
+
+    public byte[] getByteArray(String s) {
+        try {
+            if (this.hasKeyOfType(s, 7)) {
+                return ((NBTTagByteArray) this.map.get(s)).c();
+            }
+        } catch (ClassCastException classcastexception) {
+            throw new ReportedException(this.a(s, 7, classcastexception));
+        }
+
+        return new byte[0];
+    }
+
+    public int[] getIntArray(String s) {
+        try {
+            if (this.hasKeyOfType(s, 11)) {
+                return ((NBTTagIntArray) this.map.get(s)).c();
+            }
+        } catch (ClassCastException classcastexception) {
+            throw new ReportedException(this.a(s, 11, classcastexception));
+        }
+
+        return new int[0];
+    }
+
+    public NBTTagCompound getCompound(String s) {
+        try {
+            if (this.hasKeyOfType(s, 10)) {
+                return (NBTTagCompound) this.map.get(s);
+            }
+        } catch (ClassCastException classcastexception) {
+            throw new ReportedException(this.a(s, 10, classcastexception));
+        }
+
+        return new NBTTagCompound();
+    }
+
+    public NBTTagList getList(String s, int i) {
+        try {
+            if (this.d(s) == 9) {
+                NBTTagList nbttaglist = (NBTTagList) this.map.get(s);
+
+                if (!nbttaglist.isEmpty() && nbttaglist.d() != i) {
+                    return new NBTTagList();
+                }
+
+                return nbttaglist;
+            }
+        } catch (ClassCastException classcastexception) {
+            throw new ReportedException(this.a(s, 9, classcastexception));
+        }
+
+        return new NBTTagList();
+    }
+
+    public boolean getBoolean(String s) {
+        return this.getByte(s) != 0;
+    }
+
+    public void remove(String s) {
+        this.map.remove(s);
+    }
+
+    public String toString() {
+        StringBuilder stringbuilder = new StringBuilder("{");
+
+        Entry entry;
+
+        for (Iterator iterator = this.map.entrySet().iterator(); iterator.hasNext(); stringbuilder.append((String) entry.getKey()).append(':').append(entry.getValue())) {
+            entry = (Entry) iterator.next();
+            if (stringbuilder.length() != 1) {
+                stringbuilder.append(',');
+            }
+        }
+
+        return stringbuilder.append('}').toString();
+    }
+
+    public boolean isEmpty() {
+        return this.map.isEmpty();
+    }
+
+    private CrashReport a(final String s, final int i, ClassCastException classcastexception) {
+        CrashReport crashreport = CrashReport.a(classcastexception, "Reading NBT data");
+        CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Corrupt NBT tag", 1);
+
+        crashreportsystemdetails.a("Tag type found", new CrashReportCallable() {
+            public String a() throws Exception {
+                return NBTBase.a[((NBTBase) NBTTagCompound.this.map.get(s)).getTypeId()];
+            }
+
+            public Object call() throws Exception {
+                return this.a();
+            }
+        });
+        crashreportsystemdetails.a("Tag type expected", new CrashReportCallable() {
+            public String a() throws Exception {
+                return NBTBase.a[i];
+            }
+
+            public Object call() throws Exception {
+                return this.a();
+            }
+        });
+        crashreportsystemdetails.a("Tag name", (Object) s);
+        return crashreport;
+    }
+
+    public NBTBase clone() {
+        NBTTagCompound nbttagcompound = new NBTTagCompound();
+        Iterator iterator = this.map.keySet().iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+
+            nbttagcompound.set(s, ((NBTBase) this.map.get(s)).clone());
+        }
+
+        return nbttagcompound;
+    }
+
+    public boolean equals(Object object) {
+        if (super.equals(object)) {
+            NBTTagCompound nbttagcompound = (NBTTagCompound) object;
+
+            return this.map.entrySet().equals(nbttagcompound.map.entrySet());
+        } else {
+            return false;
+        }
+    }
+
+    public int hashCode() {
+        return super.hashCode() ^ this.map.hashCode();
+    }
+
+    private static void a(String s, NBTBase nbtbase, DataOutput dataoutput) throws IOException {
+        dataoutput.writeByte(nbtbase.getTypeId());
+        if (nbtbase.getTypeId() != 0) {
+            dataoutput.writeUTF(s);
+            nbtbase.write(dataoutput);
+        }
+    }
+
+    private static byte a(DataInput datainput, NBTReadLimiter nbtreadlimiter) throws IOException {
+        return datainput.readByte();
+    }
+
+    private static String b(DataInput datainput, NBTReadLimiter nbtreadlimiter) throws IOException {
+        return datainput.readUTF();
+    }
+
+    static NBTBase a(byte b0, String s, DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+        NBTBase nbtbase = NBTBase.createTag(b0);
+
+        try {
+            nbtbase.load(datainput, i, nbtreadlimiter);
+            return nbtbase;
+        } catch (IOException ioexception) {
+            CrashReport crashreport = CrashReport.a(ioexception, "Loading NBT data");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("NBT Tag");
+
+            crashreportsystemdetails.a("Tag name", (Object) s);
+            crashreportsystemdetails.a("Tag type", (Object) Byte.valueOf(b0));
+            throw new ReportedException(crashreport);
+        }
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        Iterator iterator = nbttagcompound.map.keySet().iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+            NBTBase nbtbase = (NBTBase) nbttagcompound.map.get(s);
+
+            if (nbtbase.getTypeId() == 10) {
+                if (this.hasKeyOfType(s, 10)) {
+                    NBTTagCompound nbttagcompound1 = this.getCompound(s);
+
+                    nbttagcompound1.a((NBTTagCompound) nbtbase);
+                } else {
+                    this.set(s, nbtbase.clone());
+                }
+            } else {
+                this.set(s, nbtbase.clone());
+            }
+        }
+
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/NBTTagList.java src/main/java/net/minecraft/server/NBTTagList.java
--- src_origin/main/java/net/minecraft/server/NBTTagList.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/NBTTagList.java	2016-06-08 13:02:34.691102477 +0800
@@ -0,0 +1,233 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.io.DataInput;
+import java.io.DataOutput;
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.List;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class NBTTagList extends NBTBase {
+
+    private static final Logger b = LogManager.getLogger();
+    //private List<NBTBase> list = Lists.newArrayList();
+    private List<NBTBase> list = Lists.newCopyOnWriteArrayList();
+    private byte type = 0;
+
+    public NBTTagList() {}
+
+    void write(DataOutput dataoutput) throws IOException {
+        if (!this.list.isEmpty()) {
+            this.type = ((NBTBase) this.list.get(0)).getTypeId();
+        } else {
+            this.type = 0;
+        }
+
+        dataoutput.writeByte(this.type);
+        dataoutput.writeInt(this.list.size());
+
+        for (int i = 0; i < this.list.size(); ++i) {
+            ((NBTBase) this.list.get(i)).write(dataoutput);
+        }
+
+    }
+
+    void load(DataInput datainput, int i, NBTReadLimiter nbtreadlimiter) throws IOException {
+        nbtreadlimiter.a(296L);
+        if (i > 512) {
+            throw new RuntimeException("Tried to read NBT tag with too high complexity, depth > 512");
+        } else {
+            this.type = datainput.readByte();
+            int j = datainput.readInt();
+
+            if (this.type == 0 && j > 0) {
+                throw new RuntimeException("Missing type on ListTag");
+            } else {
+                nbtreadlimiter.a(32L * (long) j);
+                this.list = Lists.newArrayListWithCapacity(j);
+
+                for (int k = 0; k < j; ++k) {
+                    NBTBase nbtbase = NBTBase.createTag(this.type);
+
+                    nbtbase.load(datainput, i + 1, nbtreadlimiter);
+                    this.list.add(nbtbase);
+                }
+
+            }
+        }
+    }
+
+    public byte getTypeId() {
+        return (byte) 9;
+    }
+
+    public String toString() {
+        StringBuilder stringbuilder = new StringBuilder("[");
+
+        for (int i = 0; i < this.list.size(); ++i) {
+            if (i != 0) {
+                stringbuilder.append(',');
+            }
+
+            stringbuilder.append(i).append(':').append(this.list.get(i));
+        }
+
+        return stringbuilder.append(']').toString();
+    }
+
+    public void add(NBTBase nbtbase) {
+        if (nbtbase.getTypeId() == 0) {
+            NBTTagList.b.warn("Invalid TagEnd added to ListTag");
+        } else {
+            if (this.type == 0) {
+                this.type = nbtbase.getTypeId();
+            } else if (this.type != nbtbase.getTypeId()) {
+                NBTTagList.b.warn("Adding mismatching tag types to tag list");
+                return;
+            }
+
+            this.list.add(nbtbase);
+        }
+    }
+
+    public void a(int i, NBTBase nbtbase) {
+        if (nbtbase.getTypeId() == 0) {
+            NBTTagList.b.warn("Invalid TagEnd added to ListTag");
+        } else if (i >= 0 && i < this.list.size()) {
+            if (this.type == 0) {
+                this.type = nbtbase.getTypeId();
+            } else if (this.type != nbtbase.getTypeId()) {
+                NBTTagList.b.warn("Adding mismatching tag types to tag list");
+                return;
+            }
+
+            this.list.set(i, nbtbase);
+        } else {
+            NBTTagList.b.warn("index out of bounds to set tag in tag list");
+        }
+    }
+
+    public NBTBase remove(int i) {
+        return (NBTBase) this.list.remove(i);
+    }
+
+    public boolean isEmpty() {
+        return this.list.isEmpty();
+    }
+
+    public NBTTagCompound get(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            if (nbtbase.getTypeId() == 10) {
+                return (NBTTagCompound) nbtbase;
+            }
+        }
+
+        return new NBTTagCompound();
+    }
+
+    public int c(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            if (nbtbase.getTypeId() == 3) {
+                return ((NBTTagInt) nbtbase).d();
+            }
+        }
+
+        return 0;
+    }
+
+    public int[] d(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            if (nbtbase.getTypeId() == 11) {
+                return ((NBTTagIntArray) nbtbase).c();
+            }
+        }
+
+        return new int[0];
+    }
+
+    public double e(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            if (nbtbase.getTypeId() == 6) {
+                return ((NBTTagDouble) nbtbase).g();
+            }
+        }
+
+        return 0.0D;
+    }
+
+    public float f(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            if (nbtbase.getTypeId() == 5) {
+                return ((NBTTagFloat) nbtbase).h();
+            }
+        }
+
+        return 0.0F;
+    }
+
+    public String getString(int i) {
+        if (i >= 0 && i < this.list.size()) {
+            NBTBase nbtbase = (NBTBase) this.list.get(i);
+
+            return nbtbase.getTypeId() == 8 ? nbtbase.a_() : nbtbase.toString();
+        } else {
+            return "";
+        }
+    }
+
+    public NBTBase h(int i) {
+        return (NBTBase) (i >= 0 && i < this.list.size() ? (NBTBase) this.list.get(i) : new NBTTagEnd());
+    }
+
+    public int size() {
+        return this.list.size();
+    }
+
+    public NBTBase clone() {
+        NBTTagList nbttaglist = new NBTTagList();
+
+        nbttaglist.type = this.type;
+        Iterator iterator = this.list.iterator();
+
+        while (iterator.hasNext()) {
+            NBTBase nbtbase = (NBTBase) iterator.next();
+            NBTBase nbtbase1 = nbtbase.clone();
+
+            nbttaglist.list.add(nbtbase1);
+        }
+
+        return nbttaglist;
+    }
+
+    public boolean equals(Object object) {
+        if (super.equals(object)) {
+            NBTTagList nbttaglist = (NBTTagList) object;
+
+            if (this.type == nbttaglist.type) {
+                return this.list.equals(nbttaglist.list);
+            }
+        }
+
+        return false;
+    }
+
+    public int hashCode() {
+        return super.hashCode() ^ this.list.hashCode();
+    }
+
+    public int d() {
+        return this.type;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/PathEntity.java src/main/java/net/minecraft/server/PathEntity.java
--- src_origin/main/java/net/minecraft/server/PathEntity.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/PathEntity.java	2016-06-08 13:02:34.726102474 +0800
@@ -0,0 +1,91 @@
+package net.minecraft.server;
+
+public class PathEntity {
+
+    private final PathPoint[] a;
+    private PathPoint[] b = new PathPoint[0];
+    private PathPoint[] c = new PathPoint[0];
+    private int e;
+    private int f;
+
+    public PathEntity(PathPoint[] apathpoint) {
+        this.a = apathpoint;
+        this.f = apathpoint.length;
+    }
+
+    public void a() {
+        ++this.e;
+    }
+
+    public boolean b() {
+        return this.e >= this.f;
+    }
+
+    public PathPoint c() {
+        return this.f > 0 ? this.a[this.f - 1] : null;
+    }
+
+    public PathPoint a(int i) {
+        return this.a[i];
+    }
+
+    public void a(int i, PathPoint pathpoint) {
+        this.a[i] = pathpoint;
+    }
+
+    public int d() {
+        return this.f;
+    }
+
+    public void b(int i) {
+        this.f = i;
+    }
+
+    public int e() {
+        return this.e;
+    }
+
+    public void c(int i) {
+        this.e = i;
+    }
+
+    public Vec3D a(Entity entity, int i) {
+        double d0 = (double) this.a[i].a + (double) ((int) (entity.width + 1.0F)) * 0.5D;
+        double d1 = (double) this.a[i].b;
+        double d2 = (double) this.a[i].c + (double) ((int) (entity.width + 1.0F)) * 0.5D;
+
+        return new Vec3D(d0, d1, d2);
+    }
+
+    public Vec3D a(Entity entity) {
+        return this.a(entity, this.e);
+    }
+
+    public Vec3D f() {
+        PathPoint pathpoint = this.a[this.e];
+
+        return new Vec3D((double) pathpoint.a, (double) pathpoint.b, (double) pathpoint.c);
+    }
+
+    public boolean a(PathEntity pathentity) {
+        if (pathentity == null) {
+            return false;
+        } else if (pathentity.a.length != this.a.length) {
+            return false;
+        } else {
+            for (int i = 0; i < this.a.length; ++i) {
+                if (this.a[i].a != pathentity.a[i].a || this.a[i].b != pathentity.a[i].b || this.a[i].c != pathentity.a[i].c) {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+    }
+
+    public boolean b(Vec3D vec3d) {
+        PathPoint pathpoint = this.c();
+
+        return pathpoint == null ? false : pathpoint.a == (int) vec3d.x && pathpoint.c == (int) vec3d.z;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/PathfinderGoalBreed.java src/main/java/net/minecraft/server/PathfinderGoalBreed.java
--- src_origin/main/java/net/minecraft/server/PathfinderGoalBreed.java	2016-05-29 15:00:14.918641533 +0800
+++ src/main/java/net/minecraft/server/PathfinderGoalBreed.java	2016-06-08 13:02:34.727102474 +0800
@@ -2,6 +2,7 @@
 
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.Random;
 
 public class PathfinderGoalBreed extends PathfinderGoal {
diff -Naur src_origin/main/java/net/minecraft/server/PathfinderGoalHurtByTarget.java src/main/java/net/minecraft/server/PathfinderGoalHurtByTarget.java
--- src_origin/main/java/net/minecraft/server/PathfinderGoalHurtByTarget.java	2016-05-29 15:00:14.932641532 +0800
+++ src/main/java/net/minecraft/server/PathfinderGoalHurtByTarget.java	2016-06-08 13:02:34.751102472 +0800
@@ -2,6 +2,7 @@
 
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 
 public class PathfinderGoalHurtByTarget extends PathfinderGoalTarget {
 
diff -Naur src_origin/main/java/net/minecraft/server/PathfinderGoalNearestAttackableTargetInsentient.java src/main/java/net/minecraft/server/PathfinderGoalNearestAttackableTargetInsentient.java
--- src_origin/main/java/net/minecraft/server/PathfinderGoalNearestAttackableTargetInsentient.java	2016-05-29 15:00:14.945641531 +0800
+++ src/main/java/net/minecraft/server/PathfinderGoalNearestAttackableTargetInsentient.java	2016-06-08 13:02:34.758102471 +0800
@@ -1,8 +1,10 @@
 package net.minecraft.server;
 
 import com.google.common.base.Predicate;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Queue;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -44,7 +46,7 @@
     public boolean a() {
         double d0 = this.f();
         List list = this.b.world.a(this.f, this.b.getBoundingBox().grow(d0, 4.0D, d0), this.c);
-
+        
         Collections.sort(list, this.d);
         if (list.isEmpty()) {
             return false;
diff -Naur src_origin/main/java/net/minecraft/server/PathfinderGoalNearestAttackableTarget.java src/main/java/net/minecraft/server/PathfinderGoalNearestAttackableTarget.java
--- src_origin/main/java/net/minecraft/server/PathfinderGoalNearestAttackableTarget.java	2016-05-29 15:00:14.937641532 +0800
+++ src/main/java/net/minecraft/server/PathfinderGoalNearestAttackableTarget.java	2016-06-08 13:02:34.754102472 +0800
@@ -2,9 +2,11 @@
 
 import com.google.common.base.Function;
 import com.google.common.base.Predicate;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.List;
+import java.util.Queue;
 import javax.annotation.Nullable;
 
 public class PathfinderGoalNearestAttackableTarget<T extends EntityLiving> extends PathfinderGoalTarget {
@@ -45,7 +47,7 @@
             return false;
         } else if (this.a != EntityHuman.class && this.a != EntityPlayer.class) {
             List list = this.e.world.a(this.a, this.a(this.f()), this.c);
-
+            
             if (list.isEmpty()) {
                 return false;
             } else {
diff -Naur src_origin/main/java/net/minecraft/server/PathfinderGoalTargetNearestPlayer.java src/main/java/net/minecraft/server/PathfinderGoalTargetNearestPlayer.java
--- src_origin/main/java/net/minecraft/server/PathfinderGoalTargetNearestPlayer.java	2016-05-29 15:00:14.977641528 +0800
+++ src/main/java/net/minecraft/server/PathfinderGoalTargetNearestPlayer.java	2016-06-08 13:02:34.795102468 +0800
@@ -1,8 +1,10 @@
 package net.minecraft.server;
 
 import com.google.common.base.Predicate;
+import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Queue;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -58,7 +60,7 @@
     public boolean a() {
         double d0 = this.f();
         List list = this.b.world.a(EntityHuman.class, this.b.getBoundingBox().grow(d0, 4.0D, d0), this.c);
-
+        
         Collections.sort(list, this.d);
         if (list.isEmpty()) {
             return false;
diff -Naur src_origin/main/java/net/minecraft/server/PlayerChunkMap.java src/main/java/net/minecraft/server/PlayerChunkMap.java
--- src_origin/main/java/net/minecraft/server/PlayerChunkMap.java	2016-05-29 15:00:14.995641526 +0800
+++ src/main/java/net/minecraft/server/PlayerChunkMap.java	2016-06-08 13:02:34.805102467 +0800
@@ -17,6 +17,8 @@
 
 // CraftBukkit start
 import java.util.LinkedList;
+import org.hose.ChunkFlush_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public class PlayerChunkMap {
@@ -100,11 +102,14 @@
         };
     }
 
+    List<PlayerChunk> chunkflush_list = new LinkedList();
+    
     public void flush() {
         long i = this.world.getTime();
         int j;
         PlayerChunk playerchunk;
-
+        
+        //long st1 = System.nanoTime();
         if (i - this.k > 8000L) {
             this.k = i;
 
@@ -114,7 +119,22 @@
                 playerchunk.c();
             }
         }
+        /*long et1 = System.nanoTime();
+        System.out.println("t1: "+(et1-st1));
+
+        long st2 = System.nanoTime();*/
+        /*
+        if (!this.f.isEmpty()) {
+            Iterator iterator = this.f.iterator();
 
+            chunkflush_list.clear();
+            while (iterator.hasNext()) {
+                chunkflush_list.add((PlayerChunk) iterator.next());
+            }
+            this.f.clear();
+        }
+        SpigotWorldConfig.ChunkFlushPool.invoke(new ChunkFlush_Pool(chunkflush_list));*/
+        
         if (!this.f.isEmpty()) {
             Iterator iterator = this.f.iterator();
 
@@ -125,6 +145,8 @@
 
             this.f.clear();
         }
+        /*long et2 = System.nanoTime();
+        System.out.println("t2: "+(et2-st2));*/
 
         if (this.l && i % 4L == 0L) {
             this.l = false;
@@ -152,11 +174,13 @@
             });
         }
 
+        //long st3 = System.nanoTime();
         if (!this.h.isEmpty()) {
             long k = System.nanoTime() + 50000000L;
-            int l = 49;
+            int l = 49;//49
             Iterator iterator1 = this.h.iterator();
 
+            //fork join
             while (iterator1.hasNext()) {
                 PlayerChunk playerchunk1 = (PlayerChunk) iterator1.next();
 
@@ -177,7 +201,10 @@
                 }
             }
         }
+        /*long et3 = System.nanoTime();
+        System.out.println("t3: "+(et3-st3));
 
+        long st4 = System.nanoTime();*/
         if (!this.g.isEmpty()) {
             j = 81;
             Iterator iterator2 = this.g.iterator();
@@ -194,6 +221,8 @@
                 }
             }
         }
+        /*long et4 = System.nanoTime();
+        System.out.println("t4: "+(et4-st4));*/
 
         if (this.managedPlayers.isEmpty()) {
             WorldProvider worldprovider = this.world.worldProvider;
diff -Naur src_origin/main/java/net/minecraft/server/StructureGenerator.java src/main/java/net/minecraft/server/StructureGenerator.java
--- src_origin/main/java/net/minecraft/server/StructureGenerator.java	2016-05-29 15:00:15.180641509 +0800
+++ src/main/java/net/minecraft/server/StructureGenerator.java	2016-06-08 13:02:34.976102451 +0800
@@ -5,6 +5,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
+import java.util.concurrent.RecursiveAction;
 
 public abstract class StructureGenerator extends WorldGenBase {
 
@@ -81,7 +82,9 @@
                 structurestart.a(world, random, new StructureBoundingBox(i, j, i + 15, j + 15));
                 structurestart.b(chunkcoordintpair);
                 flag = true;
-                this.a(structurestart.e(), structurestart.f(), structurestart);
+                //this.a(structurestart.e(), structurestart.f(), structurestart);
+                structure str_task = new structure(this, structurestart.e(), structurestart.f(), structurestart);
+                str_task.fork();
             }
         }
 
@@ -241,4 +244,23 @@
     protected abstract boolean a(int i, int j);
 
     protected abstract StructureStart b(int i, int j);
+    
+    class structure extends RecursiveAction {
+        int i, j;
+        StructureStart structurestart;
+        StructureGenerator sg;
+        
+        structure(StructureGenerator sg, int i, int j, StructureStart structurestart) {
+            this.sg = sg;
+            this.i = i;
+            this.j = j;
+            this.structurestart = structurestart;
+        }
+        
+        @Override
+        protected void compute() {
+            sg.a(structurestart.e(), structurestart.f(), structurestart);
+        }
+                 
+    }
 }
diff -Naur src_origin/main/java/net/minecraft/server/SystemUtils.java src/main/java/net/minecraft/server/SystemUtils.java
--- src_origin/main/java/net/minecraft/server/SystemUtils.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/SystemUtils.java	2016-06-08 13:02:34.994102450 +0800
@@ -0,0 +1,28 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.FutureTask;
+import javax.annotation.Nullable;
+import org.apache.logging.log4j.Logger;
+
+public class SystemUtils {
+
+    @Nullable
+    public static <V> V a(FutureTask<V> futuretask, Logger logger) {
+        try {
+            futuretask.run();
+            return futuretask.get();
+        } catch (ExecutionException executionexception) {
+            logger.fatal("Error executing task", executionexception);
+        } catch (InterruptedException interruptedexception) {
+            logger.fatal("Error executing task", interruptedexception);
+        }
+
+        return null;
+    }
+
+    public static <T> T a(List<T> list) {
+        return list.get(list.size() - 1);
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/TileEntityBeacon.java src/main/java/net/minecraft/server/TileEntityBeacon.java
--- src_origin/main/java/net/minecraft/server/TileEntityBeacon.java	2016-05-29 15:00:15.191641508 +0800
+++ src/main/java/net/minecraft/server/TileEntityBeacon.java	2016-06-08 13:02:34.994102450 +0800
@@ -6,6 +6,7 @@
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.Set;
 import javax.annotation.Nullable;
 
diff -Naur src_origin/main/java/net/minecraft/server/TileEntityChest.java src/main/java/net/minecraft/server/TileEntityChest.java
--- src_origin/main/java/net/minecraft/server/TileEntityChest.java	2016-05-29 15:00:15.205641507 +0800
+++ src/main/java/net/minecraft/server/TileEntityChest.java	2016-06-08 13:02:35.000102449 +0800
@@ -2,6 +2,7 @@
 
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import javax.annotation.Nullable;
 
 // CraftBukkit start
diff -Naur src_origin/main/java/net/minecraft/server/TileEntityEndGateway.java src/main/java/net/minecraft/server/TileEntityEndGateway.java
--- src_origin/main/java/net/minecraft/server/TileEntityEndGateway.java	2016-05-29 15:00:15.223641505 +0800
+++ src/main/java/net/minecraft/server/TileEntityEndGateway.java	2016-06-08 13:02:35.024102447 +0800
@@ -2,6 +2,7 @@
 
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.Random;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
@@ -56,7 +57,7 @@
             --this.g;
         } else if (!this.world.isClientSide) {
             List list = this.world.a(Entity.class, new AxisAlignedBB(this.getPosition()));
-
+            
             if (!list.isEmpty()) {
                 this.a((Entity) list.get(0));
             }
diff -Naur src_origin/main/java/net/minecraft/server/Village.java src/main/java/net/minecraft/server/Village.java
--- src_origin/main/java/net/minecraft/server/Village.java	2016-05-29 15:00:15.268641501 +0800
+++ src/main/java/net/minecraft/server/Village.java	2016-06-08 13:02:35.061102444 +0800
@@ -4,6 +4,7 @@
 import com.mojang.authlib.GameProfile;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.TreeMap;
 import java.util.UUID;
 
diff -Naur src_origin/main/java/net/minecraft/server/World.java src/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2016-05-29 15:00:15.302641498 +0800
+++ src/main/java/net/minecraft/server/World.java	2016-06-08 13:02:35.101102440 +0800
@@ -15,7 +15,12 @@
 
 // CraftBukkit start
 import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
 import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.RecursiveTask;
+import java.util.concurrent.RecursiveAction;
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
@@ -34,6 +39,8 @@
     private int a = 63;
     protected boolean d;
     // Spigot start - guard entity list from removals
+    public final List<Entity> entityList = new CopyOnWriteArrayList<Entity>();
+    /*
     public final List<Entity> entityList = new java.util.ArrayList<Entity>()
     {
         @Override
@@ -57,12 +64,13 @@
                 throw new java.util.ConcurrentModificationException();
             }
         }
-    };
+    };*/
     // Spigot end
     protected final List<Entity> f = Lists.newArrayList();
     public final List<TileEntity> tileEntityList = Lists.newArrayList();
     public final List<TileEntity> tileEntityListTick = Lists.newArrayList();
-    private final List<TileEntity> b = Lists.newArrayList();
+    //private final List<TileEntity> b = Lists.newArrayList();
+    private final Queue<TileEntity> b = Queues.newConcurrentLinkedQueue();
     private final List<TileEntity> tileEntityListUnload = Lists.newArrayList();
     public final List<EntityHuman> players = Lists.newArrayList();
     public final List<Entity> j = Lists.newArrayList();
@@ -299,6 +307,10 @@
     }
 
     private boolean isAreaLoaded(int i, int j, int k, int l, int i1, int j1, boolean flag) {
+        area_load ar_task = new area_load(this, i, j, k, l, i1, j1, flag);
+        ar_task.fork();
+        return ar_task.join();
+        /*
         if (i1 >= 0 && j < 256) {
             i >>= 4;
             k >>= 4;
@@ -316,7 +328,7 @@
             return true;
         } else {
             return false;
-        }
+        }*/
     }
 
     protected abstract boolean isChunkLoaded(int i, int j, boolean flag);
@@ -945,8 +957,11 @@
         return addEntity(entity, SpawnReason.DEFAULT);
     }
 
-    public boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
-        org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
+    public synchronized boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
+        //org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
+        if (org.spigotmc.AsyncCatcher.catchOp_flag()) { // HOSE
+            entity = null;
+        }
         if (entity == null) return false;
         // CraftBukkit end
         int i = MathHelper.floor(entity.locX / 16.0D);
@@ -983,6 +998,7 @@
             double radius = spigotConfig.expMerge;
             if (radius > 0) {
                 List<Entity> entities = this.getEntities(entity, entity.getBoundingBox().grow(radius, radius, radius));
+                //Queue<Entity> entities = this.getEntities(entity, entity.getBoundingBox().grow(radius, radius, radius));
                 for (Entity e : entities) {
                     if (e instanceof EntityExperienceOrb) {
                         EntityExperienceOrb loopItem = (EntityExperienceOrb) e;
@@ -1151,8 +1167,27 @@
 
         blockposition_pooledblockposition.t();
         if (entity != null) {
+            //fork join
             List list = this.getEntities(entity, axisalignedbb.g(0.25D));
 
+            Iterator it = list.iterator();
+            while (it.hasNext()) {
+                Entity entity1 = (Entity) it.next();
+
+                if (!entity.x(entity1)) {
+                    AxisAlignedBB axisalignedbb1 = entity1.af();
+
+                    if (axisalignedbb1 != null && axisalignedbb1.b(axisalignedbb)) {
+                        arraylist.add(axisalignedbb1);
+                    }
+
+                    axisalignedbb1 = entity.j(entity1);
+                    if (axisalignedbb1 != null && axisalignedbb1.b(axisalignedbb)) {
+                        arraylist.add(axisalignedbb1);
+                    }
+                }
+            }
+            /*
             for (k1 = 0; k1 < list.size(); ++k1) {
                 Entity entity1 = (Entity) list.get(k1);
 
@@ -1168,7 +1203,7 @@
                         arraylist.add(axisalignedbb1);
                     }
                 }
-            }
+            }*/
         }
 
         return arraylist;
@@ -1423,7 +1458,11 @@
             if (!entity.dead && !(entity instanceof EntityPlayer)) {
                 try {
                     SpigotTimings.tickEntityTimer.startTiming(); // Spigot
+                    //fork join
                     this.g(entity);
+                    /*en_tick en_task = new en_tick(this, entity);
+                    en_task.fork();
+                    en_task.join();*/
                     SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
                 } catch (Throwable throwable1) {
                     crashreport1 = CrashReport.a(throwable1, "Ticking entity");
@@ -1527,15 +1566,44 @@
 
         this.methodProfiler.c("pendingBlockEntities");
         if (!this.b.isEmpty()) {
+            
             for (int i1 = 0; i1 < this.b.size(); ++i1) {
+                Iterator it = this.b.iterator();
+                while (it.hasNext()) {
+                    TileEntity tileentity1 = (TileEntity) it.next();
+                    if (!tileentity1.x()) {
+                    // CraftBukkit start - Order matters, moved down
+                    //if (!this.tileEntityList.contains(tileentity1)) {
+                    //    this.a(tileentity1);
+                    //}
+                    // CraftBukkit end
+
+                        if (this.isLoaded(tileentity1.getPosition())) {
+                            Chunk chunk = this.getChunkAtWorldCoords(tileentity1.getPosition());
+                            IBlockData iblockdata = chunk.getBlockData(tileentity1.getPosition());
+
+                            chunk.a(tileentity1.getPosition(), tileentity1);
+                            this.notify(tileentity1.getPosition(), iblockdata, iblockdata, 3);
+                            // CraftBukkit start
+                            // From above, don't screw this up - SPIGOT-1746
+                            if (!this.tileEntityList.contains(tileentity1)) {
+                                this.a(tileentity1);
+                            }
+                            // CraftBukkit end
+                        }
+                    }
+                    
+                }
+            }
+                /*
                 TileEntity tileentity1 = (TileEntity) this.b.get(i1);
 
                 if (!tileentity1.x()) {
-                    /* CraftBukkit start - Order matters, moved down
-                    if (!this.tileEntityList.contains(tileentity1)) {
-                        this.a(tileentity1);
-                    }
-                    // CraftBukkit end */
+                    // CraftBukkit start - Order matters, moved down
+                    //if (!this.tileEntityList.contains(tileentity1)) {
+                    //    this.a(tileentity1);
+                    //}
+                    // CraftBukkit end
 
                     if (this.isLoaded(tileentity1.getPosition())) {
                         Chunk chunk = this.getChunkAtWorldCoords(tileentity1.getPosition());
@@ -1551,7 +1619,7 @@
                         // CraftBukkit end
                     }
                 }
-            }
+            }*/
 
             this.b.clear();
         }
@@ -1680,14 +1748,23 @@
 
     public boolean a(AxisAlignedBB axisalignedbb, @Nullable Entity entity) {
         List list = this.getEntities((Entity) null, axisalignedbb);
+        //Queue list = this.getEntities((Entity) null, axisalignedbb);
+        Iterator it = list.iterator();
+        while (it.hasNext()) {
+            Entity entity1 = (Entity) it.next();
 
+            if (!entity1.dead && entity1.i && entity1 != entity && (entity == null || entity1.x(entity))) {
+                return false;
+            }
+        }
+        /*
         for (int i = 0; i < list.size(); ++i) {
             Entity entity1 = (Entity) list.get(i);
 
             if (!entity1.dead && entity1.i && entity1 != entity && (entity == null || entity1.x(entity))) {
                 return false;
             }
-        }
+        }*/
 
         return true;
     }
@@ -1975,13 +2052,22 @@
 
     @Nullable
     private TileEntity F(BlockPosition blockposition) {
+        Iterator it = this.b.iterator();
+        while (it.hasNext()) {
+            TileEntity tileentity = (TileEntity) it.next();
+
+            if (!tileentity.x() && tileentity.getPosition().equals(blockposition)) {
+                return tileentity;
+            }
+        }
+        /*
         for (int i = 0; i < this.b.size(); ++i) {
             TileEntity tileentity = (TileEntity) this.b.get(i);
 
             if (!tileentity.x() && tileentity.getPosition().equals(blockposition)) {
                 return tileentity;
             }
-        }
+        }*/
 
         return null;
     }
@@ -2434,11 +2520,14 @@
     }
 
     public List<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb) {
+    //public Queue<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb) {
         return this.getEntities(entity, axisalignedbb, IEntitySelector.e);
     }
 
     public List<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super Entity> predicate) {
+    //public Queue<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super Entity> predicate) {
         ArrayList arraylist = Lists.newArrayList();
+        //Queue arraylist = Queues.newConcurrentLinkedQueue();
         int i = MathHelper.floor((axisalignedbb.a - 2.0D) / 16.0D);
         int j = MathHelper.floor((axisalignedbb.d + 2.0D) / 16.0D);
         int k = MathHelper.floor((axisalignedbb.c - 2.0D) / 16.0D);
@@ -2447,7 +2536,11 @@
         for (int i1 = i; i1 <= j; ++i1) {
             for (int j1 = k; j1 <= l; ++j1) {
                 if (this.isChunkLoaded(i1, j1, true)) {
-                    this.getChunkAt(i1, j1).a(entity, axisalignedbb, arraylist, predicate);
+                    //this.getChunkAt(i1, j1).a(entity, axisalignedbb, arraylist, predicate);
+                    //fork
+                    get_en en_task = new get_en(this, entity, axisalignedbb, predicate, i1, j1, arraylist);
+                    en_task.fork();
+                    en_task.join();
                 }
             }
         }
@@ -2486,15 +2579,18 @@
     }
 
     public <T extends Entity> List<T> a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb) {
+    //public <T extends Entity> Queue<T> a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb) {
         return this.a(oclass, axisalignedbb, IEntitySelector.e);
     }
 
     public <T extends Entity> List<T> a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super T> predicate) {
+    //public <T extends Entity> Queue<T> a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super T> predicate) {
         int i = MathHelper.floor((axisalignedbb.a - 2.0D) / 16.0D);
         int j = MathHelper.f((axisalignedbb.d + 2.0D) / 16.0D);
         int k = MathHelper.floor((axisalignedbb.c - 2.0D) / 16.0D);
         int l = MathHelper.f((axisalignedbb.f + 2.0D) / 16.0D);
         ArrayList arraylist = Lists.newArrayList();
+        //Queue arraylist = Queues.newConcurrentLinkedQueue();
 
         for (int i1 = i; i1 < j; ++i1) {
             for (int j1 = k; j1 < l; ++j1) {
@@ -2512,7 +2608,20 @@
         List list = this.a(oclass, axisalignedbb);
         Entity entity = null;
         double d0 = Double.MAX_VALUE;
+        Iterator it = list.iterator();
+        while (it.hasNext()) {
+            Entity entity1 = (Entity) it.next();
+
+            if (entity1 != t0 && IEntitySelector.e.apply(entity1)) {
+                double d1 = t0.h(entity1);
 
+                if (d1 <= d0) {
+                    entity = entity1;
+                    d0 = d1;
+                }
+            }
+        }
+        /*
         for (int i = 0; i < list.size(); ++i) {
             Entity entity1 = (Entity) list.get(i);
 
@@ -2524,7 +2633,7 @@
                     d0 = d1;
                 }
             }
-        }
+        }*/
 
         return (T) entity; // CraftBukkit fix decompile error
     }
@@ -3111,4 +3220,69 @@
     public LootTableRegistry ak() {
         return this.B;
     }
+    
+    class get_en extends RecursiveAction {
+        World world;
+        @Nullable Entity entity;
+        AxisAlignedBB axisalignedbb;
+        @Nullable Predicate<? super Entity> predicate;
+        int i1, j1;
+        ArrayList arraylist;
+        
+        get_en(World world, @Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super Entity> predicate, int i1, int j1, ArrayList arraylist) {
+            this.world = world;
+            this.entity = entity;
+            this.axisalignedbb = axisalignedbb;
+            this.predicate = predicate;
+            this.i1 = i1;
+            this.j1 = j1;
+            this.arraylist = arraylist;
+        }
+        
+        @Override
+        protected void compute() {
+            world.getChunkAt(i1, j1).a(entity, axisalignedbb, arraylist, predicate);
+        }
+                 
+    }
+    
+    class area_load extends RecursiveTask<Boolean> {
+        World world;
+        int i, j, k, l, i1, j1;
+        boolean flag;
+                
+        area_load(World world, int i, int j, int k, int l, int i1, int j1, boolean flag) {
+            this.i = i;
+            this.j = j;
+            this.k = k;
+            this.l = l;
+            this.i1 = i1;
+            this.j1 = j1;
+            this.flag = flag;
+            this.world = world;
+        }
+        
+        @Override
+        protected Boolean compute() {
+            if (i1 >= 0 && j < 256) {
+                i >>= 4;
+                k >>= 4;
+                l >>= 4;
+                j1 >>= 4;
+
+                for (int k1 = i; k1 <= l; ++k1) {
+                    for (int l1 = k; l1 <= j1; ++l1) {
+                        if (!world.isChunkLoaded(k1, l1, flag)) {
+                            return false;
+                        }
+                    }
+                }
+
+                return true;
+            } else {
+                return false;
+            }
+        }
+                 
+    }
 }
diff -Naur src_origin/main/java/net/minecraft/server/WorldServer.java src/main/java/net/minecraft/server/WorldServer.java
--- src_origin/main/java/net/minecraft/server/WorldServer.java	2016-05-29 15:00:15.395641490 +0800
+++ src/main/java/net/minecraft/server/WorldServer.java	2016-06-08 13:02:35.178102433 +0800
@@ -11,10 +11,12 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
 import java.util.Random;
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -47,7 +49,8 @@
     protected final VillageSiege siegeManager = new VillageSiege(this);
     private WorldServer.BlockActionDataList[] S = new WorldServer.BlockActionDataList[] { new WorldServer.BlockActionDataList(null), new WorldServer.BlockActionDataList(null)};
     private int T;
-    private List<NextTickListEntry> U = Lists.newArrayList();
+    //private List<NextTickListEntry> U = Lists.newArrayList();
+    private Queue<NextTickListEntry> U = new ConcurrentLinkedQueue();
 
     // CraftBukkit start
     public final int dimension;
@@ -531,7 +534,9 @@
         });
 
         if (!list.isEmpty()) {
-            return ((EntityLiving) list.get(this.random.nextInt(list.size()))).getChunkCoordinates();
+            //return ((EntityLiving) list.get(this.random.nextInt(list.size()))).getChunkCoordinates();
+            List llll = new ArrayList(list);
+            return ((EntityLiving) llll.get(this.random.nextInt(list.size()))).getChunkCoordinates();
         } else {
             if (blockposition1.getY() == -1) {
                 blockposition1 = blockposition1.up(2);
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java src/main/java/org/bukkit/craftbukkit/CraftWorld.java
--- src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-05-29 15:00:15.690641463 +0800
+++ src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-06-08 13:02:35.464102407 +0800
@@ -8,6 +8,7 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Iterator;
+import java.util.Queue;
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
--- src_origin/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java	2016-05-29 15:00:16.594641380 +0800
+++ src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java	2016-06-08 13:02:36.319102328 +0800
@@ -2,6 +2,7 @@
 
 import com.google.common.base.Preconditions;
 import java.util.List;
+import java.util.Queue;
 import java.util.Set;
 import java.util.UUID;
 
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-05-29 15:00:17.946641256 +0800
+++ src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-06-08 13:02:37.628102208 +0800
@@ -1,15 +1,20 @@
 package org.bukkit.craftbukkit.util;
 
+import com.google.common.collect.Sets;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.TreeSet;
+import java.util.concurrent.ConcurrentSkipListSet;
 
 public class HashTreeSet<V> implements Set<V> {
 
-    private HashSet<V> hash = new HashSet<V>();
-    private TreeSet<V> tree = new TreeSet<V>();
+    /*private HashSet<V> hash = new HashSet<V>();
+    private TreeSet<V> tree = new TreeSet<V>();*/
+    private Set<V> hash = Sets.newConcurrentHashSet();
+    private ConcurrentSkipListSet<V> tree = new ConcurrentSkipListSet<V>();
+
 
     public HashTreeSet() {
 
@@ -110,7 +115,8 @@
         tree.clear();
     }
 
-    public V first() {
+    //public V first() {
+    public synchronized V first() {
         return tree.first();
     }
 
diff -Naur src_origin/main/java/org/hose/ChunkFlush_Pool.java src/main/java/org/hose/ChunkFlush_Pool.java
--- src_origin/main/java/org/hose/ChunkFlush_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChunkFlush_Pool.java	2016-06-08 13:02:32.954102637 +0800
@@ -0,0 +1,53 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.PlayerChunk;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkFlush_Pool extends RecursiveAction {//need to use callable
+    List<PlayerChunk> chunkflush_list;
+    
+    public ChunkFlush_Pool(List<PlayerChunk> chunkflush_list){
+        this.chunkflush_list = chunkflush_list;
+    }
+    
+    @Override
+    protected void compute() {
+        List<RecursiveAction> forks = new LinkedList();
+        for (PlayerChunk pc : chunkflush_list) {
+            chunkflush task = new chunkflush(pc);
+            forks.add(task);
+            task.fork();
+            //task.join();
+        }
+        /*
+        for (RecursiveAction task : forks) {
+            task.join();
+        }*/
+    }
+    
+    
+    class chunkflush extends RecursiveAction {
+        PlayerChunk pc;
+        
+        chunkflush(PlayerChunk pc) {
+            this.pc = pc;
+        }
+        
+        @Override
+        protected void compute() {
+            pc.d();
+        }
+                 
+    }
+}
diff -Naur src_origin/main/java/org/hose/ChunkGen_Pool.java src/main/java/org/hose/ChunkGen_Pool.java
--- src_origin/main/java/org/hose/ChunkGen_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChunkGen_Pool.java	2016-06-08 13:02:32.954102637 +0800
@@ -0,0 +1,76 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.WorldServer;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkGen_Pool extends RecursiveAction {
+    WorldServer worldserver;
+    List<int[]> position;
+    
+    public ChunkGen_Pool(WorldServer worldserver, List<int[]> position){
+        this.worldserver = worldserver;
+        this.position = position;
+        
+    }
+    
+    @Override
+    protected void compute() {
+        List<RecursiveAction> forks = new LinkedList();
+        for (int[] pt : position) {
+            chunkgen task = new chunkgen(worldserver, pt);
+            forks.add(task);
+            task.fork();
+            //task.join();
+        }
+        /*
+        for (RecursiveAction task : forks) {
+            task.join();
+        }*/
+        /*
+        List<int[]> fork1 = this.position.subList(0, (this.position.size()/2));
+        List<int[]> fork2 = this.position.subList((this.position.size()/2), this.position.size());
+        chunkgen t1 = new chunkgen(worldserver, fork1);
+        chunkgen t2 = new chunkgen(worldserver, fork2);
+        t1.fork();
+        t2.fork();
+        t1.join();*/
+        /*
+        for (RecursiveAction task : forks) {
+            task.join();
+        }*/
+    }
+    
+    
+    class chunkgen extends RecursiveAction {
+        WorldServer worldserver;
+        int[] pt;
+        //List<int[]> position;
+        
+        chunkgen(WorldServer worldserver, int[] pt) {
+            this.worldserver = worldserver;
+            this.pt = pt;
+            //this.position = position;
+        }
+        
+        @Override
+        protected void compute() {
+            worldserver.getChunkProviderServer().getChunkAt(pt[0], pt[1]);
+            /*
+            for (int[] pt : position) {
+                worldserver.getChunkProviderServer().getChunkAt(pt[0], pt[1]);
+            }*/
+        }
+                 
+    }
+}
diff -Naur src_origin/main/java/org/hose/ChunkPopulate_Pool.java src/main/java/org/hose/ChunkPopulate_Pool.java
--- src_origin/main/java/org/hose/ChunkPopulate_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChunkPopulate_Pool.java	2016-06-08 13:02:32.954102637 +0800
@@ -0,0 +1,35 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.Random;
+import java.util.concurrent.RecursiveAction;
+import org.bukkit.Chunk;
+import org.bukkit.World;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkPopulate_Pool extends RecursiveAction {//need to use callable
+    World world;
+    Random random;
+    Chunk chunk;
+    org.bukkit.generator.BlockPopulator populator;
+    
+    public ChunkPopulate_Pool(World world, Random random, Chunk chunk, org.bukkit.generator.BlockPopulator populator){
+        this.world = world;
+        this.random = random;
+        this.chunk = chunk;
+        this.populator = populator;
+    }
+    
+    @Override
+    protected void compute() {
+        populator.populate(world, random, chunk);
+    }
+
+}
diff -Naur src_origin/main/java/org/spigotmc/ActivationRange.java src/main/java/org/spigotmc/ActivationRange.java
--- src_origin/main/java/org/spigotmc/ActivationRange.java	2016-05-29 15:00:13.207641690 +0800
+++ src/main/java/org/spigotmc/ActivationRange.java	2016-06-08 13:02:33.050102628 +0800
@@ -1,7 +1,9 @@
 package org.spigotmc;
 
 import java.util.List;
+import java.util.Queue;
 import java.util.Set;
+import java.util.concurrent.RecursiveAction;
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.Chunk;
 import net.minecraft.server.Entity;
@@ -126,7 +128,10 @@
                 {
                     if ( world.getWorld().isChunkLoaded( i1, j1 ) )
                     {
-                        activateChunkEntities( world.getChunkAt( i1, j1 ) );
+                        //activateChunkEntities( world.getChunkAt( i1, j1 ) );
+                        //fork
+                        active_en en_task = new active_en(world.getChunkAt( i1, j1 ));
+                        en_task.fork();
                     }
                 }
             }
@@ -141,7 +146,8 @@
      */
     private static void activateChunkEntities(Chunk chunk)
     {
-        for ( List<Entity> slice : chunk.entitySlices )
+        //for ( List<Entity> slice : chunk.entitySlices )
+        for ( Queue<Entity> slice : chunk.entitySlices )
         {
             for ( Entity entity : slice )
             {
@@ -284,4 +290,19 @@
         SpigotTimings.checkIfActiveTimer.stopTiming();
         return isActive;
     }
+    
+    static class active_en extends RecursiveAction {
+        Chunk chunk;
+                
+        active_en (Chunk chunk) {
+            //this.chunks = chunks;
+            this.chunk = chunk;
+        }
+        
+        @Override
+        protected void compute() {
+            activateChunkEntities(chunk);
+        }
+                 
+    }
 }
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2016-05-29 15:00:13.192641692 +0800
+++ src/main/java/org/spigotmc/AsyncCatcher.java	2016-06-08 13:02:33.044102628 +0800
@@ -14,4 +14,16 @@
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
         }
     }
+    
+    //hose
+    public static boolean catchOp_flag()
+    {
+        if ( enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread )
+        {
+            //return true;
+            MinecraftServer.getServer().postToMainThread(Thread.currentThread());
+            System.out.println("post to main thread");
+        }
+        return false;
+    }
 }
diff -Naur src_origin/main/java/org/spigotmc/SpigotWorldConfig.java src/main/java/org/spigotmc/SpigotWorldConfig.java
--- src_origin/main/java/org/spigotmc/SpigotWorldConfig.java	2016-05-29 15:00:13.200641691 +0800
+++ src/main/java/org/spigotmc/SpigotWorldConfig.java	2016-06-08 13:02:33.094102624 +0800
@@ -1,12 +1,115 @@
 package org.spigotmc;
 
+import io.netty.util.internal.ConcurrentSet;
 import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.ForkJoinWorkerThread;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
 public class SpigotWorldConfig
 {
-
+    //hose start
+    static public final int cpu_core = Runtime.getRuntime().availableProcessors();
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fetp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("EntityTickPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fttp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("TileTickPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fpcp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("PlayerChunkPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcfp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkFlushPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcfpt3 = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkFlushPool_T3-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcpp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkPopulate_Pool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    public static ForkJoinPool EntityTickPool;
+    public static ForkJoinPool TileTickPool;
+    public static ForkJoinPool ChunkPool;
+    public static ForkJoinPool PlayerChunkPool;
+    public static ForkJoinPool ChunkFlushPool;
+    public static ForkJoinPool ChunkFlushPool_T3;
+    public static ForkJoinPool ChunkPopulate_Pool;
+    
+    /*
+    static public FutureTask CollideTask;
+        
+    static final ThreadFactory tfcp = new ThreadFactoryBuilder().setNameFormat("Collide_Pool-%d").build();
+    static public final ExecutorService collidepool_executor = Executors.newFixedThreadPool(cpu_core, tfcp);*/
+    
+    public static int worldtickentitypool_core_multiple;
+    
+    public static int getthreadnumber(){
+        return cpu_core*worldtickentitypool_core_multiple;
+    }
+    
+    private void wetp_core_multiple()
+    {
+        worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 4);
+        EntityTickPool = new ForkJoinPool(getthreadnumber(), fetp, null, false);
+        TileTickPool = new ForkJoinPool(getthreadnumber(), fttp, null, false);
+        ChunkPool = new ForkJoinPool(getthreadnumber(), fcp, null, false);
+        PlayerChunkPool = new ForkJoinPool(getthreadnumber(), fpcp, null, false);
+        ChunkFlushPool = new ForkJoinPool(getthreadnumber(), fcfp, null, false);
+        ChunkFlushPool_T3 = new ForkJoinPool(getthreadnumber(), fcfpt3, null, false);
+        ChunkPopulate_Pool = new ForkJoinPool(getthreadnumber(), fcpp, null, false);
+        //executor = new ThreadPoolExecutor(getthreadnumber(), getthreadnumber(), 1, TimeUnit.DAYS, queue);
+        log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
+    }
+    
+    
+    //hose end
+    
     private final String worldName;
     private final YamlConfiguration config;
     private boolean verbose;
