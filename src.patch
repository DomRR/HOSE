diff -Naur src_origin/main/java/net/minecraft/server/AttributeModifiable.java src/main/java/net/minecraft/server/AttributeModifiable.java
--- src_origin/main/java/net/minecraft/server/AttributeModifiable.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/AttributeModifiable.java	2016-03-06 05:06:44.269477861 +0800
@@ -0,0 +1,169 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentMap;
+
+public class AttributeModifiable implements AttributeInstance {
+
+    private final AttributeMapBase a;
+    private final IAttribute b;
+    /*private final Map<Integer, Set<AttributeModifier>> c = Maps.newHashMap();
+    private final Map<String, Set<AttributeModifier>> d = Maps.newHashMap();
+    private final Map<UUID, AttributeModifier> e = Maps.newHashMap();*/
+    private final ConcurrentMap<Integer, HashSet<AttributeModifier>> c = Maps.newConcurrentMap();
+    private final ConcurrentMap<String, HashSet<AttributeModifier>> d = Maps.newConcurrentMap();
+    private final ConcurrentMap<UUID, AttributeModifier> e = Maps.newConcurrentMap();
+    private double f;
+    private boolean g = true;
+    private double h;
+
+    public AttributeModifiable(AttributeMapBase attributemapbase, IAttribute iattribute) {
+        this.a = attributemapbase;
+        this.b = iattribute;
+        this.f = iattribute.b();
+
+        for (int i = 0; i < 3; ++i) {
+            //this.c.put(Integer.valueOf(i), Sets.newHashSet());
+            this.c.put(Integer.valueOf(i), new HashSet());
+        }
+
+    }
+
+    public IAttribute getAttribute() {
+        return this.b;
+    }
+
+    public double b() {
+        return this.f;
+    }
+
+    public void setValue(double d0) {
+        if (d0 != this.b()) {
+            this.f = d0;
+            this.f();
+        }
+    }
+
+    public Collection<AttributeModifier> a(int i) {
+        return (Collection) this.c.get(Integer.valueOf(i));
+    }
+
+    public Collection<AttributeModifier> c() {
+        HashSet hashset = Sets.newHashSet();
+
+        for (int i = 0; i < 3; ++i) {
+            hashset.addAll(this.a(i));
+        }
+
+        return hashset;
+    }
+
+    public AttributeModifier a(UUID uuid) {
+        return (AttributeModifier) this.e.get(uuid);
+    }
+
+    public boolean a(AttributeModifier attributemodifier) {
+        return this.e.get(attributemodifier.a()) != null;
+    }
+
+    public void b(AttributeModifier attributemodifier) {
+        if (this.a(attributemodifier.a()) != null) {
+            throw new IllegalArgumentException("Modifier is already applied on this attribute!");
+        } else {
+            //Object object = (Set) this.d.get(attributemodifier.b());
+            Object object = (HashSet) this.d.get(attributemodifier.b());
+
+            if (object == null) {
+                //object = Sets.newHashSet();
+                object = new HashSet();
+                //this.d.put(attributemodifier.b(), object);
+                this.d.put(attributemodifier.b(), (HashSet)object);
+            }
+
+            ((Set) this.c.get(Integer.valueOf(attributemodifier.c()))).add(attributemodifier);
+            ((Set) object).add(attributemodifier);
+            this.e.put(attributemodifier.a(), attributemodifier);
+            this.f();
+        }
+    }
+
+    protected void f() {
+        this.g = true;
+        this.a.a((AttributeInstance) this);
+    }
+
+    public void c(AttributeModifier attributemodifier) {
+        for (int i = 0; i < 3; ++i) {
+            Set set = (Set) this.c.get(Integer.valueOf(i));
+
+            set.remove(attributemodifier);
+        }
+
+        Set set1 = (Set) this.d.get(attributemodifier.b());
+
+        if (set1 != null) {
+            set1.remove(attributemodifier);
+            if (set1.isEmpty()) {
+                this.d.remove(attributemodifier.b());
+            }
+        }
+
+        this.e.remove(attributemodifier.a());
+        this.f();
+    }
+
+    public double getValue() {
+        if (this.g) {
+            this.h = this.g();
+            this.g = false;
+        }
+
+        return this.h;
+    }
+
+    private double g() {
+        double d0 = this.b();
+
+        AttributeModifier attributemodifier;
+
+        for (Iterator iterator = this.b(0).iterator(); iterator.hasNext(); d0 += attributemodifier.d()) {
+            attributemodifier = (AttributeModifier) iterator.next();
+        }
+
+        double d1 = d0;
+
+        Iterator iterator1;
+        AttributeModifier attributemodifier1;
+
+        for (iterator1 = this.b(1).iterator(); iterator1.hasNext(); d1 += d0 * attributemodifier1.d()) {
+            attributemodifier1 = (AttributeModifier) iterator1.next();
+        }
+
+        for (iterator1 = this.b(2).iterator(); iterator1.hasNext(); d1 *= 1.0D + attributemodifier1.d()) {
+            attributemodifier1 = (AttributeModifier) iterator1.next();
+        }
+
+        return this.b.a(d1);
+    }
+
+    private Collection<AttributeModifier> b(int i) {
+        HashSet hashset = Sets.newHashSet(this.a(i));
+
+        for (IAttribute iattribute = this.b.d(); iattribute != null; iattribute = iattribute.d()) {
+            AttributeInstance attributeinstance = this.a.a(iattribute);
+
+            if (attributeinstance != null) {
+                hashset.addAll(attributeinstance.a(i));
+            }
+        }
+
+        return hashset;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java src/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java
--- src_origin/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java	2016-02-26 15:27:07.267203267 +0800
+++ src/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java	2016-03-06 05:06:45.562477982 +0800
@@ -3,6 +3,7 @@
 import com.google.common.collect.Lists;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 public abstract class BlockMinecartTrackAbstract extends Block {
 
@@ -247,7 +248,8 @@
         private final BlockMinecartTrackAbstract d;
         private IBlockData e;
         private final boolean f;
-        private final List<BlockPosition> g = Lists.newArrayList();
+        //private final List<BlockPosition> g = Lists.newArrayList();
+        private final List<BlockPosition> g = Lists.newCopyOnWriteArrayList();
 
         public MinecartTrackLogic(World world, BlockPosition blockposition, IBlockData iblockdata) {
             this.b = world;
diff -Naur src_origin/main/java/net/minecraft/server/BlockRedstoneTorch.java src/main/java/net/minecraft/server/BlockRedstoneTorch.java
--- src_origin/main/java/net/minecraft/server/BlockRedstoneTorch.java	2016-02-26 15:27:07.667203304 +0800
+++ src/main/java/net/minecraft/server/BlockRedstoneTorch.java	2016-03-06 05:06:46.298478050 +0800
@@ -1,7 +1,6 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
@@ -15,7 +14,8 @@
 
     private boolean a(World world, BlockPosition blockposition, boolean flag) {
         if (!BlockRedstoneTorch.b.containsKey(world)) {
-            BlockRedstoneTorch.b.put(world, Lists.<BlockRedstoneTorch.RedstoneUpdateInfo>newArrayList()); // CraftBukkit - fix decompile error
+            //BlockRedstoneTorch.b.put(world, Lists.<BlockRedstoneTorch.RedstoneUpdateInfo>newArrayList()); // CraftBukkit - fix decompile error
+            BlockRedstoneTorch.b.put(world, Lists.<BlockRedstoneTorch.RedstoneUpdateInfo>newCopyOnWriteArrayList()); // CraftBukkit - fix decompile error
         }
 
         List list = (List) BlockRedstoneTorch.b.get(world);
diff -Naur src_origin/main/java/net/minecraft/server/BlockRedstoneWire.java src/main/java/net/minecraft/server/BlockRedstoneWire.java
--- src_origin/main/java/net/minecraft/server/BlockRedstoneWire.java	2016-02-26 15:27:07.697203307 +0800
+++ src/main/java/net/minecraft/server/BlockRedstoneWire.java	2016-03-06 05:06:46.348478055 +0800
@@ -2,11 +2,16 @@
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
+import io.netty.util.internal.ConcurrentSet;
 import java.util.ArrayList;
 import java.util.EnumSet;
 import java.util.Iterator;
+import java.util.List;
+import java.util.Queue;
 import java.util.Random;
 import java.util.Set;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArraySet;
 
 import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
 
@@ -18,7 +23,8 @@
     public static final BlockStateEnum<BlockRedstoneWire.EnumRedstoneWireConnection> WEST = BlockStateEnum.of("west", BlockRedstoneWire.EnumRedstoneWireConnection.class);
     public static final BlockStateInteger POWER = BlockStateInteger.of("power", 0, 15);
     private boolean Q = true;
-    private final Set<BlockPosition> R = Sets.newHashSet();
+    //private final Set<BlockPosition> R = Sets.newHashSet();
+    private final ConcurrentSet<BlockPosition> R = new ConcurrentSet<BlockPosition>();
 
     public BlockRedstoneWire() {
         super(Material.ORIENTABLE);
@@ -65,7 +71,8 @@
 
     private IBlockData e(World world, BlockPosition blockposition, IBlockData iblockdata) {
         iblockdata = this.a(world, blockposition, blockposition, iblockdata);
-        ArrayList arraylist = Lists.newArrayList(this.R);
+        //ArrayList arraylist = Lists.newArrayList(this.R);
+        Queue arraylist = new ConcurrentLinkedQueue(this.R);
 
         this.R.clear();
         Iterator iterator = arraylist.iterator();
diff -Naur src_origin/main/java/net/minecraft/server/BlockSapling.java src/main/java/net/minecraft/server/BlockSapling.java
--- src_origin/main/java/net/minecraft/server/BlockSapling.java	2016-02-26 15:27:07.744203311 +0800
+++ src/main/java/net/minecraft/server/BlockSapling.java	2016-03-06 05:06:46.431478063 +0800
@@ -4,6 +4,9 @@
 
 // CraftBukkit start
 import java.util.List;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 import org.bukkit.Location;
 import org.bukkit.TreeType;
@@ -43,7 +46,9 @@
                     TreeType treeType = BlockSapling.treeType;
                     BlockSapling.treeType = null;
                     Location location = new Location(world.getWorld(), blockposition.getX(), blockposition.getY(), blockposition.getZ());
-                    List<BlockState> blocks = (List<BlockState>) world.capturedBlockStates.clone();
+                    //List<BlockState> blocks = (List<BlockState>) world.capturedBlockStates.clone();
+                    Queue<BlockState> blocks = new ConcurrentLinkedQueue<BlockState>();
+                    blocks.addAll((Queue<BlockState>) world.capturedBlockStates);
                     world.capturedBlockStates.clear();
                     StructureGrowEvent event = null;
                     if (treeType != null) {
diff -Naur src_origin/main/java/net/minecraft/server/ChatBaseComponent.java src/main/java/net/minecraft/server/ChatBaseComponent.java
--- src_origin/main/java/net/minecraft/server/ChatBaseComponent.java	2016-02-26 15:27:08.023203337 +0800
+++ src/main/java/net/minecraft/server/ChatBaseComponent.java	2016-03-06 05:06:46.909478108 +0800
@@ -8,7 +8,8 @@
 
 public abstract class ChatBaseComponent implements IChatBaseComponent {
 
-    protected List<IChatBaseComponent> a = Lists.newArrayList();
+    //protected List<IChatBaseComponent> a = Lists.newArrayList();
+    protected List<IChatBaseComponent> a = Lists.newCopyOnWriteArrayList();
     private ChatModifier b;
 
     public ChatBaseComponent() {}
diff -Naur src_origin/main/java/net/minecraft/server/Chunk.java src/main/java/net/minecraft/server/Chunk.java
--- src_origin/main/java/net/minecraft/server/Chunk.java	2016-02-26 15:27:08.084203343 +0800
+++ src/main/java/net/minecraft/server/Chunk.java	2016-03-06 05:06:47.003478116 +0800
@@ -15,6 +15,7 @@
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists; // CraftBukkit
+import java.util.Queue;
 import org.bukkit.Bukkit; // CraftBukkit
 
 public class Chunk {
@@ -31,7 +32,8 @@
     public final int locZ;
     private boolean k;
     public final Map<BlockPosition, TileEntity> tileEntities;
-    public final List<Entity>[] entitySlices; // Spigot
+    //public final List<Entity>[] entitySlices; // Spigot
+    public final Queue<Entity>[] entitySlices; // Spigot
     private boolean done;
     private boolean lit;
     private boolean p;
@@ -80,14 +82,16 @@
         this.tileEntities = Maps.newHashMap();
         this.v = 4096;
         this.w = Queues.newConcurrentLinkedQueue();
-        this.entitySlices = (List[]) (new List[16]); // Spigot
+        //this.entitySlices = (List[]) (new List[16]); // Spigot
+        this.entitySlices = (Queue[]) (new ConcurrentLinkedQueue[16]); // Spigot
         this.world = world;
         this.locX = i;
         this.locZ = j;
         this.heightMap = new int[256];
 
         for (int k = 0; k < this.entitySlices.length; ++k) {
-            this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            //this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[k] = new ConcurrentLinkedQueue(); // Spigot
         }
 
         Arrays.fill(this.f, -999);
@@ -832,6 +836,7 @@
             if ( tileentity instanceof IInventory )
             {
                 for ( org.bukkit.entity.HumanEntity h : Lists.<org.bukkit.entity.HumanEntity>newArrayList((List<org.bukkit.entity.HumanEntity>) ( (IInventory) tileentity ).getViewers() ) )
+                //for ( org.bukkit.entity.HumanEntity h : Lists.<org.bukkit.entity.HumanEntity>newCopyOnWriteArrayList((List<org.bukkit.entity.HumanEntity>) ( (IInventory) tileentity ).getViewers() ) )
                 {
                     if ( h instanceof org.bukkit.craftbukkit.entity.CraftHumanEntity )
                     {
@@ -846,7 +851,8 @@
 
         for (int i = 0; i < this.entitySlices.length; ++i) {
             // CraftBukkit start
-            List<Entity> newList = Lists.newArrayList(this.entitySlices[i]);
+            //List<Entity> newList = Lists.newArrayList(this.entitySlices[i]);
+            Queue<Entity> newList = new ConcurrentLinkedQueue<Entity>(this.entitySlices[i]);
             java.util.Iterator<Entity> iter = newList.iterator();
             while (iter.hasNext()) {
                 Entity entity = iter.next();
@@ -956,7 +962,7 @@
     public boolean isEmpty() {
         return false;
     }
-
+    
     public void loadNearby(IChunkProvider ichunkprovider, IChunkProvider ichunkprovider1, int i, int j) {
         world.timings.syncChunkLoadPostTimer.startTiming(); // Spigot
         boolean flag = ichunkprovider.isChunkLoaded(i, j - 1);
@@ -1309,7 +1315,8 @@
         return this.tileEntities;
     }
 
-    public List<Entity>[] getEntitySlices() {
+    public Queue<Entity>[] getEntitySlices() {
+    //public List<Entity>[] getEntitySlices() {
         return this.entitySlices;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderGenerate.java src/main/java/net/minecraft/server/ChunkProviderGenerate.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderGenerate.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderGenerate.java	2016-03-06 05:06:47.049478121 +0800
@@ -0,0 +1,499 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.FutureTask;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.hose.GetChunkATPool;
+import org.hose.GetCreateChunkPool;
+import org.spigotmc.SpigotWorldConfig;
+
+public class ChunkProviderGenerate implements IChunkProvider {
+
+    private Random h;
+    private NoiseGeneratorOctaves i;
+    private NoiseGeneratorOctaves j;
+    private NoiseGeneratorOctaves k;
+    private NoiseGenerator3 l;
+    public NoiseGeneratorOctaves a;
+    public NoiseGeneratorOctaves b;
+    public NoiseGeneratorOctaves c;
+    private World m;
+    private final boolean n;
+    private WorldType o;
+    private final double[] p;
+    private final float[] q;
+    private CustomWorldSettingsFinal r;
+    private Block s;
+    private double[] t;
+    private WorldGenBase u;
+    private WorldGenStronghold v;
+    private WorldGenVillage w;
+    private WorldGenMineshaft x;
+    private WorldGenLargeFeature y;
+    private WorldGenBase z;
+    private WorldGenMonument A;
+    private BiomeBase[] B;
+    double[] d;
+    double[] e;
+    double[] f;
+    double[] g;
+
+    public ChunkProviderGenerate(World world, long i, boolean flag, String s) {
+        this.s = Blocks.WATER;
+        this.t = new double[256];
+        this.u = new WorldGenCaves();
+        this.v = new WorldGenStronghold();
+        this.w = new WorldGenVillage();
+        this.x = new WorldGenMineshaft();
+        this.y = new WorldGenLargeFeature();
+        this.z = new WorldGenCanyon();
+        this.A = new WorldGenMonument();
+        this.m = world;
+        this.n = flag;
+        this.o = world.getWorldData().getType();
+        this.h = new Random(i);
+        this.i = new NoiseGeneratorOctaves(this.h, 16);
+        this.j = new NoiseGeneratorOctaves(this.h, 16);
+        this.k = new NoiseGeneratorOctaves(this.h, 8);
+        this.l = new NoiseGenerator3(this.h, 4);
+        this.a = new NoiseGeneratorOctaves(this.h, 10);
+        this.b = new NoiseGeneratorOctaves(this.h, 16);
+        this.c = new NoiseGeneratorOctaves(this.h, 8);
+        this.p = new double[825];
+        this.q = new float[25];
+
+        for (int j = -2; j <= 2; ++j) {
+            for (int k = -2; k <= 2; ++k) {
+                float f = 10.0F / MathHelper.c((float) (j * j + k * k) + 0.2F);
+
+                this.q[j + 2 + (k + 2) * 5] = f;
+            }
+        }
+
+        if (s != null) {
+            this.r = CustomWorldSettingsFinal.CustomWorldSettings.a(s).b();
+            this.s = this.r.E ? Blocks.LAVA : Blocks.WATER;
+            world.b(this.r.q);
+        }
+
+    }
+
+    public void a(int i, int j, ChunkSnapshot chunksnapshot) {
+        this.B = this.m.getWorldChunkManager().getBiomes(this.B, i * 4 - 2, j * 4 - 2, 10, 10);
+        this.a(i * 4, 0, j * 4);
+
+        for (int k = 0; k < 4; ++k) {
+            int l = k * 5;
+            int i1 = (k + 1) * 5;
+
+            for (int j1 = 0; j1 < 4; ++j1) {
+                int k1 = (l + j1) * 33;
+                int l1 = (l + j1 + 1) * 33;
+                int i2 = (i1 + j1) * 33;
+                int j2 = (i1 + j1 + 1) * 33;
+
+                for (int k2 = 0; k2 < 32; ++k2) {
+                    double d0 = 0.125D;
+                    double d1 = this.p[k1 + k2];
+                    double d2 = this.p[l1 + k2];
+                    double d3 = this.p[i2 + k2];
+                    double d4 = this.p[j2 + k2];
+                    double d5 = (this.p[k1 + k2 + 1] - d1) * d0;
+                    double d6 = (this.p[l1 + k2 + 1] - d2) * d0;
+                    double d7 = (this.p[i2 + k2 + 1] - d3) * d0;
+                    double d8 = (this.p[j2 + k2 + 1] - d4) * d0;
+
+                    for (int l2 = 0; l2 < 8; ++l2) {
+                        double d9 = 0.25D;
+                        double d10 = d1;
+                        double d11 = d2;
+                        double d12 = (d3 - d1) * d9;
+                        double d13 = (d4 - d2) * d9;
+
+                        for (int i3 = 0; i3 < 4; ++i3) {
+                            double d14 = 0.25D;
+                            double d15 = (d11 - d10) * d14;
+                            double d16 = d10 - d15;
+
+                            for (int j3 = 0; j3 < 4; ++j3) {
+                                if ((d16 += d15) > 0.0D) {
+                                    chunksnapshot.a(k * 4 + i3, k2 * 8 + l2, j1 * 4 + j3, Blocks.STONE.getBlockData());
+                                } else if (k2 * 8 + l2 < this.r.q) {
+                                    chunksnapshot.a(k * 4 + i3, k2 * 8 + l2, j1 * 4 + j3, this.s.getBlockData());
+                                }
+                            }
+
+                            d10 += d12;
+                            d11 += d13;
+                        }
+
+                        d1 += d5;
+                        d2 += d6;
+                        d3 += d7;
+                        d4 += d8;
+                    }
+                }
+            }
+        }
+
+    }
+
+    public void a(int i, int j, ChunkSnapshot chunksnapshot, BiomeBase[] abiomebase) {
+        double d0 = 0.03125D;
+
+        this.t = this.l.a(this.t, (double) (i * 16), (double) (j * 16), 16, 16, d0 * 2.0D, d0 * 2.0D, 1.0D);
+
+        for (int k = 0; k < 16; ++k) {
+            for (int l = 0; l < 16; ++l) {
+                BiomeBase biomebase = abiomebase[l + k * 16];
+
+                biomebase.a(this.m, this.h, chunksnapshot, i * 16 + k, j * 16 + l, this.t[l + k * 16]);
+            }
+        }
+
+    }
+    
+    public Chunk getOrCreateChunk(int i, int j) {
+        //return getOrCreateChunk_hose(i, j);
+        SpigotWorldConfig.GetCreateChunkTask = new FutureTask(new GetCreateChunkPool(this, i, j));
+        SpigotWorldConfig.getcreatechunkatpool_executor.submit(SpigotWorldConfig.GetCreateChunkTask);
+        try {
+            return SpigotWorldConfig.GetCreateChunkTask.get();
+        } catch (InterruptedException ex) {
+            Logger.getLogger(ChunkProviderGenerate.class.getName()).log(Level.SEVERE, null, ex);
+        } catch (ExecutionException ex) {
+            Logger.getLogger(ChunkProviderGenerate.class.getName()).log(Level.SEVERE, null, ex);
+        }
+        return null;
+    }
+    
+    public Chunk getOrCreateChunk_hose(int i, int j) {
+        this.h.setSeed((long) i * 341873128712L + (long) j * 132897987541L);
+        ChunkSnapshot chunksnapshot = new ChunkSnapshot();
+
+        this.a(i, j, chunksnapshot);
+        this.B = this.m.getWorldChunkManager().getBiomeBlock(this.B, i * 16, j * 16, 16, 16);
+        this.a(i, j, chunksnapshot, this.B);
+        if (this.r.r) {
+            this.u.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.z) {
+            this.z.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.w && this.n) {
+            this.x.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.v && this.n) {
+            this.w.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.u && this.n) {
+            this.v.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.x && this.n) {
+            this.y.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.y && this.n) {
+            this.A.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        Chunk chunk = new Chunk(this.m, chunksnapshot, i, j);
+        byte[] abyte = chunk.getBiomeIndex();
+
+        for (int k = 0; k < abyte.length; ++k) {
+            abyte[k] = (byte) this.B[k].id;
+        }
+
+        chunk.initLighting();
+        return chunk;
+    }
+
+    private void a(int i, int j, int k) {
+        this.g = this.b.a(this.g, i, k, 5, 5, (double) this.r.e, (double) this.r.f, (double) this.r.g);
+        float f = this.r.a;
+        float f1 = this.r.b;
+
+        this.d = this.k.a(this.d, i, j, k, 5, 33, 5, (double) (f / this.r.h), (double) (f1 / this.r.i), (double) (f / this.r.j));
+        this.e = this.i.a(this.e, i, j, k, 5, 33, 5, (double) f, (double) f1, (double) f);
+        this.f = this.j.a(this.f, i, j, k, 5, 33, 5, (double) f, (double) f1, (double) f);
+        boolean flag = false;
+        boolean flag1 = false;
+        int l = 0;
+        int i1 = 0;
+
+        for (int j1 = 0; j1 < 5; ++j1) {
+            for (int k1 = 0; k1 < 5; ++k1) {
+                float f2 = 0.0F;
+                float f3 = 0.0F;
+                float f4 = 0.0F;
+                byte b0 = 2;
+                BiomeBase biomebase = this.B[j1 + 2 + (k1 + 2) * 10];
+
+                for (int l1 = -b0; l1 <= b0; ++l1) {
+                    for (int i2 = -b0; i2 <= b0; ++i2) {
+                        BiomeBase biomebase1 = this.B[j1 + l1 + 2 + (k1 + i2 + 2) * 10];
+                        float f5 = this.r.n + biomebase1.an * this.r.m;
+                        float f6 = this.r.p + biomebase1.ao * this.r.o;
+
+                        if (this.o == WorldType.AMPLIFIED && f5 > 0.0F) {
+                            f5 = 1.0F + f5 * 2.0F;
+                            f6 = 1.0F + f6 * 4.0F;
+                        }
+
+                        float f7 = this.q[l1 + 2 + (i2 + 2) * 5] / (f5 + 2.0F);
+
+                        if (biomebase1.an > biomebase.an) {
+                            f7 /= 2.0F;
+                        }
+
+                        f2 += f6 * f7;
+                        f3 += f5 * f7;
+                        f4 += f7;
+                    }
+                }
+
+                f2 /= f4;
+                f3 /= f4;
+                f2 = f2 * 0.9F + 0.1F;
+                f3 = (f3 * 4.0F - 1.0F) / 8.0F;
+                double d0 = this.g[i1] / 8000.0D;
+
+                if (d0 < 0.0D) {
+                    d0 = -d0 * 0.3D;
+                }
+
+                d0 = d0 * 3.0D - 2.0D;
+                if (d0 < 0.0D) {
+                    d0 /= 2.0D;
+                    if (d0 < -1.0D) {
+                        d0 = -1.0D;
+                    }
+
+                    d0 /= 1.4D;
+                    d0 /= 2.0D;
+                } else {
+                    if (d0 > 1.0D) {
+                        d0 = 1.0D;
+                    }
+
+                    d0 /= 8.0D;
+                }
+
+                ++i1;
+                double d1 = (double) f3;
+                double d2 = (double) f2;
+
+                d1 += d0 * 0.2D;
+                d1 = d1 * (double) this.r.k / 8.0D;
+                double d3 = (double) this.r.k + d1 * 4.0D;
+
+                for (int j2 = 0; j2 < 33; ++j2) {
+                    double d4 = ((double) j2 - d3) * (double) this.r.l * 128.0D / 256.0D / d2;
+
+                    if (d4 < 0.0D) {
+                        d4 *= 4.0D;
+                    }
+
+                    double d5 = this.e[l] / (double) this.r.d;
+                    double d6 = this.f[l] / (double) this.r.c;
+                    double d7 = (this.d[l] / 10.0D + 1.0D) / 2.0D;
+                    double d8 = MathHelper.b(d5, d6, d7) - d4;
+
+                    if (j2 > 29) {
+                        double d9 = (double) ((float) (j2 - 29) / 3.0F);
+
+                        d8 = d8 * (1.0D - d9) + -10.0D * d9;
+                    }
+
+                    this.p[l] = d8;
+                    ++l;
+                }
+            }
+        }
+
+    }
+
+    public boolean isChunkLoaded(int i, int j) {
+        return true;
+    }
+   
+    public void getChunkAt(IChunkProvider ichunkprovider, int i, int j) {
+        //getChunkAt_hose(ichunkprovider, i, j);
+        SpigotWorldConfig.GetChunkATTask = new FutureTask(new GetChunkATPool(this, ichunkprovider, i, j));
+        SpigotWorldConfig.getchunkatpool_executor.submit(SpigotWorldConfig.GetChunkATTask);
+    }
+    
+    public void getChunkAt_hose(IChunkProvider ichunkprovider, int i, int j) {
+        BlockFalling.instaFall = true;
+        int k = i * 16;
+        int l = j * 16;
+        BlockPosition blockposition = new BlockPosition(k, 0, l);
+        BiomeBase biomebase = this.m.getBiome(blockposition.a(16, 0, 16));
+
+        this.h.setSeed(this.m.getSeed());
+        long i1 = this.h.nextLong() / 2L * 2L + 1L;
+        long j1 = this.h.nextLong() / 2L * 2L + 1L;
+
+        this.h.setSeed((long) i * i1 + (long) j * j1 ^ this.m.getSeed());
+        boolean flag = false;
+        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
+
+        if (this.r.w && this.n) {
+            this.x.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        if (this.r.v && this.n) {
+            flag = this.w.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        if (this.r.u && this.n) {
+            this.v.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        if (this.r.x && this.n) {
+            this.y.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        if (this.r.y && this.n) {
+            this.A.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        int k1;
+        int l1;
+        int i2;
+
+        if (biomebase != BiomeBase.DESERT && biomebase != BiomeBase.DESERT_HILLS && this.r.A && !flag && this.h.nextInt(this.r.B) == 0) {
+            k1 = this.h.nextInt(16) + 8;
+            l1 = this.h.nextInt(256);
+            i2 = this.h.nextInt(16) + 8;
+            (new WorldGenLakes(Blocks.WATER)).generate(this.m, this.h, blockposition.a(k1, l1, i2));
+        }
+
+        if (!flag && this.h.nextInt(this.r.D / 10) == 0 && this.r.C) {
+            k1 = this.h.nextInt(16) + 8;
+            l1 = this.h.nextInt(this.h.nextInt(248) + 8);
+            i2 = this.h.nextInt(16) + 8;
+            if (l1 < this.m.F() || this.h.nextInt(this.r.D / 8) == 0) {
+                (new WorldGenLakes(Blocks.LAVA)).generate(this.m, this.h, blockposition.a(k1, l1, i2));
+            }
+        }
+
+        if (this.r.s) {
+            for (k1 = 0; k1 < this.r.t; ++k1) {
+                l1 = this.h.nextInt(16) + 8;
+                i2 = this.h.nextInt(256);
+                int j2 = this.h.nextInt(16) + 8;
+
+                (new WorldGenDungeons()).generate(this.m, this.h, blockposition.a(l1, i2, j2));
+            }
+        }
+
+        biomebase.a(this.m, this.h, new BlockPosition(k, 0, l));
+        SpawnerCreature.a(this.m, biomebase, k + 8, l + 8, 16, 16, this.h);
+        blockposition = blockposition.a(8, 0, 8);
+
+        for (k1 = 0; k1 < 16; ++k1) {
+            for (l1 = 0; l1 < 16; ++l1) {
+                BlockPosition blockposition1 = this.m.q(blockposition.a(k1, 0, l1));
+                BlockPosition blockposition2 = blockposition1.down();
+
+                if (this.m.v(blockposition2)) {
+                    this.m.setTypeAndData(blockposition2, Blocks.ICE.getBlockData(), 2);
+                }
+
+                if (this.m.f(blockposition1, true)) {
+                    this.m.setTypeAndData(blockposition1, Blocks.SNOW_LAYER.getBlockData(), 2);
+                }
+            }
+        }
+
+        BlockFalling.instaFall = false;
+    }
+
+    public boolean a(IChunkProvider ichunkprovider, Chunk chunk, int i, int j) {
+        boolean flag = false;
+
+        if (this.r.y && this.n && chunk.w() < 3600L) {
+            flag |= this.A.a(this.m, this.h, new ChunkCoordIntPair(i, j));
+        }
+
+        return flag;
+    }
+
+    public boolean saveChunks(boolean flag, IProgressUpdate iprogressupdate) {
+        return true;
+    }
+
+    public void c() {}
+
+    public boolean unloadChunks() {
+        return false;
+    }
+
+    public boolean canSave() {
+        return true;
+    }
+
+    public String getName() {
+        return "RandomLevelSource";
+    }
+
+    public List<BiomeBase.BiomeMeta> getMobsFor(EnumCreatureType enumcreaturetype, BlockPosition blockposition) {
+        BiomeBase biomebase = this.m.getBiome(blockposition);
+
+        if (this.n) {
+            if (enumcreaturetype == EnumCreatureType.MONSTER && this.y.a(blockposition)) {
+                return this.y.b();
+            }
+
+            if (enumcreaturetype == EnumCreatureType.MONSTER && this.r.y && this.A.a(this.m, blockposition)) {
+                return this.A.b();
+            }
+        }
+
+        return biomebase.getMobs(enumcreaturetype);
+    }
+
+    public BlockPosition findNearestMapFeature(World world, String s, BlockPosition blockposition) {
+        return "Stronghold".equals(s) && this.v != null ? this.v.getNearestGeneratedFeature(world, blockposition) : null;
+    }
+
+    public int getLoadedChunks() {
+        return 0;
+    }
+
+    public void recreateStructures(Chunk chunk, int i, int j) {
+        if (this.r.w && this.n) {
+            this.x.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+        if (this.r.v && this.n) {
+            this.w.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+        if (this.r.u && this.n) {
+            this.v.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+        if (this.r.x && this.n) {
+            this.y.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+        if (this.r.y && this.n) {
+            this.A.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+    }
+
+    public Chunk getChunkAt(BlockPosition blockposition) {
+        return this.getOrCreateChunk(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderServer.java src/main/java/net/minecraft/server/ChunkProviderServer.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderServer.java	2016-02-26 15:27:08.093203344 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderServer.java	2016-03-06 05:06:47.096478125 +0800
@@ -1,37 +1,35 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Lists;
+import io.netty.util.internal.chmv8.ConcurrentHashMapV8;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start
 import java.util.Random;
-import java.util.logging.Level;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.bukkit.Server;
 import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
 import org.bukkit.craftbukkit.util.LongHash;
 import org.bukkit.craftbukkit.util.LongHashSet;
-import org.bukkit.craftbukkit.util.LongObjectHashMap;
+import org.bukkit.event.Event;
 import org.bukkit.event.world.ChunkUnloadEvent;
 // CraftBukkit end
 
 public class ChunkProviderServer implements IChunkProvider {
 
     private static final Logger b = LogManager.getLogger();
-    public LongHashSet unloadQueue = new LongHashSet(); // CraftBukkit - LongHashSet
+    //public LongHashSet unloadQueue = new LongHashSet(); // CraftBukkit - LongHashSet
+    public ConcurrentHashMapV8<Long, Long> unloadQueue = new ConcurrentHashMapV8<Long, Long>(); // CraftBukkit
     public Chunk emptyChunk;
     public IChunkProvider chunkProvider;
     private IChunkLoader chunkLoader;
     public boolean forceChunkLoad = false; // CraftBukkit - true -> false
-    public LongObjectHashMap<Chunk> chunks = new LongObjectHashMap<Chunk>();
+    //public LongObjectHashMap<Chunk> chunks = new LongObjectHashMap<Chunk>();
+    public ConcurrentHashMap<Long, Chunk> chunks = new ConcurrentHashMap<Long, Chunk>();
     public WorldServer world;
 
     public ChunkProviderServer(WorldServer worldserver, IChunkLoader ichunkloader, IChunkProvider ichunkprovider) {
@@ -42,10 +40,13 @@
     }
 
     public boolean isChunkLoaded(int i, int j) {
+        //return this.chunks.containsKey(LongHash.toLong(i, j)); // CraftBukkit
+        //System.out.println(this.chunks.size()+","+this.chunks.values().size());
         return this.chunks.containsKey(LongHash.toLong(i, j)); // CraftBukkit
     }
 
     // CraftBukkit start - Change return type to Collection and return the values of our chunk map
+    //public java.util.Collection a() {
     public java.util.Collection a() {
         // return this.chunkList;
         return this.chunks.values();
@@ -53,12 +54,15 @@
     }
 
     public void queueUnload(int i, int j) {
+        long key = LongHash.toLong(i, j);
         if (this.world.worldProvider.e()) {
             if (!this.world.c(i, j)) {
                 // CraftBukkit start
-                this.unloadQueue.add(i, j);
+                //this.unloadQueue.add(i, j);
+                this.unloadQueue.put(key, key);
 
-                Chunk c = chunks.get(LongHash.toLong(i, j));
+                //Chunk c = chunks.get(LongHash.toLong(i, j));
+                Chunk c = chunks.get(key);
                 if (c != null) {
                     c.mustSave = true;
                 }
@@ -66,9 +70,11 @@
             }
         } else {
             // CraftBukkit start
-            this.unloadQueue.add(i, j);
+            //this.unloadQueue.add(i, j);
+            this.unloadQueue.put(key, key);
 
-            Chunk c = chunks.get(LongHash.toLong(i, j));
+            //Chunk c = chunks.get(LongHash.toLong(i, j));
+            Chunk c = chunks.get(key);
             if (c != null) {
                 c.mustSave = true;
             }
@@ -85,21 +91,26 @@
 
             this.queueUnload(chunk.locX, chunk.locZ);
         }
-
+        
     }
 
     // CraftBukkit start - Add async variant, provide compatibility
     public Chunk getChunkIfLoaded(int x, int z) {
+        //return chunks.get(LongHash.toLong(x, z));
         return chunks.get(LongHash.toLong(x, z));
     }
 
     public Chunk getChunkAt(int i, int j) {
         return getChunkAt(i, j, null);
     }
-
-    public Chunk getChunkAt(int i, int j, Runnable runnable) {
-        unloadQueue.remove(i, j);
-        Chunk chunk = chunks.get(LongHash.toLong(i, j));
+    
+    synchronized public Chunk getChunkAt(int i, int j, Runnable runnable) {
+    //public Chunk getChunkAt(int i, int j, Runnable runnable) {
+        long key = LongHash.toLong(i, j);
+        //unloadQueue.remove(i, j);
+        unloadQueue.remove(key);
+        //Chunk chunk = chunks.get(LongHash.toLong(i, j));
+        Chunk chunk = chunks.get(key);
         ChunkRegionLoader loader = null;
 
         if (this.chunkLoader instanceof ChunkRegionLoader) {
@@ -126,8 +137,11 @@
         return chunk;
     }
     public Chunk originalGetChunkAt(int i, int j) {
-        this.unloadQueue.remove(i, j);
-        Chunk chunk = (Chunk) this.chunks.get(LongHash.toLong(i, j));
+        long key = LongHash.toLong(i, j);
+        //this.unloadQueue.remove(i, j);
+        this.unloadQueue.remove(key);
+        //Chunk chunk = (Chunk) this.chunks.get(LongHash.toLong(i, j));
+        Chunk chunk = (Chunk) this.chunks.get(key);
         boolean newChunk = false;
         // CraftBukkit end
 
@@ -152,7 +166,8 @@
                 }
                 newChunk = true; // CraftBukkit
             }
-
+            
+            //this.chunks.put(LongHash.toLong(i, j), chunk);
             this.chunks.put(LongHash.toLong(i, j), chunk);
             
             chunk.addEntities();
@@ -165,7 +180,10 @@
                  * the World constructor. We can't reliably alter that, so we have
                  * no way of creating a CraftWorld/CraftServer at that point.
                  */
-                server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, newChunk));
+                //server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, newChunk));
+                Event ev = new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, newChunk);
+                ev.setAsynchronous();
+                server.getPluginManager().callEvent(ev);
             }
 
             // Update neighbor counts
@@ -192,6 +210,7 @@
 
     public Chunk getOrCreateChunk(int i, int j) {
         // CraftBukkit start
+        //Chunk chunk = (Chunk) this.chunks.get(LongHash.toLong(i, j));
         Chunk chunk = (Chunk) this.chunks.get(LongHash.toLong(i, j));
 
         chunk = chunk == null ? (!this.world.ad() && !this.forceChunkLoad ? this.emptyChunk : this.getChunkAt(i, j)) : chunk;
@@ -286,7 +305,10 @@
                     }
                 }
                 BlockSand.instaFall = false;
-                this.world.getServer().getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(chunk.bukkitChunk));
+                //this.world.getServer().getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(chunk.bukkitChunk));
+                Event ev = new org.bukkit.event.world.ChunkPopulateEvent(chunk.bukkitChunk);
+                ev.setAsynchronous();
+                this.world.getServer().getPluginManager().callEvent(ev);
                 // CraftBukkit end
                 
                 chunk.e();
@@ -344,7 +366,8 @@
             // CraftBukkit start
             Server server = this.world.getServer();
             for (int i = 0; i < 100 && !this.unloadQueue.isEmpty(); ++i) {
-                long chunkcoordinates = this.unloadQueue.popFirst();
+                //long chunkcoordinates = this.unloadQueue.popFirst();
+                long chunkcoordinates = this.unloadQueue.entrySet().iterator().next().getKey();
                 Chunk chunk = this.chunks.get(chunkcoordinates);
                 if (chunk == null) continue;
 
@@ -356,9 +379,10 @@
                         chunk.removeEntities();
                         this.saveChunk(chunk);
                         this.saveChunkNOP(chunk);
+                        //this.chunks.remove(chunkcoordinates); // CraftBukkit
                         this.chunks.remove(chunkcoordinates); // CraftBukkit
                     }
-
+                    
                     // this.unloadQueue.remove(olong);
 
                     // Update neighbor counts
diff -Naur src_origin/main/java/net/minecraft/server/CommandSpreadPlayers.java src/main/java/net/minecraft/server/CommandSpreadPlayers.java
--- src_origin/main/java/net/minecraft/server/CommandSpreadPlayers.java	2016-02-26 15:27:08.290203362 +0800
+++ src/main/java/net/minecraft/server/CommandSpreadPlayers.java	2016-03-06 05:06:47.444478158 +0800
@@ -40,6 +40,7 @@
             double d4 = a(astring[i++], d3 + 1.0D);
             boolean flag = d(astring[i++]);
             ArrayList arraylist = Lists.newArrayList();
+            //List arraylist = Lists.newCopyOnWriteArrayList();
 
             while (i < astring.length) {
                 String s = astring[i++];
diff -Naur src_origin/main/java/net/minecraft/server/Container.java src/main/java/net/minecraft/server/Container.java
--- src_origin/main/java/net/minecraft/server/Container.java	2016-02-26 15:27:08.349203368 +0800
+++ src/main/java/net/minecraft/server/Container.java	2016-03-06 05:06:47.539478167 +0800
@@ -10,6 +10,8 @@
 // CraftBukkit start
 import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.CopyOnWriteArraySet;
 import org.bukkit.craftbukkit.inventory.CraftInventory;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.event.Event.Result;
@@ -22,12 +24,17 @@
 
     public List<ItemStack> b = Lists.newArrayList();
     public List<Slot> c = Lists.newArrayList();
+    /*public List<ItemStack> b = Lists.newCopyOnWriteArrayList();
+    public List<Slot> c = Lists.newCopyOnWriteArrayList();*/
     public int windowId;
     private int dragType = -1;
     private int g;
     private final Set<Slot> h = Sets.newHashSet();
+    //private final Set<Slot> h = new CopyOnWriteArraySet<Slot>();
     protected List<ICrafting> listeners = Lists.newArrayList();
+    //protected List<ICrafting> listeners =Lists.newCopyOnWriteArrayList();
     private Set<EntityHuman> i = Sets.newHashSet();
+    //private Set<EntityHuman> i = new CopyOnWriteArraySet<EntityHuman>();
     private int tickCount; // Spigot
 
     // CraftBukkit start
@@ -63,6 +70,7 @@
 
     public List<ItemStack> a() {
         ArrayList arraylist = Lists.newArrayList();
+        //List arraylist = Lists.newCopyOnWriteArrayList();
 
         for (int i = 0; i < this.c.size(); ++i) {
             arraylist.add(((Slot) this.c.get(i)).getItem());
diff -Naur src_origin/main/java/net/minecraft/server/CraftingManager.java src/main/java/net/minecraft/server/CraftingManager.java
--- src_origin/main/java/net/minecraft/server/CraftingManager.java	2016-02-26 15:27:08.668203398 +0800
+++ src/main/java/net/minecraft/server/CraftingManager.java	2016-03-06 05:06:48.108478220 +0800
@@ -14,6 +14,7 @@
 public class CraftingManager {
 
     private static final CraftingManager a = new CraftingManager();
+    //do not use "newCopyOnWriteArrayList"
     public List<IRecipe> recipes = Lists.newArrayList();
     // CraftBukkit start
     public IRecipe lastRecipe;
diff -Naur src_origin/main/java/net/minecraft/server/CrashReport.java src/main/java/net/minecraft/server/CrashReport.java
--- src_origin/main/java/net/minecraft/server/CrashReport.java	2016-02-26 15:27:08.705203401 +0800
+++ src/main/java/net/minecraft/server/CrashReport.java	2016-03-06 05:06:48.155478224 +0800
@@ -12,6 +12,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.Callable;
+import java.util.concurrent.CopyOnWriteArrayList;
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.lang3.ArrayUtils;
 import org.apache.logging.log4j.LogManager;
@@ -23,7 +24,8 @@
     private final String b;
     private final Throwable c;
     private final CrashReportSystemDetails d = new CrashReportSystemDetails(this, "System Details");
-    private final List<CrashReportSystemDetails> e = Lists.newArrayList();
+    //private final List<CrashReportSystemDetails> e = Lists.newArrayList();
+    private final List<CrashReportSystemDetails> e = Lists.newCopyOnWriteArrayList();
     private File f;
     private boolean g = true;
     private StackTraceElement[] h = new StackTraceElement[0];
diff -Naur src_origin/main/java/net/minecraft/server/DedicatedServer.java src/main/java/net/minecraft/server/DedicatedServer.java
--- src_origin/main/java/net/minecraft/server/DedicatedServer.java	2016-02-26 15:27:08.757203406 +0800
+++ src/main/java/net/minecraft/server/DedicatedServer.java	2016-03-06 05:06:48.251478233 +0800
@@ -29,7 +29,8 @@
 public class DedicatedServer extends MinecraftServer implements IMinecraftServer {
 
     private static final Logger LOGGER = LogManager.getLogger();
-    private final List<ServerCommand> l = Collections.synchronizedList(Lists.<ServerCommand>newArrayList()); // CraftBukkit - fix decompile error
+    //private final List<ServerCommand> l = Collections.synchronizedList(Lists.<ServerCommand>newArrayList()); // CraftBukkit - fix decompile error
+    private final List<ServerCommand> l = Lists.newCopyOnWriteArrayList(); // CraftBukkit - fix decompile error
     private RemoteStatusListener m;
     private RemoteControlListener n;
     public PropertyManager propertyManager;
diff -Naur src_origin/main/java/net/minecraft/server/EntityFallingBlock.java src/main/java/net/minecraft/server/EntityFallingBlock.java
--- src_origin/main/java/net/minecraft/server/EntityFallingBlock.java	2016-02-26 15:27:09.384203465 +0800
+++ src/main/java/net/minecraft/server/EntityFallingBlock.java	2016-03-06 05:06:49.302478331 +0800
@@ -3,6 +3,8 @@
 import com.google.common.collect.Lists;
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
 
@@ -138,7 +140,8 @@
             int i = MathHelper.f(f - 1.0F);
 
             if (i > 0) {
-                ArrayList arraylist = Lists.newArrayList(this.world.getEntities(this, this.getBoundingBox()));
+                //ArrayList arraylist = Lists.newArrayList(this.world.getEntities(this, this.getBoundingBox()));
+                List arraylist = Lists.newCopyOnWriteArrayList(this.world.getEntities(this, this.getBoundingBox()));
                 boolean flag = block == Blocks.ANVIL;
                 DamageSource damagesource = flag ? DamageSource.ANVIL : DamageSource.FALLING_BLOCK;
                 Iterator iterator = arraylist.iterator();
diff -Naur src_origin/main/java/net/minecraft/server/EntityItem.java src/main/java/net/minecraft/server/EntityItem.java
--- src_origin/main/java/net/minecraft/server/EntityItem.java	2016-02-26 15:27:09.641203489 +0800
+++ src/main/java/net/minecraft/server/EntityItem.java	2016-03-06 05:06:49.768478375 +0800
@@ -81,10 +81,10 @@
                     this.motZ = (double) ((this.random.nextFloat() - this.random.nextFloat()) * 0.2F);
                     this.makeSound("random.fizz", 0.4F, 2.0F + this.random.nextFloat() * 0.4F);
                 }
-
-                if (!this.world.isClientSide) {
+                /*
+                if (!this.world.isClientSide && this.ak == false) {
                     this.w();
-                }
+                }*/
             }
 
             float f = 0.98F;
@@ -143,6 +143,7 @@
     }
     // Spigot end
 
+    //merge will cause dup through portal
     private void w() {
         // Spigot start
         double radius = world.spigotConfig.itemMerge;
@@ -375,9 +376,10 @@
 
     public void c(int i) {
         super.c(i);
-        if (!this.world.isClientSide) {
+        /*
+        if (!this.world.isClientSide && this.ak == false) {
             this.w();
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/Entity.java src/main/java/net/minecraft/server/Entity.java
--- src_origin/main/java/net/minecraft/server/Entity.java	2016-02-26 15:27:08.930203422 +0800
+++ src/main/java/net/minecraft/server/Entity.java	2016-03-06 05:06:48.569478263 +0800
@@ -263,12 +263,12 @@
             this.world.methodProfiler.a("portal");
             MinecraftServer minecraftserver = ((WorldServer) this.world).getMinecraftServer();
             int i = this.L();
-
             if (this.ak) {
                 if (true || minecraftserver.getAllowNether()) { // CraftBukkit
                     if (this.vehicle == null && this.al++ >= i) {
                         this.al = i;
                         this.portalCooldown = this.aq();
+
                         byte b0;
 
                         if (this.world.worldProvider.getDimension() == -1) {
@@ -291,9 +291,14 @@
                     this.al = 0;
                 }
             }
-
+            /*
             if (this.portalCooldown > 0) {
                 --this.portalCooldown;
+            }*/
+            if (this.portalCooldown > 0) {
+                --this.portalCooldown;
+            } else {
+                this.teleport_count = 0;
             }
 
             this.world.methodProfiler.b();
@@ -1891,7 +1896,8 @@
     }
 
     public void c(int i) {
-        if (!this.world.isClientSide && !this.dead) {
+        //fix dup
+        if (!this.world.isClientSide && !this.dead && this.teleport_count == 0) {
             this.world.methodProfiler.a("changeDimension");
             MinecraftServer minecraftserver = MinecraftServer.getServer();
             // CraftBukkit start - Move logic into new function "teleportToLocation"
@@ -1924,8 +1930,11 @@
         }
     }
 
+    int teleport_count = 0;
     public void teleportTo(Location exit, boolean portal) {
-        if (true) {
+        //if (true) {
+        if (true && teleport_count == 0) {
+            teleport_count = 1;
             WorldServer worldserver = ((CraftWorld) getBukkitEntity().getLocation().getWorld()).getHandle();
             WorldServer worldserver1 = ((CraftWorld) exit.getWorld()).getHandle();
             int i = worldserver1.dimension;
diff -Naur src_origin/main/java/net/minecraft/server/EntityLiving.java src/main/java/net/minecraft/server/EntityLiving.java
--- src_origin/main/java/net/minecraft/server/EntityLiving.java	2016-02-26 15:27:09.784203502 +0800
+++ src/main/java/net/minecraft/server/EntityLiving.java	2016-03-06 05:06:49.990478396 +0800
@@ -461,7 +461,8 @@
 
     // CraftBukkit start
     private boolean isTickingEffects = false;
-    private List<Object> effectsToProcess = Lists.newArrayList();
+    //private List<Object> effectsToProcess = Lists.newArrayList();
+    private List<Object> effectsToProcess = Lists.newCopyOnWriteArrayList();
     // CraftBukkit end
 
     protected void bi() {
diff -Naur src_origin/main/java/net/minecraft/server/EntityMinecartAbstract.java src/main/java/net/minecraft/server/EntityMinecartAbstract.java
--- src_origin/main/java/net/minecraft/server/EntityMinecartAbstract.java	2016-02-26 15:27:09.793203503 +0800
+++ src/main/java/net/minecraft/server/EntityMinecartAbstract.java	2016-03-06 05:06:50.044478401 +0800
@@ -238,9 +238,14 @@
                     this.al = 0;
                 }
             }
-
+            /*
             if (this.portalCooldown > 0) {
                 --this.portalCooldown;
+            }*/
+            if (this.portalCooldown > 0) {
+                -- this.portalCooldown;
+            } else {
+                this.teleport_count = 0;
             }
 
             this.world.methodProfiler.b();
diff -Naur src_origin/main/java/net/minecraft/server/EntityPlayer.java src/main/java/net/minecraft/server/EntityPlayer.java
--- src_origin/main/java/net/minecraft/server/EntityPlayer.java	2016-02-26 15:27:09.996203522 +0800
+++ src/main/java/net/minecraft/server/EntityPlayer.java	2016-03-06 05:06:50.398478434 +0800
@@ -10,6 +10,7 @@
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -33,8 +34,11 @@
     public final PlayerInteractManager playerInteractManager;
     public double d;
     public double e;
-    public final List<ChunkCoordIntPair> chunkCoordIntPairQueue = Lists.newLinkedList();
-    public final List<Integer> removeQueue = Lists.newLinkedList();
+    //public final List<ChunkCoordIntPair> chunkCoordIntPairQueue = Lists.newLinkedList();
+    //casue negative array size
+    public final ConcurrentLinkedQueue<ChunkCoordIntPair> chunkCoordIntPairQueue = new ConcurrentLinkedQueue<ChunkCoordIntPair>();
+    //public final List<Integer> removeQueue = Lists.newLinkedList();
+    public final ConcurrentLinkedQueue<Integer> removeQueue = new ConcurrentLinkedQueue<Integer>();
     private final ServerStatisticManager bK;
     private float bL = Float.MIN_VALUE;
     private float bM = -1.0E8F;
@@ -217,9 +221,11 @@
         }
 
         if (!this.chunkCoordIntPairQueue.isEmpty()) {
-            ArrayList arraylist = Lists.newArrayList();
+            //ArrayList arraylist = Lists.newArrayList();
+            List arraylist = Lists.newCopyOnWriteArrayList();
             Iterator iterator1 = this.chunkCoordIntPairQueue.iterator();
-            ArrayList arraylist1 = Lists.newArrayList();
+            //ArrayList arraylist1 = Lists.newArrayList();
+            List arraylist1 = Lists.newCopyOnWriteArrayList();
 
             Chunk chunk;
 
@@ -894,11 +900,16 @@
     }
 
     public void copyTo(EntityHuman entityhuman, boolean flag) {
-        super.copyTo(entityhuman, flag);
-        this.lastSentExp = -1;
-        this.bM = -1.0F;
-        this.bN = -1;
-        this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
+        try {
+            super.copyTo(entityhuman, flag);
+            this.lastSentExp = -1;
+            this.bM = -1.0F;
+            this.bN = -1;
+            this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
+        } catch (Exception ex){
+            
+        }
+        
     }
 
     protected void a(MobEffect mobeffect) {
diff -Naur src_origin/main/java/net/minecraft/server/EntitySlice.java src/main/java/net/minecraft/server/EntitySlice.java
--- src_origin/main/java/net/minecraft/server/EntitySlice.java	2016-02-26 15:27:10.178203539 +0800
+++ src/main/java/net/minecraft/server/EntitySlice.java	2016-03-06 05:06:50.705478463 +0800
@@ -7,16 +7,19 @@
 import java.util.AbstractSet;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentMap;
 
 public class EntitySlice<T> extends AbstractSet<T> {
 
     private static final Set<Class<?>> a = Sets.newConcurrentHashSet(); // CraftBukkit
-    private final Map<Class<?>, List<T>> b = Maps.newHashMap();
+    //private final Map<Class<?>, List<T>> b = Maps.newHashMap();
+    private final ConcurrentMap<Class<?>, List<T>> b = Maps.newConcurrentMap();
+    
     private final Set<Class<?>> c = Sets.newIdentityHashSet();
     private final Class<T> d;
-    private final List<T> e = Lists.newArrayList();
+    //private final List<T> e = Lists.newArrayList();
+    private final List<T> e = Lists.newCopyOnWriteArrayList();
 
     public EntitySlice(Class<T> oclass) {
         this.d = oclass;
@@ -77,6 +80,7 @@
         List list = (List) this.b.get(oclass);
 
         if (list == null) {
+            //this.b.put(oclass, Lists.newArrayList(t0));
             this.b.put(oclass, Lists.newArrayList(t0));
         } else {
             list.add(t0);
diff -Naur src_origin/main/java/net/minecraft/server/EntityTrackerEntry.java src/main/java/net/minecraft/server/EntityTrackerEntry.java
--- src_origin/main/java/net/minecraft/server/EntityTrackerEntry.java	2016-02-26 15:27:10.392203559 +0800
+++ src/main/java/net/minecraft/server/EntityTrackerEntry.java	2016-03-06 05:06:51.082478498 +0800
@@ -1,10 +1,10 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Sets;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -39,7 +39,8 @@
     private boolean x;
     private boolean y;
     public boolean n;
-    public Set<EntityPlayer> trackedPlayers = Sets.newHashSet();
+    //public Set<EntityPlayer> trackedPlayers = Sets.newHashSet();
+    public CopyOnWriteArraySet<EntityPlayer> trackedPlayers = new CopyOnWriteArraySet<EntityPlayer>();
 
     public EntityTrackerEntry(Entity entity, int i, int j, boolean flag) {
         this.tracker = entity;
@@ -424,9 +425,14 @@
     }
 
     public void scanPlayers(List<EntityHuman> list) {
+        Iterator it = list.iterator();
+        while(it.hasNext()){
+            this.updatePlayer((EntityPlayer) it.next());
+        }
+        /*
         for (int i = 0; i < list.size(); ++i) {
             this.updatePlayer((EntityPlayer) list.get(i));
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityTracker.java src/main/java/net/minecraft/server/EntityTracker.java
--- src_origin/main/java/net/minecraft/server/EntityTracker.java	2016-02-26 15:27:10.352203555 +0800
+++ src/main/java/net/minecraft/server/EntityTracker.java	2016-03-06 05:06:51.035478494 +0800
@@ -1,11 +1,11 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
-import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Set;
-import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArraySet;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -13,10 +13,18 @@
 
     private static final Logger a = LogManager.getLogger();
     private final WorldServer world;
-    private Set<EntityTrackerEntry> c = Sets.newHashSet();
-    public IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    //private Set<EntityTrackerEntry> c = Sets.newHashSet();
+    private Set<EntityTrackerEntry> c = new CopyOnWriteArraySet<EntityTrackerEntry>();
+    //public IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    public ConcurrentHashMap<Integer, EntityTrackerEntry> trackedEntities = new ConcurrentHashMap<Integer, EntityTrackerEntry>();
     private int e;
 
+    //for spigot
+    private int g(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
+    
     public EntityTracker(WorldServer worldserver) {
         this.world = worldserver;
         this.e = worldserver.getMinecraftServer().getPlayerList().d();
@@ -94,23 +102,40 @@
     }
 
     public void addEntity(Entity entity, int i, final int j, boolean flag) {
-        org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
-        i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
-        if (i > this.e) {
-            i = this.e;
-        }
-
-        try {
-            if (this.trackedEntities.b(entity.getId())) {
-                throw new IllegalStateException("Entity is already tracked!");
+        synchronized (this) {
+            org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
+            i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
+            if (i > this.e) {
+                i = this.e;
             }
 
-            EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, j, flag);
 
-            this.c.add(entitytrackerentry);
-            this.trackedEntities.a(entity.getId(), entitytrackerentry);
-            entitytrackerentry.scanPlayers(this.world.players);
-        } catch (Throwable throwable) {
+            //just track once
+            //if (this.trackedEntities.b(entity.getId())) {
+            if (this.trackedEntities.containsKey(this.g(entity.getId()))) {
+                //do nothing
+                //throw new IllegalStateException("Entity is already tracked!");
+                //throw new Exception();
+            } else {
+                EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, j, flag);
+
+                this.c.add(entitytrackerentry);
+                //key point causing error
+                //this.trackedEntities.a(entity.getId(), entitytrackerentry);
+                this.trackedEntities.put(this.g(entity.getId()), entitytrackerentry);
+
+                entitytrackerentry.scanPlayers(this.world.players);
+            }
+        }
+        /*
+        EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, j, flag);
+
+        this.c.add(entitytrackerentry);
+        //key point causing error
+        this.trackedEntities.a(entity.getId(), entitytrackerentry);
+        entitytrackerentry.scanPlayers(this.world.players);*/
+        
+        /*} catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
             CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity To Track");
 
@@ -141,7 +166,7 @@
             } catch (ReportedException reportedexception) {
                 EntityTracker.a.error("\"Silently\" catching entity tracking error.", reportedexception);
             }
-        }
+        }*/
 
     }
 
@@ -158,8 +183,11 @@
             }
         }
 
-        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
-
+        //EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
+        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.get(this.g(entity.getId()));
+        //remember to remove trackedEntities.
+        this.trackedEntities.remove(this.g(entity.getId()));
+        
         if (entitytrackerentry1 != null) {
             this.c.remove(entitytrackerentry1);
             entitytrackerentry1.a();
@@ -168,8 +196,11 @@
     }
 
     public void updatePlayers() {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         Iterator iterator = this.c.iterator();
+        //observe track list size
+        //System.out.println(this.c.size()+","+this.trackedEntities.size()+","+arraylist.size());
 
         while (iterator.hasNext()) {
             EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
@@ -211,7 +242,8 @@
     }
 
     public void a(Entity entity, Packet packet) {
-        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        //EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(this.g(entity.getId()));
 
         if (entitytrackerentry != null) {
             entitytrackerentry.broadcast(packet);
@@ -220,7 +252,8 @@
     }
 
     public void sendPacketToEntity(Entity entity, Packet packet) {
-        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        //EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(this.g(entity.getId()));
 
         if (entitytrackerentry != null) {
             entitytrackerentry.broadcastIncludingSelf(packet);
diff -Naur src_origin/main/java/net/minecraft/server/Explosion.java src/main/java/net/minecraft/server/Explosion.java
--- src_origin/main/java/net/minecraft/server/Explosion.java	2016-02-26 15:27:10.556203574 +0800
+++ src/main/java/net/minecraft/server/Explosion.java	2016-03-06 05:06:51.399478528 +0800
@@ -28,6 +28,7 @@
     public final Entity source;
     private final float size;
     private final List<BlockPosition> blocks = Lists.newArrayList();
+    //private final List<BlockPosition> blocks = Lists.newCopyOnWriteArrayList();
     private final Map<EntityHuman, Vec3D> k = Maps.newHashMap();
     public boolean wasCanceled = false; // CraftBukkit - add field
 
diff -Naur src_origin/main/java/net/minecraft/server/IntCache.java src/main/java/net/minecraft/server/IntCache.java
--- src_origin/main/java/net/minecraft/server/IntCache.java	2016-02-26 15:27:10.750203593 +0800
+++ src/main/java/net/minecraft/server/IntCache.java	2016-03-06 05:06:51.725478558 +0800
@@ -10,7 +10,7 @@
     private static List<int[]> c = Lists.newArrayList();
     private static List<int[]> d = Lists.newArrayList();
     private static List<int[]> e = Lists.newArrayList();
-
+    
     public static synchronized int[] a(int i) {
         int[] aint;
 
diff -Naur src_origin/main/java/net/minecraft/server/ItemStack.java src/main/java/net/minecraft/server/ItemStack.java
--- src_origin/main/java/net/minecraft/server/ItemStack.java	2016-02-26 15:27:11.336203647 +0800
+++ src/main/java/net/minecraft/server/ItemStack.java	2016-03-06 05:06:52.794478658 +0800
@@ -8,6 +8,9 @@
 // CraftBukkit start
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 import org.bukkit.Location;
 import org.bukkit.TreeType;
@@ -125,7 +128,9 @@
             Location location = new Location(world.getWorld(), blockposition.getX(), blockposition.getY(), blockposition.getZ());
             TreeType treeType = BlockSapling.treeType;
             BlockSapling.treeType = null;
-            List<BlockState> blocks = (List<BlockState>) world.capturedBlockStates.clone();
+            //List<BlockState> blocks = (List<BlockState>) world.capturedBlockStates.clone();
+            Queue<BlockState> blocks = new ConcurrentLinkedQueue<BlockState>();
+            blocks.addAll((Queue<BlockState>) world.capturedBlockStates);
             world.capturedBlockStates.clear();
             StructureGrowEvent event = null;
             if (treeType != null) {
@@ -150,12 +155,19 @@
 
         if (flag) {
             org.bukkit.event.block.BlockPlaceEvent placeEvent = null;
-            List<BlockState> blocks = (List<BlockState>) world.capturedBlockStates.clone();
+            //List<BlockState> blocks = (List<BlockState>) world.capturedBlockStates.clone();
+            Queue<BlockState> blocks = new ConcurrentLinkedQueue<BlockState>();
+            blocks.addAll((Queue<BlockState>)world.capturedBlockStates);
+            BlockState first_block = null;
+            if (blocks.iterator().hasNext()){
+                first_block = blocks.iterator().next();
+            }
             world.capturedBlockStates.clear();
             if (blocks.size() > 1) {
                 placeEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callBlockMultiPlaceEvent(world, entityhuman, blocks, blockposition.getX(), blockposition.getY(), blockposition.getZ());
             } else if (blocks.size() == 1) {
-                placeEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPlaceEvent(world, entityhuman, blocks.get(0), blockposition.getX(), blockposition.getY(), blockposition.getZ());
+                //placeEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPlaceEvent(world, entityhuman, blocks.get(0), blockposition.getX(), blockposition.getY(), blockposition.getZ());
+                placeEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPlaceEvent(world, entityhuman, first_block, blockposition.getX(), blockposition.getY(), blockposition.getZ());
             }
 
             if (placeEvent != null && (placeEvent.isCancelled() || !placeEvent.canBuild())) {
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2016-02-26 15:27:11.493203662 +0800
+++ src/main/java/net/minecraft/server/MinecraftServer.java	2016-03-06 05:06:53.064478683 +0800
@@ -2,7 +2,6 @@
 
 import com.google.common.base.Charsets;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.ListenableFutureTask;
@@ -17,7 +16,6 @@
 import java.awt.GraphicsEnvironment;
 import java.awt.image.BufferedImage;
 import java.io.File;
-import java.io.IOException;
 import java.net.Proxy;
 import java.security.KeyPair;
 import java.text.SimpleDateFormat;
@@ -46,6 +44,9 @@
 
 import org.bukkit.craftbukkit.Main;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.bukkit.event.Event;
+import org.hose.ChunkGenPool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class MinecraftServer implements Runnable, ICommandListener, IAsyncTaskHandler, IMojangStatistics {
@@ -57,6 +58,7 @@
     private final MojangStatisticsGenerator n = new MojangStatisticsGenerator("server", this, az());
     public File universe;
     private final List<IUpdatePlayerListBox> p = Lists.newArrayList();
+    //private final List<IUpdatePlayerListBox> p = Lists.newCopyOnWriteArrayList();
     protected final ICommandHandler b;
     public final MethodProfiler methodProfiler = new MethodProfiler();
     private ServerConnection q; // Spigot
@@ -366,7 +368,10 @@
                     }
 
                     ++i;
-                    worldserver.chunkProviderServer.getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    //chunk loader
+                    //worldserver.chunkProviderServer.getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    SpigotWorldConfig.ChunkGenTask = new FutureTask(new ChunkGenPool(worldserver, blockposition, k, l));
+                    SpigotWorldConfig.chunkgenpool_executor.submit(SpigotWorldConfig.ChunkGenTask);
                 }
             }
         }
@@ -642,7 +647,7 @@
     protected void A() throws ExceptionWorldConflict { // CraftBukkit - added throws
         SpigotTimings.serverTickTimer.startTiming(); // Spigot
         long i = System.nanoTime();
-
+        
         ++this.ticks;
         if (this.T) {
             this.T = false;
@@ -710,10 +715,15 @@
 
         // Spigot start
         FutureTask<?> entry;
-        int count = this.j.size();
+        /*int count = this.j.size();
         while (count-- > 0 && (entry = this.j.poll()) != null) {
             SystemUtils.a(entry, MinecraftServer.LOGGER);
-         }
+        }*/
+        //int count = this.j.size();
+        Iterator it = this.j.iterator();
+        while (it.hasNext() && (entry = this.j.poll()) != null) {
+            SystemUtils.a(entry, MinecraftServer.LOGGER);
+        }
         // Spigot end
 
         this.methodProfiler.c("levels");
@@ -1023,7 +1033,8 @@
     }
 
     public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        //return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "HOSE"; // HOSE -> Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1105,7 +1116,8 @@
     }
 
     public String getName() {
-        return "Server";
+        //return "Server";
+        return org.bukkit.ChatColor.GREEN+"Server";
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
diff -Naur src_origin/main/java/net/minecraft/server/PacketPlayOutMapChunk.java src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
--- src_origin/main/java/net/minecraft/server/PacketPlayOutMapChunk.java	2016-02-26 15:27:12.026203712 +0800
+++ src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java	2016-03-06 05:06:53.969478768 +0800
@@ -4,6 +4,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.List;
 
 public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
 
@@ -55,7 +56,8 @@
     public static PacketPlayOutMapChunk.ChunkMap a(Chunk chunk, boolean flag, boolean flag1, int i) {
         ChunkSection[] achunksection = chunk.getSections();
         PacketPlayOutMapChunk.ChunkMap packetplayoutmapchunk_chunkmap = new PacketPlayOutMapChunk.ChunkMap();
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
 
         int j;
 
diff -Naur src_origin/main/java/net/minecraft/server/PlayerChunkMap.java src/main/java/net/minecraft/server/PlayerChunkMap.java
--- src_origin/main/java/net/minecraft/server/PlayerChunkMap.java	2016-02-26 15:27:12.591203765 +0800
+++ src/main/java/net/minecraft/server/PlayerChunkMap.java	2016-03-06 05:06:54.877478853 +0800
@@ -1,7 +1,6 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import org.apache.logging.log4j.LogManager;
@@ -19,7 +18,8 @@
 
     private static final Logger a = LogManager.getLogger();
     private final WorldServer world;
-    private final List<EntityPlayer> managedPlayers = Lists.newArrayList();
+    //private final List<EntityPlayer> managedPlayers = Lists.newArrayList();
+    private final List<EntityPlayer> managedPlayers = Lists.newCopyOnWriteArrayList();
     private final LongHashMap<PlayerChunkMap.PlayerChunk> d = new LongHashMap();
     private final Queue<PlayerChunkMap.PlayerChunk> e = new java.util.concurrent.ConcurrentLinkedQueue<PlayerChunkMap.PlayerChunk>(); // CraftBukkit ArrayList -> ConcurrentLinkedQueue
     private final Queue<PlayerChunkMap.PlayerChunk> f = new java.util.concurrent.ConcurrentLinkedQueue<PlayerChunkMap.PlayerChunk>(); // CraftBukkit ArrayList -> ConcurrentLinkedQueue
@@ -85,7 +85,8 @@
         return this.d.getEntry(k) != null;
     }
 
-    private PlayerChunkMap.PlayerChunk a(int i, int j, boolean flag) {
+    public PlayerChunkMap.PlayerChunk a(int i, int j, boolean flag) {
+    //private PlayerChunkMap.PlayerChunk a(int i, int j, boolean flag) {
         long k = (long) i + 2147483647L | (long) j + 2147483647L << 32;
         PlayerChunkMap.PlayerChunk playerchunkmap_playerchunk = (PlayerChunkMap.PlayerChunk) this.d.getEntry(k);
 
@@ -146,7 +147,8 @@
     }
 
     public void b(EntityPlayer entityplayer) {
-        ArrayList arraylist = Lists.newArrayList(entityplayer.chunkCoordIntPairQueue);
+        //ArrayList arraylist = Lists.newArrayList(entityplayer.chunkCoordIntPairQueue);
+        List arraylist = Lists.newCopyOnWriteArrayList(entityplayer.chunkCoordIntPairQueue);
         int i = 0;
         int j = this.g;
         int k = (int) entityplayer.locX >> 4;
@@ -178,7 +180,7 @@
         }
 
         i %= 4;
-
+        
         for (k1 = 0; k1 < j * 2; ++k1) {
             i1 += this.i[i][0];
             j1 += this.i[i][1];
@@ -256,9 +258,11 @@
                     this.a(pair.x, pair.z, true).a(entityplayer);
                 }
 
+                /*
                 if (j1 > 1 || j1 < -1 || k1 > 1 || k1 < -1) {
+                    //Collections.sort(entityplayer.chunkCoordIntPairQueue, new ChunkCoordComparator(entityplayer));
                     Collections.sort(entityplayer.chunkCoordIntPairQueue, new ChunkCoordComparator(entityplayer));
-                }
+                }*/
                 // CraftBukkit end
             }
         }
@@ -274,7 +278,8 @@
         i = MathHelper.clamp(i, 3, 32);
         if (i != this.g) {
             int j = i - this.g;
-            ArrayList arraylist = Lists.newArrayList(this.managedPlayers);
+            //ArrayList arraylist = Lists.newArrayList(this.managedPlayers);
+            List arraylist = Lists.newCopyOnWriteArrayList(this.managedPlayers);
             Iterator iterator = arraylist.iterator();
 
             while (iterator.hasNext()) {
@@ -313,10 +318,12 @@
         return i * 16 - 16;
     }
 
-    class PlayerChunk {
+    public class PlayerChunk {
 
-        private final List<EntityPlayer> b = Lists.newArrayList();
-        private final ChunkCoordIntPair location;
+        //private final List<EntityPlayer> b = Lists.newArrayList();
+        private final List<EntityPlayer> b = Lists.newCopyOnWriteArrayList();
+        //private final ChunkCoordIntPair location;
+        public final ChunkCoordIntPair location;
         private short[] dirtyBlocks = new short[64];
         private int dirtyCount;
         private int f;
diff -Naur src_origin/main/java/net/minecraft/server/PlayerConnection.java src/main/java/net/minecraft/server/PlayerConnection.java
--- src_origin/main/java/net/minecraft/server/PlayerConnection.java	2016-02-26 15:27:12.653203771 +0800
+++ src/main/java/net/minecraft/server/PlayerConnection.java	2016-03-06 05:06:54.944478859 +0800
@@ -3,7 +3,6 @@
 import com.google.common.collect.Lists;
 import com.google.common.primitives.Doubles;
 import com.google.common.primitives.Floats;
-import com.google.common.util.concurrent.Futures;
 import io.netty.buffer.Unpooled;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
@@ -23,6 +22,7 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.HashSet;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
@@ -80,12 +80,19 @@
     private static final AtomicIntegerFieldUpdater chatSpamField = AtomicIntegerFieldUpdater.newUpdater(PlayerConnection.class, "chatThrottle");
     // CraftBukkit end
     private int m;
-    private IntHashMap<Short> n = new IntHashMap();
+    //private IntHashMap<Short> n = new IntHashMap();
+    private ConcurrentHashMap<Integer, Short> n = new ConcurrentHashMap();
     private double o;
     private double p;
     private double q;
     private boolean checkMovement = true;
     private boolean processedDisconnect; // CraftBukkit - added
+    
+    //for spigot
+    private int g(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
 
     public PlayerConnection(MinecraftServer minecraftserver, NetworkManager networkmanager, EntityPlayer entityplayer) {
         this.minecraftServer = minecraftserver;
@@ -1700,7 +1707,8 @@
                     this.player.broadcastCarriedItem();
                     this.player.g = false;
                 } else {
-                    this.n.a(this.player.activeContainer.windowId, Short.valueOf(packetplayinwindowclick.d()));
+                    //this.n.a(this.player.activeContainer.windowId, Short.valueOf(packetplayinwindowclick.d()));
+                    this.n.put(this.g(this.player.activeContainer.windowId), Short.valueOf(packetplayinwindowclick.d()));
                     this.player.playerConnection.sendPacket(new PacketPlayOutTransaction(packetplayinwindowclick.a(), packetplayinwindowclick.d(), false));
                     this.player.activeContainer.a(this.player, false);
                     ArrayList arraylist1 = Lists.newArrayList();
@@ -1818,7 +1826,8 @@
     public void a(PacketPlayInTransaction packetplayintransaction) {
         if (this.player.dead) return; // CraftBukkit
         PlayerConnectionUtils.ensureMainThread(packetplayintransaction, this, this.player.u());
-        Short oshort = (Short) this.n.get(this.player.activeContainer.windowId);
+        //Short oshort = (Short) this.n.get(this.player.activeContainer.windowId);
+        Short oshort = (Short) this.n.get(this.g(this.player.activeContainer.windowId));
 
         if (oshort != null && packetplayintransaction.b() == oshort.shortValue() && this.player.activeContainer.windowId == packetplayintransaction.a() && !this.player.activeContainer.c(this.player) && !this.player.isSpectator()) {
             this.player.activeContainer.a(this.player, true);
diff -Naur src_origin/main/java/net/minecraft/server/PlayerList.java src/main/java/net/minecraft/server/PlayerList.java
--- src_origin/main/java/net/minecraft/server/PlayerList.java	2016-02-26 15:27:12.726203777 +0800
+++ src/main/java/net/minecraft/server/PlayerList.java	2016-03-06 05:06:55.089478873 +0800
@@ -48,7 +48,8 @@
     private static final Logger f = LogManager.getLogger();
     private static final SimpleDateFormat g = new SimpleDateFormat("yyyy-MM-dd \'at\' HH:mm:ss z");
     private final MinecraftServer server;
-    public final List<EntityPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
+    //public final List<EntityPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
+    public final List<EntityPlayer> players = Lists.newCopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
     private final Map<UUID, EntityPlayer> j = Maps.newHashMap();
     private final GameProfileBanList k;
     private final IpBanList l;
@@ -951,6 +952,7 @@
     public String b(boolean flag) {
         String s = "";
         ArrayList arraylist = Lists.newArrayList(this.players);
+        //List arraylist = Lists.newCopyOnWriteArrayList(this.players);
 
         for (int i = 0; i < arraylist.size(); ++i) {
             if (i > 0) {
@@ -1134,6 +1136,7 @@
 
     public List<EntityPlayer> b(String s) {
         ArrayList arraylist = Lists.newArrayList();
+        //List arraylist = Lists.newCopyOnWriteArrayList();
         Iterator iterator = this.players.iterator();
 
         while (iterator.hasNext()) {
diff -Naur src_origin/main/java/net/minecraft/server/PortalTravelAgent.java src/main/java/net/minecraft/server/PortalTravelAgent.java
--- src_origin/main/java/net/minecraft/server/PortalTravelAgent.java	2016-02-26 15:27:12.766203781 +0800
+++ src/main/java/net/minecraft/server/PortalTravelAgent.java	2016-03-06 05:06:55.133478877 +0800
@@ -1,9 +1,9 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Lists;
 import java.util.Iterator;
-import java.util.List;
+import java.util.Queue;
 import java.util.Random;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 // CraftBukkit start
 import org.bukkit.Location;
@@ -16,7 +16,8 @@
     private final WorldServer a;
     private final Random b;
     private final LongHashMap<PortalTravelAgent.ChunkCoordinatesPortal> c = new LongHashMap();
-    private final List<Long> d = Lists.newArrayList();
+    //private final List<Long> d = Lists.newArrayList();
+    private final Queue<Long> d = new ConcurrentLinkedQueue<Long>();
 
     public PortalTravelAgent(WorldServer worldserver) {
         this.a = worldserver;
diff -Naur src_origin/main/java/net/minecraft/server/ScoreboardServer.java src/main/java/net/minecraft/server/ScoreboardServer.java
--- src_origin/main/java/net/minecraft/server/ScoreboardServer.java	2016-02-26 15:27:13.079203810 +0800
+++ src/main/java/net/minecraft/server/ScoreboardServer.java	2016-03-06 05:06:55.650478925 +0800
@@ -7,11 +7,13 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
 
 public class ScoreboardServer extends Scoreboard {
 
     private final MinecraftServer a;
-    private final Set<ScoreboardObjective> b = Sets.newHashSet();
+    //private final Set<ScoreboardObjective> b = Sets.newHashSet();
+    private final Set<ScoreboardObjective> b = new CopyOnWriteArraySet<ScoreboardObjective>();
     private PersistentScoreboard c;
 
     public ScoreboardServer(MinecraftServer minecraftserver) {
diff -Naur src_origin/main/java/net/minecraft/server/ServerConnection.java src/main/java/net/minecraft/server/ServerConnection.java
--- src_origin/main/java/net/minecraft/server/ServerConnection.java	2016-02-26 15:27:13.131203815 +0800
+++ src/main/java/net/minecraft/server/ServerConnection.java	2016-03-06 05:06:55.734478933 +0800
@@ -23,7 +23,9 @@
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -61,6 +63,8 @@
     public volatile boolean d;
     private final List<ChannelFuture> g = Collections.synchronizedList(Lists.<ChannelFuture>newArrayList());
     private final List<NetworkManager> h = Collections.synchronizedList(Lists.<NetworkManager>newArrayList());
+    /*private final List<ChannelFuture> g = Lists.<ChannelFuture>newCopyOnWriteArrayList();
+    private final Queue<NetworkManager> h = new ConcurrentLinkedQueue<NetworkManager>();*/
 
     public ServerConnection(MinecraftServer minecraftserver) {
         this.f = minecraftserver;
diff -Naur src_origin/main/java/net/minecraft/server/ServerStatisticManager.java src/main/java/net/minecraft/server/ServerStatisticManager.java
--- src_origin/main/java/net/minecraft/server/ServerStatisticManager.java	2016-02-26 15:27:13.135203816 +0800
+++ src/main/java/net/minecraft/server/ServerStatisticManager.java	2016-03-06 05:06:55.782478938 +0800
@@ -15,6 +15,7 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.Map.Entry;
+import java.util.concurrent.CopyOnWriteArraySet;
 import org.apache.commons.io.FileUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -24,7 +25,8 @@
     private static final Logger b = LogManager.getLogger();
     private final MinecraftServer c;
     private final File d;
-    private final Set<Statistic> e = Sets.newHashSet();
+    //private final Set<Statistic> e = Sets.newHashSet();
+    private final Set<Statistic> e = new CopyOnWriteArraySet<Statistic>();
     private int f = -300;
     private boolean g = false;
 
diff -Naur src_origin/main/java/net/minecraft/server/SpawnerCreature.java src/main/java/net/minecraft/server/SpawnerCreature.java
--- src_origin/main/java/net/minecraft/server/SpawnerCreature.java	2016-02-26 15:27:13.289203830 +0800
+++ src/main/java/net/minecraft/server/SpawnerCreature.java	2016-03-06 05:06:55.992478957 +0800
@@ -1,21 +1,29 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Sets;
+import io.netty.util.internal.chmv8.ConcurrentHashMapV8;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
 import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.FutureTask;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.util.LongHash;
 import org.bukkit.craftbukkit.util.LongHashSet;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
+import org.hose.SpawnerCreature_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public final class SpawnerCreature {
 
     private static final int a = (int) Math.pow(17.0D, 2.0D);
-    private final LongHashSet b = new LongHashSet(); // CraftBukkit
+    //private final LongHashSet b = new LongHashSet(); // CraftBukkit
+    private final ConcurrentHashMapV8<Long, Long> b = new ConcurrentHashMapV8<Long, Long>(); // CraftBukkit
 
     public SpawnerCreature() {}
 
@@ -23,13 +31,15 @@
     private int getEntityCount(WorldServer server, Class oClass)
     {
         int i = 0;
-        Iterator<Long> it = this.b.iterator();
+        //Iterator<Long> it = this.b.iterator();
+        Iterator<Long> it = this.b.keySet().iterator();
         while ( it.hasNext() )
         {
             Long coord = it.next();
             int x = LongHash.msw( coord );
             int z = LongHash.lsw( coord );
-            if ( !server.chunkProviderServer.unloadQueue.contains( coord ) && server.isChunkLoaded( x, z, true ) )
+            //if ( !server.chunkProviderServer.unloadQueue.contains( coord ) && server.isChunkLoaded( x, z, true ) )
+            if ( !server.chunkProviderServer.unloadQueue.containsKey( coord ) && server.isChunkLoaded( x, z, true ) )
             {
                 i += server.getChunkAt( x, z ).entityCount.get( oClass );
             }
@@ -39,6 +49,21 @@
     // Spigot end
 
     public int a(WorldServer worldserver, boolean flag, boolean flag1, boolean flag2) {
+        //return a_hose(worldserver, flag, flag1, flag2);
+        SpigotWorldConfig.SpawnerCreatureTask = new FutureTask(new SpawnerCreature_Pool(this, worldserver, flag, flag1, flag2));
+        SpigotWorldConfig.spawncreaturepool_executor.submit(SpigotWorldConfig.SpawnerCreatureTask);
+        try {
+            return SpigotWorldConfig.SpawnerCreatureTask.get();
+        } catch (InterruptedException ex) {
+            Logger.getLogger(SpawnerCreature.class.getName()).log(Level.SEVERE, null, ex);
+        } catch (ExecutionException ex) {
+            Logger.getLogger(SpawnerCreature.class.getName()).log(Level.SEVERE, null, ex);
+        }
+        return 0;
+    }
+    
+    //callable
+    public int a_hose(WorldServer worldserver, boolean flag, boolean flag1, boolean flag2) {
         if (!flag && !flag1) {
             return 0;
         } else {
@@ -73,7 +98,8 @@
                             if (!this.b.contains(chunkCoords)) {
                                 ++i;
                                 if (!flag3 && worldserver.getWorldBorder().isInBounds(i1 + l, k + j)) {
-                                    this.b.add(chunkCoords);
+                                    //this.b.add(chunkCoords);
+                                    this.b.put(chunkCoords, chunkCoords);
                                 }
                             }
                             // CraftBukkit end
@@ -119,7 +145,8 @@
                     int l1 = limit * i / a; // CraftBukkit - use per-world limits
 
                     if ((mobcnt = getEntityCount(worldserver, enumcreaturetype.a())) <= limit * i / 256) {
-                        Iterator iterator1 = this.b.iterator();
+                        //Iterator iterator1 = this.b.iterator();
+                        Iterator iterator1 = this.b.keySet().iterator();
 
                         int moblimit = (limit * i / 256) - mobcnt + 1; // Spigot - up to 1 more than limit
                         label115:
diff -Naur src_origin/main/java/net/minecraft/server/TileEntityBeacon.java src/main/java/net/minecraft/server/TileEntityBeacon.java
--- src_origin/main/java/net/minecraft/server/TileEntityBeacon.java	2016-02-26 15:27:13.400203841 +0800
+++ src/main/java/net/minecraft/server/TileEntityBeacon.java	2016-03-06 05:06:56.219478979 +0800
@@ -14,6 +14,7 @@
 
     public static final MobEffectList[][] a = new MobEffectList[][] { { MobEffectList.FASTER_MOVEMENT, MobEffectList.FASTER_DIG}, { MobEffectList.RESISTANCE, MobEffectList.JUMP}, { MobEffectList.INCREASE_DAMAGE}, { MobEffectList.REGENERATION}};
     private final List<TileEntityBeacon.BeaconColorTracker> f = Lists.newArrayList();
+    //private final List<TileEntityBeacon.BeaconColorTracker> f = Lists.newCopyOnWriteArrayList();
     private boolean i;
     private int j = -1;
     private int k;
diff -Naur src_origin/main/java/net/minecraft/server/TileEntityPiston.java src/main/java/net/minecraft/server/TileEntityPiston.java
--- src_origin/main/java/net/minecraft/server/TileEntityPiston.java	2016-02-26 15:27:13.607203860 +0800
+++ src/main/java/net/minecraft/server/TileEntityPiston.java	2016-03-06 05:06:56.570479012 +0800
@@ -12,7 +12,8 @@
     private boolean h;
     private float i;
     private float j;
-    private List<Entity> k = Lists.newArrayList();
+    //private List<Entity> k = Lists.newArrayList();
+    private List<Entity> k = Lists.newCopyOnWriteArrayList();
 
     public TileEntityPiston() {}
 
diff -Naur src_origin/main/java/net/minecraft/server/UserCache.java src/main/java/net/minecraft/server/UserCache.java
--- src_origin/main/java/net/minecraft/server/UserCache.java	2016-02-26 15:27:13.676203866 +0800
+++ src/main/java/net/minecraft/server/UserCache.java	2016-03-06 05:06:56.703479024 +0800
@@ -155,6 +155,7 @@
 
     public String[] a() {
         ArrayList arraylist = Lists.newArrayList(this.c.keySet());
+        //List arraylist = Lists.newCopyOnWriteArrayList(this.c.keySet());
 
         return (String[]) arraylist.toArray(new String[arraylist.size()]);
     }
diff -Naur src_origin/main/java/net/minecraft/server/WorldBorder.java src/main/java/net/minecraft/server/WorldBorder.java
--- src_origin/main/java/net/minecraft/server/WorldBorder.java	2016-02-26 15:27:13.784203876 +0800
+++ src/main/java/net/minecraft/server/WorldBorder.java	2016-03-06 05:06:56.906479043 +0800
@@ -7,6 +7,7 @@
 public class WorldBorder {
 
     private final List<IWorldBorderListener> a = Lists.newArrayList();
+    //private final List<IWorldBorderListener> a = Lists.newCopyOnWriteArrayList();
     private double b = 0.0D;
     private double c = 0.0D;
     private double d = 6.0E7D;
@@ -186,6 +187,7 @@
 
     protected List<IWorldBorderListener> k() {
         return Lists.newArrayList(this.a);
+        //return Lists.newCopyOnWriteArrayList(this.a);
     }
 
     public void a(IWorldBorderListener iworldborderlistener) {
diff -Naur src_origin/main/java/net/minecraft/server/WorldGenLargeFeature.java src/main/java/net/minecraft/server/WorldGenLargeFeature.java
--- src_origin/main/java/net/minecraft/server/WorldGenLargeFeature.java	2016-02-26 15:27:13.882203886 +0800
+++ src/main/java/net/minecraft/server/WorldGenLargeFeature.java	2016-03-06 05:06:57.085479060 +0800
@@ -17,6 +17,7 @@
 
     public WorldGenLargeFeature() {
         this.f = Lists.newArrayList();
+        //this.f = Lists.newCopyOnWriteArrayList();
         this.g = 32;
         this.h = 8;
         this.f.add(new BiomeBase.BiomeMeta(EntityWitch.class, 1, 1, 1));
diff -Naur src_origin/main/java/net/minecraft/server/WorldGenVillagePieces.java src/main/java/net/minecraft/server/WorldGenVillagePieces.java
--- src_origin/main/java/net/minecraft/server/WorldGenVillagePieces.java	2016-02-26 15:27:14.039203900 +0800
+++ src/main/java/net/minecraft/server/WorldGenVillagePieces.java	2016-03-06 05:06:57.326479082 +0800
@@ -2,9 +2,13 @@
 
 import com.google.common.collect.Lists;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.Random;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 public class WorldGenVillagePieces {
 
@@ -25,8 +29,9 @@
     }
 
     public static List<WorldGenVillagePieces.WorldGenVillagePieceWeight> a(Random random, int i) {
-        ArrayList arraylist = Lists.newArrayList();
-
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Collections.synchronizedList(Lists.newArrayList());
+        
         arraylist.add(new WorldGenVillagePieces.WorldGenVillagePieceWeight(WorldGenVillagePieces.WorldGenVillageHouse.class, 4, MathHelper.nextInt(random, 2 + i, 4 + i * 2)));
         arraylist.add(new WorldGenVillagePieces.WorldGenVillagePieceWeight(WorldGenVillagePieces.WorldGenVillageTemple.class, 20, MathHelper.nextInt(random, 0 + i, 1 + i)));
         arraylist.add(new WorldGenVillagePieces.WorldGenVillagePieceWeight(WorldGenVillagePieces.WorldGenVillageLibrary.class, 20, MathHelper.nextInt(random, 0 + i, 2 + i)));
diff -Naur src_origin/main/java/net/minecraft/server/World.java src/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2016-02-26 15:27:13.782203876 +0800
+++ src/main/java/net/minecraft/server/World.java	2016-03-06 05:06:56.862479039 +0800
@@ -2,25 +2,26 @@
 
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
-import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.Callable;
 
 // CraftBukkit start
 import com.google.common.collect.Maps;
 import java.util.Map;
-
+import java.util.Queue;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.FutureTask;
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.craftbukkit.util.LongHashSet;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
 import org.bukkit.generator.ChunkGenerator;
 import org.bukkit.craftbukkit.CraftServer;
@@ -29,8 +30,11 @@
 import org.bukkit.event.block.BlockCanBuildEvent;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
-import org.bukkit.event.weather.WeatherChangeEvent;
-import org.bukkit.event.weather.ThunderChangeEvent;
+import org.hose.AddParticlePool;
+import org.hose.EntityTick_Pool;
+import org.hose.PhysicsTick_Pool;
+import org.hose.TileTick_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class World implements IBlockAccess {
@@ -38,39 +42,52 @@
     private int a = 63;
     protected boolean e;
     // Spigot start - guard entity list from removals
-    public final List<Entity> entityList = new java.util.ArrayList<Entity>()
+    //public final List<Entity> entityList = new java.util.ArrayList<Entity>()
+    public final List<Entity> entityList = new CopyOnWriteArrayList<Entity>();
+    //public final CopyOnWriteArrayList<Entity> entityList = new CopyOnWriteArrayList<Entity>()
+    /*
+    public final List<Entity> entityList = new CopyOnWriteArrayList<Entity>()
     {
         @Override
         public Entity remove(int index)
         {
-            guard();
+            //guard();
             return super.remove( index );
         }
 
         @Override
         public boolean remove(Object o)
         {
-            guard();
+            //guard();
             return super.remove( o );
         }
-
-        private void guard()
-        {
-            if ( guardEntityList )
-            {
-                throw new java.util.ConcurrentModificationException();
-            }
-        }
-    };
+        
+        
+        //private void guard()
+        //{
+        //    if ( guardEntityList )
+        //    {
+        //        throw new java.util.ConcurrentModificationException();
+        //    }
+        //}
+    };*/
     // Spigot end
-    protected final List<Entity> g = Lists.newArrayList();
+    /*protected final List<Entity> g = Lists.newArrayList();
     public final List<TileEntity> h = Lists.newArrayList();
     public final List<TileEntity> tileEntityList = Lists.newArrayList();
     private final List<TileEntity> b = Lists.newArrayList();
     private final List<TileEntity> c = Lists.newArrayList();
     public final List<EntityHuman> players = Lists.newArrayList();
-    public final List<Entity> k = Lists.newArrayList();
-    protected final IntHashMap<Entity> entitiesById = new IntHashMap();
+    public final List<Entity> k = Lists.newArrayList();*/
+    protected final List<Entity> g = Lists.newCopyOnWriteArrayList();
+    public final List<TileEntity> h = Lists.newCopyOnWriteArrayList();
+    public final List<TileEntity> tileEntityList = Lists.newCopyOnWriteArrayList();
+    private final Queue<TileEntity> b = new ConcurrentLinkedQueue<TileEntity>();
+    private final List<TileEntity> c = Lists.newCopyOnWriteArrayList();
+    public final List<EntityHuman> players = Lists.newCopyOnWriteArrayList();
+    public final List<Entity> k = Lists.newCopyOnWriteArrayList();
+    //protected final IntHashMap<Entity> entitiesById = new IntHashMap();
+    protected final ConcurrentHashMap<Integer, Entity> entitiesById = new ConcurrentHashMap();
     private long d = 16777215L;
     private int I;
     protected int m = (new Random()).nextInt();
@@ -82,8 +99,10 @@
     private int J;
     public final Random random = new Random();
     public WorldProvider worldProvider; // CraftBukkit - remove final
-    protected List<IWorldAccess> u = Lists.newArrayList();
-    protected IChunkProvider chunkProvider;
+    //protected List<IWorldAccess> u = Lists.newArrayList();
+    protected List<IWorldAccess> u = Lists.newCopyOnWriteArrayList();
+    //protected IChunkProvider chunkProvider;
+    public IChunkProvider chunkProvider;
     protected final IDataManager dataManager;
     public WorldData worldData; // CraftBukkit - public
     protected boolean isLoading;
@@ -110,7 +129,8 @@
 
     public boolean captureBlockStates = false;
     public boolean captureTreeGeneration = false;
-    public ArrayList<BlockState> capturedBlockStates= new ArrayList<BlockState>(){
+    //public ArrayList<BlockState> capturedBlockStates= new ArrayList<BlockState>(){
+    public Queue<BlockState> capturedBlockStates= new ConcurrentLinkedQueue<BlockState>(){
         @Override
         public boolean add( BlockState blockState ) {
             Iterator<BlockState> blockStateIterator = this.iterator();
@@ -141,6 +161,12 @@
     private org.spigotmc.TickLimiter tileLimiter;
     private int tileTickPosition;
 
+    //for spigot
+    private int g(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
+    
     public static long chunkToKey(int x, int z)
     {
         long k = ( ( ( (long) x ) & 0xFFFF0000L ) << 16 ) | ( ( ( (long) x ) & 0x0000FFFFL ) << 0 );
@@ -172,6 +198,7 @@
     }
 
     public Chunk getChunkIfLoaded(int x, int z) {
+        //System.out.println(((ChunkProviderServer) this.chunkProvider).chunks.size()+","+((ChunkProviderServer) this.chunkProvider).unloadQueue.size());
         return ((ChunkProviderServer) this.chunkProvider).getChunkIfLoaded(x, z);
     }
 
@@ -523,6 +550,13 @@
 
     }
 
+    /*
+    public void applyPhysics(BlockPosition blockposition, Block block) {
+        //applyPhysics_hose(blockposition, block);
+        SpigotWorldConfig.PhysicsTickTask = new FutureTask(new PhysicsTick_Pool(this, blockposition, block));
+        SpigotWorldConfig.physicstickpool_executor.submit(SpigotWorldConfig.PhysicsTickTask);
+    }*/
+    
     public void applyPhysics(BlockPosition blockposition, Block block) {
         this.d(blockposition.west(), block);
         this.d(blockposition.east(), block);
@@ -569,6 +603,7 @@
                 CraftWorld world = ((WorldServer) this).getWorld();
                 if (world != null) {
                     BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), CraftMagicNumbers.getId(block));
+                    event.setAsynchronous();
                     this.getServer().getPluginManager().callEvent(event);
 
                     if (event.isCancelled()) {
@@ -768,7 +803,7 @@
     public IBlockData getType(BlockPosition blockposition, boolean useCaptured) {
         // CraftBukkit start - tree generation
         if (captureTreeGeneration && useCaptured) {
-    // Spigot end
+        // Spigot end
             Iterator<BlockState> it = capturedBlockStates.iterator();
             while (it.hasNext()) {
                 BlockState previous = it.next();
@@ -967,10 +1002,13 @@
     }
 
     public void addParticle(EnumParticle enumparticle, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
-        this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        //this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        SpigotWorldConfig.AddParticleTask = new FutureTask(new AddParticlePool(this, enumparticle, d0, d1, d2, d3, d4, d5, aint));
+        SpigotWorldConfig.addparticlepool_executor.submit(SpigotWorldConfig.AddParticleTask);
     }
 
-    private void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
+    public void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
+    //private void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
         for (int j = 0; j < this.u.size(); ++j) {
             ((IWorldAccess) this.u.get(j)).a(i, flag, d0, d1, d2, d3, d4, d5, aint);
         }
@@ -1062,17 +1100,25 @@
     }
 
     protected void a(Entity entity) {
-        for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).a(entity);
+        Iterator it = this.u.iterator();
+        while (it.hasNext()){
+            ((IWorldAccess) it.next()).a(entity);
         }
+        /*for (int i = 0; i < this.u.size(); ++i) {
+            ((IWorldAccess) this.u.get(i)).a(entity);
+        }*/
 
         entity.valid = true; // CraftBukkit
     }
 
     protected void b(Entity entity) {
-        for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).b(entity);
+        Iterator it = this.u.iterator();
+        while (it.hasNext()){
+            ((IWorldAccess) it.next()).b(entity);
         }
+        /*for (int i = 0; i < this.u.size(); ++i) {
+            ((IWorldAccess) this.u.get(i)).b(entity);
+        }*/
 
         entity.valid = false; // CraftBukkit
     }
@@ -1120,13 +1166,13 @@
             this.everyoneSleeping();
         }
 
-        if (!guardEntityList) { // Spigot - It will get removed after the tick if we are ticking
+        //if (!guardEntityList) { // Spigot - It will get removed after the tick if we are ticking
         int i = entity.ae;
         int j = entity.ag;
 
         if (entity.ad && this.isChunkLoaded(i, j, true)) {
             this.getChunkAt(i, j).b(entity);
-        }
+        //}
 
         // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
         int index = this.entityList.indexOf(entity);
@@ -1146,7 +1192,8 @@
     }
 
     public List<AxisAlignedBB> getCubes(Entity entity, AxisAlignedBB axisalignedbb) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         int i = MathHelper.floor(axisalignedbb.a);
         int j = MathHelper.floor(axisalignedbb.d + 1.0D);
         int k = MathHelper.floor(axisalignedbb.b);
@@ -1253,7 +1300,8 @@
     }
 
     public List<AxisAlignedBB> a(AxisAlignedBB axisalignedbb) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         int i = MathHelper.floor(axisalignedbb.a);
         int j = MathHelper.floor(axisalignedbb.d + 1.0D);
         int k = MathHelper.floor(axisalignedbb.b);
@@ -1337,13 +1385,14 @@
     public void a(BlockPosition blockposition, Block block, int i, int j) {}
 
     public void b(BlockPosition blockposition, Block block, int i, int j) {}
-
+    
     public void tickEntities() {
         this.methodProfiler.a("entities");
         this.methodProfiler.a("global");
-
+        //System.out.println(this.players.size()+","+this.entitiesById.size());
         int i;
-        Entity entity;
+        //Entity entity;
+        Entity entity = null;
         CrashReport crashreport;
         CrashReportSystemDetails crashreportsystemdetails;
 
@@ -1396,10 +1445,11 @@
 
         this.g.clear();
         this.methodProfiler.c("regular");
-
+        //observe
+        //System.out.println(this.chunkTickList.size()+","+this.entitiesById.size());
         org.spigotmc.ActivationRange.activateEntities(this); // Spigot
         timings.entityTick.startTiming(); // Spigot
-        guardEntityList = true; // Spigot
+        //guardEntityList = true; // Spigot
         // CraftBukkit start - Use field for loop variable
         int entitiesThisCycle = 0;
         if (tickPosition < 0) tickPosition = 0;
@@ -1422,7 +1472,9 @@
             if (!entity.dead) {
                 try {
                     SpigotTimings.tickEntityTimer.startTiming(); // Spigot
-                    this.g(entity);
+                    //this.g(entity);
+                    SpigotWorldConfig.EntityTickTask = new FutureTask(new EntityTick_Pool(this,entity));
+                    SpigotWorldConfig.entitytick_pool_executor.submit(SpigotWorldConfig.EntityTickTask);
                     SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
                 } catch (Throwable throwable1) {
                     crashreport = CrashReport.a(throwable1, "Ticking entity");
@@ -1449,7 +1501,7 @@
 
             this.methodProfiler.b();
         }
-        guardEntityList = false; // Spigot
+        //guardEntityList = false; // Spigot
 
         timings.entityTick.stopTiming(); // Spigot
         this.methodProfiler.c("blockEntities");
@@ -1485,7 +1537,14 @@
                 if (this.isLoaded(blockposition) && this.N.a(blockposition)) {
                     try {
                         tileentity.tickTimer.startTiming(); // Spigot
-                        ((IUpdatePlayerListBox) tileentity).c();
+                        //tile tick
+                        //check object type
+                        if (tileentity instanceof TileEntityHopper) {
+                            SpigotWorldConfig.TileTickTask = new FutureTask(new TileTick_Pool(tileentity));
+                            SpigotWorldConfig.tiletickpool_executor.submit(SpigotWorldConfig.TileTickTask);
+                        } else {
+                            ((IUpdatePlayerListBox) tileentity).c();
+                        }
                     } catch (Throwable throwable2) {
                         CrashReport crashreport1 = CrashReport.a(throwable2, "Ticking block entity");
                         CrashReportSystemDetails crashreportsystemdetails1 = crashreport1.a("Block entity being ticked");
@@ -1524,8 +1583,9 @@
 
         this.methodProfiler.c("pendingBlockEntities");
         if (!this.b.isEmpty()) {
-            for (int l = 0; l < this.b.size(); ++l) {
-                TileEntity tileentity1 = (TileEntity) this.b.get(l);
+            Iterator it = this.b.iterator();
+            while (it.hasNext()){
+                TileEntity tileentity1 = (TileEntity) it.next();
 
                 if (!tileentity1.x()) {
                     /* CraftBukkit start - Order matters, moved down
@@ -1533,7 +1593,7 @@
                         this.a(tileentity1);
                     }
                     // CraftBukkit end */
-
+                    
                     if (this.isLoaded(tileentity1.getPosition())) {
                         this.getChunkAtWorldCoords(tileentity1.getPosition()).a(tileentity1.getPosition(), tileentity1);
                     }
@@ -1541,6 +1601,24 @@
                     this.notify(tileentity1.getPosition());
                 }
             }
+            /*
+            for (int l = 0; l < this.b.size(); ++l) {
+                TileEntity tileentity1 = (TileEntity) this.b.get(l);
+
+                if (!tileentity1.x()) {*/
+                    /* CraftBukkit start - Order matters, moved down
+                    if (!this.h.contains(tileentity1)) {
+                        this.a(tileentity1);
+                    }
+                    // CraftBukkit end */
+                    /*
+                    if (this.isLoaded(tileentity1.getPosition())) {
+                        this.getChunkAtWorldCoords(tileentity1.getPosition()).a(tileentity1.getPosition(), tileentity1);
+                    }
+
+                    this.notify(tileentity1.getPosition());
+                }
+            }*/
 
             this.b.clear();
         }
@@ -1929,13 +2007,26 @@
             TileEntity tileentity1;
 
             if (this.M) {
+                Iterator it = this.b.iterator();
+                while (it.hasNext()){
+                    tileentity1 = (TileEntity) it.next();
+                    try {
+                        if (!tileentity1.x() && tileentity1.getPosition().equals(blockposition)) {
+                            tileentity = tileentity1;
+                            break;
+                        }
+                    } catch(Exception ex){
+                        System.out.println(ex+" this.b error");
+                    }
+                }
+                /*
                 for (i = 0; i < this.b.size(); ++i) {
                     tileentity1 = (TileEntity) this.b.get(i);
                     if (!tileentity1.x() && tileentity1.getPosition().equals(blockposition)) {
                         tileentity = tileentity1;
                         break;
                     }
-                }
+                }*/
             }
 
             if (tileentity == null) {
@@ -1943,13 +2034,22 @@
             }
 
             if (tileentity == null) {
+                Iterator it = this.b.iterator();
+                while (it.hasNext()){
+                    tileentity1 = (TileEntity) it.next();
+                    if (!tileentity1.x() && tileentity1.getPosition().equals(blockposition)) {
+                        tileentity = tileentity1;
+                        break;
+                    }
+                }
+                /*
                 for (i = 0; i < this.b.size(); ++i) {
                     tileentity1 = (TileEntity) this.b.get(i);
                     if (!tileentity1.x() && tileentity1.getPosition().equals(blockposition)) {
                         tileentity = tileentity1;
                         break;
                     }
-                }
+                }*/
             }
 
             return tileentity;
@@ -2171,8 +2271,10 @@
 
             // Spigot start - Always update the chunk the player is on
             long key = chunkToKey( j, k );
-            int existingPlayers = Math.max( 0, chunkTickList.get( key ) ); // filter out -1
-            chunkTickList.put( key, (short) ( existingPlayers + 1 ) );
+            synchronized (this.chunkTickList) {
+                int existingPlayers = Math.max( 0, chunkTickList.get( key ) ); // filter out -1
+                chunkTickList.put( key, (short) ( existingPlayers + 1 ) );
+            }
 
             // Check and see if we update the chunks surrounding the player this tick
             for ( int chunk = 0; chunk < chunksPerPlayer; chunk++ )
@@ -2180,9 +2282,11 @@
                 int dx = ( random.nextBoolean() ? 1 : -1 ) * random.nextInt( randRange );
                 int dz = ( random.nextBoolean() ? 1 : -1 ) * random.nextInt( randRange );
                 long hash = chunkToKey( dx + j, dz + k );
-                if ( !chunkTickList.contains( hash ) && this.chunkProvider.isChunkLoaded(dx + j, dz + k ) )
-                {
-                    chunkTickList.put( hash, (short) -1 ); // no players
+                synchronized (this.chunkTickList) {
+                    if ( !chunkTickList.contains( hash ) && this.chunkProvider.isChunkLoaded(dx + j, dz + k ) )
+                    {
+                        chunkTickList.put( hash, (short) -1 ); // no players
+                    }
                 }
             }
         }
@@ -2504,7 +2608,8 @@
     }
 
     public List<Entity> a(Entity entity, AxisAlignedBB axisalignedbb, Predicate<? super Entity> predicate) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         int i = MathHelper.floor((axisalignedbb.a - 2.0D) / 16.0D);
         int j = MathHelper.floor((axisalignedbb.d + 2.0D) / 16.0D);
         int k = MathHelper.floor((axisalignedbb.c - 2.0D) / 16.0D);
@@ -2522,7 +2627,8 @@
     }
 
     public <T extends Entity> List<T> a(Class<? extends T> oclass, Predicate<? super T> predicate) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         Iterator iterator = this.entityList.iterator();
 
         while (iterator.hasNext()) {
@@ -2537,7 +2643,8 @@
     }
 
     public <T extends Entity> List<T> b(Class<? extends T> oclass, Predicate<? super T> predicate) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         Iterator iterator = this.players.iterator();
 
         while (iterator.hasNext()) {
@@ -2560,7 +2667,8 @@
         int j = MathHelper.floor((axisalignedbb.d + 2.0D) / 16.0D);
         int k = MathHelper.floor((axisalignedbb.c - 2.0D) / 16.0D);
         int l = MathHelper.floor((axisalignedbb.f + 2.0D) / 16.0D);
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
 
         for (int i1 = i; i1 <= j; ++i1) {
             for (int j1 = k; j1 <= l; ++j1) {
@@ -2595,7 +2703,8 @@
     }
 
     public Entity a(int i) {
-        return (Entity) this.entitiesById.get(i);
+        //return (Entity) this.entitiesById.get(i);
+        return (Entity) this.entitiesById.get(this.g(i));
     }
 
     public void b(BlockPosition blockposition, TileEntity tileentity) {
@@ -2618,14 +2727,14 @@
                     continue;
                 }
             }
-            
+
             if (oclass.isAssignableFrom(entity.getClass())) {
             // if ((!(entity instanceof EntityInsentient) || !((EntityInsentient) entity).isPersistent()) && oclass.isAssignableFrom(entity.getClass())) {
                 // CraftBukkit end
                 ++i;
             }
         }
-
+        
         return i;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/WorldMap.java src/main/java/net/minecraft/server/WorldMap.java
--- src_origin/main/java/net/minecraft/server/WorldMap.java	2016-02-26 15:27:14.088203905 +0800
+++ src/main/java/net/minecraft/server/WorldMap.java	2016-03-06 05:06:57.412479090 +0800
@@ -6,9 +6,11 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
 
 // CraftBukkit start
 import java.util.UUID;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
@@ -22,7 +24,8 @@
     public byte map;
     public byte scale;
     public byte[] colors = new byte[16384];
-    public List<WorldMap.WorldMapHumanTracker> g = Lists.newArrayList();
+    //public List<WorldMap.WorldMapHumanTracker> g = Lists.newArrayList();
+    public Queue<WorldMap.WorldMapHumanTracker> g = new ConcurrentLinkedQueue<WorldMap.WorldMapHumanTracker>();
     public Map<EntityHuman, WorldMap.WorldMapHumanTracker> i = Maps.newHashMap(); // Spigot
     public Map<UUID, MapIcon> decorations = Maps.newLinkedHashMap(); // Spigot
 
@@ -148,6 +151,20 @@
             this.decorations.remove(entityhuman.getUniqueID()); // Spigot
         }
 
+        Iterator it = this.g.iterator();
+        while (it.hasNext()){
+            WorldMap.WorldMapHumanTracker worldmap_worldmaphumantracker1 = (WorldMap.WorldMapHumanTracker) it.next();
+
+            if (!worldmap_worldmaphumantracker1.trackee.dead && (worldmap_worldmaphumantracker1.trackee.inventory.c(itemstack) || itemstack.y())) {
+                if (!itemstack.y() && worldmap_worldmaphumantracker1.trackee.dimension == this.map) {
+                    this.a(0, worldmap_worldmaphumantracker1.trackee.world, worldmap_worldmaphumantracker1.trackee.getUniqueID(), worldmap_worldmaphumantracker1.trackee.locX, worldmap_worldmaphumantracker1.trackee.locZ, (double) worldmap_worldmaphumantracker1.trackee.yaw); // Spigot
+                }
+            } else {
+                this.i.remove(worldmap_worldmaphumantracker1.trackee);
+                this.g.remove(worldmap_worldmaphumantracker1);
+            }
+        }
+        /*
         for (int i = 0; i < this.g.size(); ++i) {
             WorldMap.WorldMapHumanTracker worldmap_worldmaphumantracker1 = (WorldMap.WorldMapHumanTracker) this.g.get(i);
 
@@ -159,7 +176,7 @@
                 this.i.remove(worldmap_worldmaphumantracker1.trackee);
                 this.g.remove(worldmap_worldmaphumantracker1);
             }
-        }
+        }*/
 
         if (itemstack.y()) {
             EntityItemFrame entityitemframe = itemstack.z();
diff -Naur src_origin/main/java/net/minecraft/server/WorldServer.java src/main/java/net/minecraft/server/WorldServer.java
--- src_origin/main/java/net/minecraft/server/WorldServer.java	2016-02-26 15:27:14.144203910 +0800
+++ src/main/java/net/minecraft/server/WorldServer.java	2016-03-06 05:06:57.511479100 +0800
@@ -3,27 +3,26 @@
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
-import java.util.Set;
-import java.util.TreeSet;
 import java.util.UUID;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start
 import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.logging.Level;
 
 import org.bukkit.WeatherType;
 import org.bukkit.block.BlockState;
-import org.bukkit.craftbukkit.util.LongHash;
 import org.bukkit.craftbukkit.util.HashTreeSet;
+import org.bukkit.craftbukkit.util.LongHash;
 
 import org.bukkit.event.block.BlockFormEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
@@ -37,7 +36,8 @@
     private final PlayerChunkMap manager;
     // private final Set<NextTickListEntry> L = Sets.newHashSet(); // PAIL: Rename nextTickListHash
     private final HashTreeSet<NextTickListEntry> M = new HashTreeSet<NextTickListEntry>(); // CraftBukkit - HashTreeSet // PAIL: Rename nextTickList
-    private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
+    //private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
+    private final Map<UUID, Entity> entitiesByUUID = new ConcurrentHashMap<UUID, Entity>();
     public ChunkProviderServer chunkProviderServer;
     public boolean savingDisabled;
     private boolean O;
@@ -48,8 +48,9 @@
     private WorldServer.BlockActionDataList[] S = new WorldServer.BlockActionDataList[] { new WorldServer.BlockActionDataList(null), new WorldServer.BlockActionDataList(null)};
     private int T;
     private static final List<StructurePieceTreasure> U = Lists.newArrayList(new StructurePieceTreasure[] { new StructurePieceTreasure(Items.STICK, 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.PLANKS), 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG), 0, 1, 3, 10), new StructurePieceTreasure(Items.STONE_AXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_AXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.STONE_PICKAXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_PICKAXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.APPLE, 0, 2, 3, 5), new StructurePieceTreasure(Items.BREAD, 0, 2, 3, 3), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG2), 0, 1, 3, 10)});
-    private List<NextTickListEntry> V = Lists.newArrayList();
-
+    //private List<NextTickListEntry> V = Lists.newArrayList();
+    private Queue<NextTickListEntry> V = new ConcurrentLinkedQueue<NextTickListEntry>();
+    
     // CraftBukkit start
     public final int dimension;
 
@@ -370,18 +371,21 @@
         }
     }
 
+    //tick block
     protected void h() {
         super.h();
         if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
             // Spigot start
-           gnu.trove.iterator.TLongShortIterator iterator = this.chunkTickList.iterator();
+            synchronized (this.chunkTickList) {
+                gnu.trove.iterator.TLongShortIterator iterator = this.chunkTickList.iterator();
 
-            while (iterator.hasNext()) {
-                iterator.advance();
-                long chunkCoord = iterator.key();
+                while (iterator.hasNext()) {
+                    iterator.advance();
+                    long chunkCoord = iterator.key();
 
-                this.getChunkAt(World.keyToX( chunkCoord ), World.keyToZ( chunkCoord )).b(false);
-                // Spigot end
+                    this.getChunkAt(World.keyToX( chunkCoord ), World.keyToZ( chunkCoord )).b(false);
+                    // Spigot end
+                }
             }
 
         } else {
@@ -394,117 +398,122 @@
             //    int k = chunkcoordintpair1.x * 16;
             //    int l = chunkcoordintpair1.z * 16;
             // Spigot start
-            for (gnu.trove.iterator.TLongShortIterator iter = chunkTickList.iterator(); iter.hasNext(); )
-            {
-                iter.advance();
-                long chunkCoord = iter.key();
-                int chunkX = World.keyToX( chunkCoord );
-                int chunkZ = World.keyToZ( chunkCoord );
-                // If unloaded, or in procedd of being unloaded, drop it
-                if ( ( !this.chunkProvider.isChunkLoaded( chunkX, chunkZ ) ) || ( this.chunkProviderServer.unloadQueue.contains( chunkX, chunkZ ) ) )
+            synchronized (this.chunkTickList) {
+                for (gnu.trove.iterator.TLongShortIterator iter = chunkTickList.iterator(); iter.hasNext(); )
                 {
-                    iter.remove();
-                    continue;
-                }
-                // Spigot end
-                // ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) iterator.next();
-                int k = chunkX * 16;
-                int l = chunkZ * 16;
-
-                this.methodProfiler.a("getChunk");
-                Chunk chunk = this.getChunkAt(chunkX, chunkZ);
-                // CraftBukkit end
-
-                this.a(k, l, chunk);
-                this.methodProfiler.c("tickChunk");
-                chunk.b(false);
-                this.methodProfiler.c("thunder");
-                int i1;
-                BlockPosition blockposition;
-
-                if (this.random.nextInt(100000) == 0 && this.S() && this.R()) {
-                    this.m = this.m * 3 + 1013904223;
-                    i1 = this.m >> 2;
-                    blockposition = this.a(new BlockPosition(k + (i1 & 15), 0, l + (i1 >> 8 & 15)));
-                    if (this.isRainingAt(blockposition)) {
-                        this.strikeLightning(new EntityLightning(this, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ()));
+                    iter.advance();
+                    long chunkCoord = iter.key();
+                    int chunkX = World.keyToX( chunkCoord );
+                    int chunkZ = World.keyToZ( chunkCoord );
+                    long key = LongHash.toLong(chunkX, chunkZ);
+                    // If unloaded, or in procedd of being unloaded, drop it
+                    //if ( ( !this.chunkProvider.isChunkLoaded( chunkX, chunkZ ) ) || ( this.chunkProviderServer.unloadQueue.contains( chunkX, chunkZ ) ) )
+                    if ( ( !this.chunkProvider.isChunkLoaded( chunkX, chunkZ ) ) || ( this.chunkProviderServer.unloadQueue.containsKey(key) ) )
+                    {
+                        iter.remove();
+                        continue;
                     }
-                }
+                    // Spigot end
+                    // ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) iterator.next();
+                    int k = chunkX * 16;
+                    int l = chunkZ * 16;
 
-                this.methodProfiler.c("iceandsnow");
-                if (this.random.nextInt(16) == 0) {
-                    this.m = this.m * 3 + 1013904223;
-                    i1 = this.m >> 2;
-                    blockposition = this.q(new BlockPosition(k + (i1 & 15), 0, l + (i1 >> 8 & 15)));
-                    BlockPosition blockposition1 = blockposition.down();
-
-                    if (this.w(blockposition1)) {
-                        // CraftBukkit start
-                        BlockState blockState = this.getWorld().getBlockAt(blockposition1.getX(), blockposition1.getY(), blockposition1.getZ()).getState();
-                        blockState.setTypeId(Block.getId(Blocks.ICE));
-
-                        BlockFormEvent iceBlockForm = new BlockFormEvent(blockState.getBlock(), blockState);
-                        this.getServer().getPluginManager().callEvent(iceBlockForm);
-                        if (!iceBlockForm.isCancelled()) {
-                            blockState.update(true);
-                        }
-                        // CraftBukkit end
-                    }
+                    this.methodProfiler.a("getChunk");
+                    Chunk chunk = this.getChunkAt(chunkX, chunkZ);
+                    // CraftBukkit end
 
-                    if (this.S() && this.f(blockposition, true)) {
-                        // CraftBukkit start
-                        BlockState blockState = this.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()).getState();
-                        blockState.setTypeId(Block.getId(Blocks.SNOW_LAYER));
-
-                        BlockFormEvent snow = new BlockFormEvent(blockState.getBlock(), blockState);
-                        this.getServer().getPluginManager().callEvent(snow);
-                        if (!snow.isCancelled()) {
-                            blockState.update(true);
+                    this.a(k, l, chunk);
+                    this.methodProfiler.c("tickChunk");
+                    chunk.b(false);
+                    this.methodProfiler.c("thunder");
+                    int i1;
+                    BlockPosition blockposition;
+
+                    if (this.random.nextInt(100000) == 0 && this.S() && this.R()) {
+                        this.m = this.m * 3 + 1013904223;
+                        i1 = this.m >> 2;
+                        blockposition = this.a(new BlockPosition(k + (i1 & 15), 0, l + (i1 >> 8 & 15)));
+                        if (this.isRainingAt(blockposition)) {
+                            this.strikeLightning(new EntityLightning(this, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ()));
                         }
-                        // CraftBukkit end
                     }
 
-                    if (this.S() && this.getBiome(blockposition1).e()) {
-                        this.getType(blockposition1).getBlock().k(this, blockposition1);
-                    }
-                }
-
-                this.methodProfiler.c("tickBlocks");
-                i1 = this.getGameRules().c("randomTickSpeed");
-                if (i1 > 0) {
-                    ChunkSection[] achunksection = chunk.getSections();
-                    int j1 = achunksection.length;
-
-                    for (int k1 = 0; k1 < j1; ++k1) {
-                        ChunkSection chunksection = achunksection[k1];
+                    this.methodProfiler.c("iceandsnow");
+                    if (this.random.nextInt(16) == 0) {
+                        this.m = this.m * 3 + 1013904223;
+                        i1 = this.m >> 2;
+                        blockposition = this.q(new BlockPosition(k + (i1 & 15), 0, l + (i1 >> 8 & 15)));
+                        BlockPosition blockposition1 = blockposition.down();
+
+                        if (this.w(blockposition1)) {
+                            // CraftBukkit start
+                            BlockState blockState = this.getWorld().getBlockAt(blockposition1.getX(), blockposition1.getY(), blockposition1.getZ()).getState();
+                            blockState.setTypeId(Block.getId(Blocks.ICE));
+
+                            BlockFormEvent iceBlockForm = new BlockFormEvent(blockState.getBlock(), blockState);
+                            this.getServer().getPluginManager().callEvent(iceBlockForm);
+                            if (!iceBlockForm.isCancelled()) {
+                                blockState.update(true);
+                            }
+                            // CraftBukkit end
+                        }
 
-                        if (chunksection != null && chunksection.shouldTick()) {
-                            for (int l1 = 0; l1 < i1; ++l1) {
-                                this.m = this.m * 3 + 1013904223;
-                                int i2 = this.m >> 2;
-                                int j2 = i2 & 15;
-                                int k2 = i2 >> 8 & 15;
-                                int l2 = i2 >> 16 & 15;
+                        if (this.S() && this.f(blockposition, true)) {
+                            // CraftBukkit start
+                            BlockState blockState = this.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()).getState();
+                            blockState.setTypeId(Block.getId(Blocks.SNOW_LAYER));
+
+                            BlockFormEvent snow = new BlockFormEvent(blockState.getBlock(), blockState);
+                            this.getServer().getPluginManager().callEvent(snow);
+                            if (!snow.isCancelled()) {
+                                blockState.update(true);
+                            }
+                            // CraftBukkit end
+                        }
 
-                                ++j;
-                                IBlockData iblockdata = chunksection.getType(j2, l2, k2);
-                                Block block = iblockdata.getBlock();
+                        if (this.S() && this.getBiome(blockposition1).e()) {
+                            this.getType(blockposition1).getBlock().k(this, blockposition1);
+                        }
+                    }
 
-                                if (block.isTicking()) {
-                                    ++i;
-                                    block.a((World) this, new BlockPosition(j2 + k, l2 + chunksection.getYPosition(), k2 + l), iblockdata, this.random);
+                    this.methodProfiler.c("tickBlocks");
+                    i1 = this.getGameRules().c("randomTickSpeed");
+                    if (i1 > 0) {
+                        ChunkSection[] achunksection = chunk.getSections();
+                        int j1 = achunksection.length;
+
+                        for (int k1 = 0; k1 < j1; ++k1) {
+                            ChunkSection chunksection = achunksection[k1];
+
+                            if (chunksection != null && chunksection.shouldTick()) {
+                                for (int l1 = 0; l1 < i1; ++l1) {
+                                    this.m = this.m * 3 + 1013904223;
+                                    int i2 = this.m >> 2;
+                                    int j2 = i2 & 15;
+                                    int k2 = i2 >> 8 & 15;
+                                    int l2 = i2 >> 16 & 15;
+
+                                    ++j;
+                                    IBlockData iblockdata = chunksection.getType(j2, l2, k2);
+                                    Block block = iblockdata.getBlock();
+
+                                    if (block.isTicking()) {
+                                        ++i;
+                                        block.a((World) this, new BlockPosition(j2 + k, l2 + chunksection.getYPosition(), k2 + l), iblockdata, this.random);
+                                    }
                                 }
                             }
                         }
                     }
                 }
             }
-
         }
         // Spigot Start
         if ( spigotConfig.clearChunksOnTick )
-        {
-            chunkTickList.clear();
+        {   
+            synchronized (this.chunkTickList) {
+                chunkTickList.clear();
+            }
         }
         // Spigot End
     }
@@ -602,6 +611,7 @@
         this.emptyTime = 0;
     }
 
+    //tick pending
     public boolean a(boolean flag) {
         if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
             return false;
@@ -624,9 +634,9 @@
                 this.methodProfiler.a("cleaning");
 
                 NextTickListEntry nextticklistentry;
-
-                for (int j = 0; j < i; ++j) {
-                    nextticklistentry = (NextTickListEntry) this.M.first();
+                Iterator it = this.M.iterator();
+                while (it.hasNext()){
+                    nextticklistentry = (NextTickListEntry) it.next();
                     if (!flag && nextticklistentry.b > this.worldData.getTime()) {
                         break;
                     }
@@ -635,6 +645,23 @@
                     this.M.remove(nextticklistentry);
                     this.V.add(nextticklistentry);
                 }
+                /*
+                for (int j = 0; j < i; ++j) {
+                    try {
+                        nextticklistentry = (NextTickListEntry) this.M.first();
+                        if (!flag && nextticklistentry.b > this.worldData.getTime()) {
+                            break;
+                        }
+
+                        // CraftBukkit - use M, PAIL: Rename nextTickList
+                        this.M.remove(nextticklistentry);
+                        this.V.add(nextticklistentry);
+                    } catch (Exception ex){
+                        LogManager.getLogger().warn(this.M.size()+":"+ex);
+                        
+                        break;
+                    }
+                }*/
 
                 this.methodProfiler.b();
                 this.methodProfiler.a("ticking");
@@ -682,7 +709,8 @@
     }
 
     public List<NextTickListEntry> a(StructureBoundingBox structureboundingbox, boolean flag) {
-        ArrayList arraylist = null;
+        //ArrayList arraylist = null;
+        List arraylist = null;
 
         for (int i = 0; i < 2; ++i) {
             Iterator iterator;
@@ -704,7 +732,8 @@
                     }
 
                     if (arraylist == null) {
-                        arraylist = Lists.newArrayList();
+                        //arraylist = Lists.newArrayList();
+                        arraylist = Lists.newCopyOnWriteArrayList();
                     }
 
                     arraylist.add(nextticklistentry);
@@ -759,7 +788,8 @@
     }
 
     public List<TileEntity> getTileEntities(int i, int j, int k, int l, int i1, int j1) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
 
         // CraftBukkit start - Get tile entities from chunks instead of world
         for (int chunkX = (i >> 4); chunkX <= ((l - 1) >> 4); chunkX++) {
@@ -929,13 +959,16 @@
             // CraftBukkit - ArrayList -> Collection
             Collection arraylist = this.chunkProviderServer.a();
             Iterator iterator = arraylist.iterator();
+            try {
+                while (iterator.hasNext()) {
+                    Chunk chunk = (Chunk) iterator.next();
 
-            while (iterator.hasNext()) {
-                Chunk chunk = (Chunk) iterator.next();
-
-                if (chunk != null && !this.manager.a(chunk.locX, chunk.locZ)) {
-                    this.chunkProviderServer.queueUnload(chunk.locX, chunk.locZ);
+                    if (chunk != null && !this.manager.a(chunk.locX, chunk.locZ)) {
+                        this.chunkProviderServer.queueUnload(chunk.locX, chunk.locZ);
+                    }
                 }
+            } catch (Exception exception) {
+                LogManager.getLogger().error("Couldn\'t save chunk", exception);
             }
 
         }
@@ -966,15 +999,23 @@
         // CraftBukkit end
     }
 
+    //for spigot
+    private int g(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
+    
     protected void a(Entity entity) {
         super.a(entity);
-        this.entitiesById.a(entity.getId(), entity);
+        //this.entitiesById.a(entity.getId(), entity);
+        this.entitiesById.put(this.g(entity.getId()), entity);
         this.entitiesByUUID.put(entity.getUniqueID(), entity);
         Entity[] aentity = entity.aB();
 
         if (aentity != null) {
             for (int i = 0; i < aentity.length; ++i) {
-                this.entitiesById.a(aentity[i].getId(), aentity[i]);
+                //this.entitiesById.a(aentity[i].getId(), aentity[i]);
+                this.entitiesById.put(this.g(aentity[i].getId()), aentity[i]);
             }
         }
 
@@ -982,13 +1023,18 @@
 
     protected void b(Entity entity) {
         super.b(entity);
-        this.entitiesById.d(entity.getId());
+        //this.entitiesById.d(entity.getId());
+        //remove it
+        //this.entitiesById.get(this.g(entity.getId()));
+        this.entitiesById.remove(this.g(entity.getId()));
         this.entitiesByUUID.remove(entity.getUniqueID());
         Entity[] aentity = entity.aB();
 
         if (aentity != null) {
             for (int i = 0; i < aentity.length; ++i) {
-                this.entitiesById.d(aentity[i].getId());
+                //this.entitiesById.d(aentity[i].getId());
+                //this.entitiesById.get(this.g(aentity[i].getId()));
+                this.entitiesById.remove(this.g(aentity[i].getId()));
             }
         }
 
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
--- src_origin/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java	2016-02-26 15:27:16.164204099 +0800
+++ src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java	2016-03-06 05:07:00.001479333 +0800
@@ -10,10 +10,7 @@
 import org.bukkit.craftbukkit.util.LongHash;
 
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import net.minecraft.server.Entity;
-import net.minecraft.server.EntitySlice;
+import org.bukkit.event.Event;
 
 class ChunkIOProvider implements AsynchronousExecutor.CallBackProvider<QueuedChunk, Chunk, Runnable, RuntimeException> {
     private final AtomicInteger threadNumber = new AtomicInteger(1);
@@ -56,7 +53,10 @@
 
         Server server = queuedChunk.provider.world.getServer();
         if (server != null) {
-            server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, false));
+            Event ev = new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, false);
+            //server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, false));
+            ev.setAsynchronous();
+            server.getPluginManager().callEvent(ev);
         }
 
         // Update neighbor counts
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java src/main/java/org/bukkit/craftbukkit/CraftWorld.java
--- src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-02-26 15:27:14.770203969 +0800
+++ src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-03-06 05:06:58.409479184 +0800
@@ -194,8 +194,9 @@
             world.chunkProviderServer.saveChunk(chunk);
             world.chunkProviderServer.saveChunkNOP(chunk);
         }
-
-        world.chunkProviderServer.unloadQueue.remove(x, z);
+        long key = LongHash.toLong(x, z);
+        //world.chunkProviderServer.unloadQueue.remove(x, z);
+        world.chunkProviderServer.unloadQueue.remove(key);
         world.chunkProviderServer.chunks.remove(LongHash.toLong(x, z));
 
         return true;
@@ -203,8 +204,9 @@
 
     public boolean regenerateChunk(int x, int z) {
         unloadChunk(x, z, false, false);
-
-        world.chunkProviderServer.unloadQueue.remove(x, z);
+        long key = LongHash.toLong(x, z);
+        //world.chunkProviderServer.unloadQueue.remove(x, z);
+        world.chunkProviderServer.unloadQueue.remove(key);
 
         net.minecraft.server.Chunk chunk = null;
 
@@ -252,8 +254,9 @@
             // Use the default variant of loadChunk when generate == true.
             return world.chunkProviderServer.getChunkAt(x, z) != null;
         }
-
-        world.chunkProviderServer.unloadQueue.remove(x, z);
+        long key = LongHash.toLong(x, z);
+        //world.chunkProviderServer.unloadQueue.remove(x, z);
+        world.chunkProviderServer.unloadQueue.remove(key);
         net.minecraft.server.Chunk chunk = world.chunkProviderServer.chunks.get(LongHash.toLong(x, z));
 
         if (chunk == null) {
@@ -1371,6 +1374,27 @@
         }
 
         ChunkProviderServer cps = world.chunkProviderServer;
+        Iterator it = cps.chunks.values().iterator();
+        net.minecraft.server.Chunk chunk;
+        while (it.hasNext()){
+            //net.minecraft.server.Chunk chunk = (net.minecraft.server.Chunk) it.next();
+            chunk = (net.minecraft.server.Chunk) it.next();
+            long key = LongHash.toLong(chunk.locX, chunk.locZ);
+            // If in use, skip it
+            if (isChunkInUse(chunk.locX, chunk.locZ)) {
+                continue;
+            }
+
+            // Already unloading?
+            //if (cps.unloadQueue.contains(chunk.locX, chunk.locZ)) {
+            if (cps.unloadQueue.containsKey(key)) {
+                continue;
+            }
+
+            // Add unload request
+            cps.queueUnload(chunk.locX, chunk.locZ);
+        }
+        /*
         for (net.minecraft.server.Chunk chunk : cps.chunks.values()) {
             // If in use, skip it
             if (isChunkInUse(chunk.locX, chunk.locZ)) {
@@ -1384,7 +1408,7 @@
 
             // Add unload request
             cps.queueUnload(chunk.locX, chunk.locZ);
-        }
+        }*/
     }
     // Spigot start
     private final Spigot spigot = new Spigot()
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
--- src_origin/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java	2016-02-26 15:27:19.207204384 +0800
+++ src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java	2016-03-06 05:07:02.646479580 +0800
@@ -8,6 +8,8 @@
 
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
+import java.util.Iterator;
+import java.util.Queue;
 
 import net.minecraft.server.*;
 
@@ -91,7 +93,8 @@
     /**
      * Block place methods
      */
-    public static BlockMultiPlaceEvent callBlockMultiPlaceEvent(World world, EntityHuman who, List<BlockState> blockStates, int clickedX, int clickedY, int clickedZ) {
+    //public static BlockMultiPlaceEvent callBlockMultiPlaceEvent(World world, EntityHuman who, List<BlockState> blockStates, int clickedX, int clickedY, int clickedZ) {
+    public static BlockMultiPlaceEvent callBlockMultiPlaceEvent(World world, EntityHuman who, Queue<BlockState> blockStates, int clickedX, int clickedY, int clickedZ) {
         CraftWorld craftWorld = world.getWorld();
         CraftServer craftServer = world.getServer();
         Player player = (who == null) ? null : (Player) who.getBukkitEntity();
@@ -99,14 +102,30 @@
         Block blockClicked = craftWorld.getBlockAt(clickedX, clickedY, clickedZ);
 
         boolean canBuild = true;
+        Iterator it = blockStates.iterator();
+        while (it.hasNext()){
+            BlockState bs = (BlockState) it.next();
+            if (!canBuild(craftWorld, player, bs.getX(), bs.getZ())) {
+                canBuild = false;
+                break;
+            }
+        }
+        /*
         for (int i = 0; i < blockStates.size(); i++) {
             if (!canBuild(craftWorld, player, blockStates.get(i).getX(), blockStates.get(i).getZ())) {
                 canBuild = false;
                 break;
             }
-        }
+        }*/
 
-        BlockMultiPlaceEvent event = new BlockMultiPlaceEvent(blockStates, blockClicked, player.getItemInHand(), player, canBuild);
+        //BlockMultiPlaceEvent event = new BlockMultiPlaceEvent(blockStates, blockClicked, player.getItemInHand(), player, canBuild);
+        BlockState first_stat = null;
+        if (blockStates.iterator().hasNext()){
+            first_stat = blockStates.iterator().next();
+        }
+        
+        BlockMultiPlaceEvent event = new BlockMultiPlaceEvent(blockStates, first_stat, first_stat.getBlock(), blockClicked, player.getItemInHand(), player, canBuild);
+        
         craftServer.getPluginManager().callEvent(event);
 
         return event;
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
--- src_origin/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java	2016-02-26 15:27:20.478204503 +0800
+++ src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java	2016-03-06 05:07:03.781479686 +0800
@@ -42,6 +42,7 @@
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import net.minecraft.server.NBTCompressedStreamTools;
@@ -226,7 +227,8 @@
     private int repairCost;
     private int hideFlag;
 
-    private static final Set<String> HANDLED_TAGS = Sets.newHashSet();
+    //private static final Set<String> HANDLED_TAGS = Sets.newHashSet();
+    private static final Set<String> HANDLED_TAGS = new CopyOnWriteArraySet<String>();
 
     private final Map<String, NBTBase> unhandledTags = new HashMap<String, NBTBase>();
 
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-02-26 15:27:22.350204678 +0800
+++ src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-03-06 05:07:05.570479854 +0800
@@ -1,15 +1,17 @@
 package org.bukkit.craftbukkit.util;
 
+import com.google.common.collect.Sets;
 import java.util.Collection;
-import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
-import java.util.TreeSet;
+import java.util.concurrent.ConcurrentSkipListSet;
 
 public class HashTreeSet<V> implements Set<V> {
 
-    private HashSet<V> hash = new HashSet<V>();
-    private TreeSet<V> tree = new TreeSet<V>();
+    //private HashSet<V> hash = new HashSet<V>();
+    private Set<V> hash = Sets.newConcurrentHashSet();
+    //private TreeSet<V> tree = new TreeSet<V>();
+    private ConcurrentSkipListSet<V> tree = new ConcurrentSkipListSet<V>();
 
     public HashTreeSet() {
 
@@ -112,6 +114,6 @@
 
     public V first() {
         return tree.first();
-    }
+   }
 
 }
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java src/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java	2016-02-26 15:27:22.480204690 +0800
+++ src/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java	2016-03-06 05:07:05.663479862 +0800
@@ -14,6 +14,7 @@
 import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.Set;
+import java.util.concurrent.ConcurrentMap;
 
 @SuppressWarnings("unchecked")
 public class LongObjectHashMap<V> implements Cloneable, Serializable {
@@ -31,7 +32,7 @@
         initialize();
     }
 
-    public LongObjectHashMap(Map<? extends Long, ? extends V> map) {
+    public LongObjectHashMap(ConcurrentMap<? extends Long, ? extends V> map) {
         this();
         putAll(map);
     }
@@ -127,7 +128,7 @@
         if (inner == null) {
             return null;
         }
-
+        
         for (int i = 0; i < inner.length; i++) {
             // hit the end of the chain, didn't find this entry
             if (inner[i] == EMPTY_KEY) {
@@ -157,10 +158,16 @@
         return null;
     }
 
-    public void putAll(Map<? extends Long, ? extends V> map) {
-        for (Map.Entry entry : map.entrySet()) {
+    //public void putAll(Map<? extends Long, ? extends V> map) {
+    public void putAll(ConcurrentMap<? extends Long, ? extends V> map) {
+        Iterator it = map.entrySet().iterator();
+        while (it.hasNext()){
+            ConcurrentMap.Entry entry = (ConcurrentMap.Entry) it.next();
             put((Long) entry.getKey(), (V) entry.getValue());
         }
+        /*for (ConcurrentMap.Entry entry : map.entrySet()) {
+            put((Long) entry.getKey(), (V) entry.getValue());
+        }*/
     }
 
     public void clear() {
@@ -191,8 +198,8 @@
      * @deprecated
      */
     @Deprecated
-    public Set<Map.Entry<Long, V>> entrySet() {
-        HashSet<Map.Entry<Long, V>> set = new HashSet<Map.Entry<Long, V>>();
+    public Set<ConcurrentMap.Entry<Long, V>> entrySet() {
+        HashSet<ConcurrentMap.Entry<Long, V>> set = new HashSet<Map.Entry<Long, V>>();
         for (long key : keySet()) {
             set.add(new Entry(key, get(key)));
         }
@@ -228,6 +235,8 @@
         key *= 0xc4ceb9fe1a85ec53L;
         key ^= key >>> 33;
         return key;
+        //return (key ^ (key >>> 16)) & 0x7fffffff;
+        
     }
 
     private void writeObject(ObjectOutputStream outputStream) throws IOException {
diff -Naur src_origin/main/java/org/hose/AddParticlePool.java src/main/java/org/hose/AddParticlePool.java
--- src_origin/main/java/org/hose/AddParticlePool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/AddParticlePool.java	2016-03-06 05:06:42.189477666 +0800
@@ -0,0 +1,41 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.EnumParticle;
+import net.minecraft.server.World;
+/**
+ *
+ * @author softpak
+ */
+public class AddParticlePool implements Callable{
+    private World w;
+    private EnumParticle ep;
+    private int[] aint;
+    private double d0, d1, d2, d3, d4, d5;
+    
+    public AddParticlePool(World w, EnumParticle ep, double d0, double d1, double d2, double d3, double d4, double d5, int... aint){
+        this.w = w;
+        this.ep = ep;
+        this.aint = aint;
+        this.d0 = d0;
+        this.d1 = d1;
+        this.d2 = d2;
+        this.d3 = d3;
+        this.d4 = d4;
+        this.d5 = d5;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+        //this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        w.a(ep.c(), ep.e(), d0, d1, d2, d3, d4, d5, aint);
+        return null;
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/ChunkGenPool.java src/main/java/org/hose/ChunkGenPool.java
--- src_origin/main/java/org/hose/ChunkGenPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChunkGenPool.java	2016-03-06 05:06:42.228477670 +0800
@@ -0,0 +1,38 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.WorldServer;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkGenPool  implements Callable<Chunk>{
+    WorldServer worldserver;
+    BlockPosition blockposition;
+    
+    int k, l;
+    
+    public ChunkGenPool(WorldServer worldserver, BlockPosition blockposition, int k, int l) {
+        this.worldserver = worldserver;
+        this.blockposition = blockposition;
+        this.k = k;
+        this.l = l;
+    }
+
+    @Override
+    public Chunk call() throws Exception {
+        //worldserver.chunkProviderServer.getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+        return worldserver.chunkProviderServer.getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/EntityTick_Pool.java src/main/java/org/hose/EntityTick_Pool.java
--- src_origin/main/java/org/hose/EntityTick_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/EntityTick_Pool.java	2016-03-06 05:06:42.269477673 +0800
@@ -0,0 +1,56 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Entity;
+import net.minecraft.server.World;
+
+/**
+ *
+ * @author softpak
+ */
+public class EntityTick_Pool  implements Callable{
+    /*
+    private Entity e;
+    private World w;
+    private int start, end;
+
+    public t_Pool(World w, Entity e, int start, int end) {
+        this.e = e;
+        this.w = w;
+        this.start = start;
+        this.end = end;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        //hoseentitytick(entity);
+        w.hoseentitytick(e,start,end);
+        //el.m();
+        return null;
+    }*/
+    
+    
+    private Entity e;
+    private World w;
+
+    public EntityTick_Pool(World w, Entity e) {
+        this.e = e;
+        this.w = w;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        //hoseentitytick(entity);
+        this.w.g(e);
+        //el.m();
+        return null;
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/GetChunkATPool.java src/main/java/org/hose/GetChunkATPool.java
--- src_origin/main/java/org/hose/GetChunkATPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/GetChunkATPool.java	2016-03-06 05:06:42.308477677 +0800
@@ -0,0 +1,35 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.ChunkProviderGenerate;
+import net.minecraft.server.IChunkProvider;
+/**
+ *
+ * @author softpak
+ */
+public class GetChunkATPool implements Callable{
+    ChunkProviderGenerate cpg;
+    IChunkProvider ichunkprovider;
+    int i, j;
+    
+    public GetChunkATPool(ChunkProviderGenerate cpg, IChunkProvider ichunkprovider, int i, int j) {
+        this.cpg = cpg;
+        this.ichunkprovider = ichunkprovider;
+        this.i = i;
+        this.j = j;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        cpg.getChunkAt_hose(ichunkprovider, i, j);
+        return null;
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/GetCreateChunkPool.java src/main/java/org/hose/GetCreateChunkPool.java
--- src_origin/main/java/org/hose/GetCreateChunkPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/GetCreateChunkPool.java	2016-03-06 05:06:42.348477681 +0800
@@ -0,0 +1,32 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkProviderGenerate;
+/**
+ *
+ * @author softpak
+ */
+public class GetCreateChunkPool implements Callable<Chunk>{
+    ChunkProviderGenerate cpg;
+    int i, j;
+    
+    public GetCreateChunkPool(ChunkProviderGenerate cpg, int i, int j) {
+        this.cpg = cpg;
+        this.i = i;
+        this.j = j;
+    }
+
+    @Override
+    public Chunk call() throws Exception {
+        return cpg.getOrCreateChunk_hose(i, j);
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/PhysicsTick_Pool.java src/main/java/org/hose/PhysicsTick_Pool.java
--- src_origin/main/java/org/hose/PhysicsTick_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/PhysicsTick_Pool.java	2016-03-06 05:06:42.393477685 +0800
@@ -0,0 +1,37 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Block;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Entity;
+import net.minecraft.server.World;
+
+/**
+ *
+ * @author softpak
+ */
+public class PhysicsTick_Pool  implements Callable{
+    private World w;
+    BlockPosition blockposition;
+    Block block;
+
+    public PhysicsTick_Pool(World w, BlockPosition blockposition, Block block) {
+        this.w = w;
+        this.blockposition = blockposition;
+        this.block = block;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        //this.w.applyPhysics_hose(blockposition, block);
+        return null;
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/SpawnerCreature_Pool.java src/main/java/org/hose/SpawnerCreature_Pool.java
--- src_origin/main/java/org/hose/SpawnerCreature_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/SpawnerCreature_Pool.java	2016-03-06 05:06:42.433477689 +0800
@@ -0,0 +1,37 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.IUpdatePlayerListBox;
+import net.minecraft.server.SpawnerCreature;
+import net.minecraft.server.WorldServer;
+
+/**
+ *
+ * @author softpak
+ */
+public class SpawnerCreature_Pool  implements Callable<Integer>{
+    SpawnerCreature sc;
+    WorldServer worldserver;
+    boolean flag, flag1, flag2;
+
+    public SpawnerCreature_Pool(SpawnerCreature sc, WorldServer worldserver, boolean flag, boolean flag1, boolean flag2) {
+        this.sc = sc;
+        this.worldserver = worldserver;
+        this.flag = flag;
+        this.flag1 = flag1;
+        this.flag2 = flag2;
+    }
+
+    @Override
+    public Integer call() throws Exception {
+        return sc.a_hose(worldserver, flag, flag1, flag2);
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/TileTick_Pool.java src/main/java/org/hose/TileTick_Pool.java
--- src_origin/main/java/org/hose/TileTick_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/TileTick_Pool.java	2016-03-06 05:06:42.477477693 +0800
@@ -0,0 +1,32 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.IUpdatePlayerListBox;
+import net.minecraft.server.TileEntity;
+
+/**
+ *
+ * @author softpak
+ */
+public class TileTick_Pool  implements Callable{
+    private TileEntity tileentity;
+
+    public TileTick_Pool(TileEntity tileentity) {
+        this.tileentity = tileentity;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        //((IUpdatePlayerListBox) tileentity).c();
+        ((IUpdatePlayerListBox) this.tileentity).c();
+        return null;
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/spigotmc/ActivationRange.java src/main/java/org/spigotmc/ActivationRange.java
--- src_origin/main/java/org/spigotmc/ActivationRange.java	2016-02-26 15:27:05.386203091 +0800
+++ src/main/java/org/spigotmc/ActivationRange.java	2016-03-06 05:06:42.655477710 +0800
@@ -1,8 +1,7 @@
 package org.spigotmc;
 
-import java.util.ArrayList;
 import java.util.List;
-import java.util.Set;
+import java.util.Queue;
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.Chunk;
 import net.minecraft.server.Entity;
@@ -21,7 +20,6 @@
 import net.minecraft.server.EntityMonster;
 import net.minecraft.server.EntityProjectile;
 import net.minecraft.server.EntitySheep;
-import net.minecraft.server.EntitySlice;
 import net.minecraft.server.EntitySlime;
 import net.minecraft.server.EntityTNTPrimed;
 import net.minecraft.server.EntityVillager;
@@ -31,7 +29,6 @@
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.World;
 import org.bukkit.craftbukkit.SpigotTimings;
-import org.bukkit.entity.Creeper;
 
 public class ActivationRange
 {
@@ -143,7 +140,8 @@
      */
     private static void activateChunkEntities(Chunk chunk)
     {
-        for ( List<Entity> slice : chunk.entitySlices )
+        //for ( List<Entity> slice : chunk.entitySlices )
+        for ( Queue<Entity> slice : chunk.entitySlices )
         {
             for ( Entity entity : slice )
             {
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2016-02-26 15:27:05.429203095 +0800
+++ src/main/java/org/spigotmc/AsyncCatcher.java	2016-03-06 05:06:42.744477718 +0800
@@ -5,7 +5,7 @@
 public class AsyncCatcher
 {
 
-    public static boolean enabled = true;
+    public static boolean enabled = false;
 
     public static void catchOp(String reason)
     {
diff -Naur src_origin/main/java/org/spigotmc/SpigotWorldConfig.java src/main/java/org/spigotmc/SpigotWorldConfig.java
--- src_origin/main/java/org/spigotmc/SpigotWorldConfig.java	2016-02-26 15:27:05.636203114 +0800
+++ src/main/java/org/spigotmc/SpigotWorldConfig.java	2016-03-06 05:06:43.088477750 +0800
@@ -1,13 +1,82 @@
 package org.spigotmc;
 
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import java.util.Arrays;
 import java.util.List;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import net.minecraft.server.Chunk;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
 public class SpigotWorldConfig
 {
+    static public final int cpu_core = Runtime.getRuntime().availableProcessors();
+    
+    static public FutureTask TickTask;
+    static public FutureTask AddParticleTask;
+    static public FutureTask EntityTickTask;
+    static public FutureTask<Chunk> ChunkGenTask;
+    static public FutureTask GetChunkATTask;
+    static public FutureTask<Chunk> GetCreateChunkTask;
+    static public FutureTask PhysicsTickTask;
+    static public FutureTask TileTickTask;
+    static public FutureTask<Integer> SpawnerCreatureTask;
+    
+    static final ThreadFactory tfscp = new ThreadFactoryBuilder().setNameFormat("SpawnerCreature_Pool-%d").build();
+    static public final ExecutorService spawncreaturepool_executor = Executors.newFixedThreadPool(cpu_core, tfscp);
+    
+    static final ThreadFactory tfttp = new ThreadFactoryBuilder().setNameFormat("TileTick_Pool-%d").build();
+    static public final ExecutorService tiletickpool_executor = Executors.newFixedThreadPool(cpu_core*10, tfttp);
+    
+    static final ThreadFactory tfptp = new ThreadFactoryBuilder().setNameFormat("PhysicsTick_Pool-%d").build();
+    static public final ExecutorService physicstickpool_executor = Executors.newFixedThreadPool(cpu_core, tfptp);
+            
+    static final ThreadFactory tfgccp = new ThreadFactoryBuilder().setNameFormat("GetCreateChunkPool-%d").build();
+    static public final ExecutorService getcreatechunkatpool_executor = Executors.newFixedThreadPool(cpu_core*10, tfgccp);
+            
+    static final ThreadFactory tfgcap = new ThreadFactoryBuilder().setNameFormat("GetChunkATPool-%d").build();
+    static public final ExecutorService getchunkatpool_executor = Executors.newFixedThreadPool(cpu_core*10, tfgcap);
+    
+    static final ThreadFactory tfcgp = new ThreadFactoryBuilder().setNameFormat("ChunkGenPool-%d").build();
+    static public final ExecutorService chunkgenpool_executor = Executors.newFixedThreadPool(cpu_core*10, tfcgp);
+    
+    static final ThreadFactory tfapp = new ThreadFactoryBuilder().setNameFormat("AddParticlePool-%d").build();
+    static public final ExecutorService addparticlepool_executor = Executors.newFixedThreadPool(cpu_core, tfapp);
+    
+     static final ThreadFactory tftp = new ThreadFactoryBuilder().setNameFormat("Tick_Pool-%d").build();
+    static public ExecutorService tickpool_executor;
+    
+    static final ThreadFactory tfetp = new ThreadFactoryBuilder().setNameFormat("EntityTick_Pool-%d").build();
+    static public ExecutorService entitytick_pool_executor;
 
+    public static int worldtickentitypool_core_multiple;
+    
+    public static int getthreadnumber(){
+        return cpu_core*worldtickentitypool_core_multiple;
+    }
+    
+    /*static public BlockingQueue queue = new LinkedBlockingQueue();
+    static public ThreadPoolExecutor executor;*/
+    
+    
+    private void wetp_core_multiple()
+    {
+        worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 1);
+        tickpool_executor = Executors.newFixedThreadPool(getthreadnumber(), tftp);
+        entitytick_pool_executor = Executors.newFixedThreadPool(getthreadnumber(), tfetp);
+        //executor = new ThreadPoolExecutor(getthreadnumber(), getthreadnumber(), 1, TimeUnit.DAYS, queue);
+        log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
+    }
+    
+    
+    
     private final String worldName;
     private final YamlConfiguration config;
     private boolean verbose;
