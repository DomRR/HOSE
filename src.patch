diff -Naur src_origin/main/java/net/minecraft/server/BlockDiodeAbstract.java src/main/java/net/minecraft/server/BlockDiodeAbstract.java
--- src_origin/main/java/net/minecraft/server/BlockDiodeAbstract.java	2016-08-25 22:39:50.517601851 +0800
+++ src/main/java/net/minecraft/server/BlockDiodeAbstract.java	2016-08-26 03:24:12.923198324 +0800
@@ -1,231 +1,231 @@
-package net.minecraft.server;
-
-import java.util.Random;
-
-import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
-
-public abstract class BlockDiodeAbstract extends BlockFacingHorizontal {
-
-    protected static final AxisAlignedBB c = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.125D, 1.0D);
-    protected final boolean d;
-
-    protected BlockDiodeAbstract(boolean flag) {
-        super(Material.ORIENTABLE);
-        this.d = flag;
-    }
-
-    public AxisAlignedBB a(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
-        return BlockDiodeAbstract.c;
-    }
-
-    public boolean c(IBlockData iblockdata) {
-        return false;
-    }
-
-    public boolean canPlace(World world, BlockPosition blockposition) {
-        return world.getType(blockposition.down()).q() ? super.canPlace(world, blockposition) : false;
-    }
-
-    public boolean b(World world, BlockPosition blockposition) {
-        return world.getType(blockposition.down()).q();
-    }
-
-    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, Random random) {}
-
-    public void b(World world, BlockPosition blockposition, IBlockData iblockdata, Random random) {
-        if (!this.b((IBlockAccess) world, blockposition, iblockdata)) {
-            boolean flag = this.e(world, blockposition, iblockdata);
-
-            if (this.d && !flag) {
-                // CraftBukkit start
-                if (CraftEventFactory.callRedstoneChange(world, blockposition.getX(), blockposition.getY(), blockposition.getZ(), 15, 0).getNewCurrent() != 0) {
-                    return;
-                }
-                // CraftBukkit end
-                world.setTypeAndData(blockposition, this.y(iblockdata), 2);
-            } else if (!this.d) {
-                // CraftBukkit start
-                if (CraftEventFactory.callRedstoneChange(world, blockposition.getX(), blockposition.getY(), blockposition.getZ(), 0, 15).getNewCurrent() != 15) {
-                    return;
-                }
-                // CraftBukkit end
-                world.setTypeAndData(blockposition, this.x(iblockdata), 2);
-                if (!flag) {
-                    world.a(blockposition, this.x(iblockdata).getBlock(), this.D(iblockdata), -1);
-                }
-            }
-
-        }
-    }
-
-    protected boolean z(IBlockData iblockdata) {
-        return this.d;
-    }
-
-    public int c(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
-        return iblockdata.a(iblockaccess, blockposition, enumdirection);
-    }
-
-    public int b(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
-        return !this.z(iblockdata) ? 0 : (iblockdata.get(BlockDiodeAbstract.FACING) == enumdirection ? this.a(iblockaccess, blockposition, iblockdata) : 0);
-    }
-
-    public void a(IBlockData iblockdata, World world, BlockPosition blockposition, Block block) {
-        if (this.b(world, blockposition)) {
-            this.g(world, blockposition, iblockdata);
-        } else {
-            this.b(world, blockposition, iblockdata, 0);
-            world.setAir(blockposition);
-            EnumDirection[] aenumdirection = EnumDirection.values();
-            int i = aenumdirection.length;
-
-            for (int j = 0; j < i; ++j) {
-                EnumDirection enumdirection = aenumdirection[j];
-
-                world.applyPhysics(blockposition.shift(enumdirection), this);
-            }
-
-        }
-    }
-
-    protected void g(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        if (!this.b((IBlockAccess) world, blockposition, iblockdata)) {
-            boolean flag = this.e(world, blockposition, iblockdata);
-
-            if ((this.d && !flag || !this.d && flag) && !world.a(blockposition, (Block) this)) {
-                byte b0 = -1;
-
-                if (this.i(world, blockposition, iblockdata)) {
-                    b0 = -3;
-                } else if (this.d) {
-                    b0 = -2;
-                }
-
-                world.a(blockposition, this, this.i(iblockdata), b0);
-            }
-
-        }
-    }
-
-    public boolean b(IBlockAccess iblockaccess, BlockPosition blockposition, IBlockData iblockdata) {
-        return false;
-    }
-
-    protected boolean e(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        return this.f(world, blockposition, iblockdata) > 0;
-    }
-
-    protected int f(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockDiodeAbstract.FACING);
-        BlockPosition blockposition1 = blockposition.shift(enumdirection);
-        int i = world.getBlockFacePower(blockposition1, enumdirection);
-
-        if (i >= 15) {
-            return i;
-        } else {
-            IBlockData iblockdata1 = world.getType(blockposition1);
-
-            return Math.max(i, iblockdata1.getBlock() == Blocks.REDSTONE_WIRE ? ((Integer) iblockdata1.get(BlockRedstoneWire.POWER)).intValue() : 0);
-        }
-    }
-
-    protected int c(IBlockAccess iblockaccess, BlockPosition blockposition, IBlockData iblockdata) {
-        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockDiodeAbstract.FACING);
-        EnumDirection enumdirection1 = enumdirection.e();
-        EnumDirection enumdirection2 = enumdirection.f();
-
-        return Math.max(this.b(iblockaccess, blockposition.shift(enumdirection1), enumdirection1), this.b(iblockaccess, blockposition.shift(enumdirection2), enumdirection2));
-    }
-
-    protected int b(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
-        IBlockData iblockdata = iblockaccess.getType(blockposition);
-        Block block = iblockdata.getBlock();
-
-        return this.A(iblockdata) ? (block == Blocks.REDSTONE_BLOCK ? 15 : (block == Blocks.REDSTONE_WIRE ? ((Integer) iblockdata.get(BlockRedstoneWire.POWER)).intValue() : iblockaccess.getBlockPower(blockposition, enumdirection))) : 0;
-    }
-
-    public boolean isPowerSource(IBlockData iblockdata) {
-        return true;
-    }
-
-    public IBlockData getPlacedState(World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2, int i, EntityLiving entityliving) {
-        return this.getBlockData().set(BlockDiodeAbstract.FACING, entityliving.getDirection().opposite());
-    }
-
-    public void postPlace(World world, BlockPosition blockposition, IBlockData iblockdata, EntityLiving entityliving, ItemStack itemstack) {
-        if (this.e(world, blockposition, iblockdata)) {
-            world.a(blockposition, (Block) this, 1);
-        }
-
-    }
-
-    public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        this.h(world, blockposition, iblockdata);
-    }
-
-    protected void h(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockDiodeAbstract.FACING);
-        BlockPosition blockposition1 = blockposition.shift(enumdirection.opposite());
-
-        world.e(blockposition1, this);
-        world.a(blockposition1, (Block) this, enumdirection);
-    }
-
-    public void postBreak(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        if (this.d) {
-            EnumDirection[] aenumdirection = EnumDirection.values();
-            int i = aenumdirection.length;
-
-            for (int j = 0; j < i; ++j) {
-                EnumDirection enumdirection = aenumdirection[j];
-
-                world.applyPhysics(blockposition.shift(enumdirection), this);
-            }
-        }
-
-        super.postBreak(world, blockposition, iblockdata);
-    }
-
-    public boolean b(IBlockData iblockdata) {
-        return false;
-    }
-
-    protected boolean A(IBlockData iblockdata) {
-        return iblockdata.m();
-    }
-
-    protected int a(IBlockAccess iblockaccess, BlockPosition blockposition, IBlockData iblockdata) {
-        return 15;
-    }
-
-    public static boolean isDiode(IBlockData iblockdata) {
-        return Blocks.UNPOWERED_REPEATER.C(iblockdata) || Blocks.UNPOWERED_COMPARATOR.C(iblockdata);
-    }
-
-    public boolean C(IBlockData iblockdata) {
-        Block block = iblockdata.getBlock();
-
-        return block == this.x(this.getBlockData()).getBlock() || block == this.y(this.getBlockData()).getBlock();
-    }
-
-    public boolean i(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        EnumDirection enumdirection = ((EnumDirection) iblockdata.get(BlockDiodeAbstract.FACING)).opposite();
-        BlockPosition blockposition1 = blockposition.shift(enumdirection);
-
-        return isDiode(world.getType(blockposition1)) ? world.getType(blockposition1).get(BlockDiodeAbstract.FACING) != enumdirection : false;
-    }
-
-    protected int D(IBlockData iblockdata) {
-        return this.i(iblockdata);
-    }
-
-    protected abstract int i(IBlockData iblockdata);
-
-    protected abstract IBlockData x(IBlockData iblockdata);
-
-    protected abstract IBlockData y(IBlockData iblockdata);
-
-    public boolean b(Block block) {
-        return this.C(block.getBlockData());
-    }
-}
+package net.minecraft.server;
+
+import java.util.Random;
+
+import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
+
+public abstract class BlockDiodeAbstract extends BlockFacingHorizontal {
+
+    protected static final AxisAlignedBB c = new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.125D, 1.0D);
+    protected final boolean d;
+
+    protected BlockDiodeAbstract(boolean flag) {
+        super(Material.ORIENTABLE);
+        this.d = flag;
+    }
+
+    public AxisAlignedBB a(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
+        return BlockDiodeAbstract.c;
+    }
+
+    public boolean c(IBlockData iblockdata) {
+        return false;
+    }
+
+    public boolean canPlace(World world, BlockPosition blockposition) {
+        return world.getType(blockposition.down()).q() ? super.canPlace(world, blockposition) : false;
+    }
+
+    public boolean b(World world, BlockPosition blockposition) {
+        return world.getType(blockposition.down()).q();
+    }
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, Random random) {}
+
+    public void b(World world, BlockPosition blockposition, IBlockData iblockdata, Random random) {
+        if (!this.b((IBlockAccess) world, blockposition, iblockdata)) {
+            boolean flag = this.e(world, blockposition, iblockdata);
+
+            if (this.d && !flag) {
+                // CraftBukkit start
+                if (CraftEventFactory.callRedstoneChange(world, blockposition.getX(), blockposition.getY(), blockposition.getZ(), 15, 0).getNewCurrent() != 0) {
+                    return;
+                }
+                // CraftBukkit end
+                world.setTypeAndData(blockposition, this.y(iblockdata), 2);
+            } else if (!this.d) {
+                // CraftBukkit start
+                if (CraftEventFactory.callRedstoneChange(world, blockposition.getX(), blockposition.getY(), blockposition.getZ(), 0, 15).getNewCurrent() != 15) {
+                    return;
+                }
+                // CraftBukkit end
+                world.setTypeAndData(blockposition, this.x(iblockdata), 2);
+                if (!flag) {
+                    world.a(blockposition, this.x(iblockdata).getBlock(), this.D(iblockdata), -1);
+                }
+            }
+
+        }
+    }
+
+    protected boolean z(IBlockData iblockdata) {
+        return this.d;
+    }
+
+    public int c(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
+        return iblockdata.a(iblockaccess, blockposition, enumdirection);
+    }
+
+    public int b(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
+        return !this.z(iblockdata) ? 0 : (iblockdata.get(BlockDiodeAbstract.FACING) == enumdirection ? this.a(iblockaccess, blockposition, iblockdata) : 0);
+    }
+
+    public void a(IBlockData iblockdata, World world, BlockPosition blockposition, Block block) {
+        if (this.b(world, blockposition)) {
+            this.g(world, blockposition, iblockdata);
+        } else {
+            this.b(world, blockposition, iblockdata, 0);
+            world.setAir(blockposition);
+            EnumDirection[] aenumdirection = EnumDirection.values();
+            int i = aenumdirection.length;
+
+            for (int j = 0; j < i; ++j) {
+                EnumDirection enumdirection = aenumdirection[j];
+
+                world.applyPhysics(blockposition.shift(enumdirection), this);
+            }
+
+        }
+    }
+
+    protected void g(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        if (!this.b((IBlockAccess) world, blockposition, iblockdata)) {
+            boolean flag = this.e(world, blockposition, iblockdata);
+
+            if ((this.d && !flag || !this.d && flag) && !world.a(blockposition, (Block) this)) {
+                byte b0 = -1;
+
+                if (this.i(world, blockposition, iblockdata)) {
+                    b0 = -3;
+                } else if (this.d) {
+                    b0 = -2;
+                }
+
+                world.a(blockposition, this, this.i(iblockdata), b0);
+            }
+
+        }
+    }
+
+    public boolean b(IBlockAccess iblockaccess, BlockPosition blockposition, IBlockData iblockdata) {
+        return false;
+    }
+
+    protected boolean e(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        return this.f(world, blockposition, iblockdata) > 0;
+    }
+
+    protected int f(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockDiodeAbstract.FACING);
+        BlockPosition blockposition1 = blockposition.shift(enumdirection);
+        int i = world.getBlockFacePower(blockposition1, enumdirection);
+
+        if (i >= 15) {
+            return i;
+        } else {
+            IBlockData iblockdata1 = world.getType(blockposition1);
+
+            return Math.max(i, iblockdata1.getBlock() == Blocks.REDSTONE_WIRE ? ((Integer) iblockdata1.get(BlockRedstoneWire.POWER)).intValue() : 0);
+        }
+    }
+
+    protected int c(IBlockAccess iblockaccess, BlockPosition blockposition, IBlockData iblockdata) {
+        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockDiodeAbstract.FACING);
+        EnumDirection enumdirection1 = enumdirection.e();
+        EnumDirection enumdirection2 = enumdirection.f();
+
+        return Math.max(this.b(iblockaccess, blockposition.shift(enumdirection1), enumdirection1), this.b(iblockaccess, blockposition.shift(enumdirection2), enumdirection2));
+    }
+
+    protected int b(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
+        IBlockData iblockdata = iblockaccess.getType(blockposition);
+        Block block = iblockdata.getBlock();
+
+        return this.A(iblockdata) ? (block == Blocks.REDSTONE_BLOCK ? 15 : (block == Blocks.REDSTONE_WIRE ? ((Integer) iblockdata.get(BlockRedstoneWire.POWER)).intValue() : iblockaccess.getBlockPower(blockposition, enumdirection))) : 0;
+    }
+
+    public boolean isPowerSource(IBlockData iblockdata) {
+        return true;
+    }
+
+    public IBlockData getPlacedState(World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2, int i, EntityLiving entityliving) {
+        return this.getBlockData().set(BlockDiodeAbstract.FACING, entityliving.getDirection().opposite());
+    }
+
+    public void postPlace(World world, BlockPosition blockposition, IBlockData iblockdata, EntityLiving entityliving, ItemStack itemstack) {
+        if (this.e(world, blockposition, iblockdata)) {
+            world.a(blockposition, (Block) this, 1);
+        }
+
+    }
+
+    public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        this.h(world, blockposition, iblockdata);
+    }
+
+    protected void h(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockDiodeAbstract.FACING);
+        BlockPosition blockposition1 = blockposition.shift(enumdirection.opposite());
+
+        world.e(blockposition1, this);
+        world.a(blockposition1, (Block) this, enumdirection);
+    }
+
+    public void postBreak(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        if (this.d) {
+            EnumDirection[] aenumdirection = EnumDirection.values();
+            int i = aenumdirection.length;
+
+            for (int j = 0; j < i; ++j) {
+                EnumDirection enumdirection = aenumdirection[j];
+
+                world.applyPhysics(blockposition.shift(enumdirection), this);
+            }
+        }
+
+        super.postBreak(world, blockposition, iblockdata);
+    }
+
+    public boolean b(IBlockData iblockdata) {
+        return false;
+    }
+
+    protected boolean A(IBlockData iblockdata) {
+        return iblockdata.m();
+    }
+
+    protected int a(IBlockAccess iblockaccess, BlockPosition blockposition, IBlockData iblockdata) {
+        return 15;
+    }
+
+    public static boolean isDiode(IBlockData iblockdata) {
+        return Blocks.UNPOWERED_REPEATER.C(iblockdata) || Blocks.UNPOWERED_COMPARATOR.C(iblockdata);
+    }
+
+    public boolean C(IBlockData iblockdata) {
+        Block block = iblockdata.getBlock();
+
+        return block == this.x(this.getBlockData()).getBlock() || block == this.y(this.getBlockData()).getBlock();
+    }
+
+    public boolean i(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        EnumDirection enumdirection = ((EnumDirection) iblockdata.get(BlockDiodeAbstract.FACING)).opposite();
+        BlockPosition blockposition1 = blockposition.shift(enumdirection);
+
+        return isDiode(world.getType(blockposition1)) ? world.getType(blockposition1).get(BlockDiodeAbstract.FACING) != enumdirection : false;
+    }
+
+    protected int D(IBlockData iblockdata) {
+        return this.i(iblockdata);
+    }
+
+    protected abstract int i(IBlockData iblockdata);
+
+    protected abstract IBlockData x(IBlockData iblockdata);
+
+    protected abstract IBlockData y(IBlockData iblockdata);
+
+    public boolean b(Block block) {
+        return this.C(block.getBlockData());
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/BlockRedstoneWire.java src/main/java/net/minecraft/server/BlockRedstoneWire.java
--- src_origin/main/java/net/minecraft/server/BlockRedstoneWire.java	2016-08-25 22:39:50.751601873 +0800
+++ src/main/java/net/minecraft/server/BlockRedstoneWire.java	2016-08-26 03:24:13.153198345 +0800
@@ -1,493 +1,497 @@
-package net.minecraft.server;
-
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
-import java.util.ArrayList;
-import java.util.EnumSet;
-import java.util.Iterator;
-import java.util.Random;
-import java.util.Set;
-import javax.annotation.Nullable;
-
-import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
-
-public class BlockRedstoneWire extends Block {
-
-    public static final BlockStateEnum<BlockRedstoneWire.EnumRedstoneWireConnection> NORTH = BlockStateEnum.of("north", BlockRedstoneWire.EnumRedstoneWireConnection.class);
-    public static final BlockStateEnum<BlockRedstoneWire.EnumRedstoneWireConnection> EAST = BlockStateEnum.of("east", BlockRedstoneWire.EnumRedstoneWireConnection.class);
-    public static final BlockStateEnum<BlockRedstoneWire.EnumRedstoneWireConnection> SOUTH = BlockStateEnum.of("south", BlockRedstoneWire.EnumRedstoneWireConnection.class);
-    public static final BlockStateEnum<BlockRedstoneWire.EnumRedstoneWireConnection> WEST = BlockStateEnum.of("west", BlockRedstoneWire.EnumRedstoneWireConnection.class);
-    public static final BlockStateInteger POWER = BlockStateInteger.of("power", 0, 15);
-    protected static final AxisAlignedBB[] f = new AxisAlignedBB[] { new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 1.0D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 1.0D, 0.0625D, 1.0D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 1.0D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.0625D, 1.0D)};
-    private boolean g = true;
-    private final Set<BlockPosition> B = Sets.newHashSet();
-
-    public BlockRedstoneWire() {
-        super(Material.ORIENTABLE);
-        this.w(this.blockStateList.getBlockData().set(BlockRedstoneWire.NORTH, BlockRedstoneWire.EnumRedstoneWireConnection.NONE).set(BlockRedstoneWire.EAST, BlockRedstoneWire.EnumRedstoneWireConnection.NONE).set(BlockRedstoneWire.SOUTH, BlockRedstoneWire.EnumRedstoneWireConnection.NONE).set(BlockRedstoneWire.WEST, BlockRedstoneWire.EnumRedstoneWireConnection.NONE).set(BlockRedstoneWire.POWER, Integer.valueOf(0)));
-    }
-
-    public AxisAlignedBB a(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
-        return BlockRedstoneWire.f[x(iblockdata.b(iblockaccess, blockposition))];
-    }
-
-    private static int x(IBlockData iblockdata) {
-        int i = 0;
-        boolean flag = iblockdata.get(BlockRedstoneWire.NORTH) != BlockRedstoneWire.EnumRedstoneWireConnection.NONE;
-        boolean flag1 = iblockdata.get(BlockRedstoneWire.EAST) != BlockRedstoneWire.EnumRedstoneWireConnection.NONE;
-        boolean flag2 = iblockdata.get(BlockRedstoneWire.SOUTH) != BlockRedstoneWire.EnumRedstoneWireConnection.NONE;
-        boolean flag3 = iblockdata.get(BlockRedstoneWire.WEST) != BlockRedstoneWire.EnumRedstoneWireConnection.NONE;
-
-        if (flag || flag2 && !flag && !flag1 && !flag3) {
-            i |= 1 << EnumDirection.NORTH.get2DRotationValue();
-        }
-
-        if (flag1 || flag3 && !flag && !flag1 && !flag2) {
-            i |= 1 << EnumDirection.EAST.get2DRotationValue();
-        }
-
-        if (flag2 || flag && !flag1 && !flag2 && !flag3) {
-            i |= 1 << EnumDirection.SOUTH.get2DRotationValue();
-        }
-
-        if (flag3 || flag1 && !flag && !flag2 && !flag3) {
-            i |= 1 << EnumDirection.WEST.get2DRotationValue();
-        }
-
-        return i;
-    }
-
-    public IBlockData updateState(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
-        iblockdata = iblockdata.set(BlockRedstoneWire.WEST, this.b(iblockaccess, blockposition, EnumDirection.WEST));
-        iblockdata = iblockdata.set(BlockRedstoneWire.EAST, this.b(iblockaccess, blockposition, EnumDirection.EAST));
-        iblockdata = iblockdata.set(BlockRedstoneWire.NORTH, this.b(iblockaccess, blockposition, EnumDirection.NORTH));
-        iblockdata = iblockdata.set(BlockRedstoneWire.SOUTH, this.b(iblockaccess, blockposition, EnumDirection.SOUTH));
-        return iblockdata;
-    }
-
-    private BlockRedstoneWire.EnumRedstoneWireConnection b(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
-        BlockPosition blockposition1 = blockposition.shift(enumdirection);
-        IBlockData iblockdata = iblockaccess.getType(blockposition.shift(enumdirection));
-
-        if (!a(iblockaccess.getType(blockposition1), enumdirection) && (iblockdata.l() || !i(iblockaccess.getType(blockposition1.down())))) {
-            IBlockData iblockdata1 = iblockaccess.getType(blockposition.up());
-
-            if (!iblockdata1.l()) {
-                boolean flag = iblockaccess.getType(blockposition1).q() || iblockaccess.getType(blockposition1).getBlock() == Blocks.GLOWSTONE;
-
-                if (flag && i(iblockaccess.getType(blockposition1.up()))) {
-                    if (iblockdata.k()) {
-                        return BlockRedstoneWire.EnumRedstoneWireConnection.UP;
-                    }
-
-                    return BlockRedstoneWire.EnumRedstoneWireConnection.SIDE;
-                }
-            }
-
-            return BlockRedstoneWire.EnumRedstoneWireConnection.NONE;
-        } else {
-            return BlockRedstoneWire.EnumRedstoneWireConnection.SIDE;
-        }
-    }
-
-    @Nullable
-    public AxisAlignedBB a(IBlockData iblockdata, World world, BlockPosition blockposition) {
-        return BlockRedstoneWire.k;
-    }
-
-    public boolean b(IBlockData iblockdata) {
-        return false;
-    }
-
-    public boolean c(IBlockData iblockdata) {
-        return false;
-    }
-
-    public boolean canPlace(World world, BlockPosition blockposition) {
-        return world.getType(blockposition.down()).q() || world.getType(blockposition.down()).getBlock() == Blocks.GLOWSTONE;
-    }
-
-    private IBlockData e(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        iblockdata = this.a(world, blockposition, blockposition, iblockdata);
-        ArrayList arraylist = Lists.newArrayList(this.B);
-
-        this.B.clear();
-        Iterator iterator = arraylist.iterator();
-
-        while (iterator.hasNext()) {
-            BlockPosition blockposition1 = (BlockPosition) iterator.next();
-
-            world.applyPhysics(blockposition1, this);
-        }
-
-        return iblockdata;
-    }
-
-    private IBlockData a(World world, BlockPosition blockposition, BlockPosition blockposition1, IBlockData iblockdata) {
-        IBlockData iblockdata1 = iblockdata;
-        int i = ((Integer) iblockdata.get(BlockRedstoneWire.POWER)).intValue();
-        byte b0 = 0;
-        int j = this.getPower(world, blockposition1, b0);
-
-        this.g = false;
-        int k = world.z(blockposition);
-
-        this.g = true;
-        if (k > 0 && k > j - 1) {
-            j = k;
-        }
-
-        int l = 0;
-        Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
-
-        while (iterator.hasNext()) {
-            EnumDirection enumdirection = (EnumDirection) iterator.next();
-            BlockPosition blockposition2 = blockposition.shift(enumdirection);
-            boolean flag = blockposition2.getX() != blockposition1.getX() || blockposition2.getZ() != blockposition1.getZ();
-
-            if (flag) {
-                l = this.getPower(world, blockposition2, l);
-            }
-
-            if (world.getType(blockposition2).l() && !world.getType(blockposition.up()).l()) {
-                if (flag && blockposition.getY() >= blockposition1.getY()) {
-                    l = this.getPower(world, blockposition2.up(), l);
-                }
-            } else if (!world.getType(blockposition2).l() && flag && blockposition.getY() <= blockposition1.getY()) {
-                l = this.getPower(world, blockposition2.down(), l);
-            }
-        }
-
-        if (l > j) {
-            j = l - 1;
-        } else if (j > 0) {
-            --j;
-        } else {
-            j = 0;
-        }
-
-        if (k > j - 1) {
-            j = k;
-        }
-
-        // CraftBukkit start
-        if (i != j) {
-            BlockRedstoneEvent event = new BlockRedstoneEvent(world.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), i, j);
-            world.getServer().getPluginManager().callEvent(event);
-
-            j = event.getNewCurrent();
-        }
-        // CraftBukkit end
-
-        if (i != j) {
-            iblockdata = iblockdata.set(BlockRedstoneWire.POWER, Integer.valueOf(j));
-            if (world.getType(blockposition) == iblockdata1) {
-                world.setTypeAndData(blockposition, iblockdata, 2);
-            }
-
-            this.B.add(blockposition);
-            EnumDirection[] aenumdirection = EnumDirection.values();
-            int i1 = aenumdirection.length;
-
-            for (int j1 = 0; j1 < i1; ++j1) {
-                EnumDirection enumdirection1 = aenumdirection[j1];
-
-                this.B.add(blockposition.shift(enumdirection1));
-            }
-        }
-
-        return iblockdata;
-    }
-
-    private void b(World world, BlockPosition blockposition) {
-        if (world.getType(blockposition).getBlock() == this) {
-            world.applyPhysics(blockposition, this);
-            EnumDirection[] aenumdirection = EnumDirection.values();
-            int i = aenumdirection.length;
-
-            for (int j = 0; j < i; ++j) {
-                EnumDirection enumdirection = aenumdirection[j];
-
-                world.applyPhysics(blockposition.shift(enumdirection), this);
-            }
-
-        }
-    }
-
-    public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        if (!world.isClientSide) {
-            this.e(world, blockposition, iblockdata);
-            Iterator iterator = EnumDirection.EnumDirectionLimit.VERTICAL.iterator();
-
-            EnumDirection enumdirection;
-
-            while (iterator.hasNext()) {
-                enumdirection = (EnumDirection) iterator.next();
-                world.applyPhysics(blockposition.shift(enumdirection), this);
-            }
-
-            iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
-
-            while (iterator.hasNext()) {
-                enumdirection = (EnumDirection) iterator.next();
-                this.b(world, blockposition.shift(enumdirection));
-            }
-
-            iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
-
-            while (iterator.hasNext()) {
-                enumdirection = (EnumDirection) iterator.next();
-                BlockPosition blockposition1 = blockposition.shift(enumdirection);
-
-                if (world.getType(blockposition1).l()) {
-                    this.b(world, blockposition1.up());
-                } else {
-                    this.b(world, blockposition1.down());
-                }
-            }
-
-        }
-    }
-
-    public void remove(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        super.remove(world, blockposition, iblockdata);
-        if (!world.isClientSide) {
-            EnumDirection[] aenumdirection = EnumDirection.values();
-            int i = aenumdirection.length;
-
-            for (int j = 0; j < i; ++j) {
-                EnumDirection enumdirection = aenumdirection[j];
-
-                world.applyPhysics(blockposition.shift(enumdirection), this);
-            }
-
-            this.e(world, blockposition, iblockdata);
-            Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
-
-            EnumDirection enumdirection1;
-
-            while (iterator.hasNext()) {
-                enumdirection1 = (EnumDirection) iterator.next();
-                this.b(world, blockposition.shift(enumdirection1));
-            }
-
-            iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
-
-            while (iterator.hasNext()) {
-                enumdirection1 = (EnumDirection) iterator.next();
-                BlockPosition blockposition1 = blockposition.shift(enumdirection1);
-
-                if (world.getType(blockposition1).l()) {
-                    this.b(world, blockposition1.up());
-                } else {
-                    this.b(world, blockposition1.down());
-                }
-            }
-
-        }
-    }
-
-    public int getPower(World world, BlockPosition blockposition, int i) {
-        if (world.getType(blockposition).getBlock() != this) {
-            return i;
-        } else {
-            int j = ((Integer) world.getType(blockposition).get(BlockRedstoneWire.POWER)).intValue();
-
-            return j > i ? j : i;
-        }
-    }
-
-    public void a(IBlockData iblockdata, World world, BlockPosition blockposition, Block block) {
-        if (!world.isClientSide) {
-            if (this.canPlace(world, blockposition)) {
-                this.e(world, blockposition, iblockdata);
-            } else {
-                this.b(world, blockposition, iblockdata, 0);
-                world.setAir(blockposition);
-            }
-
-        }
-    }
-
-    @Nullable
-    public Item getDropType(IBlockData iblockdata, Random random, int i) {
-        return Items.REDSTONE;
-    }
-
-    public int c(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
-        return !this.g ? 0 : iblockdata.a(iblockaccess, blockposition, enumdirection);
-    }
-
-    public int b(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
-        if (!this.g) {
-            return 0;
-        } else {
-            int i = ((Integer) iblockdata.get(BlockRedstoneWire.POWER)).intValue();
-
-            if (i == 0) {
-                return 0;
-            } else if (enumdirection == EnumDirection.UP) {
-                return i;
-            } else {
-                EnumSet enumset = EnumSet.noneOf(EnumDirection.class);
-                Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
-
-                while (iterator.hasNext()) {
-                    EnumDirection enumdirection1 = (EnumDirection) iterator.next();
-
-                    if (this.c(iblockaccess, blockposition, enumdirection1)) {
-                        enumset.add(enumdirection1);
-                    }
-                }
-
-                if (enumdirection.k().c() && enumset.isEmpty()) {
-                    return i;
-                } else if (enumset.contains(enumdirection) && !enumset.contains(enumdirection.f()) && !enumset.contains(enumdirection.e())) {
-                    return i;
-                } else {
-                    return 0;
-                }
-            }
-        }
-    }
-
-    private boolean c(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
-        BlockPosition blockposition1 = blockposition.shift(enumdirection);
-        IBlockData iblockdata = iblockaccess.getType(blockposition1);
-        boolean flag = iblockdata.l();
-        boolean flag1 = iblockaccess.getType(blockposition.up()).l();
-
-        return !flag1 && flag && c(iblockaccess, blockposition1.up()) ? true : (a(iblockdata, enumdirection) ? true : (iblockdata.getBlock() == Blocks.POWERED_REPEATER && iblockdata.get(BlockDiodeAbstract.FACING) == enumdirection ? true : !flag && c(iblockaccess, blockposition1.down())));
-    }
-
-    protected static boolean c(IBlockAccess iblockaccess, BlockPosition blockposition) {
-        return i(iblockaccess.getType(blockposition));
-    }
-
-    protected static boolean i(IBlockData iblockdata) {
-        return a(iblockdata, (EnumDirection) null);
-    }
-
-    protected static boolean a(IBlockData iblockdata, @Nullable EnumDirection enumdirection) {
-        Block block = iblockdata.getBlock();
-
-        if (block == Blocks.REDSTONE_WIRE) {
-            return true;
-        } else if (Blocks.UNPOWERED_REPEATER.C(iblockdata)) {
-            EnumDirection enumdirection1 = (EnumDirection) iblockdata.get(BlockRepeater.FACING);
-
-            return enumdirection1 == enumdirection || enumdirection1.opposite() == enumdirection;
-        } else {
-            return iblockdata.m() && enumdirection != null;
-        }
-    }
-
-    public boolean isPowerSource(IBlockData iblockdata) {
-        return this.g;
-    }
-
-    public ItemStack a(World world, BlockPosition blockposition, IBlockData iblockdata) {
-        return new ItemStack(Items.REDSTONE);
-    }
-
-    public IBlockData fromLegacyData(int i) {
-        return this.getBlockData().set(BlockRedstoneWire.POWER, Integer.valueOf(i));
-    }
-
-    public int toLegacyData(IBlockData iblockdata) {
-        return ((Integer) iblockdata.get(BlockRedstoneWire.POWER)).intValue();
-    }
-
-    public IBlockData a(IBlockData iblockdata, EnumBlockRotation enumblockrotation) {
-        switch (BlockRedstoneWire.SyntheticClass_1.a[enumblockrotation.ordinal()]) {
-        case 1:
-            return iblockdata.set(BlockRedstoneWire.NORTH, iblockdata.get(BlockRedstoneWire.SOUTH)).set(BlockRedstoneWire.EAST, iblockdata.get(BlockRedstoneWire.WEST)).set(BlockRedstoneWire.SOUTH, iblockdata.get(BlockRedstoneWire.NORTH)).set(BlockRedstoneWire.WEST, iblockdata.get(BlockRedstoneWire.EAST));
-
-        case 2:
-            return iblockdata.set(BlockRedstoneWire.NORTH, iblockdata.get(BlockRedstoneWire.EAST)).set(BlockRedstoneWire.EAST, iblockdata.get(BlockRedstoneWire.SOUTH)).set(BlockRedstoneWire.SOUTH, iblockdata.get(BlockRedstoneWire.WEST)).set(BlockRedstoneWire.WEST, iblockdata.get(BlockRedstoneWire.NORTH));
-
-        case 3:
-            return iblockdata.set(BlockRedstoneWire.NORTH, iblockdata.get(BlockRedstoneWire.WEST)).set(BlockRedstoneWire.EAST, iblockdata.get(BlockRedstoneWire.NORTH)).set(BlockRedstoneWire.SOUTH, iblockdata.get(BlockRedstoneWire.EAST)).set(BlockRedstoneWire.WEST, iblockdata.get(BlockRedstoneWire.SOUTH));
-
-        default:
-            return iblockdata;
-        }
-    }
-
-    public IBlockData a(IBlockData iblockdata, EnumBlockMirror enumblockmirror) {
-        switch (BlockRedstoneWire.SyntheticClass_1.b[enumblockmirror.ordinal()]) {
-        case 1:
-            return iblockdata.set(BlockRedstoneWire.NORTH, iblockdata.get(BlockRedstoneWire.SOUTH)).set(BlockRedstoneWire.SOUTH, iblockdata.get(BlockRedstoneWire.NORTH));
-
-        case 2:
-            return iblockdata.set(BlockRedstoneWire.EAST, iblockdata.get(BlockRedstoneWire.WEST)).set(BlockRedstoneWire.WEST, iblockdata.get(BlockRedstoneWire.EAST));
-
-        default:
-            return super.a(iblockdata, enumblockmirror);
-        }
-    }
-
-    protected BlockStateList getStateList() {
-        return new BlockStateList(this, new IBlockState[] { BlockRedstoneWire.NORTH, BlockRedstoneWire.EAST, BlockRedstoneWire.SOUTH, BlockRedstoneWire.WEST, BlockRedstoneWire.POWER});
-    }
-
-    static class SyntheticClass_1 {
-
-        static final int[] a;
-        static final int[] b = new int[EnumBlockMirror.values().length];
-
-        static {
-            try {
-                BlockRedstoneWire.SyntheticClass_1.b[EnumBlockMirror.LEFT_RIGHT.ordinal()] = 1;
-            } catch (NoSuchFieldError nosuchfielderror) {
-                ;
-            }
-
-            try {
-                BlockRedstoneWire.SyntheticClass_1.b[EnumBlockMirror.FRONT_BACK.ordinal()] = 2;
-            } catch (NoSuchFieldError nosuchfielderror1) {
-                ;
-            }
-
-            a = new int[EnumBlockRotation.values().length];
-
-            try {
-                BlockRedstoneWire.SyntheticClass_1.a[EnumBlockRotation.CLOCKWISE_180.ordinal()] = 1;
-            } catch (NoSuchFieldError nosuchfielderror2) {
-                ;
-            }
-
-            try {
-                BlockRedstoneWire.SyntheticClass_1.a[EnumBlockRotation.COUNTERCLOCKWISE_90.ordinal()] = 2;
-            } catch (NoSuchFieldError nosuchfielderror3) {
-                ;
-            }
-
-            try {
-                BlockRedstoneWire.SyntheticClass_1.a[EnumBlockRotation.CLOCKWISE_90.ordinal()] = 3;
-            } catch (NoSuchFieldError nosuchfielderror4) {
-                ;
-            }
-
-        }
-    }
-
-    static enum EnumRedstoneWireConnection implements INamable {
-
-        UP("up"), SIDE("side"), NONE("none");
-
-        private final String d;
-
-        private EnumRedstoneWireConnection(String s) {
-            this.d = s;
-        }
-
-        public String toString() {
-            return this.getName();
-        }
-
-        public String getName() {
-            return this.d;
-        }
-    }
-}
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.Iterator;
+import java.util.Random;
+import java.util.Set;
+import javax.annotation.Nullable;
+
+import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
+
+public class BlockRedstoneWire extends Block {
+
+    public static final BlockStateEnum<BlockRedstoneWire.EnumRedstoneWireConnection> NORTH = BlockStateEnum.of("north", BlockRedstoneWire.EnumRedstoneWireConnection.class);
+    public static final BlockStateEnum<BlockRedstoneWire.EnumRedstoneWireConnection> EAST = BlockStateEnum.of("east", BlockRedstoneWire.EnumRedstoneWireConnection.class);
+    public static final BlockStateEnum<BlockRedstoneWire.EnumRedstoneWireConnection> SOUTH = BlockStateEnum.of("south", BlockRedstoneWire.EnumRedstoneWireConnection.class);
+    public static final BlockStateEnum<BlockRedstoneWire.EnumRedstoneWireConnection> WEST = BlockStateEnum.of("west", BlockRedstoneWire.EnumRedstoneWireConnection.class);
+    public static final BlockStateInteger POWER = BlockStateInteger.of("power", 0, 15);
+    protected static final AxisAlignedBB[] f = new AxisAlignedBB[] { new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 1.0D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 1.0D, 0.0625D, 1.0D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 1.0D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.0625D, 1.0D)};
+    private boolean g = true;
+    //private final Set<BlockPosition> B = Sets.newHashSet();
+    private final Set<BlockPosition> B = Collections.synchronizedSet(Sets.newHashSet());
+
+    public BlockRedstoneWire() {
+        super(Material.ORIENTABLE);
+        this.w(this.blockStateList.getBlockData().set(BlockRedstoneWire.NORTH, BlockRedstoneWire.EnumRedstoneWireConnection.NONE).set(BlockRedstoneWire.EAST, BlockRedstoneWire.EnumRedstoneWireConnection.NONE).set(BlockRedstoneWire.SOUTH, BlockRedstoneWire.EnumRedstoneWireConnection.NONE).set(BlockRedstoneWire.WEST, BlockRedstoneWire.EnumRedstoneWireConnection.NONE).set(BlockRedstoneWire.POWER, Integer.valueOf(0)));
+    }
+
+    public AxisAlignedBB a(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
+        return BlockRedstoneWire.f[x(iblockdata.b(iblockaccess, blockposition))];
+    }
+
+    private static int x(IBlockData iblockdata) {
+        int i = 0;
+        boolean flag = iblockdata.get(BlockRedstoneWire.NORTH) != BlockRedstoneWire.EnumRedstoneWireConnection.NONE;
+        boolean flag1 = iblockdata.get(BlockRedstoneWire.EAST) != BlockRedstoneWire.EnumRedstoneWireConnection.NONE;
+        boolean flag2 = iblockdata.get(BlockRedstoneWire.SOUTH) != BlockRedstoneWire.EnumRedstoneWireConnection.NONE;
+        boolean flag3 = iblockdata.get(BlockRedstoneWire.WEST) != BlockRedstoneWire.EnumRedstoneWireConnection.NONE;
+
+        if (flag || flag2 && !flag && !flag1 && !flag3) {
+            i |= 1 << EnumDirection.NORTH.get2DRotationValue();
+        }
+
+        if (flag1 || flag3 && !flag && !flag1 && !flag2) {
+            i |= 1 << EnumDirection.EAST.get2DRotationValue();
+        }
+
+        if (flag2 || flag && !flag1 && !flag2 && !flag3) {
+            i |= 1 << EnumDirection.SOUTH.get2DRotationValue();
+        }
+
+        if (flag3 || flag1 && !flag && !flag2 && !flag3) {
+            i |= 1 << EnumDirection.WEST.get2DRotationValue();
+        }
+
+        return i;
+    }
+
+    public IBlockData updateState(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition) {
+        iblockdata = iblockdata.set(BlockRedstoneWire.WEST, this.b(iblockaccess, blockposition, EnumDirection.WEST));
+        iblockdata = iblockdata.set(BlockRedstoneWire.EAST, this.b(iblockaccess, blockposition, EnumDirection.EAST));
+        iblockdata = iblockdata.set(BlockRedstoneWire.NORTH, this.b(iblockaccess, blockposition, EnumDirection.NORTH));
+        iblockdata = iblockdata.set(BlockRedstoneWire.SOUTH, this.b(iblockaccess, blockposition, EnumDirection.SOUTH));
+        return iblockdata;
+    }
+
+    private BlockRedstoneWire.EnumRedstoneWireConnection b(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
+        BlockPosition blockposition1 = blockposition.shift(enumdirection);
+        IBlockData iblockdata = iblockaccess.getType(blockposition.shift(enumdirection));
+
+        if (!a(iblockaccess.getType(blockposition1), enumdirection) && (iblockdata.l() || !i(iblockaccess.getType(blockposition1.down())))) {
+            IBlockData iblockdata1 = iblockaccess.getType(blockposition.up());
+
+            if (!iblockdata1.l()) {
+                boolean flag = iblockaccess.getType(blockposition1).q() || iblockaccess.getType(blockposition1).getBlock() == Blocks.GLOWSTONE;
+
+                if (flag && i(iblockaccess.getType(blockposition1.up()))) {
+                    if (iblockdata.k()) {
+                        return BlockRedstoneWire.EnumRedstoneWireConnection.UP;
+                    }
+
+                    return BlockRedstoneWire.EnumRedstoneWireConnection.SIDE;
+                }
+            }
+
+            return BlockRedstoneWire.EnumRedstoneWireConnection.NONE;
+        } else {
+            return BlockRedstoneWire.EnumRedstoneWireConnection.SIDE;
+        }
+    }
+
+    @Nullable
+    public AxisAlignedBB a(IBlockData iblockdata, World world, BlockPosition blockposition) {
+        return BlockRedstoneWire.k;
+    }
+
+    public boolean b(IBlockData iblockdata) {
+        return false;
+    }
+
+    public boolean c(IBlockData iblockdata) {
+        return false;
+    }
+
+    public boolean canPlace(World world, BlockPosition blockposition) {
+        return world.getType(blockposition.down()).q() || world.getType(blockposition.down()).getBlock() == Blocks.GLOWSTONE;
+    }
+
+    private IBlockData e(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        iblockdata = this.a(world, blockposition, blockposition, iblockdata);
+        synchronized (this.B) {
+            ArrayList arraylist = Lists.newArrayList(this.B);
+
+            this.B.clear();
+            Iterator iterator = arraylist.iterator();
+
+            while (iterator.hasNext()) {
+                BlockPosition blockposition1 = (BlockPosition) iterator.next();
+
+                world.applyPhysics(blockposition1, this);
+            }
+
+            return iblockdata;
+        }
+    }
+
+    private IBlockData a(World world, BlockPosition blockposition, BlockPosition blockposition1, IBlockData iblockdata) {
+        IBlockData iblockdata1 = iblockdata;
+        int i = ((Integer) iblockdata.get(BlockRedstoneWire.POWER)).intValue();
+        byte b0 = 0;
+        int j = this.getPower(world, blockposition1, b0);
+
+        this.g = false;
+        int k = world.z(blockposition);
+
+        this.g = true;
+        if (k > 0 && k > j - 1) {
+            j = k;
+        }
+
+        int l = 0;
+        Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+        while (iterator.hasNext()) {
+            EnumDirection enumdirection = (EnumDirection) iterator.next();
+            BlockPosition blockposition2 = blockposition.shift(enumdirection);
+            boolean flag = blockposition2.getX() != blockposition1.getX() || blockposition2.getZ() != blockposition1.getZ();
+
+            if (flag) {
+                l = this.getPower(world, blockposition2, l);
+            }
+
+            if (world.getType(blockposition2).l() && !world.getType(blockposition.up()).l()) {
+                if (flag && blockposition.getY() >= blockposition1.getY()) {
+                    l = this.getPower(world, blockposition2.up(), l);
+                }
+            } else if (!world.getType(blockposition2).l() && flag && blockposition.getY() <= blockposition1.getY()) {
+                l = this.getPower(world, blockposition2.down(), l);
+            }
+        }
+
+        if (l > j) {
+            j = l - 1;
+        } else if (j > 0) {
+            --j;
+        } else {
+            j = 0;
+        }
+
+        if (k > j - 1) {
+            j = k;
+        }
+
+        // CraftBukkit start
+        if (i != j) {
+            BlockRedstoneEvent event = new BlockRedstoneEvent(world.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), i, j);
+            world.getServer().getPluginManager().callEvent(event);
+
+            j = event.getNewCurrent();
+        }
+        // CraftBukkit end
+
+        if (i != j) {
+            iblockdata = iblockdata.set(BlockRedstoneWire.POWER, Integer.valueOf(j));
+            if (world.getType(blockposition) == iblockdata1) {
+                world.setTypeAndData(blockposition, iblockdata, 2);
+            }
+
+            this.B.add(blockposition);
+            EnumDirection[] aenumdirection = EnumDirection.values();
+            int i1 = aenumdirection.length;
+
+            for (int j1 = 0; j1 < i1; ++j1) {
+                EnumDirection enumdirection1 = aenumdirection[j1];
+
+                this.B.add(blockposition.shift(enumdirection1));
+            }
+        }
+
+        return iblockdata;
+    }
+
+    private void b(World world, BlockPosition blockposition) {
+        if (world.getType(blockposition).getBlock() == this) {
+            world.applyPhysics(blockposition, this);
+            EnumDirection[] aenumdirection = EnumDirection.values();
+            int i = aenumdirection.length;
+
+            for (int j = 0; j < i; ++j) {
+                EnumDirection enumdirection = aenumdirection[j];
+
+                world.applyPhysics(blockposition.shift(enumdirection), this);
+            }
+
+        }
+    }
+
+    public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        if (!world.isClientSide) {
+            this.e(world, blockposition, iblockdata);
+            Iterator iterator = EnumDirection.EnumDirectionLimit.VERTICAL.iterator();
+
+            EnumDirection enumdirection;
+
+            while (iterator.hasNext()) {
+                enumdirection = (EnumDirection) iterator.next();
+                world.applyPhysics(blockposition.shift(enumdirection), this);
+            }
+
+            iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+            while (iterator.hasNext()) {
+                enumdirection = (EnumDirection) iterator.next();
+                this.b(world, blockposition.shift(enumdirection));
+            }
+
+            iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+            while (iterator.hasNext()) {
+                enumdirection = (EnumDirection) iterator.next();
+                BlockPosition blockposition1 = blockposition.shift(enumdirection);
+
+                if (world.getType(blockposition1).l()) {
+                    this.b(world, blockposition1.up());
+                } else {
+                    this.b(world, blockposition1.down());
+                }
+            }
+
+        }
+    }
+
+    public void remove(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        super.remove(world, blockposition, iblockdata);
+        if (!world.isClientSide) {
+            EnumDirection[] aenumdirection = EnumDirection.values();
+            int i = aenumdirection.length;
+
+            for (int j = 0; j < i; ++j) {
+                EnumDirection enumdirection = aenumdirection[j];
+
+                world.applyPhysics(blockposition.shift(enumdirection), this);
+            }
+
+            this.e(world, blockposition, iblockdata);
+            Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+            EnumDirection enumdirection1;
+
+            while (iterator.hasNext()) {
+                enumdirection1 = (EnumDirection) iterator.next();
+                this.b(world, blockposition.shift(enumdirection1));
+            }
+
+            iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+            while (iterator.hasNext()) {
+                enumdirection1 = (EnumDirection) iterator.next();
+                BlockPosition blockposition1 = blockposition.shift(enumdirection1);
+
+                if (world.getType(blockposition1).l()) {
+                    this.b(world, blockposition1.up());
+                } else {
+                    this.b(world, blockposition1.down());
+                }
+            }
+
+        }
+    }
+
+    public int getPower(World world, BlockPosition blockposition, int i) {
+        if (world.getType(blockposition).getBlock() != this) {
+            return i;
+        } else {
+            int j = ((Integer) world.getType(blockposition).get(BlockRedstoneWire.POWER)).intValue();
+
+            return j > i ? j : i;
+        }
+    }
+
+    public void a(IBlockData iblockdata, World world, BlockPosition blockposition, Block block) {
+        if (!world.isClientSide) {
+            if (this.canPlace(world, blockposition)) {
+                this.e(world, blockposition, iblockdata);
+            } else {
+                this.b(world, blockposition, iblockdata, 0);
+                world.setAir(blockposition);
+            }
+
+        }
+    }
+
+    @Nullable
+    public Item getDropType(IBlockData iblockdata, Random random, int i) {
+        return Items.REDSTONE;
+    }
+
+    public int c(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
+        return !this.g ? 0 : iblockdata.a(iblockaccess, blockposition, enumdirection);
+    }
+
+    public int b(IBlockData iblockdata, IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
+        if (!this.g) {
+            return 0;
+        } else {
+            int i = ((Integer) iblockdata.get(BlockRedstoneWire.POWER)).intValue();
+
+            if (i == 0) {
+                return 0;
+            } else if (enumdirection == EnumDirection.UP) {
+                return i;
+            } else {
+                EnumSet enumset = EnumSet.noneOf(EnumDirection.class);
+                Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+                while (iterator.hasNext()) {
+                    EnumDirection enumdirection1 = (EnumDirection) iterator.next();
+
+                    if (this.c(iblockaccess, blockposition, enumdirection1)) {
+                        enumset.add(enumdirection1);
+                    }
+                }
+
+                if (enumdirection.k().c() && enumset.isEmpty()) {
+                    return i;
+                } else if (enumset.contains(enumdirection) && !enumset.contains(enumdirection.f()) && !enumset.contains(enumdirection.e())) {
+                    return i;
+                } else {
+                    return 0;
+                }
+            }
+        }
+    }
+
+    private boolean c(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
+        BlockPosition blockposition1 = blockposition.shift(enumdirection);
+        IBlockData iblockdata = iblockaccess.getType(blockposition1);
+        boolean flag = iblockdata.l();
+        boolean flag1 = iblockaccess.getType(blockposition.up()).l();
+
+        return !flag1 && flag && c(iblockaccess, blockposition1.up()) ? true : (a(iblockdata, enumdirection) ? true : (iblockdata.getBlock() == Blocks.POWERED_REPEATER && iblockdata.get(BlockDiodeAbstract.FACING) == enumdirection ? true : !flag && c(iblockaccess, blockposition1.down())));
+    }
+
+    protected static boolean c(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        return i(iblockaccess.getType(blockposition));
+    }
+
+    protected static boolean i(IBlockData iblockdata) {
+        return a(iblockdata, (EnumDirection) null);
+    }
+
+    protected static boolean a(IBlockData iblockdata, @Nullable EnumDirection enumdirection) {
+        Block block = iblockdata.getBlock();
+
+        if (block == Blocks.REDSTONE_WIRE) {
+            return true;
+        } else if (Blocks.UNPOWERED_REPEATER.C(iblockdata)) {
+            EnumDirection enumdirection1 = (EnumDirection) iblockdata.get(BlockRepeater.FACING);
+
+            return enumdirection1 == enumdirection || enumdirection1.opposite() == enumdirection;
+        } else {
+            return iblockdata.m() && enumdirection != null;
+        }
+    }
+
+    public boolean isPowerSource(IBlockData iblockdata) {
+        return this.g;
+    }
+
+    public ItemStack a(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        return new ItemStack(Items.REDSTONE);
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        return this.getBlockData().set(BlockRedstoneWire.POWER, Integer.valueOf(i));
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        return ((Integer) iblockdata.get(BlockRedstoneWire.POWER)).intValue();
+    }
+
+    public IBlockData a(IBlockData iblockdata, EnumBlockRotation enumblockrotation) {
+        switch (BlockRedstoneWire.SyntheticClass_1.a[enumblockrotation.ordinal()]) {
+        case 1:
+            return iblockdata.set(BlockRedstoneWire.NORTH, iblockdata.get(BlockRedstoneWire.SOUTH)).set(BlockRedstoneWire.EAST, iblockdata.get(BlockRedstoneWire.WEST)).set(BlockRedstoneWire.SOUTH, iblockdata.get(BlockRedstoneWire.NORTH)).set(BlockRedstoneWire.WEST, iblockdata.get(BlockRedstoneWire.EAST));
+
+        case 2:
+            return iblockdata.set(BlockRedstoneWire.NORTH, iblockdata.get(BlockRedstoneWire.EAST)).set(BlockRedstoneWire.EAST, iblockdata.get(BlockRedstoneWire.SOUTH)).set(BlockRedstoneWire.SOUTH, iblockdata.get(BlockRedstoneWire.WEST)).set(BlockRedstoneWire.WEST, iblockdata.get(BlockRedstoneWire.NORTH));
+
+        case 3:
+            return iblockdata.set(BlockRedstoneWire.NORTH, iblockdata.get(BlockRedstoneWire.WEST)).set(BlockRedstoneWire.EAST, iblockdata.get(BlockRedstoneWire.NORTH)).set(BlockRedstoneWire.SOUTH, iblockdata.get(BlockRedstoneWire.EAST)).set(BlockRedstoneWire.WEST, iblockdata.get(BlockRedstoneWire.SOUTH));
+
+        default:
+            return iblockdata;
+        }
+    }
+
+    public IBlockData a(IBlockData iblockdata, EnumBlockMirror enumblockmirror) {
+        switch (BlockRedstoneWire.SyntheticClass_1.b[enumblockmirror.ordinal()]) {
+        case 1:
+            return iblockdata.set(BlockRedstoneWire.NORTH, iblockdata.get(BlockRedstoneWire.SOUTH)).set(BlockRedstoneWire.SOUTH, iblockdata.get(BlockRedstoneWire.NORTH));
+
+        case 2:
+            return iblockdata.set(BlockRedstoneWire.EAST, iblockdata.get(BlockRedstoneWire.WEST)).set(BlockRedstoneWire.WEST, iblockdata.get(BlockRedstoneWire.EAST));
+
+        default:
+            return super.a(iblockdata, enumblockmirror);
+        }
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockRedstoneWire.NORTH, BlockRedstoneWire.EAST, BlockRedstoneWire.SOUTH, BlockRedstoneWire.WEST, BlockRedstoneWire.POWER});
+    }
+
+    static class SyntheticClass_1 {
+
+        static final int[] a;
+        static final int[] b = new int[EnumBlockMirror.values().length];
+
+        static {
+            try {
+                BlockRedstoneWire.SyntheticClass_1.b[EnumBlockMirror.LEFT_RIGHT.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror) {
+                ;
+            }
+
+            try {
+                BlockRedstoneWire.SyntheticClass_1.b[EnumBlockMirror.FRONT_BACK.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror1) {
+                ;
+            }
+
+            a = new int[EnumBlockRotation.values().length];
+
+            try {
+                BlockRedstoneWire.SyntheticClass_1.a[EnumBlockRotation.CLOCKWISE_180.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror2) {
+                ;
+            }
+
+            try {
+                BlockRedstoneWire.SyntheticClass_1.a[EnumBlockRotation.COUNTERCLOCKWISE_90.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror3) {
+                ;
+            }
+
+            try {
+                BlockRedstoneWire.SyntheticClass_1.a[EnumBlockRotation.CLOCKWISE_90.ordinal()] = 3;
+            } catch (NoSuchFieldError nosuchfielderror4) {
+                ;
+            }
+
+        }
+    }
+
+    static enum EnumRedstoneWireConnection implements INamable {
+
+        UP("up"), SIDE("side"), NONE("none");
+
+        private final String d;
+
+        private EnumRedstoneWireConnection(String s) {
+            this.d = s;
+        }
+
+        public String toString() {
+            return this.getName();
+        }
+
+        public String getName() {
+            return this.d;
+        }
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/Chunk.java src/main/java/net/minecraft/server/Chunk.java
--- src_origin/main/java/net/minecraft/server/Chunk.java	2016-08-25 22:39:50.874601885 +0800
+++ src/main/java/net/minecraft/server/Chunk.java	2016-08-26 03:24:13.291198358 +0800
@@ -1,1341 +1,1370 @@
-package net.minecraft.server;
-
-import com.google.common.base.Predicate;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Queues;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.concurrent.ConcurrentLinkedQueue;
-import javax.annotation.Nullable;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-
-import com.google.common.collect.Lists; // CraftBukkit
-import org.bukkit.Server; // CraftBukkit
-
-public class Chunk {
-
-    private static final Logger e = LogManager.getLogger();
-    public static final ChunkSection a = null;
-    private final ChunkSection[] sections;
-    private final byte[] g;
-    private final int[] h;
-    private final boolean[] i;
-    private boolean j;
-    public final World world;
-    public final int[] heightMap;
-    public final int locX;
-    public final int locZ;
-    private boolean m;
-    public final Map<BlockPosition, TileEntity> tileEntities;
-    public final List<Entity>[] entitySlices; // Spigot
-    private boolean done;
-    private boolean lit;
-    private boolean r;
-    private boolean s;
-    private boolean t;
-    private long lastSaved;
-    private int v;
-    private long w;
-    private int x;
-    private ConcurrentLinkedQueue<BlockPosition> y;
-    public boolean d;
-    protected gnu.trove.map.hash.TObjectIntHashMap<Class> entityCount = new gnu.trove.map.hash.TObjectIntHashMap<Class>(); // Spigot
-
-    // CraftBukkit start - Neighbor loaded cache for chunk lighting and entity ticking
-    private int neighbors = 0x1 << 12;
-    public long chunkKey;
-
-    public boolean areNeighborsLoaded(final int radius) {
-        switch (radius) {
-            case 2:
-                return this.neighbors == Integer.MAX_VALUE >> 6;
-            case 1:
-                final int mask =
-                        //       x        z   offset          x        z   offset          x         z   offset
-                        (0x1 << (1 * 5 +  1 + 12)) | (0x1 << (0 * 5 +  1 + 12)) | (0x1 << (-1 * 5 +  1 + 12)) |
-                        (0x1 << (1 * 5 +  0 + 12)) | (0x1 << (0 * 5 +  0 + 12)) | (0x1 << (-1 * 5 +  0 + 12)) |
-                        (0x1 << (1 * 5 + -1 + 12)) | (0x1 << (0 * 5 + -1 + 12)) | (0x1 << (-1 * 5 + -1 + 12));
-                return (this.neighbors & mask) == mask;
-            default:
-                throw new UnsupportedOperationException(String.valueOf(radius));
-        }
-    }
-
-    public void setNeighborLoaded(final int x, final int z) {
-        this.neighbors |= 0x1 << (x * 5 + 12 + z);
-    }
-
-    public void setNeighborUnloaded(final int x, final int z) {
-        this.neighbors &= ~(0x1 << (x * 5 + 12 + z));
-    }
-    // CraftBukkit end
-
-    public Chunk(World world, int i, int j) {
-        this.sections = new ChunkSection[16];
-        this.g = new byte[256];
-        this.h = new int[256];
-        this.i = new boolean[256];
-        this.tileEntities = Maps.newHashMap();
-        this.x = 4096;
-        this.y = Queues.newConcurrentLinkedQueue();
-        this.entitySlices = (List[]) (new List[16]); // Spigot
-        this.world = world;
-        this.locX = i;
-        this.locZ = j;
-        this.heightMap = new int[256];
-
-        for (int k = 0; k < this.entitySlices.length; ++k) {
-            this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
-        }
-
-        Arrays.fill(this.h, -999);
-        Arrays.fill(this.g, (byte) -1);
-        // CraftBukkit start
-        this.bukkitChunk = new org.bukkit.craftbukkit.CraftChunk(this);
-        this.chunkKey = ChunkCoordIntPair.a(this.locX, this.locZ);
-    }
-
-    public org.bukkit.Chunk bukkitChunk;
-    public boolean mustSave;
-    // CraftBukkit end
-
-    public Chunk(World world, ChunkSnapshot chunksnapshot, int i, int j) {
-        this(world, i, j);
-        boolean flag = true;
-        boolean flag1 = !world.worldProvider.m();
-
-        for (int k = 0; k < 16; ++k) {
-            for (int l = 0; l < 16; ++l) {
-                for (int i1 = 0; i1 < 256; ++i1) {
-                    IBlockData iblockdata = chunksnapshot.a(k, i1, l);
-
-                    if (iblockdata.getMaterial() != Material.AIR) {
-                        int j1 = i1 >> 4;
-
-                        if (this.sections[j1] == Chunk.a) {
-                            this.sections[j1] = new ChunkSection(j1 << 4, flag1);
-                        }
-
-                        this.sections[j1].setType(k, i1 & 15, l, iblockdata);
-                    }
-                }
-            }
-        }
-
-    }
-
-    public boolean a(int i, int j) {
-        return i == this.locX && j == this.locZ;
-    }
-
-    public int e(BlockPosition blockposition) {
-        return this.b(blockposition.getX() & 15, blockposition.getZ() & 15);
-    }
-
-    public int b(int i, int j) {
-        return this.heightMap[j << 4 | i];
-    }
-
-    @Nullable
-    private ChunkSection y() {
-        for (int i = this.sections.length - 1; i >= 0; --i) {
-            if (this.sections[i] != Chunk.a) {
-                return this.sections[i];
-            }
-        }
-
-        return null;
-    }
-
-    public int g() {
-        ChunkSection chunksection = this.y();
-
-        return chunksection == null ? 0 : chunksection.getYPosition();
-    }
-
-    public ChunkSection[] getSections() {
-        return this.sections;
-    }
-
-    public void initLighting() {
-        int i = this.g();
-
-        this.v = Integer.MAX_VALUE;
-
-        for (int j = 0; j < 16; ++j) {
-            int k = 0;
-
-            while (k < 16) {
-                this.h[j + (k << 4)] = -999;
-                int l = i + 16;
-
-                while (true) {
-                    if (l > 0) {
-                        if (this.d(j, l - 1, k) == 0) {
-                            --l;
-                            continue;
-                        }
-
-                        this.heightMap[k << 4 | j] = l;
-                        if (l < this.v) {
-                            this.v = l;
-                        }
-                    }
-
-                    if (!this.world.worldProvider.m()) {
-                        l = 15;
-                        int i1 = i + 16 - 1;
-
-                        do {
-                            int j1 = this.d(j, i1, k);
-
-                            if (j1 == 0 && l != 15) {
-                                j1 = 1;
-                            }
-
-                            l -= j1;
-                            if (l > 0) {
-                                ChunkSection chunksection = this.sections[i1 >> 4];
-
-                                if (chunksection != Chunk.a) {
-                                    chunksection.a(j, i1 & 15, k, l);
-                                    this.world.m(new BlockPosition((this.locX << 4) + j, i1, (this.locZ << 4) + k));
-                                }
-                            }
-
-                            --i1;
-                        } while (i1 > 0 && l > 0);
-                    }
-
-                    ++k;
-                    break;
-                }
-            }
-        }
-
-        this.s = true;
-    }
-
-    private void d(int i, int j) {
-        this.i[i + j * 16] = true;
-        this.m = true;
-    }
-
-    private void h(boolean flag) {
-        this.world.methodProfiler.a("recheckGaps");
-        if (this.world.areChunksLoaded(new BlockPosition(this.locX * 16 + 8, 0, this.locZ * 16 + 8), 16)) {
-            for (int i = 0; i < 16; ++i) {
-                for (int j = 0; j < 16; ++j) {
-                    if (this.i[i + j * 16]) {
-                        this.i[i + j * 16] = false;
-                        int k = this.b(i, j);
-                        int l = this.locX * 16 + i;
-                        int i1 = this.locZ * 16 + j;
-                        int j1 = Integer.MAX_VALUE;
-
-                        Iterator iterator;
-                        EnumDirection enumdirection;
-
-                        for (iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator(); iterator.hasNext(); j1 = Math.min(j1, this.world.c(l + enumdirection.getAdjacentX(), i1 + enumdirection.getAdjacentZ()))) {
-                            enumdirection = (EnumDirection) iterator.next();
-                        }
-
-                        this.b(l, i1, j1);
-                        iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
-
-                        while (iterator.hasNext()) {
-                            enumdirection = (EnumDirection) iterator.next();
-                            this.b(l + enumdirection.getAdjacentX(), i1 + enumdirection.getAdjacentZ(), k);
-                        }
-
-                        if (flag) {
-                            this.world.methodProfiler.b();
-                            return;
-                        }
-                    }
-                }
-            }
-
-            this.m = false;
-        }
-
-        this.world.methodProfiler.b();
-    }
-
-    private void b(int i, int j, int k) {
-        int l = this.world.getHighestBlockYAt(new BlockPosition(i, 0, j)).getY();
-
-        if (l > k) {
-            this.a(i, j, k, l + 1);
-        } else if (l < k) {
-            this.a(i, j, l, k + 1);
-        }
-
-    }
-
-    private void a(int i, int j, int k, int l) {
-        if (l > k && this.world.areChunksLoaded(new BlockPosition(i, 0, j), 16)) {
-            for (int i1 = k; i1 < l; ++i1) {
-                this.world.c(EnumSkyBlock.SKY, new BlockPosition(i, i1, j));
-            }
-
-            this.s = true;
-        }
-
-    }
-
-    private void c(int i, int j, int k) {
-        int l = this.heightMap[k << 4 | i] & 255;
-        int i1 = l;
-
-        if (j > l) {
-            i1 = j;
-        }
-
-        while (i1 > 0 && this.d(i, i1 - 1, k) == 0) {
-            --i1;
-        }
-
-        if (i1 != l) {
-            this.world.a(i + this.locX * 16, k + this.locZ * 16, i1, l);
-            this.heightMap[k << 4 | i] = i1;
-            int j1 = this.locX * 16 + i;
-            int k1 = this.locZ * 16 + k;
-            int l1;
-            int i2;
-
-            if (!this.world.worldProvider.m()) {
-                ChunkSection chunksection;
-
-                if (i1 < l) {
-                    for (l1 = i1; l1 < l; ++l1) {
-                        chunksection = this.sections[l1 >> 4];
-                        if (chunksection != Chunk.a) {
-                            chunksection.a(i, l1 & 15, k, 15);
-                            this.world.m(new BlockPosition((this.locX << 4) + i, l1, (this.locZ << 4) + k));
-                        }
-                    }
-                } else {
-                    for (l1 = l; l1 < i1; ++l1) {
-                        chunksection = this.sections[l1 >> 4];
-                        if (chunksection != Chunk.a) {
-                            chunksection.a(i, l1 & 15, k, 0);
-                            this.world.m(new BlockPosition((this.locX << 4) + i, l1, (this.locZ << 4) + k));
-                        }
-                    }
-                }
-
-                l1 = 15;
-
-                while (i1 > 0 && l1 > 0) {
-                    --i1;
-                    i2 = this.d(i, i1, k);
-                    if (i2 == 0) {
-                        i2 = 1;
-                    }
-
-                    l1 -= i2;
-                    if (l1 < 0) {
-                        l1 = 0;
-                    }
-
-                    ChunkSection chunksection1 = this.sections[i1 >> 4];
-
-                    if (chunksection1 != Chunk.a) {
-                        chunksection1.a(i, i1 & 15, k, l1);
-                    }
-                }
-            }
-
-            l1 = this.heightMap[k << 4 | i];
-            i2 = l;
-            int j2 = l1;
-
-            if (l1 < l) {
-                i2 = l1;
-                j2 = l;
-            }
-
-            if (l1 < this.v) {
-                this.v = l1;
-            }
-
-            if (!this.world.worldProvider.m()) {
-                Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
-
-                while (iterator.hasNext()) {
-                    EnumDirection enumdirection = (EnumDirection) iterator.next();
-
-                    this.a(j1 + enumdirection.getAdjacentX(), k1 + enumdirection.getAdjacentZ(), i2, j2);
-                }
-
-                this.a(j1, k1, i2, j2);
-            }
-
-            this.s = true;
-        }
-    }
-
-    public int b(BlockPosition blockposition) {
-        return this.getBlockData(blockposition).c();
-    }
-
-    private int d(int i, int j, int k) {
-        return this.a(i, j, k).c();
-    }
-
-    public IBlockData getBlockData(BlockPosition blockposition) {
-        return this.a(blockposition.getX(), blockposition.getY(), blockposition.getZ());
-    }
-
-    public IBlockData a(final int i, final int j, final int k) {
-        if (this.world.L() == WorldType.DEBUG_ALL_BLOCK_STATES) {
-            IBlockData iblockdata = null;
-
-            if (j == 60) {
-                iblockdata = Blocks.BARRIER.getBlockData();
-            }
-
-            if (j == 70) {
-                iblockdata = ChunkProviderDebug.c(i, k);
-            }
-
-            return iblockdata == null ? Blocks.AIR.getBlockData() : iblockdata;
-        } else {
-            try {
-                if (j >= 0 && j >> 4 < this.sections.length) {
-                    ChunkSection chunksection = this.sections[j >> 4];
-
-                    if (chunksection != Chunk.a) {
-                        return chunksection.getType(i & 15, j & 15, k & 15);
-                    }
-                }
-
-                return Blocks.AIR.getBlockData();
-            } catch (Throwable throwable) {
-                CrashReport crashreport = CrashReport.a(throwable, "Getting block state");
-                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being got");
-
-                crashreportsystemdetails.a("Location", new CrashReportCallable() {
-                    public String a() throws Exception {
-                        return CrashReportSystemDetails.a(i, j, k);
-                    }
-
-                    public Object call() throws Exception {
-                        return this.a();
-                    }
-                });
-                throw new ReportedException(crashreport);
-            }
-        }
-    }
-
-    @Nullable
-    public IBlockData a(BlockPosition blockposition, IBlockData iblockdata) {
-        int i = blockposition.getX() & 15;
-        int j = blockposition.getY();
-        int k = blockposition.getZ() & 15;
-        int l = k << 4 | i;
-
-        if (j >= this.h[l] - 1) {
-            this.h[l] = -999;
-        }
-
-        int i1 = this.heightMap[l];
-        IBlockData iblockdata1 = this.getBlockData(blockposition);
-
-        if (iblockdata1 == iblockdata) {
-            return null;
-        } else {
-            Block block = iblockdata.getBlock();
-            Block block1 = iblockdata1.getBlock();
-            ChunkSection chunksection = this.sections[j >> 4];
-            boolean flag = false;
-
-            if (chunksection == Chunk.a) {
-                if (block == Blocks.AIR) {
-                    return null;
-                }
-
-                chunksection = new ChunkSection(j >> 4 << 4, !this.world.worldProvider.m());
-                this.sections[j >> 4] = chunksection;
-                flag = j >= i1;
-            }
-
-            chunksection.setType(i, j & 15, k, iblockdata);
-            if (block1 != block) {
-                if (!this.world.isClientSide) {
-                    block1.remove(this.world, blockposition, iblockdata1);
-                } else if (block1 instanceof ITileEntity) {
-                    this.world.s(blockposition);
-                }
-            }
-
-            if (chunksection.getType(i, j & 15, k).getBlock() != block) {
-                return null;
-            } else {
-                if (flag) {
-                    this.initLighting();
-                } else {
-                    int j1 = iblockdata.c();
-                    int k1 = iblockdata1.c();
-
-                    if (j1 > 0) {
-                        if (j >= i1) {
-                            this.c(i, j + 1, k);
-                        }
-                    } else if (j == i1 - 1) {
-                        this.c(i, j, k);
-                    }
-
-                    if (j1 != k1 && (j1 < k1 || this.getBrightness(EnumSkyBlock.SKY, blockposition) > 0 || this.getBrightness(EnumSkyBlock.BLOCK, blockposition) > 0)) {
-                        this.d(i, k);
-                    }
-                }
-
-                TileEntity tileentity;
-
-                if (block1 instanceof ITileEntity) {
-                    tileentity = this.a(blockposition, Chunk.EnumTileEntityState.CHECK);
-                    if (tileentity != null) {
-                        tileentity.invalidateBlockCache();
-                    }
-                }
-
-                // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
-                if (!this.world.isClientSide && block1 != block  && (!this.world.captureBlockStates || block instanceof BlockTileEntity)) {
-                    block.onPlace(this.world, blockposition, iblockdata);
-                }
-
-                if (block instanceof ITileEntity) {
-                    tileentity = this.a(blockposition, Chunk.EnumTileEntityState.CHECK);
-                    if (tileentity == null) {
-                        tileentity = ((ITileEntity) block).a(this.world, block.toLegacyData(iblockdata));
-                        this.world.setTileEntity(blockposition, tileentity);
-                    }
-
-                    if (tileentity != null) {
-                        tileentity.invalidateBlockCache();
-                    }
-                }
-
-                this.s = true;
-                return iblockdata1;
-            }
-        }
-    }
-
-    public int getBrightness(EnumSkyBlock enumskyblock, BlockPosition blockposition) {
-        int i = blockposition.getX() & 15;
-        int j = blockposition.getY();
-        int k = blockposition.getZ() & 15;
-        ChunkSection chunksection = this.sections[j >> 4];
-
-        return chunksection == Chunk.a ? (this.c(blockposition) ? enumskyblock.c : 0) : (enumskyblock == EnumSkyBlock.SKY ? (this.world.worldProvider.m() ? 0 : chunksection.b(i, j & 15, k)) : (enumskyblock == EnumSkyBlock.BLOCK ? chunksection.c(i, j & 15, k) : enumskyblock.c));
-    }
-
-    public void a(EnumSkyBlock enumskyblock, BlockPosition blockposition, int i) {
-        int j = blockposition.getX() & 15;
-        int k = blockposition.getY();
-        int l = blockposition.getZ() & 15;
-        ChunkSection chunksection = this.sections[k >> 4];
-
-        if (chunksection == Chunk.a) {
-            chunksection = new ChunkSection(k >> 4 << 4, !this.world.worldProvider.m());
-            this.sections[k >> 4] = chunksection;
-            this.initLighting();
-        }
-
-        this.s = true;
-        if (enumskyblock == EnumSkyBlock.SKY) {
-            if (!this.world.worldProvider.m()) {
-                chunksection.a(j, k & 15, l, i);
-            }
-        } else if (enumskyblock == EnumSkyBlock.BLOCK) {
-            chunksection.b(j, k & 15, l, i);
-        }
-
-    }
-
-    public int a(BlockPosition blockposition, int i) {
-        int j = blockposition.getX() & 15;
-        int k = blockposition.getY();
-        int l = blockposition.getZ() & 15;
-        ChunkSection chunksection = this.sections[k >> 4];
-
-        if (chunksection == Chunk.a) {
-            return !this.world.worldProvider.m() && i < EnumSkyBlock.SKY.c ? EnumSkyBlock.SKY.c - i : 0;
-        } else {
-            int i1 = this.world.worldProvider.m() ? 0 : chunksection.b(j, k & 15, l);
-
-            i1 -= i;
-            int j1 = chunksection.c(j, k & 15, l);
-
-            if (j1 > i1) {
-                i1 = j1;
-            }
-
-            return i1;
-        }
-    }
-
-    public void a(Entity entity) {
-        this.t = true;
-        int i = MathHelper.floor(entity.locX / 16.0D);
-        int j = MathHelper.floor(entity.locZ / 16.0D);
-
-        if (i != this.locX || j != this.locZ) {
-            Chunk.e.warn("Wrong location! ({}, {}) should be ({}, {}), {}", new Object[] { Integer.valueOf(i), Integer.valueOf(j), Integer.valueOf(this.locX), Integer.valueOf(this.locZ), entity, entity});
-            entity.die();
-        }
-
-        int k = MathHelper.floor(entity.locY / 16.0D);
-
-        if (k < 0) {
-            k = 0;
-        }
-
-        if (k >= this.entitySlices.length) {
-            k = this.entitySlices.length - 1;
-        }
-
-        entity.ab = true;
-        entity.ac = this.locX;
-        entity.ad = k;
-        entity.ae = this.locZ;
-        this.entitySlices[k].add(entity);
-        // Spigot start - increment creature type count
-        // Keep this synced up with World.a(Class)
-        if (entity instanceof EntityInsentient) {
-            EntityInsentient entityinsentient = (EntityInsentient) entity;
-            if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
-                return;
-            }
-        }
-        for ( EnumCreatureType creatureType : EnumCreatureType.values() )
-        {
-            if ( creatureType.a().isAssignableFrom( entity.getClass() ) )
-            {
-                this.entityCount.adjustOrPutValue( creatureType.a(), 1, 1 );
-            }
-        }
-        // Spigot end
-    }
-
-    public void b(Entity entity) {
-        this.a(entity, entity.ad);
-    }
-
-    public void a(Entity entity, int i) {
-        if (i < 0) {
-            i = 0;
-        }
-
-        if (i >= this.entitySlices.length) {
-            i = this.entitySlices.length - 1;
-        }
-
-        this.entitySlices[i].remove(entity);
-        // Spigot start - decrement creature type count
-        // Keep this synced up with World.a(Class)
-        if (entity instanceof EntityInsentient) {
-            EntityInsentient entityinsentient = (EntityInsentient) entity;
-            if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
-                return;
-            }
-        }
-        for ( EnumCreatureType creatureType : EnumCreatureType.values() )
-        {
-            if ( creatureType.a().isAssignableFrom( entity.getClass() ) )
-            {
-                this.entityCount.adjustValue( creatureType.a(), -1 );
-            }
-        }
-        // Spigot end
-    }
-
-    public boolean c(BlockPosition blockposition) {
-        int i = blockposition.getX() & 15;
-        int j = blockposition.getY();
-        int k = blockposition.getZ() & 15;
-
-        return j >= this.heightMap[k << 4 | i];
-    }
-
-    @Nullable
-    private TileEntity g(BlockPosition blockposition) {
-        IBlockData iblockdata = this.getBlockData(blockposition);
-        Block block = iblockdata.getBlock();
-
-        return !block.isTileEntity() ? null : ((ITileEntity) block).a(this.world, iblockdata.getBlock().toLegacyData(iblockdata));
-    }
-
-    @Nullable
-    public TileEntity a(BlockPosition blockposition, Chunk.EnumTileEntityState chunk_enumtileentitystate) {
-        // CraftBukkit start
-        TileEntity tileentity = null;
-        if (world.captureBlockStates) {
-            tileentity = world.capturedTileEntities.get(blockposition);
-        }
-        if (tileentity == null) {
-            tileentity = (TileEntity) this.tileEntities.get(blockposition);
-        }
-        // CraftBukkit end
-
-        if (tileentity == null) {
-            if (chunk_enumtileentitystate == Chunk.EnumTileEntityState.IMMEDIATE) {
-                tileentity = this.g(blockposition);
-                this.world.setTileEntity(blockposition, tileentity);
-            } else if (chunk_enumtileentitystate == Chunk.EnumTileEntityState.QUEUED) {
-                this.y.add(blockposition);
-            }
-        } else if (tileentity.x()) {
-            this.tileEntities.remove(blockposition);
-            return null;
-        }
-
-        return tileentity;
-    }
-
-    public void a(TileEntity tileentity) {
-        this.a(tileentity.getPosition(), tileentity);
-        if (this.j) {
-            this.world.a(tileentity);
-        }
-
-    }
-
-    public void a(BlockPosition blockposition, TileEntity tileentity) {
-        tileentity.a(this.world);
-        tileentity.setPosition(blockposition);
-        if (this.getBlockData(blockposition).getBlock() instanceof ITileEntity) {
-            if (this.tileEntities.containsKey(blockposition)) {
-                ((TileEntity) this.tileEntities.get(blockposition)).y();
-            }
-
-            tileentity.z();
-            this.tileEntities.put(blockposition, tileentity);
-            // CraftBukkit start
-        } else {
-            System.out.println("Attempted to place a tile entity (" + tileentity + ") at " + tileentity.position.getX() + "," + tileentity.position.getY() + "," + tileentity.position.getZ()
-                + " (" + org.bukkit.craftbukkit.util.CraftMagicNumbers.getMaterial(getBlockData(blockposition).getBlock()) + ") where there was no entity tile!");
-            System.out.println("Chunk coordinates: " + (this.locX * 16) + "," + (this.locZ * 16));
-            new Exception().printStackTrace();
-            // CraftBukkit end
-        }
-    }
-
-    public void d(BlockPosition blockposition) {
-        if (this.j) {
-            TileEntity tileentity = (TileEntity) this.tileEntities.remove(blockposition);
-
-            if (tileentity != null) {
-                tileentity.y();
-            }
-        }
-
-    }
-
-    public void addEntities() {
-        this.j = true;
-        this.world.b(this.tileEntities.values());
-        List[] aentityslice = this.entitySlices; // Spigot
-        int i = aentityslice.length;
-
-        for (int j = 0; j < i; ++j) {
-            List entityslice = aentityslice[j]; // Spigot
-
-            this.world.a((Collection) entityslice);
-        }
-
-    }
-
-    public void removeEntities() {
-        this.j = false;
-        Iterator iterator = this.tileEntities.values().iterator();
-
-        while (iterator.hasNext()) {
-            TileEntity tileentity = (TileEntity) iterator.next();
-            // Spigot Start
-            if ( tileentity instanceof IInventory )
-            {
-                for ( org.bukkit.entity.HumanEntity h : Lists.<org.bukkit.entity.HumanEntity>newArrayList((List<org.bukkit.entity.HumanEntity>) ( (IInventory) tileentity ).getViewers() ) )
-                {
-                    if ( h instanceof org.bukkit.craftbukkit.entity.CraftHumanEntity )
-                    {
-                       ( (org.bukkit.craftbukkit.entity.CraftHumanEntity) h).getHandle().closeInventory();
-                    }
-                }
-            }
-            // Spigot End
-
-            this.world.b(tileentity);
-        }
-
-        List[] aentityslice = this.entitySlices; // Spigot
-        int i = aentityslice.length;
-
-        for (int j = 0; j < i; ++j) {
-            // CraftBukkit start
-            List<Entity> newList = Lists.newArrayList(aentityslice[j]);
-            java.util.Iterator<Entity> iter = newList.iterator();
-            while (iter.hasNext()) {
-                Entity entity = iter.next();
-                // Spigot Start
-                if ( entity instanceof IInventory )
-                {
-                    for ( org.bukkit.entity.HumanEntity h : Lists.<org.bukkit.entity.HumanEntity>newArrayList( (List<org.bukkit.entity.HumanEntity>) ( (IInventory) entity ).getViewers() ) )
-                    {
-                        if ( h instanceof org.bukkit.craftbukkit.entity.CraftHumanEntity )
-                        {
-                           ( (org.bukkit.craftbukkit.entity.CraftHumanEntity) h).getHandle().closeInventory();
-                        }
-                    }
-                }
-                // Spigot End
-
-                // Do not pass along players, as doing so can get them stuck outside of time.
-                // (which for example disables inventory icon updates and prevents block breaking)
-                if (entity instanceof EntityPlayer) {
-                    iter.remove();
-                }
-            }
-
-            this.world.c(newList);
-            // CraftBukkit end
-        }
-
-    }
-
-    public void e() {
-        this.s = true;
-    }
-
-    public void a(@Nullable Entity entity, AxisAlignedBB axisalignedbb, List<Entity> list, Predicate<? super Entity> predicate) {
-        int i = MathHelper.floor((axisalignedbb.b - 2.0D) / 16.0D);
-        int j = MathHelper.floor((axisalignedbb.e + 2.0D) / 16.0D);
-
-        i = MathHelper.clamp(i, 0, this.entitySlices.length - 1);
-        j = MathHelper.clamp(j, 0, this.entitySlices.length - 1);
-
-        for (int k = i; k <= j; ++k) {
-            if (!this.entitySlices[k].isEmpty()) {
-                Iterator iterator = this.entitySlices[k].iterator();
-
-                while (iterator.hasNext()) {
-                    Entity entity1 = (Entity) iterator.next();
-
-                    if (entity1.getBoundingBox().b(axisalignedbb) && entity1 != entity) {
-                        if (predicate == null || predicate.apply(entity1)) {
-                            list.add(entity1);
-                        }
-
-                        Entity[] aentity = entity1.aT();
-
-                        if (aentity != null) {
-                            Entity[] aentity1 = aentity;
-                            int l = aentity.length;
-
-                            for (int i1 = 0; i1 < l; ++i1) {
-                                Entity entity2 = aentity1[i1];
-
-                                if (entity2 != entity && entity2.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply(entity2))) {
-                                    list.add(entity2);
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-    }
-
-    public <T extends Entity> void a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb, List<T> list, Predicate<? super T> predicate) {
-        int i = MathHelper.floor((axisalignedbb.b - 2.0D) / 16.0D);
-        int j = MathHelper.floor((axisalignedbb.e + 2.0D) / 16.0D);
-
-        i = MathHelper.clamp(i, 0, this.entitySlices.length - 1);
-        j = MathHelper.clamp(j, 0, this.entitySlices.length - 1);
-
-        for (int k = i; k <= j; ++k) {
-            Iterator iterator = this.entitySlices[k].iterator(); // Spigot
-
-            while (iterator.hasNext()) {
-                Entity entity = (Entity) iterator.next();
-
-                if (oclass.isInstance(entity) && entity.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply((T) entity))) { // CraftBukkit - fix decompile error // Spigot
-                    list.add((T) entity); // Fix decompile error
-                }
-            }
-        }
-
-    }
-
-    public boolean a(boolean flag) {
-        if (flag) {
-            if (this.t && this.world.getTime() != this.lastSaved || this.s) {
-                return true;
-            }
-        } else if (this.t && this.world.getTime() >= this.lastSaved + MinecraftServer.getServer().autosavePeriod * 4) { // Spigot - Only save if we've passed 2 auto save intervals without modification
-            return true;
-        }
-
-        return this.s;
-    }
-
-    public Random a(long i) {
-        return new Random(this.world.getSeed() + (long) (this.locX * this.locX * 4987142) + (long) (this.locX * 5947611) + (long) (this.locZ * this.locZ) * 4392871L + (long) (this.locZ * 389711) ^ i);
-    }
-
-    public boolean isEmpty() {
-        return false;
-    }
-
-    // CraftBukkit start
-    public void loadNearby(IChunkProvider ichunkprovider, ChunkGenerator chunkgenerator, boolean newChunk) {
-        world.timings.syncChunkLoadPostTimer.startTiming(); // Spigot
-        Server server = world.getServer();
-        if (server != null) {
-            /*
-             * If it's a new world, the first few chunks are generated inside
-             * the World constructor. We can't reliably alter that, so we have
-             * no way of creating a CraftWorld/CraftServer at that point.
-             */
-            server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(bukkitChunk, newChunk));
-        }
-
-        // Update neighbor counts
-        for (int x = -2; x < 3; x++) {
-            for (int z = -2; z < 3; z++) {
-                if (x == 0 && z == 0) {
-                    continue;
-                }
-
-                Chunk neighbor = getWorld().getChunkIfLoaded(locX + x, locZ + z);
-                if (neighbor != null) {
-                    neighbor.setNeighborLoaded(-x, -z);
-                    setNeighborLoaded(x, z);
-                }
-            }
-        }
-        // CraftBukkit end
-
-        Chunk chunk = ichunkprovider.getLoadedChunkAt(this.locX, this.locZ - 1);
-        Chunk chunk1 = ichunkprovider.getLoadedChunkAt(this.locX + 1, this.locZ);
-        Chunk chunk2 = ichunkprovider.getLoadedChunkAt(this.locX, this.locZ + 1);
-        Chunk chunk3 = ichunkprovider.getLoadedChunkAt(this.locX - 1, this.locZ);
-
-        if (chunk1 != null && chunk2 != null && ichunkprovider.getLoadedChunkAt(this.locX + 1, this.locZ + 1) != null) {
-            this.a(chunkgenerator);
-        }
-
-        if (chunk3 != null && chunk2 != null && ichunkprovider.getLoadedChunkAt(this.locX - 1, this.locZ + 1) != null) {
-            chunk3.a(chunkgenerator);
-        }
-
-        if (chunk != null && chunk1 != null && ichunkprovider.getLoadedChunkAt(this.locX + 1, this.locZ - 1) != null) {
-            chunk.a(chunkgenerator);
-        }
-
-        if (chunk != null && chunk3 != null) {
-            Chunk chunk4 = ichunkprovider.getLoadedChunkAt(this.locX - 1, this.locZ - 1);
-
-            if (chunk4 != null) {
-                chunk4.a(chunkgenerator);
-            }
-        }
-        world.timings.syncChunkLoadPostTimer.stopTiming(); // Spigot
-
-    }
-
-    protected void a(ChunkGenerator chunkgenerator) {
-        if (this.isDone()) {
-            if (chunkgenerator.a(this, this.locX, this.locZ)) {
-                this.e();
-            }
-        } else {
-            this.o();
-            chunkgenerator.recreateStructures(this.locX, this.locZ);
-
-            // CraftBukkit start
-            BlockSand.instaFall = true;
-            Random random = new Random();
-            random.setSeed(world.getSeed());
-            long xRand = random.nextLong() / 2L * 2L + 1L;
-            long zRand = random.nextLong() / 2L * 2L + 1L;
-            random.setSeed((long) locX * xRand + (long) locZ * zRand ^ world.getSeed());
-
-            org.bukkit.World world = this.world.getWorld();
-            if (world != null) {
-                this.world.populating = true;
-                try {
-                    for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
-                        populator.populate(world, random, bukkitChunk);
-                    }
-                } finally {
-                    this.world.populating = false;
-                }
-            }
-            BlockSand.instaFall = false;
-            this.world.getServer().getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(bukkitChunk));
-            // CraftBukkit end
-            this.e();
-        }
-
-    }
-
-    public BlockPosition f(BlockPosition blockposition) {
-        int i = blockposition.getX() & 15;
-        int j = blockposition.getZ() & 15;
-        int k = i | j << 4;
-        BlockPosition blockposition1 = new BlockPosition(blockposition.getX(), this.h[k], blockposition.getZ());
-
-        if (blockposition1.getY() == -999) {
-            int l = this.g() + 15;
-
-            blockposition1 = new BlockPosition(blockposition.getX(), l, blockposition.getZ());
-            int i1 = -1;
-
-            while (blockposition1.getY() > 0 && i1 == -1) {
-                IBlockData iblockdata = this.getBlockData(blockposition1);
-                Material material = iblockdata.getMaterial();
-
-                if (!material.isSolid() && !material.isLiquid()) {
-                    blockposition1 = blockposition1.down();
-                } else {
-                    i1 = blockposition1.getY() + 1;
-                }
-            }
-
-            this.h[k] = i1;
-        }
-
-        return new BlockPosition(blockposition.getX(), this.h[k], blockposition.getZ());
-    }
-
-    public void b(boolean flag) {
-        if (this.m && !this.world.worldProvider.m() && !flag) {
-            this.h(this.world.isClientSide);
-        }
-
-        this.r = true;
-        if (!this.lit && this.done && this.world.spigotConfig.randomLightUpdates) { // Spigot - also use random light updates setting to determine if we should relight
-            this.o();
-        }
-
-        while (!this.y.isEmpty()) {
-            BlockPosition blockposition = (BlockPosition) this.y.poll();
-
-            if (this.a(blockposition, Chunk.EnumTileEntityState.CHECK) == null && this.getBlockData(blockposition).getBlock().isTileEntity()) {
-                TileEntity tileentity = this.g(blockposition);
-
-                this.world.setTileEntity(blockposition, tileentity);
-                this.world.b(blockposition, blockposition);
-            }
-        }
-
-    }
-
-    public boolean isReady() {
-        // Spigot Start
-        /*
-         * As of 1.7, Mojang added a check to make sure that only chunks which have been lit are sent to the client.
-         * Unfortunately this interferes with our modified chunk ticking algorithm, which will only tick chunks distant from the player on a very infrequent basis.
-         * We cannot unfortunately do this lighting stage during chunk gen as it appears to put a lot more noticeable load on the server, than when it is done at play time.
-         * For now at least we will simply send all chunks, in accordance with pre 1.7 behaviour.
-         */
-        return true;
-        // Spigot End
-    }
-
-    public boolean j() {
-        return this.r;
-    }
-
-    public ChunkCoordIntPair k() {
-        return new ChunkCoordIntPair(this.locX, this.locZ);
-    }
-
-    public boolean c(int i, int j) {
-        if (i < 0) {
-            i = 0;
-        }
-
-        if (j >= 256) {
-            j = 255;
-        }
-
-        for (int k = i; k <= j; k += 16) {
-            ChunkSection chunksection = this.sections[k >> 4];
-
-            if (chunksection != Chunk.a && !chunksection.a()) {
-                return false;
-            }
-        }
-
-        return true;
-    }
-
-    public void a(ChunkSection[] achunksection) {
-        if (this.sections.length != achunksection.length) {
-            Chunk.e.warn("Could not set level chunk sections, array length is {} instead of {}", new Object[] { Integer.valueOf(achunksection.length), Integer.valueOf(this.sections.length)});
-        } else {
-            System.arraycopy(achunksection, 0, this.sections, 0, this.sections.length);
-        }
-    }
-
-    public BiomeBase getBiome(BlockPosition blockposition, WorldChunkManager worldchunkmanager) {
-        int i = blockposition.getX() & 15;
-        int j = blockposition.getZ() & 15;
-        int k = this.g[j << 4 | i] & 255;
-        BiomeBase biomebase;
-
-        if (k == 255) {
-            biomebase = worldchunkmanager.getBiome(blockposition, Biomes.c);
-            k = BiomeBase.a(biomebase);
-            this.g[j << 4 | i] = (byte) (k & 255);
-        }
-
-        biomebase = BiomeBase.getBiome(k);
-        return biomebase == null ? Biomes.c : biomebase;
-    }
-
-    public byte[] getBiomeIndex() {
-        return this.g;
-    }
-
-    public void a(byte[] abyte) {
-        if (this.g.length != abyte.length) {
-            Chunk.e.warn("Could not set level chunk biomes, array length is {} instead of {}", new Object[] { Integer.valueOf(abyte.length), Integer.valueOf(this.g.length)});
-        } else {
-            System.arraycopy(abyte, 0, this.g, 0, this.g.length);
-        }
-    }
-
-    public void m() {
-        this.x = 0;
-    }
-
-    public void n() {
-        if (this.x < 4096) {
-            BlockPosition blockposition = new BlockPosition(this.locX << 4, 0, this.locZ << 4);
-
-            for (int i = 0; i < 8; ++i) {
-                if (this.x >= 4096) {
-                    return;
-                }
-
-                int j = this.x % 16;
-                int k = this.x / 16 % 16;
-                int l = this.x / 256;
-
-                ++this.x;
-
-                for (int i1 = 0; i1 < 16; ++i1) {
-                    BlockPosition blockposition1 = blockposition.a(k, (j << 4) + i1, l);
-                    boolean flag = i1 == 0 || i1 == 15 || k == 0 || k == 15 || l == 0 || l == 15;
-
-                    if (this.sections[j] == Chunk.a && flag || this.sections[j] != Chunk.a && this.sections[j].getType(k, i1, l).getMaterial() == Material.AIR) {
-                        EnumDirection[] aenumdirection = EnumDirection.values();
-                        int j1 = aenumdirection.length;
-
-                        for (int k1 = 0; k1 < j1; ++k1) {
-                            EnumDirection enumdirection = aenumdirection[k1];
-                            BlockPosition blockposition2 = blockposition1.shift(enumdirection);
-
-                            if (this.world.getType(blockposition2).d() > 0) {
-                                this.world.w(blockposition2);
-                            }
-                        }
-
-                        this.world.w(blockposition1);
-                    }
-                }
-            }
-
-        }
-    }
-
-    public void o() {
-        this.done = true;
-        this.lit = true;
-        BlockPosition blockposition = new BlockPosition(this.locX << 4, 0, this.locZ << 4);
-
-        if (!this.world.worldProvider.m()) {
-            if (this.world.areChunksLoadedBetween(blockposition.a(-1, 0, -1), blockposition.a(16, this.world.K(), 16))) {
-                label42:
-                for (int i = 0; i < 16; ++i) {
-                    for (int j = 0; j < 16; ++j) {
-                        if (!this.e(i, j)) {
-                            this.lit = false;
-                            break label42;
-                        }
-                    }
-                }
-
-                if (this.lit) {
-                    Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
-
-                    while (iterator.hasNext()) {
-                        EnumDirection enumdirection = (EnumDirection) iterator.next();
-                        int k = enumdirection.c() == EnumDirection.EnumAxisDirection.POSITIVE ? 16 : 1;
-
-                        this.world.getChunkAtWorldCoords(blockposition.shift(enumdirection, k)).a(enumdirection.opposite());
-                    }
-
-                    this.z();
-                }
-            } else {
-                this.lit = false;
-            }
-        }
-
-    }
-
-    private void z() {
-        for (int i = 0; i < this.i.length; ++i) {
-            this.i[i] = true;
-        }
-
-        this.h(false);
-    }
-
-    private void a(EnumDirection enumdirection) {
-        if (this.done) {
-            int i;
-
-            if (enumdirection == EnumDirection.EAST) {
-                for (i = 0; i < 16; ++i) {
-                    this.e(15, i);
-                }
-            } else if (enumdirection == EnumDirection.WEST) {
-                for (i = 0; i < 16; ++i) {
-                    this.e(0, i);
-                }
-            } else if (enumdirection == EnumDirection.SOUTH) {
-                for (i = 0; i < 16; ++i) {
-                    this.e(i, 15);
-                }
-            } else if (enumdirection == EnumDirection.NORTH) {
-                for (i = 0; i < 16; ++i) {
-                    this.e(i, 0);
-                }
-            }
-
-        }
-    }
-
-    private boolean e(int i, int j) {
-        int k = this.g();
-        boolean flag = false;
-        boolean flag1 = false;
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition((this.locX << 4) + i, 0, (this.locZ << 4) + j);
-
-        int l;
-
-        for (l = k + 16 - 1; l > this.world.K() || l > 0 && !flag1; --l) {
-            blockposition_mutableblockposition.c(blockposition_mutableblockposition.getX(), l, blockposition_mutableblockposition.getZ());
-            int i1 = this.b((BlockPosition) blockposition_mutableblockposition);
-
-            if (i1 == 255 && blockposition_mutableblockposition.getY() < this.world.K()) {
-                flag1 = true;
-            }
-
-            if (!flag && i1 > 0) {
-                flag = true;
-            } else if (flag && i1 == 0 && !this.world.w(blockposition_mutableblockposition)) {
-                return false;
-            }
-        }
-
-        for (l = blockposition_mutableblockposition.getY(); l > 0; --l) {
-            blockposition_mutableblockposition.c(blockposition_mutableblockposition.getX(), l, blockposition_mutableblockposition.getZ());
-            if (this.getBlockData(blockposition_mutableblockposition).d() > 0) {
-                this.world.w(blockposition_mutableblockposition);
-            }
-        }
-
-        return true;
-    }
-
-    public boolean p() {
-        return this.j;
-    }
-
-    public World getWorld() {
-        return this.world;
-    }
-
-    public int[] r() {
-        return this.heightMap;
-    }
-
-    public void a(int[] aint) {
-        if (this.heightMap.length != aint.length) {
-            Chunk.e.warn("Could not set level chunk heightmap, array length is {} instead of {}", new Object[] { Integer.valueOf(aint.length), Integer.valueOf(this.heightMap.length)});
-        } else {
-            System.arraycopy(aint, 0, this.heightMap, 0, this.heightMap.length);
-        }
-    }
-
-    public Map<BlockPosition, TileEntity> getTileEntities() {
-        return this.tileEntities;
-    }
-
-    public List<Entity>[] getEntitySlices() {
-        return this.entitySlices;
-    }
-
-    public boolean isDone() {
-        return this.done;
-    }
-
-    public void d(boolean flag) {
-        this.done = flag;
-    }
-
-    public boolean v() {
-        return this.lit;
-    }
-
-    public void e(boolean flag) {
-        this.lit = flag;
-    }
-
-    public void f(boolean flag) {
-        this.s = flag;
-    }
-
-    public void g(boolean flag) {
-        this.t = flag;
-    }
-
-    public void setLastSaved(long i) {
-        this.lastSaved = i;
-    }
-
-    public int w() {
-        return this.v;
-    }
-
-    public long x() {
-        return this.w;
-    }
-
-    public void c(long i) {
-        this.w = i;
-    }
-
-    public static enum EnumTileEntityState {
-
-        IMMEDIATE, QUEUED, CHECK;
-
-        private EnumTileEntityState() {}
-    }
-}
+package net.minecraft.server;
+
+import com.google.common.base.Predicate;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import javax.annotation.Nullable;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import com.google.common.collect.Lists; // CraftBukkit
+import java.util.Queue;
+import org.bukkit.Server; // CraftBukkit
+
+public class Chunk {
+
+    private static final Logger e = LogManager.getLogger();
+    public static final ChunkSection a = null;
+    private final ChunkSection[] sections;
+    private final byte[] g;
+    private final int[] h;
+    private final boolean[] i;
+    private boolean j;
+    public final World world;
+    public final int[] heightMap;
+    public final int locX;
+    public final int locZ;
+    private boolean m;
+    public final Map<BlockPosition, TileEntity> tileEntities;
+    //public final List<Entity>[] entitySlices; // Spigot
+    public final Queue<Entity>[] entitySlices;
+    private boolean done;
+    private boolean lit;
+    private boolean r;
+    private boolean s;
+    private boolean t;
+    private long lastSaved;
+    private int v;
+    private long w;
+    private int x;
+    private ConcurrentLinkedQueue<BlockPosition> y;
+    public boolean d;
+    protected gnu.trove.map.hash.TObjectIntHashMap<Class> entityCount = new gnu.trove.map.hash.TObjectIntHashMap<Class>(); // Spigot
+
+    // CraftBukkit start - Neighbor loaded cache for chunk lighting and entity ticking
+    private int neighbors = 0x1 << 12;
+    public long chunkKey;
+
+    public boolean areNeighborsLoaded(final int radius) {
+        switch (radius) {
+            case 2:
+                return this.neighbors == Integer.MAX_VALUE >> 6;
+            case 1:
+                final int mask =
+                        //       x        z   offset          x        z   offset          x         z   offset
+                        (0x1 << (1 * 5 +  1 + 12)) | (0x1 << (0 * 5 +  1 + 12)) | (0x1 << (-1 * 5 +  1 + 12)) |
+                        (0x1 << (1 * 5 +  0 + 12)) | (0x1 << (0 * 5 +  0 + 12)) | (0x1 << (-1 * 5 +  0 + 12)) |
+                        (0x1 << (1 * 5 + -1 + 12)) | (0x1 << (0 * 5 + -1 + 12)) | (0x1 << (-1 * 5 + -1 + 12));
+                return (this.neighbors & mask) == mask;
+            default:
+                throw new UnsupportedOperationException(String.valueOf(radius));
+        }
+    }
+
+    public void setNeighborLoaded(final int x, final int z) {
+        this.neighbors |= 0x1 << (x * 5 + 12 + z);
+    }
+
+    public void setNeighborUnloaded(final int x, final int z) {
+        this.neighbors &= ~(0x1 << (x * 5 + 12 + z));
+    }
+    // CraftBukkit end
+
+    public Chunk(World world, int i, int j) {
+        this.sections = new ChunkSection[16];
+        this.g = new byte[256];
+        this.h = new int[256];
+        this.i = new boolean[256];
+        this.tileEntities = Maps.newHashMap();
+        this.x = 4096;
+        this.y = Queues.newConcurrentLinkedQueue();
+        //this.entitySlices = (List[]) (new List[16]); // Spigot
+        this.entitySlices = (Queue[]) (new Queue[16]);
+        this.world = world;
+        this.locX = i;
+        this.locZ = j;
+        this.heightMap = new int[256];
+
+        for (int k = 0; k < this.entitySlices.length; ++k) {
+            //this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[k] = Queues.newConcurrentLinkedQueue();
+        }
+
+        Arrays.fill(this.h, -999);
+        Arrays.fill(this.g, (byte) -1);
+        // CraftBukkit start
+        this.bukkitChunk = new org.bukkit.craftbukkit.CraftChunk(this);
+        this.chunkKey = ChunkCoordIntPair.a(this.locX, this.locZ);
+    }
+
+    public org.bukkit.Chunk bukkitChunk;
+    public boolean mustSave;
+    // CraftBukkit end
+
+    public Chunk(World world, ChunkSnapshot chunksnapshot, int i, int j) {
+        this(world, i, j);
+        boolean flag = true;
+        boolean flag1 = !world.worldProvider.m();
+
+        for (int k = 0; k < 16; ++k) {
+            for (int l = 0; l < 16; ++l) {
+                for (int i1 = 0; i1 < 256; ++i1) {
+                    IBlockData iblockdata = chunksnapshot.a(k, i1, l);
+
+                    if (iblockdata.getMaterial() != Material.AIR) {
+                        int j1 = i1 >> 4;
+
+                        if (this.sections[j1] == Chunk.a) {
+                            this.sections[j1] = new ChunkSection(j1 << 4, flag1);
+                        }
+
+                        this.sections[j1].setType(k, i1 & 15, l, iblockdata);
+                    }
+                }
+            }
+        }
+
+    }
+
+    public boolean a(int i, int j) {
+        return i == this.locX && j == this.locZ;
+    }
+
+    public int e(BlockPosition blockposition) {
+        return this.b(blockposition.getX() & 15, blockposition.getZ() & 15);
+    }
+
+    public int b(int i, int j) {
+        return this.heightMap[j << 4 | i];
+    }
+
+    @Nullable
+    private ChunkSection y() {
+        for (int i = this.sections.length - 1; i >= 0; --i) {
+            if (this.sections[i] != Chunk.a) {
+                return this.sections[i];
+            }
+        }
+
+        return null;
+    }
+
+    public int g() {
+        ChunkSection chunksection = this.y();
+
+        return chunksection == null ? 0 : chunksection.getYPosition();
+    }
+
+    public ChunkSection[] getSections() {
+        return this.sections;
+    }
+
+    public void initLighting() {
+        int i = this.g();
+
+        this.v = Integer.MAX_VALUE;
+
+        for (int j = 0; j < 16; ++j) {
+            int k = 0;
+
+            while (k < 16) {
+                this.h[j + (k << 4)] = -999;
+                int l = i + 16;
+
+                while (true) {
+                    if (l > 0) {
+                        if (this.d(j, l - 1, k) == 0) {
+                            --l;
+                            continue;
+                        }
+
+                        this.heightMap[k << 4 | j] = l;
+                        if (l < this.v) {
+                            this.v = l;
+                        }
+                    }
+
+                    if (!this.world.worldProvider.m()) {
+                        l = 15;
+                        int i1 = i + 16 - 1;
+
+                        do {
+                            int j1 = this.d(j, i1, k);
+
+                            if (j1 == 0 && l != 15) {
+                                j1 = 1;
+                            }
+
+                            l -= j1;
+                            if (l > 0) {
+                                ChunkSection chunksection = this.sections[i1 >> 4];
+
+                                if (chunksection != Chunk.a) {
+                                    chunksection.a(j, i1 & 15, k, l);
+                                    this.world.m(new BlockPosition((this.locX << 4) + j, i1, (this.locZ << 4) + k));
+                                }
+                            }
+
+                            --i1;
+                        } while (i1 > 0 && l > 0);
+                    }
+
+                    ++k;
+                    break;
+                }
+            }
+        }
+
+        this.s = true;
+    }
+
+    private void d(int i, int j) {
+        this.i[i + j * 16] = true;
+        this.m = true;
+    }
+
+    private void h(boolean flag) {
+        this.world.methodProfiler.a("recheckGaps");
+        if (this.world.areChunksLoaded(new BlockPosition(this.locX * 16 + 8, 0, this.locZ * 16 + 8), 16)) {
+            for (int i = 0; i < 16; ++i) {
+                for (int j = 0; j < 16; ++j) {
+                    if (this.i[i + j * 16]) {
+                        this.i[i + j * 16] = false;
+                        int k = this.b(i, j);
+                        int l = this.locX * 16 + i;
+                        int i1 = this.locZ * 16 + j;
+                        int j1 = Integer.MAX_VALUE;
+
+                        Iterator iterator;
+                        EnumDirection enumdirection;
+
+                        for (iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator(); iterator.hasNext(); j1 = Math.min(j1, this.world.c(l + enumdirection.getAdjacentX(), i1 + enumdirection.getAdjacentZ()))) {
+                            enumdirection = (EnumDirection) iterator.next();
+                        }
+
+                        this.b(l, i1, j1);
+                        iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+                        while (iterator.hasNext()) {
+                            enumdirection = (EnumDirection) iterator.next();
+                            this.b(l + enumdirection.getAdjacentX(), i1 + enumdirection.getAdjacentZ(), k);
+                        }
+
+                        if (flag) {
+                            this.world.methodProfiler.b();
+                            return;
+                        }
+                    }
+                }
+            }
+
+            this.m = false;
+        }
+
+        this.world.methodProfiler.b();
+    }
+
+    private void b(int i, int j, int k) {
+        int l = this.world.getHighestBlockYAt(new BlockPosition(i, 0, j)).getY();
+
+        if (l > k) {
+            this.a(i, j, k, l + 1);
+        } else if (l < k) {
+            this.a(i, j, l, k + 1);
+        }
+
+    }
+
+    private void a(int i, int j, int k, int l) {
+        if (l > k && this.world.areChunksLoaded(new BlockPosition(i, 0, j), 16)) {
+            for (int i1 = k; i1 < l; ++i1) {
+                this.world.c(EnumSkyBlock.SKY, new BlockPosition(i, i1, j));
+            }
+
+            this.s = true;
+        }
+
+    }
+
+    private void c(int i, int j, int k) {
+        int l = this.heightMap[k << 4 | i] & 255;
+        int i1 = l;
+
+        if (j > l) {
+            i1 = j;
+        }
+
+        while (i1 > 0 && this.d(i, i1 - 1, k) == 0) {
+            --i1;
+        }
+
+        if (i1 != l) {
+            this.world.a(i + this.locX * 16, k + this.locZ * 16, i1, l);
+            this.heightMap[k << 4 | i] = i1;
+            int j1 = this.locX * 16 + i;
+            int k1 = this.locZ * 16 + k;
+            int l1;
+            int i2;
+
+            if (!this.world.worldProvider.m()) {
+                ChunkSection chunksection;
+
+                if (i1 < l) {
+                    for (l1 = i1; l1 < l; ++l1) {
+                        chunksection = this.sections[l1 >> 4];
+                        if (chunksection != Chunk.a) {
+                            chunksection.a(i, l1 & 15, k, 15);
+                            this.world.m(new BlockPosition((this.locX << 4) + i, l1, (this.locZ << 4) + k));
+                        }
+                    }
+                } else {
+                    for (l1 = l; l1 < i1; ++l1) {
+                        chunksection = this.sections[l1 >> 4];
+                        if (chunksection != Chunk.a) {
+                            chunksection.a(i, l1 & 15, k, 0);
+                            this.world.m(new BlockPosition((this.locX << 4) + i, l1, (this.locZ << 4) + k));
+                        }
+                    }
+                }
+
+                l1 = 15;
+
+                while (i1 > 0 && l1 > 0) {
+                    --i1;
+                    i2 = this.d(i, i1, k);
+                    if (i2 == 0) {
+                        i2 = 1;
+                    }
+
+                    l1 -= i2;
+                    if (l1 < 0) {
+                        l1 = 0;
+                    }
+
+                    ChunkSection chunksection1 = this.sections[i1 >> 4];
+
+                    if (chunksection1 != Chunk.a) {
+                        chunksection1.a(i, i1 & 15, k, l1);
+                    }
+                }
+            }
+
+            l1 = this.heightMap[k << 4 | i];
+            i2 = l;
+            int j2 = l1;
+
+            if (l1 < l) {
+                i2 = l1;
+                j2 = l;
+            }
+
+            if (l1 < this.v) {
+                this.v = l1;
+            }
+
+            if (!this.world.worldProvider.m()) {
+                Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+                while (iterator.hasNext()) {
+                    EnumDirection enumdirection = (EnumDirection) iterator.next();
+
+                    this.a(j1 + enumdirection.getAdjacentX(), k1 + enumdirection.getAdjacentZ(), i2, j2);
+                }
+
+                this.a(j1, k1, i2, j2);
+            }
+
+            this.s = true;
+        }
+    }
+
+    public int b(BlockPosition blockposition) {
+        return this.getBlockData(blockposition).c();
+    }
+
+    private int d(int i, int j, int k) {
+        return this.a(i, j, k).c();
+    }
+
+    public IBlockData getBlockData(BlockPosition blockposition) {
+        return this.a(blockposition.getX(), blockposition.getY(), blockposition.getZ());
+    }
+
+    public IBlockData a(final int i, final int j, final int k) {
+        if (this.world.L() == WorldType.DEBUG_ALL_BLOCK_STATES) {
+            IBlockData iblockdata = null;
+
+            if (j == 60) {
+                iblockdata = Blocks.BARRIER.getBlockData();
+            }
+
+            if (j == 70) {
+                iblockdata = ChunkProviderDebug.c(i, k);
+            }
+
+            return iblockdata == null ? Blocks.AIR.getBlockData() : iblockdata;
+        } else {
+            try {
+                if (j >= 0 && j >> 4 < this.sections.length) {
+                    ChunkSection chunksection = this.sections[j >> 4];
+
+                    if (chunksection != Chunk.a) {
+                        return chunksection.getType(i & 15, j & 15, k & 15);
+                    }
+                }
+
+                return Blocks.AIR.getBlockData();
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Getting block state");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being got");
+
+                crashreportsystemdetails.a("Location", new CrashReportCallable() {
+                    public String a() throws Exception {
+                        return CrashReportSystemDetails.a(i, j, k);
+                    }
+
+                    public Object call() throws Exception {
+                        return this.a();
+                    }
+                });
+                throw new ReportedException(crashreport);
+            }
+        }
+    }
+
+    @Nullable
+    public IBlockData a(BlockPosition blockposition, IBlockData iblockdata) {
+        int i = blockposition.getX() & 15;
+        int j = blockposition.getY();
+        int k = blockposition.getZ() & 15;
+        int l = k << 4 | i;
+
+        if (j >= this.h[l] - 1) {
+            this.h[l] = -999;
+        }
+
+        int i1 = this.heightMap[l];
+        IBlockData iblockdata1 = this.getBlockData(blockposition);
+
+        if (iblockdata1 == iblockdata) {
+            return null;
+        } else {
+            Block block = iblockdata.getBlock();
+            Block block1 = iblockdata1.getBlock();
+            ChunkSection chunksection = this.sections[j >> 4];
+            boolean flag = false;
+
+            if (chunksection == Chunk.a) {
+                if (block == Blocks.AIR) {
+                    return null;
+                }
+
+                chunksection = new ChunkSection(j >> 4 << 4, !this.world.worldProvider.m());
+                this.sections[j >> 4] = chunksection;
+                flag = j >= i1;
+            }
+
+            chunksection.setType(i, j & 15, k, iblockdata);
+            if (block1 != block) {
+                if (!this.world.isClientSide) {
+                    block1.remove(this.world, blockposition, iblockdata1);
+                } else if (block1 instanceof ITileEntity) {
+                    this.world.s(blockposition);
+                }
+            }
+
+            if (chunksection.getType(i, j & 15, k).getBlock() != block) {
+                return null;
+            } else {
+                if (flag) {
+                    this.initLighting();
+                } else {
+                    int j1 = iblockdata.c();
+                    int k1 = iblockdata1.c();
+
+                    if (j1 > 0) {
+                        if (j >= i1) {
+                            this.c(i, j + 1, k);
+                        }
+                    } else if (j == i1 - 1) {
+                        this.c(i, j, k);
+                    }
+
+                    if (j1 != k1 && (j1 < k1 || this.getBrightness(EnumSkyBlock.SKY, blockposition) > 0 || this.getBrightness(EnumSkyBlock.BLOCK, blockposition) > 0)) {
+                        this.d(i, k);
+                    }
+                }
+
+                TileEntity tileentity;
+
+                if (block1 instanceof ITileEntity) {
+                    tileentity = this.a(blockposition, Chunk.EnumTileEntityState.CHECK);
+                    if (tileentity != null) {
+                        tileentity.invalidateBlockCache();
+                    }
+                }
+
+                // CraftBukkit - Don't place while processing the BlockPlaceEvent, unless it's a BlockContainer. Prevents blocks such as TNT from activating when cancelled.
+                if (!this.world.isClientSide && block1 != block  && (!this.world.captureBlockStates || block instanceof BlockTileEntity)) {
+                    block.onPlace(this.world, blockposition, iblockdata);
+                }
+
+                if (block instanceof ITileEntity) {
+                    tileentity = this.a(blockposition, Chunk.EnumTileEntityState.CHECK);
+                    if (tileentity == null) {
+                        tileentity = ((ITileEntity) block).a(this.world, block.toLegacyData(iblockdata));
+                        this.world.setTileEntity(blockposition, tileentity);
+                    }
+
+                    if (tileentity != null) {
+                        tileentity.invalidateBlockCache();
+                    }
+                }
+
+                this.s = true;
+                return iblockdata1;
+            }
+        }
+    }
+
+    public int getBrightness(EnumSkyBlock enumskyblock, BlockPosition blockposition) {
+        int i = blockposition.getX() & 15;
+        int j = blockposition.getY();
+        int k = blockposition.getZ() & 15;
+        ChunkSection chunksection = this.sections[j >> 4];
+
+        return chunksection == Chunk.a ? (this.c(blockposition) ? enumskyblock.c : 0) : (enumskyblock == EnumSkyBlock.SKY ? (this.world.worldProvider.m() ? 0 : chunksection.b(i, j & 15, k)) : (enumskyblock == EnumSkyBlock.BLOCK ? chunksection.c(i, j & 15, k) : enumskyblock.c));
+    }
+
+    public void a(EnumSkyBlock enumskyblock, BlockPosition blockposition, int i) {
+        int j = blockposition.getX() & 15;
+        int k = blockposition.getY();
+        int l = blockposition.getZ() & 15;
+        ChunkSection chunksection = this.sections[k >> 4];
+
+        if (chunksection == Chunk.a) {
+            chunksection = new ChunkSection(k >> 4 << 4, !this.world.worldProvider.m());
+            this.sections[k >> 4] = chunksection;
+            this.initLighting();
+        }
+
+        this.s = true;
+        if (enumskyblock == EnumSkyBlock.SKY) {
+            if (!this.world.worldProvider.m()) {
+                chunksection.a(j, k & 15, l, i);
+            }
+        } else if (enumskyblock == EnumSkyBlock.BLOCK) {
+            chunksection.b(j, k & 15, l, i);
+        }
+
+    }
+
+    public int a(BlockPosition blockposition, int i) {
+        int j = blockposition.getX() & 15;
+        int k = blockposition.getY();
+        int l = blockposition.getZ() & 15;
+        ChunkSection chunksection = this.sections[k >> 4];
+
+        if (chunksection == Chunk.a) {
+            return !this.world.worldProvider.m() && i < EnumSkyBlock.SKY.c ? EnumSkyBlock.SKY.c - i : 0;
+        } else {
+            int i1 = this.world.worldProvider.m() ? 0 : chunksection.b(j, k & 15, l);
+
+            i1 -= i;
+            int j1 = chunksection.c(j, k & 15, l);
+
+            if (j1 > i1) {
+                i1 = j1;
+            }
+
+            return i1;
+        }
+    }
+
+    public void a(Entity entity) {
+        this.t = true;
+        int i = MathHelper.floor(entity.locX / 16.0D);
+        int j = MathHelper.floor(entity.locZ / 16.0D);
+
+        if (i != this.locX || j != this.locZ) {
+            Chunk.e.warn("Wrong location! ({}, {}) should be ({}, {}), {}", new Object[] { Integer.valueOf(i), Integer.valueOf(j), Integer.valueOf(this.locX), Integer.valueOf(this.locZ), entity, entity});
+            entity.die();
+        }
+
+        int k = MathHelper.floor(entity.locY / 16.0D);
+
+        if (k < 0) {
+            k = 0;
+        }
+
+        if (k >= this.entitySlices.length) {
+            k = this.entitySlices.length - 1;
+        }
+
+        entity.ab = true;
+        entity.ac = this.locX;
+        entity.ad = k;
+        entity.ae = this.locZ;
+        this.entitySlices[k].add(entity);
+        // Spigot start - increment creature type count
+        // Keep this synced up with World.a(Class)
+        if (entity instanceof EntityInsentient) {
+            EntityInsentient entityinsentient = (EntityInsentient) entity;
+            if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
+                return;
+            }
+        }
+        for ( EnumCreatureType creatureType : EnumCreatureType.values() )
+        {
+            if ( creatureType.a().isAssignableFrom( entity.getClass() ) )
+            {
+                this.entityCount.adjustOrPutValue( creatureType.a(), 1, 1 );
+            }
+        }
+        // Spigot end
+    }
+
+    public void b(Entity entity) {
+        this.a(entity, entity.ad);
+    }
+
+    public void a(Entity entity, int i) {
+        if (i < 0) {
+            i = 0;
+        }
+
+        if (i >= this.entitySlices.length) {
+            i = this.entitySlices.length - 1;
+        }
+
+        this.entitySlices[i].remove(entity);
+        // Spigot start - decrement creature type count
+        // Keep this synced up with World.a(Class)
+        if (entity instanceof EntityInsentient) {
+            EntityInsentient entityinsentient = (EntityInsentient) entity;
+            if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
+                return;
+            }
+        }
+        for ( EnumCreatureType creatureType : EnumCreatureType.values() )
+        {
+            if ( creatureType.a().isAssignableFrom( entity.getClass() ) )
+            {
+                this.entityCount.adjustValue( creatureType.a(), -1 );
+            }
+        }
+        // Spigot end
+    }
+
+    public boolean c(BlockPosition blockposition) {
+        int i = blockposition.getX() & 15;
+        int j = blockposition.getY();
+        int k = blockposition.getZ() & 15;
+
+        return j >= this.heightMap[k << 4 | i];
+    }
+
+    @Nullable
+    private TileEntity g(BlockPosition blockposition) {
+        IBlockData iblockdata = this.getBlockData(blockposition);
+        Block block = iblockdata.getBlock();
+
+        return !block.isTileEntity() ? null : ((ITileEntity) block).a(this.world, iblockdata.getBlock().toLegacyData(iblockdata));
+    }
+
+    @Nullable
+    public TileEntity a(BlockPosition blockposition, Chunk.EnumTileEntityState chunk_enumtileentitystate) {
+        // CraftBukkit start
+        TileEntity tileentity = null;
+        if (world.captureBlockStates) {
+            tileentity = world.capturedTileEntities.get(blockposition);
+        }
+        if (tileentity == null) {
+            tileentity = (TileEntity) this.tileEntities.get(blockposition);
+        }
+        // CraftBukkit end
+
+        if (tileentity == null) {
+            if (chunk_enumtileentitystate == Chunk.EnumTileEntityState.IMMEDIATE) {
+                tileentity = this.g(blockposition);
+                this.world.setTileEntity(blockposition, tileentity);
+            } else if (chunk_enumtileentitystate == Chunk.EnumTileEntityState.QUEUED) {
+                this.y.add(blockposition);
+            }
+        } else if (tileentity.x()) {
+            this.tileEntities.remove(blockposition);
+            return null;
+        }
+
+        return tileentity;
+    }
+
+    public void a(TileEntity tileentity) {
+        this.a(tileentity.getPosition(), tileentity);
+        if (this.j) {
+            this.world.a(tileentity);
+        }
+
+    }
+
+    public void a(BlockPosition blockposition, TileEntity tileentity) {
+        tileentity.a(this.world);
+        tileentity.setPosition(blockposition);
+        if (this.getBlockData(blockposition).getBlock() instanceof ITileEntity) {
+            if (this.tileEntities.containsKey(blockposition)) {
+                ((TileEntity) this.tileEntities.get(blockposition)).y();
+            }
+
+            tileentity.z();
+            this.tileEntities.put(blockposition, tileentity);
+            // CraftBukkit start
+        } else {
+            System.out.println("Attempted to place a tile entity (" + tileentity + ") at " + tileentity.position.getX() + "," + tileentity.position.getY() + "," + tileentity.position.getZ()
+                + " (" + org.bukkit.craftbukkit.util.CraftMagicNumbers.getMaterial(getBlockData(blockposition).getBlock()) + ") where there was no entity tile!");
+            System.out.println("Chunk coordinates: " + (this.locX * 16) + "," + (this.locZ * 16));
+            new Exception().printStackTrace();
+            // CraftBukkit end
+        }
+    }
+
+    public void d(BlockPosition blockposition) {
+        if (this.j) {
+            TileEntity tileentity = (TileEntity) this.tileEntities.remove(blockposition);
+
+            if (tileentity != null) {
+                tileentity.y();
+            }
+        }
+
+    }
+
+    public void addEntities() {
+        this.j = true;
+        this.world.b(this.tileEntities.values());
+        //List[] aentityslice = this.entitySlices; // Spigot
+        Queue[] aentityslice = this.entitySlices;
+        int i = aentityslice.length;
+
+        for (int j = 0; j < i; ++j) {
+            //List entityslice = aentityslice[j]; // Spigot
+            Queue entityslice = aentityslice[j];
+
+            this.world.a((Collection) entityslice);
+        }
+
+    }
+
+    public void removeEntities() {
+        this.j = false;
+        this.tileEntities.values().parallelStream().forEach(tileentity -> {
+            if ( tileentity instanceof IInventory )
+            {
+                for ( org.bukkit.entity.HumanEntity h : Lists.<org.bukkit.entity.HumanEntity>newArrayList((List<org.bukkit.entity.HumanEntity>) ( (IInventory) tileentity ).getViewers() ) )
+                {
+                    if ( h instanceof org.bukkit.craftbukkit.entity.CraftHumanEntity )
+                    {
+                       ( (org.bukkit.craftbukkit.entity.CraftHumanEntity) h).getHandle().closeInventory();
+                    }
+                }
+            }
+            // Spigot End
+            
+            this.world.b(tileentity);            //remove tile
+        });
+        /*
+        Iterator iterator = this.tileEntities.values().iterator();
+        
+        while (iterator.hasNext()) {
+            TileEntity tileentity = (TileEntity) iterator.next();
+            // Spigot Start
+            if ( tileentity instanceof IInventory )
+            {
+                for ( org.bukkit.entity.HumanEntity h : Lists.<org.bukkit.entity.HumanEntity>newArrayList((List<org.bukkit.entity.HumanEntity>) ( (IInventory) tileentity ).getViewers() ) )
+                {
+                    if ( h instanceof org.bukkit.craftbukkit.entity.CraftHumanEntity )
+                    {
+                       ( (org.bukkit.craftbukkit.entity.CraftHumanEntity) h).getHandle().closeInventory();
+                    }
+                }
+            }
+            // Spigot End
+            
+            this.world.b(tileentity);            //remove tile
+        }*/
+
+        //List[] aentityslice = this.entitySlices; // Spigot
+        Queue[] aentityslice = this.entitySlices;
+        int i = aentityslice.length;
+
+        for (int j = 0; j < i; ++j) {
+            // CraftBukkit start
+            List<Entity> newList = Lists.newArrayList(aentityslice[j]);
+            java.util.Iterator<Entity> iter = newList.iterator();
+            while (iter.hasNext()) {
+                Entity entity = iter.next();
+                // Spigot Start
+                if ( entity instanceof IInventory )
+                {
+                    for ( org.bukkit.entity.HumanEntity h : Lists.<org.bukkit.entity.HumanEntity>newArrayList( (List<org.bukkit.entity.HumanEntity>) ( (IInventory) entity ).getViewers() ) )
+                    {
+                        if ( h instanceof org.bukkit.craftbukkit.entity.CraftHumanEntity )
+                        {
+                           ( (org.bukkit.craftbukkit.entity.CraftHumanEntity) h).getHandle().closeInventory();
+                        }
+                    }
+                }
+                // Spigot End
+
+                // Do not pass along players, as doing so can get them stuck outside of time.
+                // (which for example disables inventory icon updates and prevents block breaking)
+                if (entity instanceof EntityPlayer) {
+                    iter.remove();
+                }
+            }
+
+            this.world.c(newList);
+            // CraftBukkit end
+        }
+
+    }
+
+    public void e() {
+        this.s = true;
+    }
+
+    public void a(@Nullable Entity entity, AxisAlignedBB axisalignedbb, List<Entity> list, Predicate<? super Entity> predicate) {
+        int i = MathHelper.floor((axisalignedbb.b - 2.0D) / 16.0D);
+        int j = MathHelper.floor((axisalignedbb.e + 2.0D) / 16.0D);
+
+        i = MathHelper.clamp(i, 0, this.entitySlices.length - 1);
+        j = MathHelper.clamp(j, 0, this.entitySlices.length - 1);
+
+        for (int k = i; k <= j; ++k) {
+            if (!this.entitySlices[k].isEmpty()) {
+                Iterator iterator = this.entitySlices[k].iterator();
+                while (iterator.hasNext()) {
+                    try {
+                        Entity entity1 = (Entity) iterator.next();
+                        if (entity1.getBoundingBox().b(axisalignedbb) && entity1 != entity) {
+                            if (predicate == null || predicate.apply(entity1)) {
+                                list.add(entity1);
+                            }
+
+                            Entity[] aentity = entity1.aT();
+
+                            if (aentity != null) {
+                                Entity[] aentity1 = aentity;
+                                int l = aentity.length;
+
+                                for (int i1 = 0; i1 < l; ++i1) {
+                                    Entity entity2 = aentity1[i1];
+
+                                    if (entity2 != entity && entity2.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply(entity2))) {
+                                        list.add(entity2);
+                                    }
+                                }
+                            }
+                        }
+                    } catch (Exception ex) {
+                        ;
+                    }
+                }
+            }
+        }
+
+    }
+
+    public <T extends Entity> void a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb, List<T> list, Predicate<? super T> predicate) {
+        int i = MathHelper.floor((axisalignedbb.b - 2.0D) / 16.0D);
+        int j = MathHelper.floor((axisalignedbb.e + 2.0D) / 16.0D);
+
+        i = MathHelper.clamp(i, 0, this.entitySlices.length - 1);
+        j = MathHelper.clamp(j, 0, this.entitySlices.length - 1);
+
+        for (int k = i; k <= j; ++k) {
+            Iterator iterator = this.entitySlices[k].iterator(); // Spigot
+
+            while (iterator.hasNext()) {
+                try {
+                    Entity entity = (Entity) iterator.next();
+                    if (oclass.isInstance(entity) && entity.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply((T) entity))) { // CraftBukkit - fix decompile error // Spigot
+                        list.add((T) entity); // Fix decompile error
+                    }
+                } catch (Exception ex) {
+                    ;
+                }
+            }
+        }
+
+    }
+
+    public boolean a(boolean flag) {
+        if (flag) {
+            if (this.t && this.world.getTime() != this.lastSaved || this.s) {
+                return true;
+            }
+        } else if (this.t && this.world.getTime() >= this.lastSaved + MinecraftServer.getServer().autosavePeriod * 4) { // Spigot - Only save if we've passed 2 auto save intervals without modification
+            return true;
+        }
+
+        return this.s;
+    }
+
+    public Random a(long i) {
+        return new Random(this.world.getSeed() + (long) (this.locX * this.locX * 4987142) + (long) (this.locX * 5947611) + (long) (this.locZ * this.locZ) * 4392871L + (long) (this.locZ * 389711) ^ i);
+    }
+
+    public boolean isEmpty() {
+        return false;
+    }
+
+    // CraftBukkit start
+    public void loadNearby(IChunkProvider ichunkprovider, ChunkGenerator chunkgenerator, boolean newChunk) {
+        world.timings.syncChunkLoadPostTimer.startTiming(); // Spigot
+        Server server = world.getServer();
+        if (server != null) {
+            /*
+             * If it's a new world, the first few chunks are generated inside
+             * the World constructor. We can't reliably alter that, so we have
+             * no way of creating a CraftWorld/CraftServer at that point.
+             */
+            server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(bukkitChunk, newChunk));
+        }
+
+        // Update neighbor counts
+        for (int x = -2; x < 3; x++) {
+            for (int z = -2; z < 3; z++) {
+                if (x == 0 && z == 0) {
+                    continue;
+                }
+
+                Chunk neighbor = getWorld().getChunkIfLoaded(locX + x, locZ + z);
+                if (neighbor != null) {
+                    neighbor.setNeighborLoaded(-x, -z);
+                    setNeighborLoaded(x, z);
+                }
+            }
+        }
+        // CraftBukkit end
+
+        Chunk chunk = ichunkprovider.getLoadedChunkAt(this.locX, this.locZ - 1);
+        Chunk chunk1 = ichunkprovider.getLoadedChunkAt(this.locX + 1, this.locZ);
+        Chunk chunk2 = ichunkprovider.getLoadedChunkAt(this.locX, this.locZ + 1);
+        Chunk chunk3 = ichunkprovider.getLoadedChunkAt(this.locX - 1, this.locZ);
+
+        if (chunk1 != null && chunk2 != null && ichunkprovider.getLoadedChunkAt(this.locX + 1, this.locZ + 1) != null) {
+            this.a(chunkgenerator);
+        }
+
+        if (chunk3 != null && chunk2 != null && ichunkprovider.getLoadedChunkAt(this.locX - 1, this.locZ + 1) != null) {
+            chunk3.a(chunkgenerator);
+        }
+
+        if (chunk != null && chunk1 != null && ichunkprovider.getLoadedChunkAt(this.locX + 1, this.locZ - 1) != null) {
+            chunk.a(chunkgenerator);
+        }
+
+        if (chunk != null && chunk3 != null) {
+            Chunk chunk4 = ichunkprovider.getLoadedChunkAt(this.locX - 1, this.locZ - 1);
+
+            if (chunk4 != null) {
+                chunk4.a(chunkgenerator);
+            }
+        }
+        world.timings.syncChunkLoadPostTimer.stopTiming(); // Spigot
+
+    }
+
+    protected void a(ChunkGenerator chunkgenerator) {
+        if (this.isDone()) {
+            if (chunkgenerator.a(this, this.locX, this.locZ)) {
+                this.e();
+            }
+        } else {
+            this.o();
+            chunkgenerator.recreateStructures(this.locX, this.locZ);
+
+            // CraftBukkit start
+            BlockSand.instaFall = true;
+            Random random = new Random();
+            random.setSeed(world.getSeed());
+            long xRand = random.nextLong() / 2L * 2L + 1L;
+            long zRand = random.nextLong() / 2L * 2L + 1L;
+            random.setSeed((long) locX * xRand + (long) locZ * zRand ^ world.getSeed());
+
+            org.bukkit.World world = this.world.getWorld();
+            if (world != null) {
+                this.world.populating = true;
+                try {
+                    for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
+                        populator.populate(world, random, bukkitChunk);
+                    }
+                } finally {
+                    this.world.populating = false;
+                }
+            }
+            BlockSand.instaFall = false;
+            this.world.getServer().getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(bukkitChunk));
+            // CraftBukkit end
+            this.e();
+        }
+
+    }
+
+    public BlockPosition f(BlockPosition blockposition) {
+        int i = blockposition.getX() & 15;
+        int j = blockposition.getZ() & 15;
+        int k = i | j << 4;
+        BlockPosition blockposition1 = new BlockPosition(blockposition.getX(), this.h[k], blockposition.getZ());
+
+        if (blockposition1.getY() == -999) {
+            int l = this.g() + 15;
+
+            blockposition1 = new BlockPosition(blockposition.getX(), l, blockposition.getZ());
+            int i1 = -1;
+
+            while (blockposition1.getY() > 0 && i1 == -1) {
+                IBlockData iblockdata = this.getBlockData(blockposition1);
+                Material material = iblockdata.getMaterial();
+
+                if (!material.isSolid() && !material.isLiquid()) {
+                    blockposition1 = blockposition1.down();
+                } else {
+                    i1 = blockposition1.getY() + 1;
+                }
+            }
+
+            this.h[k] = i1;
+        }
+
+        return new BlockPosition(blockposition.getX(), this.h[k], blockposition.getZ());
+    }
+
+    public void b(boolean flag) {
+        if (this.m && !this.world.worldProvider.m() && !flag) {
+            this.h(this.world.isClientSide);
+        }
+
+        this.r = true;
+        if (!this.lit && this.done && this.world.spigotConfig.randomLightUpdates) { // Spigot - also use random light updates setting to determine if we should relight
+            this.o();
+        }
+
+        while (!this.y.isEmpty()) {
+            BlockPosition blockposition = (BlockPosition) this.y.poll();
+
+            if (this.a(blockposition, Chunk.EnumTileEntityState.CHECK) == null && this.getBlockData(blockposition).getBlock().isTileEntity()) {
+                TileEntity tileentity = this.g(blockposition);
+
+                this.world.setTileEntity(blockposition, tileentity);
+                this.world.b(blockposition, blockposition);
+            }
+        }
+
+    }
+
+    public boolean isReady() {
+        // Spigot Start
+        /*
+         * As of 1.7, Mojang added a check to make sure that only chunks which have been lit are sent to the client.
+         * Unfortunately this interferes with our modified chunk ticking algorithm, which will only tick chunks distant from the player on a very infrequent basis.
+         * We cannot unfortunately do this lighting stage during chunk gen as it appears to put a lot more noticeable load on the server, than when it is done at play time.
+         * For now at least we will simply send all chunks, in accordance with pre 1.7 behaviour.
+         */
+        return true;
+        // Spigot End
+    }
+
+    public boolean j() {
+        return this.r;
+    }
+
+    public ChunkCoordIntPair k() {
+        return new ChunkCoordIntPair(this.locX, this.locZ);
+    }
+
+    public boolean c(int i, int j) {
+        if (i < 0) {
+            i = 0;
+        }
+
+        if (j >= 256) {
+            j = 255;
+        }
+
+        for (int k = i; k <= j; k += 16) {
+            ChunkSection chunksection = this.sections[k >> 4];
+
+            if (chunksection != Chunk.a && !chunksection.a()) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public void a(ChunkSection[] achunksection) {
+        if (this.sections.length != achunksection.length) {
+            Chunk.e.warn("Could not set level chunk sections, array length is {} instead of {}", new Object[] { Integer.valueOf(achunksection.length), Integer.valueOf(this.sections.length)});
+        } else {
+            System.arraycopy(achunksection, 0, this.sections, 0, this.sections.length);
+        }
+    }
+
+    public BiomeBase getBiome(BlockPosition blockposition, WorldChunkManager worldchunkmanager) {
+        int i = blockposition.getX() & 15;
+        int j = blockposition.getZ() & 15;
+        int k = this.g[j << 4 | i] & 255;
+        BiomeBase biomebase;
+
+        if (k == 255) {
+            biomebase = worldchunkmanager.getBiome(blockposition, Biomes.c);
+            k = BiomeBase.a(biomebase);
+            this.g[j << 4 | i] = (byte) (k & 255);
+        }
+
+        biomebase = BiomeBase.getBiome(k);
+        return biomebase == null ? Biomes.c : biomebase;
+    }
+
+    public byte[] getBiomeIndex() {
+        return this.g;
+    }
+
+    public void a(byte[] abyte) {
+        if (this.g.length != abyte.length) {
+            Chunk.e.warn("Could not set level chunk biomes, array length is {} instead of {}", new Object[] { Integer.valueOf(abyte.length), Integer.valueOf(this.g.length)});
+        } else {
+            System.arraycopy(abyte, 0, this.g, 0, this.g.length);
+        }
+    }
+
+    public void m() {
+        this.x = 0;
+    }
+
+    public void n() {
+        if (this.x < 4096) {
+            BlockPosition blockposition = new BlockPosition(this.locX << 4, 0, this.locZ << 4);
+
+            for (int i = 0; i < 8; ++i) {
+                if (this.x >= 4096) {
+                    return;
+                }
+
+                int j = this.x % 16;
+                int k = this.x / 16 % 16;
+                int l = this.x / 256;
+
+                ++this.x;
+
+                for (int i1 = 0; i1 < 16; ++i1) {
+                    BlockPosition blockposition1 = blockposition.a(k, (j << 4) + i1, l);
+                    boolean flag = i1 == 0 || i1 == 15 || k == 0 || k == 15 || l == 0 || l == 15;
+
+                    if (this.sections[j] == Chunk.a && flag || this.sections[j] != Chunk.a && this.sections[j].getType(k, i1, l).getMaterial() == Material.AIR) {
+                        EnumDirection[] aenumdirection = EnumDirection.values();
+                        int j1 = aenumdirection.length;
+
+                        for (int k1 = 0; k1 < j1; ++k1) {
+                            EnumDirection enumdirection = aenumdirection[k1];
+                            BlockPosition blockposition2 = blockposition1.shift(enumdirection);
+
+                            if (this.world.getType(blockposition2).d() > 0) {
+                                this.world.w(blockposition2);
+                            }
+                        }
+
+                        this.world.w(blockposition1);
+                    }
+                }
+            }
+
+        }
+    }
+
+    public void o() {
+        this.done = true;
+        this.lit = true;
+        BlockPosition blockposition = new BlockPosition(this.locX << 4, 0, this.locZ << 4);
+
+        if (!this.world.worldProvider.m()) {
+            if (this.world.areChunksLoadedBetween(blockposition.a(-1, 0, -1), blockposition.a(16, this.world.K(), 16))) {
+                label42:
+                for (int i = 0; i < 16; ++i) {
+                    for (int j = 0; j < 16; ++j) {
+                        if (!this.e(i, j)) {
+                            this.lit = false;
+                            break label42;
+                        }
+                    }
+                }
+
+                if (this.lit) {
+                    Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+                    while (iterator.hasNext()) {
+                        EnumDirection enumdirection = (EnumDirection) iterator.next();
+                        int k = enumdirection.c() == EnumDirection.EnumAxisDirection.POSITIVE ? 16 : 1;
+
+                        this.world.getChunkAtWorldCoords(blockposition.shift(enumdirection, k)).a(enumdirection.opposite());
+                    }
+
+                    this.z();
+                }
+            } else {
+                this.lit = false;
+            }
+        }
+
+    }
+
+    private void z() {
+        for (int i = 0; i < this.i.length; ++i) {
+            this.i[i] = true;
+        }
+
+        this.h(false);
+    }
+
+    private void a(EnumDirection enumdirection) {
+        if (this.done) {
+            int i;
+
+            if (enumdirection == EnumDirection.EAST) {
+                for (i = 0; i < 16; ++i) {
+                    this.e(15, i);
+                }
+            } else if (enumdirection == EnumDirection.WEST) {
+                for (i = 0; i < 16; ++i) {
+                    this.e(0, i);
+                }
+            } else if (enumdirection == EnumDirection.SOUTH) {
+                for (i = 0; i < 16; ++i) {
+                    this.e(i, 15);
+                }
+            } else if (enumdirection == EnumDirection.NORTH) {
+                for (i = 0; i < 16; ++i) {
+                    this.e(i, 0);
+                }
+            }
+
+        }
+    }
+
+    private boolean e(int i, int j) {
+        int k = this.g();
+        boolean flag = false;
+        boolean flag1 = false;
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition((this.locX << 4) + i, 0, (this.locZ << 4) + j);
+
+        int l;
+
+        for (l = k + 16 - 1; l > this.world.K() || l > 0 && !flag1; --l) {
+            blockposition_mutableblockposition.c(blockposition_mutableblockposition.getX(), l, blockposition_mutableblockposition.getZ());
+            int i1 = this.b((BlockPosition) blockposition_mutableblockposition);
+
+            if (i1 == 255 && blockposition_mutableblockposition.getY() < this.world.K()) {
+                flag1 = true;
+            }
+
+            if (!flag && i1 > 0) {
+                flag = true;
+            } else if (flag && i1 == 0 && !this.world.w(blockposition_mutableblockposition)) {
+                return false;
+            }
+        }
+
+        for (l = blockposition_mutableblockposition.getY(); l > 0; --l) {
+            blockposition_mutableblockposition.c(blockposition_mutableblockposition.getX(), l, blockposition_mutableblockposition.getZ());
+            if (this.getBlockData(blockposition_mutableblockposition).d() > 0) {
+                this.world.w(blockposition_mutableblockposition);
+            }
+        }
+
+        return true;
+    }
+
+    public boolean p() {
+        return this.j;
+    }
+
+    public World getWorld() {
+        return this.world;
+    }
+
+    public int[] r() {
+        return this.heightMap;
+    }
+
+    public void a(int[] aint) {
+        if (this.heightMap.length != aint.length) {
+            Chunk.e.warn("Could not set level chunk heightmap, array length is {} instead of {}", new Object[] { Integer.valueOf(aint.length), Integer.valueOf(this.heightMap.length)});
+        } else {
+            System.arraycopy(aint, 0, this.heightMap, 0, this.heightMap.length);
+        }
+    }
+
+    public Map<BlockPosition, TileEntity> getTileEntities() {
+        return this.tileEntities;
+    }
+
+    //public List<Entity>[] getEntitySlices() {
+    public Queue<Entity>[] getEntitySlices() {
+        return this.entitySlices;
+    }
+
+    public boolean isDone() {
+        return this.done;
+    }
+
+    public void d(boolean flag) {
+        this.done = flag;
+    }
+
+    public boolean v() {
+        return this.lit;
+    }
+
+    public void e(boolean flag) {
+        this.lit = flag;
+    }
+
+    public void f(boolean flag) {
+        this.s = flag;
+    }
+
+    public void g(boolean flag) {
+        this.t = flag;
+    }
+
+    public void setLastSaved(long i) {
+        this.lastSaved = i;
+    }
+
+    public int w() {
+        return this.v;
+    }
+
+    public long x() {
+        return this.w;
+    }
+
+    public void c(long i) {
+        this.w = i;
+    }
+
+    public static enum EnumTileEntityState {
+
+        IMMEDIATE, QUEUED, CHECK;
+
+        private EnumTileEntityState() {}
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderServer.java src/main/java/net/minecraft/server/ChunkProviderServer.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderServer.java	2016-08-25 22:39:50.876601885 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderServer.java	2016-08-26 03:24:13.293198358 +0800
@@ -1,332 +1,358 @@
-package net.minecraft.server;
-
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
-import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-import javax.annotation.Nullable;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-
-// CraftBukkit start
-import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
-import org.bukkit.event.world.ChunkUnloadEvent;
-// CraftBukkit end
-
-public class ChunkProviderServer implements IChunkProvider {
-
-    private static final Logger a = LogManager.getLogger();
-    public final Set<Long> unloadQueue = Sets.newHashSet();
-    public final ChunkGenerator chunkGenerator;
-    private final IChunkLoader chunkLoader;
-    public final Long2ObjectMap<Chunk> chunks = new Long2ObjectOpenHashMap(8192);
-    public final WorldServer world;
-
-    public ChunkProviderServer(WorldServer worldserver, IChunkLoader ichunkloader, ChunkGenerator chunkgenerator) {
-        this.world = worldserver;
-        this.chunkLoader = ichunkloader;
-        this.chunkGenerator = chunkgenerator;
-    }
-
-    public Collection<Chunk> a() {
-        return this.chunks.values();
-    }
-
-    public void unload(Chunk chunk) {
-        if (this.world.worldProvider.c(chunk.locX, chunk.locZ)) {
-            this.unloadQueue.add(Long.valueOf(ChunkCoordIntPair.a(chunk.locX, chunk.locZ)));
-            chunk.d = true;
-        }
-
-    }
-
-    public void b() {
-        Iterator iterator = this.chunks.values().iterator();
-
-        while (iterator.hasNext()) {
-            Chunk chunk = (Chunk) iterator.next();
-
-            this.unload(chunk);
-        }
-
-    }
-
-    @Nullable
-    public Chunk getLoadedChunkAt(int i, int j) {
-        long k = ChunkCoordIntPair.a(i, j);
-        Chunk chunk = (Chunk) this.chunks.get(k);
-
-        if (chunk != null) {
-            chunk.d = false;
-        }
-
-        return chunk;
-    }
-
-    @Nullable
-    public Chunk getOrLoadChunkAt(int i, int j) {
-        Chunk chunk = this.getLoadedChunkAt(i, j);
-
-        if (chunk == null) {
-            // CraftBukkit start
-            ChunkRegionLoader loader = null;
-
-            if (this.chunkLoader instanceof ChunkRegionLoader) {
-                loader = (ChunkRegionLoader) this.chunkLoader;
-            }
-            if (loader != null && loader.chunkExists(world, i, j)) {
-                chunk = ChunkIOExecutor.syncChunkLoad(world, loader, this, i, j);
-            }
-        }
-
-        return chunk;
-    }
-
-    @Nullable
-    public Chunk originalGetOrLoadChunkAt(int i, int j) {
-        // CraftBukkit end
-        Chunk chunk = this.getLoadedChunkAt(i, j);
-
-        if (chunk == null) {
-            chunk = this.loadChunk(i, j);
-            if (chunk != null) {
-                this.chunks.put(ChunkCoordIntPair.a(i, j), chunk);
-                chunk.addEntities();
-                chunk.loadNearby(this, this.chunkGenerator, false); // CraftBukkit
-            }
-        }
-
-        return chunk;
-    }
-
-    // CraftBukkit start
-    public Chunk getChunkIfLoaded(int x, int z) {
-        return chunks.get(ChunkCoordIntPair.a(x, z));
-    }
-    // CraftBukkit end
-
-    public Chunk getChunkAt(int i, int j) {
-        return getChunkAt(i, j, null);
-    }
-
-    public Chunk getChunkAt(int i, int j, Runnable runnable) {
-        return getChunkAt(i, j, runnable, true);
-    }
-
-    public Chunk getChunkAt(int i, int j, Runnable runnable, boolean generate) {
-        Chunk chunk = getChunkIfLoaded(i, j);
-        ChunkRegionLoader loader = null;
-
-        if (this.chunkLoader instanceof ChunkRegionLoader) {
-            loader = (ChunkRegionLoader) this.chunkLoader;
-
-        }
-        // We can only use the queue for already generated chunks
-        if (chunk == null && loader != null && loader.chunkExists(world, i, j)) {
-            if (runnable != null) {
-                ChunkIOExecutor.queueChunkLoad(world, loader, this, i, j, runnable);
-                return null;
-            } else {
-                chunk = ChunkIOExecutor.syncChunkLoad(world, loader, this, i, j);
-            }
-        } else if (chunk == null && generate) {
-            chunk = originalGetChunkAt(i, j);
-        }
-
-        // If we didn't load the chunk async and have a callback run it now
-        if (runnable != null) {
-            runnable.run();
-        }
-
-        return chunk;
-    }
-
-    public Chunk originalGetChunkAt(int i, int j) {
-        Chunk chunk = this.originalGetOrLoadChunkAt(i, j);
-        // CraftBukkit end
-
-        if (chunk == null) {
-            world.timings.syncChunkLoadTimer.startTiming(); // Spigot
-            long k = ChunkCoordIntPair.a(i, j);
-
-            try {
-                chunk = this.chunkGenerator.getOrCreateChunk(i, j);
-            } catch (Throwable throwable) {
-                CrashReport crashreport = CrashReport.a(throwable, "Exception generating new chunk");
-                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Chunk to be generated");
-
-                crashreportsystemdetails.a("Location", (Object) String.format("%d,%d", new Object[] { Integer.valueOf(i), Integer.valueOf(j)}));
-                crashreportsystemdetails.a("Position hash", (Object) Long.valueOf(k));
-                crashreportsystemdetails.a("Generator", (Object) this.chunkGenerator);
-                throw new ReportedException(crashreport);
-            }
-
-            this.chunks.put(k, chunk);
-            chunk.addEntities();
-            chunk.loadNearby(this, this.chunkGenerator, true); // CraftBukkit
-            world.timings.syncChunkLoadTimer.stopTiming(); // Spigot
-        }
-
-        return chunk;
-    }
-
-    @Nullable
-    public Chunk loadChunk(int i, int j) {
-        try {
-            Chunk chunk = this.chunkLoader.a(this.world, i, j);
-
-            if (chunk != null) {
-                chunk.setLastSaved(this.world.getTime());
-                this.chunkGenerator.recreateStructures(chunk, i, j);
-            }
-
-            return chunk;
-        } catch (Exception exception) {
-            ChunkProviderServer.a.error("Couldn\'t load chunk", exception);
-            return null;
-        }
-    }
-
-    public void saveChunkNOP(Chunk chunk) {
-        try {
-            this.chunkLoader.b(this.world, chunk);
-        } catch (Exception exception) {
-            ChunkProviderServer.a.error("Couldn\'t save entities", exception);
-        }
-
-    }
-
-    public void saveChunk(Chunk chunk) {
-        try {
-            chunk.setLastSaved(this.world.getTime());
-            this.chunkLoader.a(this.world, chunk);
-        } catch (IOException ioexception) {
-            ChunkProviderServer.a.error("Couldn\'t save chunk", ioexception);
-        } catch (ExceptionWorldConflict exceptionworldconflict) {
-            ChunkProviderServer.a.error("Couldn\'t save chunk; already in use by another instance of Minecraft?", exceptionworldconflict);
-        }
-
-    }
-
-    public boolean a(boolean flag) {
-        int i = 0;
-
-        // CraftBukkit start
-        Iterator iterator = this.chunks.values().iterator();
-        while (iterator.hasNext()) {
-            Chunk chunk = (Chunk) iterator.next();
-            // CraftBukkit end
-
-            if (flag) {
-                this.saveChunkNOP(chunk);
-            }
-
-            if (chunk.a(flag)) {
-                this.saveChunk(chunk);
-                chunk.f(false);
-                ++i;
-                if (i == 24 && !flag && false) { // Spigot
-                    return false;
-                }
-            }
-        }
-
-        return true;
-    }
-
-    public void c() {
-        this.chunkLoader.b();
-    }
-
-    public boolean unloadChunks() {
-        if (!this.world.savingDisabled) {
-            if (!this.unloadQueue.isEmpty()) {
-                Iterator iterator = this.unloadQueue.iterator();
-
-                for (int i = 0; i < 100 && iterator.hasNext(); iterator.remove()) {
-                    Long olong = (Long) iterator.next();
-                    Chunk chunk = (Chunk) this.chunks.get(olong);
-
-                    if (chunk != null && chunk.d) {
-                        // CraftBukkit start - move unload logic to own method
-                        if (!unloadChunk(chunk, true)) {
-                            continue;
-                        }
-                        // CraftBukkit end
-
-                        ++i;
-                    }
-                }
-            }
-
-            this.chunkLoader.a();
-        }
-
-        return false;
-    }
-
-    // CraftBukkit start
-    public boolean unloadChunk(Chunk chunk, boolean save) {
-        ChunkUnloadEvent event = new ChunkUnloadEvent(chunk.bukkitChunk, save);
-        this.world.getServer().getPluginManager().callEvent(event);
-        if (event.isCancelled()) {
-            return false;
-        }
-        save = event.isSaveChunk();
-
-        // Update neighbor counts
-        for (int x = -2; x < 3; x++) {
-            for (int z = -2; z < 3; z++) {
-                if (x == 0 && z == 0) {
-                    continue;
-                }
-
-                Chunk neighbor = this.getChunkIfLoaded(chunk.locX + x, chunk.locZ + z);
-                if (neighbor != null) {
-                    neighbor.setNeighborUnloaded(-x, -z);
-                    chunk.setNeighborUnloaded(x, z);
-                }
-            }
-        }
-        // Moved from unloadChunks above
-        chunk.removeEntities();
-        if (save) {
-            this.saveChunk(chunk);
-            this.saveChunkNOP(chunk);
-        }
-        this.chunks.remove(chunk.chunkKey);
-        return true;
-    }
-    // CraftBukkit end
-
-    public boolean e() {
-        return !this.world.savingDisabled;
-    }
-
-    public String getName() {
-        return "ServerChunkCache: " + this.chunks.size() + " Drop: " + this.unloadQueue.size();
-    }
-
-    public List<BiomeBase.BiomeMeta> a(EnumCreatureType enumcreaturetype, BlockPosition blockposition) {
-        return this.chunkGenerator.getMobsFor(enumcreaturetype, blockposition);
-    }
-
-    @Nullable
-    public BlockPosition a(World world, String s, BlockPosition blockposition) {
-        return this.chunkGenerator.findNearestMapFeature(world, s, blockposition);
-    }
-
-    public int g() {
-        return this.chunks.size();
-    }
-
-    public boolean isLoaded(int i, int j) {
-        return this.chunks.containsKey(ChunkCoordIntPair.a(i, j));
-    }
-}
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ForkJoinTask;
+import java.util.logging.Level;
+import javax.annotation.Nullable;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+// CraftBukkit start
+import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
+import org.bukkit.event.world.ChunkUnloadEvent;
+import org.spigotmc.SpigotWorldConfig;
+// CraftBukkit end
+
+public class ChunkProviderServer implements IChunkProvider {
+
+    private static final Logger a = LogManager.getLogger();
+    public final Set<Long> unloadQueue = Sets.newHashSet();
+    public final ChunkGenerator chunkGenerator;
+    private final IChunkLoader chunkLoader;
+    //public final Long2ObjectMap<Chunk> chunks = new Long2ObjectOpenHashMap(8192);
+    public final Map<Long, Chunk> chunks = Maps.newConcurrentMap();
+    public final WorldServer world;
+
+    public ChunkProviderServer(WorldServer worldserver, IChunkLoader ichunkloader, ChunkGenerator chunkgenerator) {
+        this.world = worldserver;
+        this.chunkLoader = ichunkloader;
+        this.chunkGenerator = chunkgenerator;
+    }
+
+    public Collection<Chunk> a() {
+        return this.chunks.values();
+    }
+
+    public void unload(Chunk chunk) {
+        if (this.world.worldProvider.c(chunk.locX, chunk.locZ)) {
+            this.unloadQueue.add(Long.valueOf(ChunkCoordIntPair.a(chunk.locX, chunk.locZ)));
+            chunk.d = true;
+        }
+
+    }
+
+    public void b() {
+        Iterator iterator = this.chunks.values().iterator();
+
+        while (iterator.hasNext()) {
+            Chunk chunk = (Chunk) iterator.next();
+
+            this.unload(chunk);
+        }
+
+    }
+
+    @Nullable
+    public Chunk getLoadedChunkAt(int i, int j) {
+        long k = ChunkCoordIntPair.a(i, j);
+        Chunk chunk = (Chunk) this.chunks.get(k);
+
+        if (chunk != null) {
+            chunk.d = false;
+        }
+
+        return chunk;
+    }
+
+    @Nullable
+    public Chunk getOrLoadChunkAt(int i, int j) {
+        Chunk chunk = this.getLoadedChunkAt(i, j);
+
+        if (chunk == null) {
+            // CraftBukkit start
+            ChunkRegionLoader loader = null;
+
+            if (this.chunkLoader instanceof ChunkRegionLoader) {
+                loader = (ChunkRegionLoader) this.chunkLoader;
+            }
+            if (loader != null && loader.chunkExists(world, i, j)) {
+                chunk = ChunkIOExecutor.syncChunkLoad(world, loader, this, i, j);
+            }
+        }
+
+        return chunk;
+    }
+
+    @Nullable
+    public Chunk originalGetOrLoadChunkAt(int i, int j) {
+        // CraftBukkit end
+        Chunk chunk = this.getLoadedChunkAt(i, j);
+
+        if (chunk == null) {
+            chunk = this.loadChunk(i, j);
+            if (chunk != null) {
+                this.chunks.put(ChunkCoordIntPair.a(i, j), chunk);
+                chunk.addEntities();
+                chunk.loadNearby(this, this.chunkGenerator, false); // CraftBukkit
+            }
+        }
+
+        return chunk;
+    }
+
+    // CraftBukkit start
+    public Chunk getChunkIfLoaded(int x, int z) {
+        return chunks.get(ChunkCoordIntPair.a(x, z));
+    }
+    // CraftBukkit end
+
+    public Chunk getChunkAt(int i, int j) {
+        return getChunkAt(i, j, null);
+    }
+
+    public Chunk getChunkAt(int i, int j, Runnable runnable) {
+        return getChunkAt(i, j, runnable, true);
+    }
+
+    public Chunk getChunkAt(int i, int j, Runnable runnable, boolean generate) {
+        Chunk chunk = getChunkIfLoaded(i, j);
+        ChunkRegionLoader loader = null;
+
+        if (this.chunkLoader instanceof ChunkRegionLoader) {
+            loader = (ChunkRegionLoader) this.chunkLoader;
+
+        }
+        // We can only use the queue for already generated chunks
+        if (chunk == null && loader != null && loader.chunkExists(world, i, j)) {
+            if (runnable != null) {
+                ChunkIOExecutor.queueChunkLoad(world, loader, this, i, j, runnable);
+                return null;
+            } else {
+                chunk = ChunkIOExecutor.syncChunkLoad(world, loader, this, i, j);
+            }
+        } else if (chunk == null && generate) {
+            chunk = originalGetChunkAt(i, j);
+        }
+
+        // If we didn't load the chunk async and have a callback run it now
+        if (runnable != null) {
+            runnable.run();
+        }
+
+        return chunk;
+    }
+
+    public Chunk originalGetChunkAt(int i, int j) {
+        Chunk chunk = this.originalGetOrLoadChunkAt(i, j);
+        // CraftBukkit end
+
+        if (chunk == null) {
+            world.timings.syncChunkLoadTimer.startTiming(); // Spigot
+            long k = ChunkCoordIntPair.a(i, j);
+
+            try {
+                //chunk = this.chunkGenerator.getOrCreateChunk(i, j);
+                SpigotWorldConfig.ChunkTask = ForkJoinTask.adapt(new originalGetChunkAt(i, j));
+                SpigotWorldConfig.ChunkPool.submit(SpigotWorldConfig.ChunkTask);
+                chunk = SpigotWorldConfig.ChunkTask.get();
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Exception generating new chunk");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Chunk to be generated");
+
+                crashreportsystemdetails.a("Location", (Object) String.format("%d,%d", new Object[] { Integer.valueOf(i), Integer.valueOf(j)}));
+                crashreportsystemdetails.a("Position hash", (Object) Long.valueOf(k));
+                crashreportsystemdetails.a("Generator", (Object) this.chunkGenerator);
+                throw new ReportedException(crashreport);
+            }
+
+            this.chunks.put(k, chunk);
+            chunk.addEntities();
+            chunk.loadNearby(this, this.chunkGenerator, true); // CraftBukkit
+            world.timings.syncChunkLoadTimer.stopTiming(); // Spigot
+        }
+
+        return chunk;
+    }
+
+    @Nullable
+    public Chunk loadChunk(int i, int j) {
+        try {
+            Chunk chunk = this.chunkLoader.a(this.world, i, j);
+
+            if (chunk != null) {
+                chunk.setLastSaved(this.world.getTime());
+                this.chunkGenerator.recreateStructures(chunk, i, j);
+            }
+
+            return chunk;
+        } catch (Exception exception) {
+            ChunkProviderServer.a.error("Couldn\'t load chunk", exception);
+            return null;
+        }
+    }
+
+    public void saveChunkNOP(Chunk chunk) {
+        try {
+            this.chunkLoader.b(this.world, chunk);
+        } catch (Exception exception) {
+            ChunkProviderServer.a.error("Couldn\'t save entities", exception);
+        }
+
+    }
+
+    public void saveChunk(Chunk chunk) {
+        try {
+            chunk.setLastSaved(this.world.getTime());
+            this.chunkLoader.a(this.world, chunk);
+        } catch (IOException ioexception) {
+            ChunkProviderServer.a.error("Couldn\'t save chunk", ioexception);
+        } catch (ExceptionWorldConflict exceptionworldconflict) {
+            ChunkProviderServer.a.error("Couldn\'t save chunk; already in use by another instance of Minecraft?", exceptionworldconflict);
+        }
+
+    }
+
+    public boolean a(boolean flag) {
+        int i = 0;
+
+        // CraftBukkit start
+        Iterator iterator = this.chunks.values().iterator();
+        while (iterator.hasNext()) {
+            Chunk chunk = (Chunk) iterator.next();
+            // CraftBukkit end
+
+            if (flag) {
+                this.saveChunkNOP(chunk);
+            }
+
+            if (chunk.a(flag)) {
+                this.saveChunk(chunk);
+                chunk.f(false);
+                ++i;
+                if (i == 24 && !flag && false) { // Spigot
+                    return false;
+                }
+            }
+        }
+
+        return true;
+    }
+
+    public void c() {
+        this.chunkLoader.b();
+    }
+
+    public boolean unloadChunks() {
+        if (!this.world.savingDisabled) {
+            if (!this.unloadQueue.isEmpty()) {
+                Iterator iterator = this.unloadQueue.iterator();
+
+                for (int i = 0; i < 100 && iterator.hasNext(); iterator.remove()) {
+                    Long olong = (Long) iterator.next();
+                    Chunk chunk = (Chunk) this.chunks.get(olong);
+
+                    if (chunk != null && chunk.d) {
+                        // CraftBukkit start - move unload logic to own method
+                        if (!unloadChunk(chunk, true)) {
+                            continue;
+                        }
+                        // CraftBukkit end
+
+                        ++i;
+                    }
+                }
+            }
+
+            this.chunkLoader.a();
+        }
+
+        return false;
+    }
+
+    // CraftBukkit start
+    public boolean unloadChunk(Chunk chunk, boolean save) {
+        ChunkUnloadEvent event = new ChunkUnloadEvent(chunk.bukkitChunk, save);
+        this.world.getServer().getPluginManager().callEvent(event);
+        if (event.isCancelled()) {
+            return false;
+        }
+        save = event.isSaveChunk();
+
+        // Update neighbor counts
+        for (int x = -2; x < 3; x++) {
+            for (int z = -2; z < 3; z++) {
+                if (x == 0 && z == 0) {
+                    continue;
+                }
+
+                Chunk neighbor = this.getChunkIfLoaded(chunk.locX + x, chunk.locZ + z);
+                if (neighbor != null) {
+                    neighbor.setNeighborUnloaded(-x, -z);
+                    chunk.setNeighborUnloaded(x, z);
+                }
+            }
+        }
+        // Moved from unloadChunks above
+        chunk.removeEntities();
+        if (save) {
+            this.saveChunk(chunk);
+            this.saveChunkNOP(chunk);
+        }
+        this.chunks.remove(chunk.chunkKey);
+        return true;
+    }
+    // CraftBukkit end
+
+    public boolean e() {
+        return !this.world.savingDisabled;
+    }
+
+    public String getName() {
+        return "ServerChunkCache: " + this.chunks.size() + " Drop: " + this.unloadQueue.size();
+    }
+
+    public List<BiomeBase.BiomeMeta> a(EnumCreatureType enumcreaturetype, BlockPosition blockposition) {
+        return this.chunkGenerator.getMobsFor(enumcreaturetype, blockposition);
+    }
+
+    @Nullable
+    public BlockPosition a(World world, String s, BlockPosition blockposition) {
+        return this.chunkGenerator.findNearestMapFeature(world, s, blockposition);
+    }
+
+    public int g() {
+        return this.chunks.size();
+    }
+
+    public boolean isLoaded(int i, int j) {
+        return this.chunks.containsKey(ChunkCoordIntPair.a(i, j));
+    }
+    
+    class originalGetChunkAt implements Callable<Chunk> {
+        int i, j;
+        
+        originalGetChunkAt(int i, int j){
+            this.i = i;
+            this.j = j;
+        }
+        
+        @Override
+        public Chunk call() throws Exception {
+            return chunkGenerator.getOrCreateChunk(i, j);
+        }
+        
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/ChunkRegionLoader.java src/main/java/net/minecraft/server/ChunkRegionLoader.java
--- src_origin/main/java/net/minecraft/server/ChunkRegionLoader.java	2016-08-25 22:39:50.892601887 +0800
+++ src/main/java/net/minecraft/server/ChunkRegionLoader.java	2016-08-26 03:24:13.309198360 +0800
@@ -1,551 +1,564 @@
-package net.minecraft.server;
-
-import java.io.DataInputStream;
-import java.io.DataOutput;
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
-import javax.annotation.Nullable;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-
-public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
-
-    private static final Logger a = LogManager.getLogger();
-    private final Map<ChunkCoordIntPair, NBTTagCompound> b = new ConcurrentHashMap();
-    private final Set<ChunkCoordIntPair> c = Collections.newSetFromMap(new ConcurrentHashMap());
-    private final File d;
-    private final DataConverterManager e;
-    private boolean f;
-
-    public ChunkRegionLoader(File file, DataConverterManager dataconvertermanager) {
-        this.d = file;
-        this.e = dataconvertermanager;
-    }
-
-    // CraftBukkit start
-    public boolean chunkExists(World world, int i, int j) {
-        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
-
-        if (this.c.contains(chunkcoordintpair)) {
-            if (this.b.containsKey(chunkcoordintpair)) {
-                return true;
-            }
-        }
-
-        return RegionFileCache.a(this.d, i, j).chunkExists(i & 31, j & 31);
-    }
-    // CraftBukkit end
-
-    // CraftBukkit start - Add async variant, provide compatibility
-    @Nullable
-    public Chunk a(World world, int i, int j) throws IOException {
-        world.timings.syncChunkLoadDataTimer.startTiming(); // Spigot
-        Object[] data = loadChunk(world, i, j);
-        world.timings.syncChunkLoadDataTimer.stopTiming(); // Spigot
-        if (data != null) {
-            Chunk chunk = (Chunk) data[0];
-            NBTTagCompound nbttagcompound = (NBTTagCompound) data[1];
-            loadEntities(chunk, nbttagcompound.getCompound("Level"), world);
-            return chunk;
-        }
-
-        return null;
-    }
-
-    public Object[] loadChunk(World world, int i, int j) throws IOException {
-        // CraftBukkit end
-        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
-        NBTTagCompound nbttagcompound = (NBTTagCompound) this.b.get(chunkcoordintpair);
-
-        if (nbttagcompound == null) {
-            // CraftBukkit start
-            nbttagcompound = RegionFileCache.c(this.d, i, j);
-
-            if (nbttagcompound == null) {
-                return null;
-            }
-
-            nbttagcompound = this.e.a((DataConverterType) DataConverterTypes.CHUNK, nbttagcompound);
-            // CraftBukkit end
-        }
-
-        return this.a(world, i, j, nbttagcompound);
-    }
-
-    protected Object[] a(World world, int i, int j, NBTTagCompound nbttagcompound) { // CraftBukkit - return Chunk -> Object[]
-        if (!nbttagcompound.hasKeyOfType("Level", 10)) {
-            ChunkRegionLoader.a.error("Chunk file at {},{} is missing level data, skipping", new Object[] { Integer.valueOf(i), Integer.valueOf(j)});
-            return null;
-        } else {
-            NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("Level");
-
-            if (!nbttagcompound1.hasKeyOfType("Sections", 9)) {
-                ChunkRegionLoader.a.error("Chunk file at {},{} is missing block data, skipping", new Object[] { Integer.valueOf(i), Integer.valueOf(j)});
-                return null;
-            } else {
-                Chunk chunk = this.a(world, nbttagcompound1);
-
-                if (!chunk.a(i, j)) {
-                    ChunkRegionLoader.a.error("Chunk file at {},{} is in the wrong location; relocating. (Expected {}, {}, got {}, {})", new Object[] { Integer.valueOf(i), Integer.valueOf(j), Integer.valueOf(i), Integer.valueOf(j), Integer.valueOf(chunk.locX), Integer.valueOf(chunk.locZ)});
-                    nbttagcompound1.setInt("xPos", i);
-                    nbttagcompound1.setInt("zPos", j);
-
-                    // CraftBukkit start - Have to move tile entities since we don't load them at this stage
-                    NBTTagList tileEntities = nbttagcompound.getCompound("Level").getList("TileEntities", 10);
-                    if (tileEntities != null) {
-                        for (int te = 0; te < tileEntities.size(); te++) {
-                            NBTTagCompound tileEntity = (NBTTagCompound) tileEntities.get(te);
-                            int x = tileEntity.getInt("x") - chunk.locX * 16;
-                            int z = tileEntity.getInt("z") - chunk.locZ * 16;
-                            tileEntity.setInt("x", i * 16 + x);
-                            tileEntity.setInt("z", j * 16 + z);
-                        }
-                    }
-                    // CraftBukkit end
-                    chunk = this.a(world, nbttagcompound1);
-                }
-
-                // CraftBukkit start
-                Object[] data = new Object[2];
-                data[0] = chunk;
-                data[1] = nbttagcompound;
-                return data;
-                // CraftBukkit end
-            }
-        }
-    }
-
-    public void a(World world, Chunk chunk) throws IOException, ExceptionWorldConflict {
-        world.checkSession();
-
-        try {
-            NBTTagCompound nbttagcompound = new NBTTagCompound();
-            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
-
-            nbttagcompound.set("Level", nbttagcompound1);
-            nbttagcompound.setInt("DataVersion", 512);
-            this.a(chunk, world, nbttagcompound1);
-            this.a(chunk.k(), nbttagcompound);
-        } catch (Exception exception) {
-            ChunkRegionLoader.a.error("Failed to save chunk", exception);
-        }
-
-    }
-
-    protected void a(ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound) {
-        if (!this.c.contains(chunkcoordintpair)) {
-            this.b.put(chunkcoordintpair, nbttagcompound);
-        }
-
-        FileIOThread.a().a(this);
-    }
-
-    public boolean c() {
-        if (this.b.isEmpty()) {
-            if (this.f) {
-                ChunkRegionLoader.a.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", new Object[] { this.d.getName()});
-            }
-
-            return false;
-        } else {
-            ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) this.b.keySet().iterator().next();
-
-            boolean flag;
-
-            try {
-                this.c.add(chunkcoordintpair);
-                NBTTagCompound nbttagcompound = (NBTTagCompound) this.b.remove(chunkcoordintpair);
-
-                if (nbttagcompound != null) {
-                    try {
-                        this.b(chunkcoordintpair, nbttagcompound);
-                    } catch (Exception exception) {
-                        ChunkRegionLoader.a.error("Failed to save chunk", exception);
-                    }
-                }
-
-                flag = true;
-            } finally {
-                this.c.remove(chunkcoordintpair);
-            }
-
-            return flag;
-        }
-    }
-
-    private void b(ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound) throws IOException {
-        // CraftBukkit start
-        RegionFileCache.d(this.d, chunkcoordintpair.x, chunkcoordintpair.z, nbttagcompound);
-
-        /*
-        NBTCompressedStreamTools.a(nbttagcompound, (DataOutput) dataoutputstream);
-        dataoutputstream.close();
-        */
-        // CraftBukkit end
-    }
-
-    public void b(World world, Chunk chunk) throws IOException {}
-
-    public void a() {}
-
-    public void b() {
-        try {
-            this.f = true;
-
-            while (true) {
-                if (this.c()) {
-                    continue;
-                }
-                break; // CraftBukkit - Fix infinite loop when saving chunks
-            }
-        } finally {
-            this.f = false;
-        }
-
-    }
-
-    public static void a(DataConverterManager dataconvertermanager) {
-        dataconvertermanager.a(DataConverterTypes.CHUNK, new DataInspector() {
-            public NBTTagCompound a(DataConverter dataconverter, NBTTagCompound nbttagcompound, int i) {
-                if (nbttagcompound.hasKeyOfType("Level", 10)) {
-                    NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("Level");
-                    NBTTagList nbttaglist;
-                    int j;
-
-                    if (nbttagcompound1.hasKeyOfType("Entities", 9)) {
-                        nbttaglist = nbttagcompound1.getList("Entities", 10);
-
-                        for (j = 0; j < nbttaglist.size(); ++j) {
-                            nbttaglist.a(j, dataconverter.a(DataConverterTypes.ENTITY, (NBTTagCompound) nbttaglist.h(j), i));
-                        }
-                    }
-
-                    if (nbttagcompound1.hasKeyOfType("TileEntities", 9)) {
-                        nbttaglist = nbttagcompound1.getList("TileEntities", 10);
-
-                        for (j = 0; j < nbttaglist.size(); ++j) {
-                            nbttaglist.a(j, dataconverter.a(DataConverterTypes.BLOCK_ENTITY, (NBTTagCompound) nbttaglist.h(j), i));
-                        }
-                    }
-                }
-
-                return nbttagcompound;
-            }
-        });
-    }
-
-    private void a(Chunk chunk, World world, NBTTagCompound nbttagcompound) {
-        nbttagcompound.setInt("xPos", chunk.locX);
-        nbttagcompound.setInt("zPos", chunk.locZ);
-        nbttagcompound.setLong("LastUpdate", world.getTime());
-        nbttagcompound.setIntArray("HeightMap", chunk.r());
-        nbttagcompound.setBoolean("TerrainPopulated", chunk.isDone());
-        nbttagcompound.setBoolean("LightPopulated", chunk.v());
-        nbttagcompound.setLong("InhabitedTime", chunk.x());
-        ChunkSection[] achunksection = chunk.getSections();
-        NBTTagList nbttaglist = new NBTTagList();
-        boolean flag = !world.worldProvider.m();
-        ChunkSection[] achunksection1 = achunksection;
-        int i = achunksection.length;
-
-        NBTTagCompound nbttagcompound1;
-
-        for (int j = 0; j < i; ++j) {
-            ChunkSection chunksection = achunksection1[j];
-
-            if (chunksection != Chunk.a) {
-                nbttagcompound1 = new NBTTagCompound();
-                nbttagcompound1.setByte("Y", (byte) (chunksection.getYPosition() >> 4 & 255));
-                byte[] abyte = new byte[4096];
-                NibbleArray nibblearray = new NibbleArray();
-                NibbleArray nibblearray1 = chunksection.getBlocks().exportData(abyte, nibblearray);
-
-                nbttagcompound1.setByteArray("Blocks", abyte);
-                nbttagcompound1.setByteArray("Data", nibblearray.asBytes());
-                if (nibblearray1 != null) {
-                    nbttagcompound1.setByteArray("Add", nibblearray1.asBytes());
-                }
-
-                nbttagcompound1.setByteArray("BlockLight", chunksection.getEmittedLightArray().asBytes());
-                if (flag) {
-                    nbttagcompound1.setByteArray("SkyLight", chunksection.getSkyLightArray().asBytes());
-                } else {
-                    nbttagcompound1.setByteArray("SkyLight", new byte[chunksection.getEmittedLightArray().asBytes().length]);
-                }
-
-                nbttaglist.add(nbttagcompound1);
-            }
-        }
-
-        nbttagcompound.set("Sections", nbttaglist);
-        nbttagcompound.setByteArray("Biomes", chunk.getBiomeIndex());
-        chunk.g(false);
-        NBTTagList nbttaglist1 = new NBTTagList();
-
-        Iterator iterator;
-
-        for (i = 0; i < chunk.getEntitySlices().length; ++i) {
-            iterator = chunk.getEntitySlices()[i].iterator();
-
-            while (iterator.hasNext()) {
-                Entity entity = (Entity) iterator.next();
-
-                nbttagcompound1 = new NBTTagCompound();
-                if (entity.d(nbttagcompound1)) {
-                    chunk.g(true);
-                    nbttaglist1.add(nbttagcompound1);
-                }
-            }
-        }
-
-        nbttagcompound.set("Entities", nbttaglist1);
-        NBTTagList nbttaglist2 = new NBTTagList();
-
-        iterator = chunk.getTileEntities().values().iterator();
-
-        while (iterator.hasNext()) {
-            TileEntity tileentity = (TileEntity) iterator.next();
-
-            nbttagcompound1 = tileentity.save(new NBTTagCompound());
-            nbttaglist2.add(nbttagcompound1);
-        }
-
-        nbttagcompound.set("TileEntities", nbttaglist2);
-        List list = world.a(chunk, false);
-
-        if (list != null) {
-            long k = world.getTime();
-            NBTTagList nbttaglist3 = new NBTTagList();
-            Iterator iterator1 = list.iterator();
-
-            while (iterator1.hasNext()) {
-                NextTickListEntry nextticklistentry = (NextTickListEntry) iterator1.next();
-                NBTTagCompound nbttagcompound2 = new NBTTagCompound();
-                MinecraftKey minecraftkey = (MinecraftKey) Block.REGISTRY.b(nextticklistentry.a());
-
-                nbttagcompound2.setString("i", minecraftkey == null ? "" : minecraftkey.toString());
-                nbttagcompound2.setInt("x", nextticklistentry.a.getX());
-                nbttagcompound2.setInt("y", nextticklistentry.a.getY());
-                nbttagcompound2.setInt("z", nextticklistentry.a.getZ());
-                nbttagcompound2.setInt("t", (int) (nextticklistentry.b - k));
-                nbttagcompound2.setInt("p", nextticklistentry.c);
-                nbttaglist3.add(nbttagcompound2);
-            }
-
-            nbttagcompound.set("TileTicks", nbttaglist3);
-        }
-
-    }
-
-    private Chunk a(World world, NBTTagCompound nbttagcompound) {
-        int i = nbttagcompound.getInt("xPos");
-        int j = nbttagcompound.getInt("zPos");
-        Chunk chunk = new Chunk(world, i, j);
-
-        chunk.a(nbttagcompound.getIntArray("HeightMap"));
-        chunk.d(nbttagcompound.getBoolean("TerrainPopulated"));
-        chunk.e(nbttagcompound.getBoolean("LightPopulated"));
-        chunk.c(nbttagcompound.getLong("InhabitedTime"));
-        NBTTagList nbttaglist = nbttagcompound.getList("Sections", 10);
-        boolean flag = true;
-        ChunkSection[] achunksection = new ChunkSection[16];
-        boolean flag1 = !world.worldProvider.m();
-
-        for (int k = 0; k < nbttaglist.size(); ++k) {
-            NBTTagCompound nbttagcompound1 = nbttaglist.get(k);
-            byte b0 = nbttagcompound1.getByte("Y");
-            ChunkSection chunksection = new ChunkSection(b0 << 4, flag1);
-            byte[] abyte = nbttagcompound1.getByteArray("Blocks");
-            NibbleArray nibblearray = new NibbleArray(nbttagcompound1.getByteArray("Data"));
-            NibbleArray nibblearray1 = nbttagcompound1.hasKeyOfType("Add", 7) ? new NibbleArray(nbttagcompound1.getByteArray("Add")) : null;
-
-            chunksection.getBlocks().a(abyte, nibblearray, nibblearray1);
-            chunksection.a(new NibbleArray(nbttagcompound1.getByteArray("BlockLight")));
-            if (flag1) {
-                chunksection.b(new NibbleArray(nbttagcompound1.getByteArray("SkyLight")));
-            }
-
-            chunksection.recalcBlockCounts();
-            achunksection[b0] = chunksection;
-        }
-
-        chunk.a(achunksection);
-        if (nbttagcompound.hasKeyOfType("Biomes", 7)) {
-            chunk.a(nbttagcompound.getByteArray("Biomes"));
-        }
-
-        // CraftBukkit start - End this method here and split off entity loading to another method
-        return chunk;
-    }
-
-    public void loadEntities(Chunk chunk, NBTTagCompound nbttagcompound, World world) {
-        // CraftBukkit end
-        world.timings.syncChunkLoadEntitiesTimer.startTiming(); // Spigot
-        NBTTagList nbttaglist1 = nbttagcompound.getList("Entities", 10);
-
-        if (nbttaglist1 != null) {
-            for (int l = 0; l < nbttaglist1.size(); ++l) {
-                NBTTagCompound nbttagcompound2 = nbttaglist1.get(l);
-
-                a(nbttagcompound2, world, chunk);
-                chunk.g(true);
-            }
-        }
-        world.timings.syncChunkLoadEntitiesTimer.stopTiming(); // Spigot
-        world.timings.syncChunkLoadTileEntitiesTimer.startTiming(); // Spigot
-        NBTTagList nbttaglist2 = nbttagcompound.getList("TileEntities", 10);
-
-        if (nbttaglist2 != null) {
-            for (int i1 = 0; i1 < nbttaglist2.size(); ++i1) {
-                NBTTagCompound nbttagcompound3 = nbttaglist2.get(i1);
-                TileEntity tileentity = TileEntity.a(world, nbttagcompound3);
-
-                if (tileentity != null) {
-                    chunk.a(tileentity);
-                }
-            }
-        }
-        world.timings.syncChunkLoadTileEntitiesTimer.stopTiming(); // Spigot
-        world.timings.syncChunkLoadTileTicksTimer.startTiming(); // Spigot
-
-        if (nbttagcompound.hasKeyOfType("TileTicks", 9)) {
-            NBTTagList nbttaglist3 = nbttagcompound.getList("TileTicks", 10);
-
-            if (nbttaglist3 != null) {
-                for (int j1 = 0; j1 < nbttaglist3.size(); ++j1) {
-                    NBTTagCompound nbttagcompound4 = nbttaglist3.get(j1);
-                    Block block;
-
-                    if (nbttagcompound4.hasKeyOfType("i", 8)) {
-                        block = Block.getByName(nbttagcompound4.getString("i"));
-                    } else {
-                        block = Block.getById(nbttagcompound4.getInt("i"));
-                    }
-
-                    world.b(new BlockPosition(nbttagcompound4.getInt("x"), nbttagcompound4.getInt("y"), nbttagcompound4.getInt("z")), block, nbttagcompound4.getInt("t"), nbttagcompound4.getInt("p"));
-                }
-            }
-        }
-        world.timings.syncChunkLoadTileTicksTimer.stopTiming(); // Spigot
-
-        // return chunk; // CraftBukkit
-    }
-
-    @Nullable
-    public static Entity a(NBTTagCompound nbttagcompound, World world, Chunk chunk) {
-        Entity entity = a(nbttagcompound, world);
-
-        if (entity == null) {
-            return null;
-        } else {
-            chunk.a(entity);
-            if (nbttagcompound.hasKeyOfType("Passengers", 9)) {
-                NBTTagList nbttaglist = nbttagcompound.getList("Passengers", 10);
-
-                for (int i = 0; i < nbttaglist.size(); ++i) {
-                    Entity entity1 = a(nbttaglist.get(i), world, chunk);
-
-                    if (entity1 != null) {
-                        entity1.a(entity, true);
-                    }
-                }
-            }
-
-            return entity;
-        }
-    }
-
-    @Nullable
-    // CraftBukkit start
-    public static Entity a(NBTTagCompound nbttagcompound, World world, double d0, double d1, double d2, boolean flag) {
-        return spawnEntity(nbttagcompound, world, d0, d1, d2, flag, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT);
-    }
-
-    public static Entity spawnEntity(NBTTagCompound nbttagcompound, World world, double d0, double d1, double d2, boolean flag, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason spawnReason) {
-        // CraftBukkit end
-        Entity entity = a(nbttagcompound, world);
-
-        if (entity == null) {
-            return null;
-        } else {
-            entity.setPositionRotation(d0, d1, d2, entity.yaw, entity.pitch);
-            if (flag && !world.addEntity(entity, spawnReason)) { // CraftBukkit
-                return null;
-            } else {
-                if (nbttagcompound.hasKeyOfType("Passengers", 9)) {
-                    NBTTagList nbttaglist = nbttagcompound.getList("Passengers", 10);
-
-                    for (int i = 0; i < nbttaglist.size(); ++i) {
-                        Entity entity1 = a(nbttaglist.get(i), world, d0, d1, d2, flag);
-
-                        if (entity1 != null) {
-                            entity1.a(entity, true);
-                        }
-                    }
-                }
-
-                return entity;
-            }
-        }
-    }
-
-    @Nullable
-    protected static Entity a(NBTTagCompound nbttagcompound, World world) {
-        try {
-            return EntityTypes.a(nbttagcompound, world);
-        } catch (RuntimeException runtimeexception) {
-            return null;
-        }
-    }
-
-    // CraftBukkit start
-    public static void a(Entity entity, World world) {
-        a(entity, world, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT);
-    }
-
-    public static void a(Entity entity, World world, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) {
-        if (world.addEntity(entity, reason) && entity.isVehicle()) {
-            // CraftBukkit end
-            Iterator iterator = entity.bx().iterator();
-
-            while (iterator.hasNext()) {
-                Entity entity1 = (Entity) iterator.next();
-
-                a(entity1, world);
-            }
-        }
-
-    }
-
-    @Nullable
-    public static Entity a(NBTTagCompound nbttagcompound, World world, boolean flag) {
-        Entity entity = a(nbttagcompound, world);
-
-        if (entity == null) {
-            return null;
-        } else if (flag && !world.addEntity(entity)) {
-            return null;
-        } else {
-            if (nbttagcompound.hasKeyOfType("Passengers", 9)) {
-                NBTTagList nbttaglist = nbttagcompound.getList("Passengers", 10);
-
-                for (int i = 0; i < nbttaglist.size(); ++i) {
-                    Entity entity1 = a(nbttaglist.get(i), world, flag);
-
-                    if (entity1 != null) {
-                        entity1.a(entity, true);
-                    }
-                }
-            }
-
-            return entity;
-        }
-    }
-}
+package net.minecraft.server;
+
+import java.io.DataInputStream;
+import java.io.DataOutput;
+import java.io.DataOutputStream;
+import java.io.File;
+import java.io.IOException;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ForkJoinTask;
+import java.util.concurrent.RecursiveAction;
+import java.util.logging.Level;
+import java.util.stream.IntStream;
+import javax.annotation.Nullable;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.spigotmc.SpigotWorldConfig;
+
+public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
+
+    private static final Logger a = LogManager.getLogger();
+    private final Map<ChunkCoordIntPair, NBTTagCompound> b = new ConcurrentHashMap();
+    private final Set<ChunkCoordIntPair> c = Collections.newSetFromMap(new ConcurrentHashMap());
+    private final File d;
+    private final DataConverterManager e;
+    private boolean f;
+
+    public ChunkRegionLoader(File file, DataConverterManager dataconvertermanager) {
+        this.d = file;
+        this.e = dataconvertermanager;
+    }
+
+    // CraftBukkit start
+    public boolean chunkExists(World world, int i, int j) {
+        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
+
+        if (this.c.contains(chunkcoordintpair)) {
+            if (this.b.containsKey(chunkcoordintpair)) {
+                return true;
+            }
+        }
+
+        return RegionFileCache.a(this.d, i, j).chunkExists(i & 31, j & 31);
+    }
+    // CraftBukkit end
+
+    // CraftBukkit start - Add async variant, provide compatibility
+    @Nullable
+    public Chunk a(World world, int i, int j) throws IOException {
+        world.timings.syncChunkLoadDataTimer.startTiming(); // Spigot
+        Object[] data = loadChunk(world, i, j);
+        world.timings.syncChunkLoadDataTimer.stopTiming(); // Spigot
+        if (data != null) {
+            Chunk chunk = (Chunk) data[0];
+            NBTTagCompound nbttagcompound = (NBTTagCompound) data[1];
+            loadEntities(chunk, nbttagcompound.getCompound("Level"), world);
+            return chunk;
+        }
+
+        return null;
+    }
+
+    public Object[] loadChunk(World world, int i, int j) throws IOException {
+        // CraftBukkit end
+        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
+        NBTTagCompound nbttagcompound = (NBTTagCompound) this.b.get(chunkcoordintpair);
+
+        if (nbttagcompound == null) {
+            // CraftBukkit start
+            nbttagcompound = RegionFileCache.c(this.d, i, j);
+
+            if (nbttagcompound == null) {
+                return null;
+            }
+
+            nbttagcompound = this.e.a((DataConverterType) DataConverterTypes.CHUNK, nbttagcompound);
+            // CraftBukkit end
+        }
+
+        return this.a(world, i, j, nbttagcompound);
+    }
+
+    protected Object[] a(World world, int i, int j, NBTTagCompound nbttagcompound) { // CraftBukkit - return Chunk -> Object[]
+        if (!nbttagcompound.hasKeyOfType("Level", 10)) {
+            ChunkRegionLoader.a.error("Chunk file at {},{} is missing level data, skipping", new Object[] { Integer.valueOf(i), Integer.valueOf(j)});
+            return null;
+        } else {
+            NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("Level");
+
+            if (!nbttagcompound1.hasKeyOfType("Sections", 9)) {
+                ChunkRegionLoader.a.error("Chunk file at {},{} is missing block data, skipping", new Object[] { Integer.valueOf(i), Integer.valueOf(j)});
+                return null;
+            } else {
+                Chunk chunk = this.a(world, nbttagcompound1);
+
+                if (!chunk.a(i, j)) {
+                    ChunkRegionLoader.a.error("Chunk file at {},{} is in the wrong location; relocating. (Expected {}, {}, got {}, {})", new Object[] { Integer.valueOf(i), Integer.valueOf(j), Integer.valueOf(i), Integer.valueOf(j), Integer.valueOf(chunk.locX), Integer.valueOf(chunk.locZ)});
+                    nbttagcompound1.setInt("xPos", i);
+                    nbttagcompound1.setInt("zPos", j);
+
+                    // CraftBukkit start - Have to move tile entities since we don't load them at this stage
+                    NBTTagList tileEntities = nbttagcompound.getCompound("Level").getList("TileEntities", 10);
+                    if (tileEntities != null) {
+                        for (int te = 0; te < tileEntities.size(); te++) {
+                            NBTTagCompound tileEntity = (NBTTagCompound) tileEntities.get(te);
+                            int x = tileEntity.getInt("x") - chunk.locX * 16;
+                            int z = tileEntity.getInt("z") - chunk.locZ * 16;
+                            tileEntity.setInt("x", i * 16 + x);
+                            tileEntity.setInt("z", j * 16 + z);
+                        }
+                    }
+                    // CraftBukkit end
+                    chunk = this.a(world, nbttagcompound1);
+                }
+
+                // CraftBukkit start
+                Object[] data = new Object[2];
+                data[0] = chunk;
+                data[1] = nbttagcompound;
+                return data;
+                // CraftBukkit end
+            }
+        }
+    }
+
+    public void a(World world, Chunk chunk) throws IOException, ExceptionWorldConflict {
+        world.checkSession();
+
+        try {
+            NBTTagCompound nbttagcompound = new NBTTagCompound();
+            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+            nbttagcompound.set("Level", nbttagcompound1);
+            nbttagcompound.setInt("DataVersion", 512);
+            this.a(chunk, world, nbttagcompound1);
+            this.a(chunk.k(), nbttagcompound);
+        } catch (Exception exception) {
+            ChunkRegionLoader.a.error("Failed to save chunk", exception);
+        }
+
+    }
+
+    protected void a(ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound) {
+        if (!this.c.contains(chunkcoordintpair)) {
+            this.b.put(chunkcoordintpair, nbttagcompound);
+        }
+
+        FileIOThread.a().a(this);
+    }
+
+    public boolean c() {
+        if (this.b.isEmpty()) {
+            if (this.f) {
+                ChunkRegionLoader.a.info("ThreadedAnvilChunkStorage ({}): All chunks are saved", new Object[] { this.d.getName()});
+            }
+
+            return false;
+        } else {
+            ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) this.b.keySet().iterator().next();
+
+            boolean flag;
+
+            try {
+                this.c.add(chunkcoordintpair);
+                NBTTagCompound nbttagcompound = (NBTTagCompound) this.b.remove(chunkcoordintpair);
+
+                if (nbttagcompound != null) {
+                    try {
+                        this.b(chunkcoordintpair, nbttagcompound);
+                    } catch (Exception exception) {
+                        ChunkRegionLoader.a.error("Failed to save chunk", exception);
+                    }
+                }
+
+                flag = true;
+            } finally {
+                this.c.remove(chunkcoordintpair);
+            }
+
+            return flag;
+        }
+    }
+
+    private void b(ChunkCoordIntPair chunkcoordintpair, NBTTagCompound nbttagcompound) throws IOException {
+        // CraftBukkit start
+        RegionFileCache.d(this.d, chunkcoordintpair.x, chunkcoordintpair.z, nbttagcompound);
+
+        /*
+        NBTCompressedStreamTools.a(nbttagcompound, (DataOutput) dataoutputstream);
+        dataoutputstream.close();
+        */
+        // CraftBukkit end
+    }
+
+    public void b(World world, Chunk chunk) throws IOException {}
+
+    public void a() {}
+
+    public void b() {
+        try {
+            this.f = true;
+
+            while (true) {
+                if (this.c()) {
+                    continue;
+                }
+                break; // CraftBukkit - Fix infinite loop when saving chunks
+            }
+        } finally {
+            this.f = false;
+        }
+
+    }
+
+    public static void a(DataConverterManager dataconvertermanager) {
+        dataconvertermanager.a(DataConverterTypes.CHUNK, new DataInspector() {
+            public NBTTagCompound a(DataConverter dataconverter, NBTTagCompound nbttagcompound, int i) {
+                if (nbttagcompound.hasKeyOfType("Level", 10)) {
+                    NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("Level");
+                    NBTTagList nbttaglist;
+                    int j;
+
+                    if (nbttagcompound1.hasKeyOfType("Entities", 9)) {
+                        nbttaglist = nbttagcompound1.getList("Entities", 10);
+
+                        for (j = 0; j < nbttaglist.size(); ++j) {
+                            nbttaglist.a(j, dataconverter.a(DataConverterTypes.ENTITY, (NBTTagCompound) nbttaglist.h(j), i));
+                        }
+                    }
+
+                    if (nbttagcompound1.hasKeyOfType("TileEntities", 9)) {
+                        nbttaglist = nbttagcompound1.getList("TileEntities", 10);
+
+                        for (j = 0; j < nbttaglist.size(); ++j) {
+                            nbttaglist.a(j, dataconverter.a(DataConverterTypes.BLOCK_ENTITY, (NBTTagCompound) nbttaglist.h(j), i));
+                        }
+                    }
+                }
+
+                return nbttagcompound;
+            }
+        });
+    }
+
+    private void a(Chunk chunk, World world, NBTTagCompound nbttagcompound) {
+        nbttagcompound.setInt("xPos", chunk.locX);
+        nbttagcompound.setInt("zPos", chunk.locZ);
+        nbttagcompound.setLong("LastUpdate", world.getTime());
+        nbttagcompound.setIntArray("HeightMap", chunk.r());
+        nbttagcompound.setBoolean("TerrainPopulated", chunk.isDone());
+        nbttagcompound.setBoolean("LightPopulated", chunk.v());
+        nbttagcompound.setLong("InhabitedTime", chunk.x());
+        ChunkSection[] achunksection = chunk.getSections();
+        NBTTagList nbttaglist = new NBTTagList();
+        boolean flag = !world.worldProvider.m();
+        ChunkSection[] achunksection1 = achunksection;
+        int i = achunksection.length;
+
+        NBTTagCompound nbttagcompound1;
+
+        for (int j = 0; j < i; ++j) {
+            ChunkSection chunksection = achunksection1[j];
+
+            if (chunksection != Chunk.a) {
+                nbttagcompound1 = new NBTTagCompound();
+                nbttagcompound1.setByte("Y", (byte) (chunksection.getYPosition() >> 4 & 255));
+                byte[] abyte = new byte[4096];
+                NibbleArray nibblearray = new NibbleArray();
+                NibbleArray nibblearray1 = chunksection.getBlocks().exportData(abyte, nibblearray);
+
+                nbttagcompound1.setByteArray("Blocks", abyte);
+                nbttagcompound1.setByteArray("Data", nibblearray.asBytes());
+                if (nibblearray1 != null) {
+                    nbttagcompound1.setByteArray("Add", nibblearray1.asBytes());
+                }
+
+                nbttagcompound1.setByteArray("BlockLight", chunksection.getEmittedLightArray().asBytes());
+                if (flag) {
+                    nbttagcompound1.setByteArray("SkyLight", chunksection.getSkyLightArray().asBytes());
+                } else {
+                    nbttagcompound1.setByteArray("SkyLight", new byte[chunksection.getEmittedLightArray().asBytes().length]);
+                }
+
+                nbttaglist.add(nbttagcompound1);
+            }
+        }
+
+        nbttagcompound.set("Sections", nbttaglist);
+        nbttagcompound.setByteArray("Biomes", chunk.getBiomeIndex());
+        chunk.g(false);
+        NBTTagList nbttaglist1 = new NBTTagList();
+
+        Iterator iterator;
+
+        for (i = 0; i < chunk.getEntitySlices().length; ++i) {
+            iterator = chunk.getEntitySlices()[i].iterator();
+
+            while (iterator.hasNext()) {
+                Entity entity = (Entity) iterator.next();
+
+                nbttagcompound1 = new NBTTagCompound();
+                if (entity.d(nbttagcompound1)) {
+                    chunk.g(true);
+                    nbttaglist1.add(nbttagcompound1);
+                }
+            }
+        }
+
+        nbttagcompound.set("Entities", nbttaglist1);
+        NBTTagList nbttaglist2 = new NBTTagList();
+
+        iterator = chunk.getTileEntities().values().iterator();
+
+        while (iterator.hasNext()) {
+            TileEntity tileentity = (TileEntity) iterator.next();
+
+            nbttagcompound1 = tileentity.save(new NBTTagCompound());
+            nbttaglist2.add(nbttagcompound1);
+        }
+
+        nbttagcompound.set("TileEntities", nbttaglist2);
+        List list = world.a(chunk, false);
+
+        if (list != null) {
+            long k = world.getTime();
+            NBTTagList nbttaglist3 = new NBTTagList();
+            Iterator iterator1 = list.iterator();
+
+            while (iterator1.hasNext()) {
+                NextTickListEntry nextticklistentry = (NextTickListEntry) iterator1.next();
+                NBTTagCompound nbttagcompound2 = new NBTTagCompound();
+                MinecraftKey minecraftkey = (MinecraftKey) Block.REGISTRY.b(nextticklistentry.a());
+
+                nbttagcompound2.setString("i", minecraftkey == null ? "" : minecraftkey.toString());
+                nbttagcompound2.setInt("x", nextticklistentry.a.getX());
+                nbttagcompound2.setInt("y", nextticklistentry.a.getY());
+                nbttagcompound2.setInt("z", nextticklistentry.a.getZ());
+                nbttagcompound2.setInt("t", (int) (nextticklistentry.b - k));
+                nbttagcompound2.setInt("p", nextticklistentry.c);
+                nbttaglist3.add(nbttagcompound2);
+            }
+
+            nbttagcompound.set("TileTicks", nbttaglist3);
+        }
+
+    }
+
+    private Chunk a(World world, NBTTagCompound nbttagcompound) {
+        int i = nbttagcompound.getInt("xPos");
+        int j = nbttagcompound.getInt("zPos");
+        Chunk chunk = new Chunk(world, i, j);
+
+        chunk.a(nbttagcompound.getIntArray("HeightMap"));
+        chunk.d(nbttagcompound.getBoolean("TerrainPopulated"));
+        chunk.e(nbttagcompound.getBoolean("LightPopulated"));
+        chunk.c(nbttagcompound.getLong("InhabitedTime"));
+        NBTTagList nbttaglist = nbttagcompound.getList("Sections", 10);
+        boolean flag = true;
+        ChunkSection[] achunksection = new ChunkSection[16];
+        boolean flag1 = !world.worldProvider.m();
+
+        for (int k = 0; k < nbttaglist.size(); ++k) {
+            NBTTagCompound nbttagcompound1 = nbttaglist.get(k);
+            byte b0 = nbttagcompound1.getByte("Y");
+            ChunkSection chunksection = new ChunkSection(b0 << 4, flag1);
+            byte[] abyte = nbttagcompound1.getByteArray("Blocks");
+            NibbleArray nibblearray = new NibbleArray(nbttagcompound1.getByteArray("Data"));
+            NibbleArray nibblearray1 = nbttagcompound1.hasKeyOfType("Add", 7) ? new NibbleArray(nbttagcompound1.getByteArray("Add")) : null;
+
+            chunksection.getBlocks().a(abyte, nibblearray, nibblearray1);
+            chunksection.a(new NibbleArray(nbttagcompound1.getByteArray("BlockLight")));
+            if (flag1) {
+                chunksection.b(new NibbleArray(nbttagcompound1.getByteArray("SkyLight")));
+            }
+
+            chunksection.recalcBlockCounts();
+            achunksection[b0] = chunksection;
+        }
+
+        chunk.a(achunksection);
+        if (nbttagcompound.hasKeyOfType("Biomes", 7)) {
+            chunk.a(nbttagcompound.getByteArray("Biomes"));
+        }
+
+        // CraftBukkit start - End this method here and split off entity loading to another method
+        return chunk;
+    }
+
+    //fork this
+    public void loadEntities(Chunk chunk, NBTTagCompound nbttagcompound, World world) {
+        // CraftBukkit end
+        world.timings.syncChunkLoadEntitiesTimer.startTiming(); // Spigot
+        NBTTagList nbttaglist1 = nbttagcompound.getList("Entities", 10);
+
+        if (nbttaglist1 != null) {
+            for (int l = 0; l < nbttaglist1.size(); ++l) {
+                NBTTagCompound nbttagcompound2 = nbttaglist1.get(l);
+
+                a(nbttagcompound2, world, chunk);
+                chunk.g(true);
+            }
+        }
+        world.timings.syncChunkLoadEntitiesTimer.stopTiming(); // Spigot
+        world.timings.syncChunkLoadTileEntitiesTimer.startTiming(); // Spigot
+        NBTTagList nbttaglist2 = nbttagcompound.getList("TileEntities", 10);
+
+        if (nbttaglist2 != null) {
+            for (int i1 = 0; i1 < nbttaglist2.size(); ++i1) {
+                NBTTagCompound nbttagcompound3 = nbttaglist2.get(i1);
+                TileEntity tileentity = TileEntity.a(world, nbttagcompound3);
+
+                if (tileentity != null) {
+                    chunk.a(tileentity);
+                }
+            }
+        }
+        world.timings.syncChunkLoadTileEntitiesTimer.stopTiming(); // Spigot
+        world.timings.syncChunkLoadTileTicksTimer.startTiming(); // Spigot
+
+        if (nbttagcompound.hasKeyOfType("TileTicks", 9)) {
+            NBTTagList nbttaglist3 = nbttagcompound.getList("TileTicks", 10);
+
+            if (nbttaglist3 != null) {
+                for (int j1 = 0; j1 < nbttaglist3.size(); ++j1) {
+                    NBTTagCompound nbttagcompound4 = nbttaglist3.get(j1);
+                    Block block;
+
+                    if (nbttagcompound4.hasKeyOfType("i", 8)) {
+                        block = Block.getByName(nbttagcompound4.getString("i"));
+                    } else {
+                        block = Block.getById(nbttagcompound4.getInt("i"));
+                    }
+                    //add to next tick, include button
+                    world.b(new BlockPosition(nbttagcompound4.getInt("x"), nbttagcompound4.getInt("y"), nbttagcompound4.getInt("z")), block, nbttagcompound4.getInt("t"), nbttagcompound4.getInt("p"));
+                }
+            }
+        }
+        //add to next at once
+        /*if (!WorldServer.nextTickQueue.isEmpty()) {
+            WorldServer.nextTickList.addAll(WorldServer.nextTickQueue);
+            WorldServer.nextTickQueue.clear();
+        }*/
+        world.timings.syncChunkLoadTileTicksTimer.stopTiming(); // Spigot
+
+        // return chunk; // CraftBukkit
+    }
+
+    @Nullable
+    public static Entity a(NBTTagCompound nbttagcompound, World world, Chunk chunk) {
+        Entity entity = a(nbttagcompound, world);
+
+        if (entity == null) {
+            return null;
+        } else {
+            chunk.a(entity);
+            if (nbttagcompound.hasKeyOfType("Passengers", 9)) {
+                NBTTagList nbttaglist = nbttagcompound.getList("Passengers", 10);
+
+                for (int i = 0; i < nbttaglist.size(); ++i) {
+                    Entity entity1 = a(nbttaglist.get(i), world, chunk);
+
+                    if (entity1 != null) {
+                        entity1.a(entity, true);
+                    }
+                }
+            }
+
+            return entity;
+        }
+    }
+
+    @Nullable
+    // CraftBukkit start
+    public static Entity a(NBTTagCompound nbttagcompound, World world, double d0, double d1, double d2, boolean flag) {
+        return spawnEntity(nbttagcompound, world, d0, d1, d2, flag, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT);
+    }
+
+    public static Entity spawnEntity(NBTTagCompound nbttagcompound, World world, double d0, double d1, double d2, boolean flag, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason spawnReason) {
+        // CraftBukkit end
+        Entity entity = a(nbttagcompound, world);
+
+        if (entity == null) {
+            return null;
+        } else {
+            entity.setPositionRotation(d0, d1, d2, entity.yaw, entity.pitch);
+            if (flag && !world.addEntity(entity, spawnReason)) { // CraftBukkit
+                return null;
+            } else {
+                if (nbttagcompound.hasKeyOfType("Passengers", 9)) {
+                    NBTTagList nbttaglist = nbttagcompound.getList("Passengers", 10);
+
+                    for (int i = 0; i < nbttaglist.size(); ++i) {
+                        Entity entity1 = a(nbttaglist.get(i), world, d0, d1, d2, flag);
+
+                        if (entity1 != null) {
+                            entity1.a(entity, true);
+                        }
+                    }
+                }
+
+                return entity;
+            }
+        }
+    }
+
+    @Nullable
+    protected static Entity a(NBTTagCompound nbttagcompound, World world) {
+        try {
+            return EntityTypes.a(nbttagcompound, world);
+        } catch (RuntimeException runtimeexception) {
+            return null;
+        }
+    }
+
+    // CraftBukkit start
+    public static void a(Entity entity, World world) {
+        a(entity, world, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT);
+    }
+
+    public static void a(Entity entity, World world, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason reason) {
+        if (world.addEntity(entity, reason) && entity.isVehicle()) {
+            // CraftBukkit end
+            Iterator iterator = entity.bx().iterator();
+
+            while (iterator.hasNext()) {
+                Entity entity1 = (Entity) iterator.next();
+
+                a(entity1, world);
+            }
+        }
+
+    }
+
+    @Nullable
+    public static Entity a(NBTTagCompound nbttagcompound, World world, boolean flag) {
+        Entity entity = a(nbttagcompound, world);
+
+        if (entity == null) {
+            return null;
+        } else if (flag && !world.addEntity(entity)) {
+            return null;
+        } else {
+            if (nbttagcompound.hasKeyOfType("Passengers", 9)) {
+                NBTTagList nbttaglist = nbttagcompound.getList("Passengers", 10);
+
+                for (int i = 0; i < nbttaglist.size(); ++i) {
+                    Entity entity1 = a(nbttaglist.get(i), world, flag);
+
+                    if (entity1 != null) {
+                        entity1.a(entity, true);
+                    }
+                }
+            }
+
+            return entity;
+        }
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/EntityInsentient.java src/main/java/net/minecraft/server/EntityInsentient.java
--- src_origin/main/java/net/minecraft/server/EntityInsentient.java	2016-08-25 22:39:51.351601930 +0800
+++ src/main/java/net/minecraft/server/EntityInsentient.java	2016-08-26 03:24:13.792198405 +0800
@@ -1,1273 +1,1281 @@
-package net.minecraft.server;
-
-import com.google.common.collect.Maps;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.UUID;
-import javax.annotation.Nullable;
-
-// CraftBukkit start
-import org.bukkit.craftbukkit.event.CraftEventFactory;
-import org.bukkit.craftbukkit.entity.CraftLivingEntity;
-import org.bukkit.event.entity.EntityTargetLivingEntityEvent;
-import org.bukkit.event.entity.EntityTargetEvent;
-import org.bukkit.event.entity.EntityUnleashEvent;
-import org.bukkit.event.entity.EntityUnleashEvent.UnleashReason;
-// CraftBukkit end
-
-public abstract class EntityInsentient extends EntityLiving {
-
-    private static final DataWatcherObject<Byte> a = DataWatcher.a(EntityInsentient.class, DataWatcherRegistry.a);
-    public int a_;
-    protected int b_;
-    private final ControllerLook lookController;
-    protected ControllerMove moveController;
-    protected ControllerJump g;
-    private final EntityAIBodyControl c;
-    protected NavigationAbstract navigation;
-    public PathfinderGoalSelector goalSelector;
-    public PathfinderGoalSelector targetSelector;
-    private EntityLiving goalTarget;
-    private final EntitySenses bw;
-    private final ItemStack[] bx = new ItemStack[2];
-    public float[] dropChanceHand = new float[2];
-    private final ItemStack[] by = new ItemStack[4];
-    public float[] dropChanceArmor = new float[4];
-    public boolean canPickUpLoot;
-    public boolean persistent;
-    private final Map<PathType, Float> bB = Maps.newEnumMap(PathType.class);
-    private MinecraftKey bC;
-    private long bD;
-    private boolean bE;
-    private Entity leashHolder;
-    private NBTTagCompound bG;
-
-    public EntityInsentient(World world) {
-        super(world);
-        this.goalSelector = new PathfinderGoalSelector(world != null && world.methodProfiler != null ? world.methodProfiler : null);
-        this.targetSelector = new PathfinderGoalSelector(world != null && world.methodProfiler != null ? world.methodProfiler : null);
-        this.lookController = new ControllerLook(this);
-        this.moveController = new ControllerMove(this);
-        this.g = new ControllerJump(this);
-        this.c = this.s();
-        this.navigation = this.b(world);
-        this.bw = new EntitySenses(this);
-        Arrays.fill(this.dropChanceArmor, 0.085F);
-        Arrays.fill(this.dropChanceHand, 0.085F);
-        if (world != null && !world.isClientSide) {
-            this.r();
-        }
-
-        // CraftBukkit start - default persistance to type's persistance value
-        this.persistent = !isTypeNotPersistent();
-        // CraftBukkit end
-    }
-
-    protected void r() {}
-
-    protected void initAttributes() {
-        super.initAttributes();
-        this.getAttributeMap().b(GenericAttributes.FOLLOW_RANGE).setValue(16.0D);
-    }
-
-    protected NavigationAbstract b(World world) {
-        return new Navigation(this, world);
-    }
-
-    public float a(PathType pathtype) {
-        // CraftBukkit - decompile error
-        Float ofloat = (Float) this.bB.get(pathtype);
-
-        return ofloat == null ? pathtype.a() : ofloat.floatValue();
-    }
-
-    public void a(PathType pathtype, float f) {
-        this.bB.put(pathtype, Float.valueOf(f));
-    }
-
-    protected EntityAIBodyControl s() {
-        return new EntityAIBodyControl(this);
-    }
-
-    public ControllerLook getControllerLook() {
-        return this.lookController;
-    }
-
-    public ControllerMove getControllerMove() {
-        return this.moveController;
-    }
-
-    public ControllerJump getControllerJump() {
-        return this.g;
-    }
-
-    public NavigationAbstract getNavigation() {
-        return this.navigation;
-    }
-
-    public EntitySenses getEntitySenses() {
-        return this.bw;
-    }
-
-    @Nullable
-    public EntityLiving getGoalTarget() {
-        return this.goalTarget;
-    }
-
-    public void setGoalTarget(@Nullable EntityLiving entityliving) {
-        // CraftBukkit start - fire event
-        setGoalTarget(entityliving, EntityTargetEvent.TargetReason.UNKNOWN, true);
-    }
-
-    public boolean setGoalTarget(EntityLiving entityliving, EntityTargetEvent.TargetReason reason, boolean fireEvent) {
-        if (getGoalTarget() == entityliving) return false;
-        if (fireEvent) {
-            if (reason == EntityTargetEvent.TargetReason.UNKNOWN && getGoalTarget() != null && entityliving == null) {
-                reason = getGoalTarget().isAlive() ? EntityTargetEvent.TargetReason.FORGOT_TARGET : EntityTargetEvent.TargetReason.TARGET_DIED;
-            }
-            if (reason == EntityTargetEvent.TargetReason.UNKNOWN) {
-                world.getServer().getLogger().log(java.util.logging.Level.WARNING, "Unknown target reason, please report on the issue tracker", new Exception());
-            }
-            CraftLivingEntity ctarget = null;
-            if (entityliving != null) {
-                ctarget = (CraftLivingEntity) entityliving.getBukkitEntity();
-            }
-            EntityTargetLivingEntityEvent event = new EntityTargetLivingEntityEvent(this.getBukkitEntity(), ctarget, reason);
-            world.getServer().getPluginManager().callEvent(event);
-            if (event.isCancelled()) {
-                return false;
-            }
-
-            if (event.getTarget() != null) {
-                entityliving = ((CraftLivingEntity) event.getTarget()).getHandle();
-            } else {
-                entityliving = null;
-            }
-        }
-        this.goalTarget = entityliving;
-        return true;
-        // CraftBukkit end
-    }
-
-    public boolean d(Class<? extends EntityLiving> oclass) {
-        return oclass != EntityGhast.class;
-    }
-
-    public void A() {}
-
-    protected void i() {
-        super.i();
-        this.datawatcher.register(EntityInsentient.a, Byte.valueOf((byte) 0));
-    }
-
-    public int C() {
-        return 80;
-    }
-
-    public void D() {
-        SoundEffect soundeffect = this.G();
-
-        if (soundeffect != null) {
-            this.a(soundeffect, this.ch(), this.ci());
-        }
-
-    }
-
-    public void U() {
-        super.U();
-        this.world.methodProfiler.a("mobBaseTick");
-        if (this.isAlive() && this.random.nextInt(1000) < this.a_++) {
-            this.o();
-            this.D();
-        }
-
-        this.world.methodProfiler.b();
-    }
-
-    protected void c(DamageSource damagesource) {
-        this.o();
-        super.c(damagesource);
-    }
-
-    private void o() {
-        this.a_ = -this.C();
-    }
-
-    protected int getExpValue(EntityHuman entityhuman) {
-        if (this.b_ > 0) {
-            int i = this.b_;
-
-            int j;
-
-            for (j = 0; j < this.by.length; ++j) {
-                if (this.by[j] != null && this.dropChanceArmor[j] <= 1.0F) {
-                    i += 1 + this.random.nextInt(3);
-                }
-            }
-
-            for (j = 0; j < this.bx.length; ++j) {
-                if (this.bx[j] != null && this.dropChanceHand[j] <= 1.0F) {
-                    i += 1 + this.random.nextInt(3);
-                }
-            }
-
-            return i;
-        } else {
-            return this.b_;
-        }
-    }
-
-    public void doSpawnEffect() {
-        if (this.world.isClientSide) {
-            for (int i = 0; i < 20; ++i) {
-                double d0 = this.random.nextGaussian() * 0.02D;
-                double d1 = this.random.nextGaussian() * 0.02D;
-                double d2 = this.random.nextGaussian() * 0.02D;
-                double d3 = 10.0D;
-
-                this.world.addParticle(EnumParticle.EXPLOSION_NORMAL, this.locX + (double) (this.random.nextFloat() * this.width * 2.0F) - (double) this.width - d0 * 10.0D, this.locY + (double) (this.random.nextFloat() * this.length) - d1 * 10.0D, this.locZ + (double) (this.random.nextFloat() * this.width * 2.0F) - (double) this.width - d2 * 10.0D, d0, d1, d2, new int[0]);
-            }
-        } else {
-            this.world.broadcastEntityEffect(this, (byte) 20);
-        }
-
-    }
-
-    public void m() {
-        super.m();
-        if (!this.world.isClientSide) {
-            this.cT();
-            if (this.ticksLived % 5 == 0) {
-                boolean flag = !(this.bw() instanceof EntityInsentient);
-                boolean flag1 = !(this.bB() instanceof EntityBoat);
-
-                this.goalSelector.a(1, flag);
-                this.goalSelector.a(4, flag && flag1);
-                this.goalSelector.a(2, flag);
-            }
-        }
-
-    }
-
-    protected float h(float f, float f1) {
-        this.c.a();
-        return f1;
-    }
-
-    @Nullable
-    protected SoundEffect G() {
-        return null;
-    }
-
-    @Nullable
-    protected Item getLoot() {
-        return null;
-    }
-
-    protected void dropDeathLoot(boolean flag, int i) {
-        Item item = this.getLoot();
-
-        if (item != null) {
-            int j = this.random.nextInt(3);
-
-            if (i > 0) {
-                j += this.random.nextInt(i + 1);
-            }
-
-            for (int k = 0; k < j; ++k) {
-                this.a(item, 1);
-            }
-        }
-
-    }
-
-    public static void a(DataConverterManager dataconvertermanager, String s) {
-        dataconvertermanager.a(DataConverterTypes.ENTITY, (DataInspector) (new DataInspectorItemList(s, new String[] { "ArmorItems", "HandItems"})));
-    }
-
-    public static void a(DataConverterManager dataconvertermanager) {
-        a(dataconvertermanager, "Mob");
-    }
-
-    public void b(NBTTagCompound nbttagcompound) {
-        super.b(nbttagcompound);
-        nbttagcompound.setBoolean("CanPickUpLoot", this.cR());
-        nbttagcompound.setBoolean("PersistenceRequired", this.persistent);
-        NBTTagList nbttaglist = new NBTTagList();
-        ItemStack[] aitemstack = this.by;
-        int i = aitemstack.length;
-
-        int j;
-
-        for (j = 0; j < i; ++j) {
-            ItemStack itemstack = aitemstack[j];
-            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
-
-            if (itemstack != null) {
-                itemstack.save(nbttagcompound1);
-            }
-
-            nbttaglist.add(nbttagcompound1);
-        }
-
-        nbttagcompound.set("ArmorItems", nbttaglist);
-        NBTTagList nbttaglist1 = new NBTTagList();
-        ItemStack[] aitemstack1 = this.bx;
-
-        j = aitemstack1.length;
-
-        int k;
-
-        for (k = 0; k < j; ++k) {
-            ItemStack itemstack1 = aitemstack1[k];
-            NBTTagCompound nbttagcompound2 = new NBTTagCompound();
-
-            if (itemstack1 != null) {
-                itemstack1.save(nbttagcompound2);
-            }
-
-            nbttaglist1.add(nbttagcompound2);
-        }
-
-        nbttagcompound.set("HandItems", nbttaglist1);
-        NBTTagList nbttaglist2 = new NBTTagList();
-        float[] afloat = this.dropChanceArmor;
-
-        k = afloat.length;
-
-        int l;
-
-        for (l = 0; l < k; ++l) {
-            float f = afloat[l];
-
-            nbttaglist2.add(new NBTTagFloat(f));
-        }
-
-        nbttagcompound.set("ArmorDropChances", nbttaglist2);
-        NBTTagList nbttaglist3 = new NBTTagList();
-        float[] afloat1 = this.dropChanceHand;
-
-        l = afloat1.length;
-
-        for (int i1 = 0; i1 < l; ++i1) {
-            float f1 = afloat1[i1];
-
-            nbttaglist3.add(new NBTTagFloat(f1));
-        }
-
-        nbttagcompound.set("HandDropChances", nbttaglist3);
-        nbttagcompound.setBoolean("Leashed", this.bE);
-        if (this.leashHolder != null) {
-            NBTTagCompound nbttagcompound3 = new NBTTagCompound();
-
-            if (this.leashHolder instanceof EntityLiving) {
-                UUID uuid = this.leashHolder.getUniqueID();
-
-                nbttagcompound3.a("UUID", uuid);
-            } else if (this.leashHolder instanceof EntityHanging) {
-                BlockPosition blockposition = ((EntityHanging) this.leashHolder).getBlockPosition();
-
-                nbttagcompound3.setInt("X", blockposition.getX());
-                nbttagcompound3.setInt("Y", blockposition.getY());
-                nbttagcompound3.setInt("Z", blockposition.getZ());
-            }
-
-            nbttagcompound.set("Leash", nbttagcompound3);
-        }
-
-        nbttagcompound.setBoolean("LeftHanded", this.cX());
-        if (this.bC != null) {
-            nbttagcompound.setString("DeathLootTable", this.bC.toString());
-            if (this.bD != 0L) {
-                nbttagcompound.setLong("DeathLootTableSeed", this.bD);
-            }
-        }
-
-        if (this.hasAI()) {
-            nbttagcompound.setBoolean("NoAI", this.hasAI());
-        }
-
-    }
-
-    public void a(NBTTagCompound nbttagcompound) {
-        super.a(nbttagcompound);
-
-        // CraftBukkit start - If looting or persistence is false only use it if it was set after we started using it
-        if (nbttagcompound.hasKeyOfType("CanPickUpLoot", 1)) {
-            boolean data = nbttagcompound.getBoolean("CanPickUpLoot");
-            if (isLevelAtLeast(nbttagcompound, 1) || data) {
-                this.l(data);
-            }
-        }
-
-        boolean data = nbttagcompound.getBoolean("PersistenceRequired");
-        if (isLevelAtLeast(nbttagcompound, 1) || data) {
-            this.persistent = data;
-        }
-        // CraftBukkit end
-        NBTTagList nbttaglist;
-        int i;
-
-        if (nbttagcompound.hasKeyOfType("ArmorItems", 9)) {
-            nbttaglist = nbttagcompound.getList("ArmorItems", 10);
-
-            for (i = 0; i < this.by.length; ++i) {
-                this.by[i] = ItemStack.createStack(nbttaglist.get(i));
-            }
-        }
-
-        if (nbttagcompound.hasKeyOfType("HandItems", 9)) {
-            nbttaglist = nbttagcompound.getList("HandItems", 10);
-
-            for (i = 0; i < this.bx.length; ++i) {
-                this.bx[i] = ItemStack.createStack(nbttaglist.get(i));
-            }
-        }
-
-        if (nbttagcompound.hasKeyOfType("ArmorDropChances", 9)) {
-            nbttaglist = nbttagcompound.getList("ArmorDropChances", 5);
-
-            for (i = 0; i < nbttaglist.size(); ++i) {
-                this.dropChanceArmor[i] = nbttaglist.f(i);
-            }
-        }
-
-        if (nbttagcompound.hasKeyOfType("HandDropChances", 9)) {
-            nbttaglist = nbttagcompound.getList("HandDropChances", 5);
-
-            for (i = 0; i < nbttaglist.size(); ++i) {
-                this.dropChanceHand[i] = nbttaglist.f(i);
-            }
-        }
-
-        this.bE = nbttagcompound.getBoolean("Leashed");
-        if (this.bE && nbttagcompound.hasKeyOfType("Leash", 10)) {
-            this.bG = nbttagcompound.getCompound("Leash");
-        }
-
-        this.o(nbttagcompound.getBoolean("LeftHanded"));
-        if (nbttagcompound.hasKeyOfType("DeathLootTable", 8)) {
-            this.bC = new MinecraftKey(nbttagcompound.getString("DeathLootTable"));
-            this.bD = nbttagcompound.getLong("DeathLootTableSeed");
-        }
-
-        this.setAI(nbttagcompound.getBoolean("NoAI"));
-    }
-
-    @Nullable
-    protected MinecraftKey J() {
-        return null;
-    }
-
-    protected void a(boolean flag, int i, DamageSource damagesource) {
-        MinecraftKey minecraftkey = this.bC;
-
-        if (minecraftkey == null) {
-            minecraftkey = this.J();
-        }
-
-        if (minecraftkey != null) {
-            LootTable loottable = this.world.ak().a(minecraftkey);
-
-            this.bC = null;
-            LootTableInfo.a loottableinfo_a = (new LootTableInfo.a((WorldServer) this.world)).a((Entity) this).a(damagesource);
-
-            if (flag && this.killer != null) {
-                loottableinfo_a = loottableinfo_a.a(this.killer).a(this.killer.dg());
-            }
-
-            List list = loottable.a(this.bD == 0L ? this.random : new Random(this.bD), loottableinfo_a.a());
-            Iterator iterator = list.iterator();
-
-            while (iterator.hasNext()) {
-                ItemStack itemstack = (ItemStack) iterator.next();
-
-                this.a(itemstack, 0.0F);
-            }
-
-            this.dropEquipment(flag, i);
-        } else {
-            super.a(flag, i, damagesource);
-        }
-
-    }
-
-    public void o(float f) {
-        this.bg = f;
-    }
-
-    public void p(float f) {
-        this.bf = f;
-    }
-
-    public void l(float f) {
-        super.l(f);
-        this.o(f);
-    }
-
-    public void n() {
-        super.n();
-        this.world.methodProfiler.a("looting");
-        if (!this.world.isClientSide && this.cR() && !this.aV && this.world.getGameRules().getBoolean("mobGriefing")) {
-            List list = this.world.a(EntityItem.class, this.getBoundingBox().grow(1.0D, 0.0D, 1.0D));
-            Iterator iterator = list.iterator();
-
-            while (iterator.hasNext()) {
-                EntityItem entityitem = (EntityItem) iterator.next();
-
-                if (!entityitem.dead && entityitem.getItemStack() != null && !entityitem.t()) {
-                    this.a(entityitem);
-                }
-            }
-        }
-
-        this.world.methodProfiler.b();
-    }
-
-    protected void a(EntityItem entityitem) {
-        ItemStack itemstack = entityitem.getItemStack();
-        EnumItemSlot enumitemslot = d(itemstack);
-        boolean flag = true;
-        ItemStack itemstack1 = this.getEquipment(enumitemslot);
-
-        if (itemstack1 != null) {
-            if (enumitemslot.a() == EnumItemSlot.Function.HAND) {
-                if (itemstack.getItem() instanceof ItemSword && !(itemstack1.getItem() instanceof ItemSword)) {
-                    flag = true;
-                } else if (itemstack.getItem() instanceof ItemSword && itemstack1.getItem() instanceof ItemSword) {
-                    ItemSword itemsword = (ItemSword) itemstack.getItem();
-                    ItemSword itemsword1 = (ItemSword) itemstack1.getItem();
-
-                    if (itemsword.g() == itemsword1.g()) {
-                        flag = itemstack.getData() > itemstack1.getData() || itemstack.hasTag() && !itemstack1.hasTag();
-                    } else {
-                        flag = itemsword.g() > itemsword1.g();
-                    }
-                } else if (itemstack.getItem() instanceof ItemBow && itemstack1.getItem() instanceof ItemBow) {
-                    flag = itemstack.hasTag() && !itemstack1.hasTag();
-                } else {
-                    flag = false;
-                }
-            } else if (itemstack.getItem() instanceof ItemArmor && !(itemstack1.getItem() instanceof ItemArmor)) {
-                flag = true;
-            } else if (itemstack.getItem() instanceof ItemArmor && itemstack1.getItem() instanceof ItemArmor) {
-                ItemArmor itemarmor = (ItemArmor) itemstack.getItem();
-                ItemArmor itemarmor1 = (ItemArmor) itemstack1.getItem();
-
-                if (itemarmor.d == itemarmor1.d) {
-                    flag = itemstack.getData() > itemstack1.getData() || itemstack.hasTag() && !itemstack1.hasTag();
-                } else {
-                    flag = itemarmor.d > itemarmor1.d;
-                }
-            } else {
-                flag = false;
-            }
-        }
-
-        if (flag && this.c(itemstack)) {
-            double d0;
-
-            switch (EntityInsentient.SyntheticClass_1.a[enumitemslot.a().ordinal()]) {
-            case 1:
-                d0 = (double) this.dropChanceHand[enumitemslot.b()];
-                break;
-
-            case 2:
-                d0 = (double) this.dropChanceArmor[enumitemslot.b()];
-                break;
-
-            default:
-                d0 = 0.0D;
-            }
-
-            if (itemstack1 != null && (double) (this.random.nextFloat() - 0.1F) < d0) {
-                this.a(itemstack1, 0.0F);
-            }
-
-            if (itemstack.getItem() == Items.DIAMOND && entityitem.n() != null) {
-                EntityHuman entityhuman = this.world.a(entityitem.n());
-
-                if (entityhuman != null) {
-                    entityhuman.b((Statistic) AchievementList.x);
-                }
-            }
-
-            this.setSlot(enumitemslot, itemstack);
-            switch (EntityInsentient.SyntheticClass_1.a[enumitemslot.a().ordinal()]) {
-            case 1:
-                this.dropChanceHand[enumitemslot.b()] = 2.0F;
-                break;
-
-            case 2:
-                this.dropChanceArmor[enumitemslot.b()] = 2.0F;
-            }
-
-            this.persistent = true;
-            this.receive(entityitem, 1);
-            entityitem.die();
-        }
-
-    }
-
-    protected boolean c(ItemStack itemstack) {
-        return true;
-    }
-
-    protected boolean isTypeNotPersistent() {
-        return true;
-    }
-
-    protected void L() {
-        if (this.persistent) {
-            this.ticksFarFromPlayer = 0;
-        } else {
-            EntityHuman entityhuman = this.world.findNearbyPlayer(this, -1.0D);
-
-            if (entityhuman != null) {
-                double d0 = entityhuman.locX - this.locX;
-                double d1 = entityhuman.locY - this.locY;
-                double d2 = entityhuman.locZ - this.locZ;
-                double d3 = d0 * d0 + d1 * d1 + d2 * d2;
-
-                if (d3 > 16384.0D) { // CraftBukkit - remove isTypeNotPersistent() check
-                    this.die();
-                }
-
-                if (this.ticksFarFromPlayer > 600 && this.random.nextInt(800) == 0 && d3 > 1024.0D) { // CraftBukkit - remove isTypeNotPersistent() check
-                    this.die();
-                } else if (d3 < 1024.0D) {
-                    this.ticksFarFromPlayer = 0;
-                }
-            }
-
-        }
-    }
-
-    protected final void doTick() {
-        ++this.ticksFarFromPlayer;
-        this.world.methodProfiler.a("checkDespawn");
-        this.L();
-        this.world.methodProfiler.b();
-        // Spigot Start
-        if ( this.fromMobSpawner )
-        {
-            return;
-        }
-        // Spigot End
-        this.world.methodProfiler.a("sensing");
-        this.bw.a();
-        this.world.methodProfiler.b();
-        this.world.methodProfiler.a("targetSelector");
-        this.targetSelector.a();
-        this.world.methodProfiler.b();
-        this.world.methodProfiler.a("goalSelector");
-        this.goalSelector.a();
-        this.world.methodProfiler.b();
-        this.world.methodProfiler.a("navigation");
-        this.navigation.l();
-        this.world.methodProfiler.b();
-        this.world.methodProfiler.a("mob tick");
-        this.M();
-        this.world.methodProfiler.b();
-        if (this.isPassenger() && this.bB() instanceof EntityInsentient) {
-            EntityInsentient entityinsentient = (EntityInsentient) this.bB();
-
-            entityinsentient.getNavigation().a(this.getNavigation().k(), 1.5D);
-            entityinsentient.getControllerMove().a(this.getControllerMove());
-        }
-
-        this.world.methodProfiler.a("controls");
-        this.world.methodProfiler.a("move");
-        this.moveController.c();
-        this.world.methodProfiler.c("look");
-        this.lookController.a();
-        this.world.methodProfiler.c("jump");
-        this.g.b();
-        this.world.methodProfiler.b();
-        this.world.methodProfiler.b();
-    }
-
-    protected void M() {}
-
-    public int N() {
-        return 40;
-    }
-
-    public int cJ() {
-        return 10;
-    }
-
-    public void a(Entity entity, float f, float f1) {
-        double d0 = entity.locX - this.locX;
-        double d1 = entity.locZ - this.locZ;
-        double d2;
-
-        if (entity instanceof EntityLiving) {
-            EntityLiving entityliving = (EntityLiving) entity;
-
-            d2 = entityliving.locY + (double) entityliving.getHeadHeight() - (this.locY + (double) this.getHeadHeight());
-        } else {
-            d2 = (entity.getBoundingBox().b + entity.getBoundingBox().e) / 2.0D - (this.locY + (double) this.getHeadHeight());
-        }
-
-        double d3 = (double) MathHelper.sqrt(d0 * d0 + d1 * d1);
-        float f2 = (float) (MathHelper.b(d1, d0) * 57.2957763671875D) - 90.0F;
-        float f3 = (float) (-(MathHelper.b(d2, d3) * 57.2957763671875D));
-
-        this.pitch = this.b(this.pitch, f3, f1);
-        this.yaw = this.b(this.yaw, f2, f);
-    }
-
-    private float b(float f, float f1, float f2) {
-        float f3 = MathHelper.g(f1 - f);
-
-        if (f3 > f2) {
-            f3 = f2;
-        }
-
-        if (f3 < -f2) {
-            f3 = -f2;
-        }
-
-        return f + f3;
-    }
-
-    public boolean cK() {
-        IBlockData iblockdata = this.world.getType((new BlockPosition(this)).down());
-
-        return iblockdata.a((Entity) this);
-    }
-
-    public boolean canSpawn() {
-        return !this.world.containsLiquid(this.getBoundingBox()) && this.world.getCubes(this, this.getBoundingBox()).isEmpty() && this.world.a(this.getBoundingBox(), (Entity) this);
-    }
-
-    public int cO() {
-        return 4;
-    }
-
-    public int aY() {
-        if (this.getGoalTarget() == null) {
-            return 3;
-        } else {
-            int i = (int) (this.getHealth() - this.getMaxHealth() * 0.33F);
-
-            i -= (3 - this.world.getDifficulty().a()) * 4;
-            if (i < 0) {
-                i = 0;
-            }
-
-            return i + 3;
-        }
-    }
-
-    public Iterable<ItemStack> aG() {
-        return Arrays.asList(this.bx);
-    }
-
-    public Iterable<ItemStack> getArmorItems() {
-        return Arrays.asList(this.by);
-    }
-
-    @Nullable
-    public ItemStack getEquipment(EnumItemSlot enumitemslot) {
-        ItemStack itemstack = null;
-
-        switch (EntityInsentient.SyntheticClass_1.a[enumitemslot.a().ordinal()]) {
-        case 1:
-            itemstack = this.bx[enumitemslot.b()];
-            break;
-
-        case 2:
-            itemstack = this.by[enumitemslot.b()];
-        }
-
-        return itemstack;
-    }
-
-    public void setSlot(EnumItemSlot enumitemslot, @Nullable ItemStack itemstack) {
-        switch (EntityInsentient.SyntheticClass_1.a[enumitemslot.a().ordinal()]) {
-        case 1:
-            this.bx[enumitemslot.b()] = itemstack;
-            break;
-
-        case 2:
-            this.by[enumitemslot.b()] = itemstack;
-        }
-
-    }
-
-    protected void dropEquipment(boolean flag, int i) {
-        EnumItemSlot[] aenumitemslot = EnumItemSlot.values();
-        int j = aenumitemslot.length;
-
-        for (int k = 0; k < j; ++k) {
-            EnumItemSlot enumitemslot = aenumitemslot[k];
-            ItemStack itemstack = this.getEquipment(enumitemslot);
-            double d0;
-
-            switch (EntityInsentient.SyntheticClass_1.a[enumitemslot.a().ordinal()]) {
-            case 1:
-                d0 = (double) this.dropChanceHand[enumitemslot.b()];
-                break;
-
-            case 2:
-                d0 = (double) this.dropChanceArmor[enumitemslot.b()];
-                break;
-
-            default:
-                d0 = 0.0D;
-            }
-
-            boolean flag1 = d0 > 1.0D;
-
-            if (itemstack != null && (flag || flag1) && (double) (this.random.nextFloat() - (float) i * 0.01F) < d0) {
-                if (!flag1 && itemstack.e()) {
-                    int l = Math.max(itemstack.j() - 25, 1);
-                    int i1 = itemstack.j() - this.random.nextInt(this.random.nextInt(l) + 1);
-
-                    if (i1 > l) {
-                        i1 = l;
-                    }
-
-                    if (i1 < 1) {
-                        i1 = 1;
-                    }
-
-                    itemstack.setData(i1);
-                }
-
-                this.a(itemstack, 0.0F);
-            }
-        }
-
-    }
-
-    protected void a(DifficultyDamageScaler difficultydamagescaler) {
-        if (this.random.nextFloat() < 0.15F * difficultydamagescaler.d()) {
-            int i = this.random.nextInt(2);
-            float f = this.world.getDifficulty() == EnumDifficulty.HARD ? 0.1F : 0.25F;
-
-            if (this.random.nextFloat() < 0.095F) {
-                ++i;
-            }
-
-            if (this.random.nextFloat() < 0.095F) {
-                ++i;
-            }
-
-            if (this.random.nextFloat() < 0.095F) {
-                ++i;
-            }
-
-            boolean flag = true;
-            EnumItemSlot[] aenumitemslot = EnumItemSlot.values();
-            int j = aenumitemslot.length;
-
-            for (int k = 0; k < j; ++k) {
-                EnumItemSlot enumitemslot = aenumitemslot[k];
-
-                if (enumitemslot.a() == EnumItemSlot.Function.ARMOR) {
-                    ItemStack itemstack = this.getEquipment(enumitemslot);
-
-                    if (!flag && this.random.nextFloat() < f) {
-                        break;
-                    }
-
-                    flag = false;
-                    if (itemstack == null) {
-                        Item item = a(enumitemslot, i);
-
-                        if (item != null) {
-                            this.setSlot(enumitemslot, new ItemStack(item));
-                        }
-                    }
-                }
-            }
-        }
-
-    }
-
-    public static EnumItemSlot d(ItemStack itemstack) {
-        return itemstack.getItem() != Item.getItemOf(Blocks.PUMPKIN) && itemstack.getItem() != Items.SKULL ? (itemstack.getItem() instanceof ItemArmor ? ((ItemArmor) itemstack.getItem()).c : (itemstack.getItem() == Items.cR ? EnumItemSlot.CHEST : (itemstack.getItem() == Items.SHIELD ? EnumItemSlot.OFFHAND : EnumItemSlot.MAINHAND))) : EnumItemSlot.HEAD;
-    }
-
-    public static Item a(EnumItemSlot enumitemslot, int i) {
-        switch (EntityInsentient.SyntheticClass_1.b[enumitemslot.ordinal()]) {
-        case 1:
-            if (i == 0) {
-                return Items.LEATHER_HELMET;
-            } else if (i == 1) {
-                return Items.GOLDEN_HELMET;
-            } else if (i == 2) {
-                return Items.CHAINMAIL_HELMET;
-            } else if (i == 3) {
-                return Items.IRON_HELMET;
-            } else if (i == 4) {
-                return Items.DIAMOND_HELMET;
-            }
-
-        case 2:
-            if (i == 0) {
-                return Items.LEATHER_CHESTPLATE;
-            } else if (i == 1) {
-                return Items.GOLDEN_CHESTPLATE;
-            } else if (i == 2) {
-                return Items.CHAINMAIL_CHESTPLATE;
-            } else if (i == 3) {
-                return Items.IRON_CHESTPLATE;
-            } else if (i == 4) {
-                return Items.DIAMOND_CHESTPLATE;
-            }
-
-        case 3:
-            if (i == 0) {
-                return Items.LEATHER_LEGGINGS;
-            } else if (i == 1) {
-                return Items.GOLDEN_LEGGINGS;
-            } else if (i == 2) {
-                return Items.CHAINMAIL_LEGGINGS;
-            } else if (i == 3) {
-                return Items.IRON_LEGGINGS;
-            } else if (i == 4) {
-                return Items.DIAMOND_LEGGINGS;
-            }
-
-        case 4:
-            if (i == 0) {
-                return Items.LEATHER_BOOTS;
-            } else if (i == 1) {
-                return Items.GOLDEN_BOOTS;
-            } else if (i == 2) {
-                return Items.CHAINMAIL_BOOTS;
-            } else if (i == 3) {
-                return Items.IRON_BOOTS;
-            } else if (i == 4) {
-                return Items.DIAMOND_BOOTS;
-            }
-
-        default:
-            return null;
-        }
-    }
-
-    protected void b(DifficultyDamageScaler difficultydamagescaler) {
-        float f = difficultydamagescaler.d();
-
-        if (this.getItemInMainHand() != null && this.random.nextFloat() < 0.25F * f) {
-            EnchantmentManager.a(this.random, this.getItemInMainHand(), (int) (5.0F + f * (float) this.random.nextInt(18)), false);
-        }
-
-        EnumItemSlot[] aenumitemslot = EnumItemSlot.values();
-        int i = aenumitemslot.length;
-
-        for (int j = 0; j < i; ++j) {
-            EnumItemSlot enumitemslot = aenumitemslot[j];
-
-            if (enumitemslot.a() == EnumItemSlot.Function.ARMOR) {
-                ItemStack itemstack = this.getEquipment(enumitemslot);
-
-                if (itemstack != null && this.random.nextFloat() < 0.5F * f) {
-                    EnchantmentManager.a(this.random, itemstack, (int) (5.0F + f * (float) this.random.nextInt(18)), false);
-                }
-            }
-        }
-
-    }
-
-    @Nullable
-    public GroupDataEntity prepare(DifficultyDamageScaler difficultydamagescaler, @Nullable GroupDataEntity groupdataentity) {
-        this.getAttributeInstance(GenericAttributes.FOLLOW_RANGE).b(new AttributeModifier("Random spawn bonus", this.random.nextGaussian() * 0.05D, 1));
-        if (this.random.nextFloat() < 0.05F) {
-            this.o(true);
-        } else {
-            this.o(false);
-        }
-
-        return groupdataentity;
-    }
-
-    public boolean cP() {
-        return false;
-    }
-
-    public void cQ() {
-        this.persistent = true;
-    }
-
-    public void a(EnumItemSlot enumitemslot, float f) {
-        switch (EntityInsentient.SyntheticClass_1.a[enumitemslot.a().ordinal()]) {
-        case 1:
-            this.dropChanceHand[enumitemslot.b()] = f;
-            break;
-
-        case 2:
-            this.dropChanceArmor[enumitemslot.b()] = f;
-        }
-
-    }
-
-    public boolean cR() {
-        return this.canPickUpLoot;
-    }
-
-    public void m(boolean flag) {
-        this.canPickUpLoot = flag;
-    }
-
-    public boolean isPersistent() {
-        return this.persistent;
-    }
-
-    public final boolean a(EntityHuman entityhuman, @Nullable ItemStack itemstack, EnumHand enumhand) {
-        if (this.isLeashed() && this.getLeashHolder() == entityhuman) {
-            // CraftBukkit start - fire PlayerUnleashEntityEvent
-            if (CraftEventFactory.callPlayerUnleashEntityEvent(this, entityhuman).isCancelled()) {
-                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutAttachEntity(this, this.getLeashHolder()));
-                return false;
-            }
-            // CraftBukkit end
-            this.unleash(true, !entityhuman.abilities.canInstantlyBuild);
-            return true;
-        } else if (itemstack != null && itemstack.getItem() == Items.LEAD && this.a(entityhuman)) {
-            // CraftBukkit start - fire PlayerLeashEntityEvent
-            if (CraftEventFactory.callPlayerLeashEntityEvent(this, entityhuman, entityhuman).isCancelled()) {
-                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutAttachEntity(this, this.getLeashHolder()));
-                return false;
-            }
-            // CraftBukkit end
-            this.setLeashHolder(entityhuman, true);
-            --itemstack.count;
-            return true;
-        } else {
-            return this.a(entityhuman, enumhand, itemstack) ? true : super.a(entityhuman, itemstack, enumhand);
-        }
-    }
-
-    protected boolean a(EntityHuman entityhuman, EnumHand enumhand, @Nullable ItemStack itemstack) {
-        return false;
-    }
-
-    protected void cT() {
-        if (this.bG != null) {
-            this.cY();
-        }
-
-        if (this.bE) {
-            if (!this.isAlive()) {
-                this.world.getServer().getPluginManager().callEvent(new EntityUnleashEvent(this.getBukkitEntity(), UnleashReason.PLAYER_UNLEASH)); // CraftBukkit
-                this.unleash(true, true);
-            }
-
-            if (this.leashHolder == null || this.leashHolder.dead) {
-                this.world.getServer().getPluginManager().callEvent(new EntityUnleashEvent(this.getBukkitEntity(), UnleashReason.HOLDER_GONE)); // CraftBukkit
-                this.unleash(true, true);
-            }
-        }
-    }
-
-    public void unleash(boolean flag, boolean flag1) {
-        if (this.bE) {
-            this.bE = false;
-            this.leashHolder = null;
-            if (!this.world.isClientSide && flag1) {
-                this.forceDrops = true; // CraftBukkit
-                this.a(Items.LEAD, 1);
-                this.forceDrops = false; // CraftBukkit
-            }
-
-            if (!this.world.isClientSide && flag && this.world instanceof WorldServer) {
-                ((WorldServer) this.world).getTracker().a((Entity) this, (Packet) (new PacketPlayOutAttachEntity(this, (Entity) null)));
-            }
-        }
-
-    }
-
-    public boolean a(EntityHuman entityhuman) {
-        return !this.isLeashed() && !(this instanceof IMonster);
-    }
-
-    public boolean isLeashed() {
-        return this.bE;
-    }
-
-    public Entity getLeashHolder() {
-        return this.leashHolder;
-    }
-
-    public void setLeashHolder(Entity entity, boolean flag) {
-        this.bE = true;
-        this.leashHolder = entity;
-        if (!this.world.isClientSide && flag && this.world instanceof WorldServer) {
-            ((WorldServer) this.world).getTracker().a((Entity) this, (Packet) (new PacketPlayOutAttachEntity(this, this.leashHolder)));
-        }
-
-        if (this.isPassenger()) {
-            this.stopRiding();
-        }
-
-    }
-
-    public boolean a(Entity entity, boolean flag) {
-        boolean flag1 = super.a(entity, flag);
-
-        if (flag1 && this.isLeashed()) {
-            this.unleash(true, true);
-        }
-
-        return flag1;
-    }
-
-    private void cY() {
-        if (this.bE && this.bG != null) {
-            if (this.bG.b("UUID")) {
-                UUID uuid = this.bG.a("UUID");
-                List list = this.world.a(EntityLiving.class, this.getBoundingBox().g(10.0D));
-                Iterator iterator = list.iterator();
-
-                while (iterator.hasNext()) {
-                    EntityLiving entityliving = (EntityLiving) iterator.next();
-
-                    if (entityliving.getUniqueID().equals(uuid)) {
-                        this.leashHolder = entityliving;
-                        break;
-                    }
-                }
-            } else if (this.bG.hasKeyOfType("X", 99) && this.bG.hasKeyOfType("Y", 99) && this.bG.hasKeyOfType("Z", 99)) {
-                BlockPosition blockposition = new BlockPosition(this.bG.getInt("X"), this.bG.getInt("Y"), this.bG.getInt("Z"));
-                EntityLeash entityleash = EntityLeash.b(this.world, blockposition);
-
-                if (entityleash == null) {
-                    entityleash = EntityLeash.a(this.world, blockposition);
-                }
-
-                this.leashHolder = entityleash;
-            } else {
-                this.world.getServer().getPluginManager().callEvent(new EntityUnleashEvent(this.getBukkitEntity(), UnleashReason.UNKNOWN)); // CraftBukkit
-                this.unleash(false, true);
-            }
-        }
-
-        this.bG = null;
-    }
-
-    public boolean c(int i, @Nullable ItemStack itemstack) {
-        EnumItemSlot enumitemslot;
-
-        if (i == 98) {
-            enumitemslot = EnumItemSlot.MAINHAND;
-        } else if (i == 99) {
-            enumitemslot = EnumItemSlot.OFFHAND;
-        } else if (i == 100 + EnumItemSlot.HEAD.b()) {
-            enumitemslot = EnumItemSlot.HEAD;
-        } else if (i == 100 + EnumItemSlot.CHEST.b()) {
-            enumitemslot = EnumItemSlot.CHEST;
-        } else if (i == 100 + EnumItemSlot.LEGS.b()) {
-            enumitemslot = EnumItemSlot.LEGS;
-        } else {
-            if (i != 100 + EnumItemSlot.FEET.b()) {
-                return false;
-            }
-
-            enumitemslot = EnumItemSlot.FEET;
-        }
-
-        if (itemstack != null && !b(enumitemslot, itemstack) && enumitemslot != EnumItemSlot.HEAD) {
-            return false;
-        } else {
-            this.setSlot(enumitemslot, itemstack);
-            return true;
-        }
-    }
-
-    public static boolean b(EnumItemSlot enumitemslot, ItemStack itemstack) {
-        EnumItemSlot enumitemslot1 = d(itemstack);
-
-        return enumitemslot1 == enumitemslot || enumitemslot1 == EnumItemSlot.MAINHAND && enumitemslot == EnumItemSlot.OFFHAND || enumitemslot1 == EnumItemSlot.OFFHAND && enumitemslot == EnumItemSlot.MAINHAND;
-    }
-
-    public boolean ct() {
-        return super.ct() && !this.hasAI();
-    }
-
-    public void setAI(boolean flag) {
-        byte b0 = ((Byte) this.datawatcher.get(EntityInsentient.a)).byteValue();
-
-        this.datawatcher.set(EntityInsentient.a, Byte.valueOf(flag ? (byte) (b0 | 1) : (byte) (b0 & -2)));
-    }
-
-    public void o(boolean flag) {
-        byte b0 = ((Byte) this.datawatcher.get(EntityInsentient.a)).byteValue();
-
-        this.datawatcher.set(EntityInsentient.a, Byte.valueOf(flag ? (byte) (b0 | 2) : (byte) (b0 & -3)));
-    }
-
-    public boolean hasAI() {
-        return (((Byte) this.datawatcher.get(EntityInsentient.a)).byteValue() & 1) != 0;
-    }
-
-    public boolean cX() {
-        return (((Byte) this.datawatcher.get(EntityInsentient.a)).byteValue() & 2) != 0;
-    }
-
-    public EnumMainHand getMainHand() {
-        return this.cX() ? EnumMainHand.LEFT : EnumMainHand.RIGHT;
-    }
-
-    static class SyntheticClass_1 {
-
-        static final int[] a;
-        static final int[] b = new int[EnumItemSlot.values().length];
-
-        static {
-            try {
-                EntityInsentient.SyntheticClass_1.b[EnumItemSlot.HEAD.ordinal()] = 1;
-            } catch (NoSuchFieldError nosuchfielderror) {
-                ;
-            }
-
-            try {
-                EntityInsentient.SyntheticClass_1.b[EnumItemSlot.CHEST.ordinal()] = 2;
-            } catch (NoSuchFieldError nosuchfielderror1) {
-                ;
-            }
-
-            try {
-                EntityInsentient.SyntheticClass_1.b[EnumItemSlot.LEGS.ordinal()] = 3;
-            } catch (NoSuchFieldError nosuchfielderror2) {
-                ;
-            }
-
-            try {
-                EntityInsentient.SyntheticClass_1.b[EnumItemSlot.FEET.ordinal()] = 4;
-            } catch (NoSuchFieldError nosuchfielderror3) {
-                ;
-            }
-
-            a = new int[EnumItemSlot.Function.values().length];
-
-            try {
-                EntityInsentient.SyntheticClass_1.a[EnumItemSlot.Function.HAND.ordinal()] = 1;
-            } catch (NoSuchFieldError nosuchfielderror4) {
-                ;
-            }
-
-            try {
-                EntityInsentient.SyntheticClass_1.a[EnumItemSlot.Function.ARMOR.ordinal()] = 2;
-            } catch (NoSuchFieldError nosuchfielderror5) {
-                ;
-            }
-
-        }
-    }
-
-    public static enum EnumEntityPositionType {
-
-        ON_GROUND, IN_AIR, IN_WATER;
-
-        private EnumEntityPositionType() {}
-    }
-}
+package net.minecraft.server;
+
+import com.google.common.collect.Maps;
+import java.util.Arrays;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.UUID;
+import javax.annotation.Nullable;
+
+// CraftBukkit start
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.entity.CraftLivingEntity;
+import org.bukkit.event.entity.EntityTargetLivingEntityEvent;
+import org.bukkit.event.entity.EntityTargetEvent;
+import org.bukkit.event.entity.EntityUnleashEvent;
+import org.bukkit.event.entity.EntityUnleashEvent.UnleashReason;
+// CraftBukkit end
+
+public abstract class EntityInsentient extends EntityLiving {
+
+    private static final DataWatcherObject<Byte> a = DataWatcher.a(EntityInsentient.class, DataWatcherRegistry.a);
+    public int a_;
+    protected int b_;
+    private final ControllerLook lookController;
+    protected ControllerMove moveController;
+    protected ControllerJump g;
+    private final EntityAIBodyControl c;
+    protected NavigationAbstract navigation;
+    public PathfinderGoalSelector goalSelector;
+    public PathfinderGoalSelector targetSelector;
+    private EntityLiving goalTarget;
+    private final EntitySenses bw;
+    private final ItemStack[] bx = new ItemStack[2];
+    public float[] dropChanceHand = new float[2];
+    private final ItemStack[] by = new ItemStack[4];
+    public float[] dropChanceArmor = new float[4];
+    public boolean canPickUpLoot;
+    public boolean persistent;
+    private final Map<PathType, Float> bB = Maps.newEnumMap(PathType.class);
+    private MinecraftKey bC;
+    private long bD;
+    private boolean bE;
+    private Entity leashHolder;
+    private NBTTagCompound bG;
+
+    public EntityInsentient(World world) {
+        super(world);
+        this.goalSelector = new PathfinderGoalSelector(world != null && world.methodProfiler != null ? world.methodProfiler : null);
+        this.targetSelector = new PathfinderGoalSelector(world != null && world.methodProfiler != null ? world.methodProfiler : null);
+        this.lookController = new ControllerLook(this);
+        this.moveController = new ControllerMove(this);
+        this.g = new ControllerJump(this);
+        this.c = this.s();
+        this.navigation = this.b(world);
+        this.bw = new EntitySenses(this);
+        Arrays.fill(this.dropChanceArmor, 0.085F);
+        Arrays.fill(this.dropChanceHand, 0.085F);
+        if (world != null && !world.isClientSide) {
+            this.r();
+        }
+
+        // CraftBukkit start - default persistance to type's persistance value
+        this.persistent = !isTypeNotPersistent();
+        // CraftBukkit end
+    }
+
+    protected void r() {}
+
+    protected void initAttributes() {
+        super.initAttributes();
+        this.getAttributeMap().b(GenericAttributes.FOLLOW_RANGE).setValue(16.0D);
+    }
+
+    protected NavigationAbstract b(World world) {
+        return new Navigation(this, world);
+    }
+
+    public float a(PathType pathtype) {
+        // CraftBukkit - decompile error
+        Float ofloat = (Float) this.bB.get(pathtype);
+
+        return ofloat == null ? pathtype.a() : ofloat.floatValue();
+    }
+
+    public void a(PathType pathtype, float f) {
+        this.bB.put(pathtype, Float.valueOf(f));
+    }
+
+    protected EntityAIBodyControl s() {
+        return new EntityAIBodyControl(this);
+    }
+
+    public ControllerLook getControllerLook() {
+        return this.lookController;
+    }
+
+    public ControllerMove getControllerMove() {
+        return this.moveController;
+    }
+
+    public ControllerJump getControllerJump() {
+        return this.g;
+    }
+
+    public NavigationAbstract getNavigation() {
+        return this.navigation;
+    }
+
+    public EntitySenses getEntitySenses() {
+        return this.bw;
+    }
+
+    @Nullable
+    public EntityLiving getGoalTarget() {
+        return this.goalTarget;
+    }
+
+    public void setGoalTarget(@Nullable EntityLiving entityliving) {
+        // CraftBukkit start - fire event
+        setGoalTarget(entityliving, EntityTargetEvent.TargetReason.UNKNOWN, true);
+    }
+
+    public boolean setGoalTarget(EntityLiving entityliving, EntityTargetEvent.TargetReason reason, boolean fireEvent) {
+        if (getGoalTarget() == entityliving) return false;
+        if (fireEvent) {
+            if (reason == EntityTargetEvent.TargetReason.UNKNOWN && getGoalTarget() != null && entityliving == null) {
+                reason = getGoalTarget().isAlive() ? EntityTargetEvent.TargetReason.FORGOT_TARGET : EntityTargetEvent.TargetReason.TARGET_DIED;
+            }
+            if (reason == EntityTargetEvent.TargetReason.UNKNOWN) {
+                world.getServer().getLogger().log(java.util.logging.Level.WARNING, "Unknown target reason, please report on the issue tracker", new Exception());
+            }
+            CraftLivingEntity ctarget = null;
+            if (entityliving != null) {
+                ctarget = (CraftLivingEntity) entityliving.getBukkitEntity();
+            }
+            EntityTargetLivingEntityEvent event = new EntityTargetLivingEntityEvent(this.getBukkitEntity(), ctarget, reason);
+            world.getServer().getPluginManager().callEvent(event);
+            if (event.isCancelled()) {
+                return false;
+            }
+
+            if (event.getTarget() != null) {
+                entityliving = ((CraftLivingEntity) event.getTarget()).getHandle();
+            } else {
+                entityliving = null;
+            }
+        }
+        this.goalTarget = entityliving;
+        return true;
+        // CraftBukkit end
+    }
+
+    public boolean d(Class<? extends EntityLiving> oclass) {
+        return oclass != EntityGhast.class;
+    }
+
+    public void A() {}
+
+    protected void i() {
+        super.i();
+        this.datawatcher.register(EntityInsentient.a, Byte.valueOf((byte) 0));
+    }
+
+    public int C() {
+        return 80;
+    }
+
+    public void D() {
+        SoundEffect soundeffect = this.G();
+
+        if (soundeffect != null) {
+            this.a(soundeffect, this.ch(), this.ci());
+        }
+
+    }
+
+    public void U() {
+        super.U();
+        this.world.methodProfiler.a("mobBaseTick");
+        if (this.isAlive() && this.random.nextInt(1000) < this.a_++) {
+            this.o();
+            this.D();
+        }
+
+        this.world.methodProfiler.b();
+    }
+
+    protected void c(DamageSource damagesource) {
+        this.o();
+        super.c(damagesource);
+    }
+
+    private void o() {
+        this.a_ = -this.C();
+    }
+
+    protected int getExpValue(EntityHuman entityhuman) {
+        if (this.b_ > 0) {
+            int i = this.b_;
+
+            int j;
+
+            for (j = 0; j < this.by.length; ++j) {
+                if (this.by[j] != null && this.dropChanceArmor[j] <= 1.0F) {
+                    i += 1 + this.random.nextInt(3);
+                }
+            }
+
+            for (j = 0; j < this.bx.length; ++j) {
+                if (this.bx[j] != null && this.dropChanceHand[j] <= 1.0F) {
+                    i += 1 + this.random.nextInt(3);
+                }
+            }
+
+            return i;
+        } else {
+            return this.b_;
+        }
+    }
+
+    public void doSpawnEffect() {
+        if (this.world.isClientSide) {
+            for (int i = 0; i < 20; ++i) {
+                double d0 = this.random.nextGaussian() * 0.02D;
+                double d1 = this.random.nextGaussian() * 0.02D;
+                double d2 = this.random.nextGaussian() * 0.02D;
+                double d3 = 10.0D;
+
+                this.world.addParticle(EnumParticle.EXPLOSION_NORMAL, this.locX + (double) (this.random.nextFloat() * this.width * 2.0F) - (double) this.width - d0 * 10.0D, this.locY + (double) (this.random.nextFloat() * this.length) - d1 * 10.0D, this.locZ + (double) (this.random.nextFloat() * this.width * 2.0F) - (double) this.width - d2 * 10.0D, d0, d1, d2, new int[0]);
+            }
+        } else {
+            this.world.broadcastEntityEffect(this, (byte) 20);
+        }
+
+    }
+
+    public void m() {
+        super.m();
+        if (!this.world.isClientSide) {
+            this.cT();
+            if (this.ticksLived % 5 == 0) {
+                boolean flag = !(this.bw() instanceof EntityInsentient);
+                boolean flag1 = !(this.bB() instanceof EntityBoat);
+
+                this.goalSelector.a(1, flag);
+                this.goalSelector.a(4, flag && flag1);
+                this.goalSelector.a(2, flag);
+            }
+        }
+
+    }
+
+    protected float h(float f, float f1) {
+        this.c.a();
+        return f1;
+    }
+
+    @Nullable
+    protected SoundEffect G() {
+        return null;
+    }
+
+    @Nullable
+    protected Item getLoot() {
+        return null;
+    }
+
+    protected void dropDeathLoot(boolean flag, int i) {
+        Item item = this.getLoot();
+
+        if (item != null) {
+            int j = this.random.nextInt(3);
+
+            if (i > 0) {
+                j += this.random.nextInt(i + 1);
+            }
+
+            for (int k = 0; k < j; ++k) {
+                this.a(item, 1);
+            }
+        }
+
+    }
+
+    public static void a(DataConverterManager dataconvertermanager, String s) {
+        dataconvertermanager.a(DataConverterTypes.ENTITY, (DataInspector) (new DataInspectorItemList(s, new String[] { "ArmorItems", "HandItems"})));
+    }
+
+    public static void a(DataConverterManager dataconvertermanager) {
+        a(dataconvertermanager, "Mob");
+    }
+
+    public void b(NBTTagCompound nbttagcompound) {
+        super.b(nbttagcompound);
+        nbttagcompound.setBoolean("CanPickUpLoot", this.cR());
+        nbttagcompound.setBoolean("PersistenceRequired", this.persistent);
+        NBTTagList nbttaglist = new NBTTagList();
+        ItemStack[] aitemstack = this.by;
+        int i = aitemstack.length;
+
+        int j;
+
+        for (j = 0; j < i; ++j) {
+            ItemStack itemstack = aitemstack[j];
+            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+            if (itemstack != null) {
+                itemstack.save(nbttagcompound1);
+            }
+
+            nbttaglist.add(nbttagcompound1);
+        }
+
+        nbttagcompound.set("ArmorItems", nbttaglist);
+        NBTTagList nbttaglist1 = new NBTTagList();
+        ItemStack[] aitemstack1 = this.bx;
+
+        j = aitemstack1.length;
+
+        int k;
+
+        for (k = 0; k < j; ++k) {
+            ItemStack itemstack1 = aitemstack1[k];
+            NBTTagCompound nbttagcompound2 = new NBTTagCompound();
+
+            if (itemstack1 != null) {
+                itemstack1.save(nbttagcompound2);
+            }
+
+            nbttaglist1.add(nbttagcompound2);
+        }
+
+        nbttagcompound.set("HandItems", nbttaglist1);
+        NBTTagList nbttaglist2 = new NBTTagList();
+        float[] afloat = this.dropChanceArmor;
+
+        k = afloat.length;
+
+        int l;
+
+        for (l = 0; l < k; ++l) {
+            float f = afloat[l];
+
+            nbttaglist2.add(new NBTTagFloat(f));
+        }
+
+        nbttagcompound.set("ArmorDropChances", nbttaglist2);
+        NBTTagList nbttaglist3 = new NBTTagList();
+        float[] afloat1 = this.dropChanceHand;
+
+        l = afloat1.length;
+
+        for (int i1 = 0; i1 < l; ++i1) {
+            float f1 = afloat1[i1];
+
+            nbttaglist3.add(new NBTTagFloat(f1));
+        }
+
+        nbttagcompound.set("HandDropChances", nbttaglist3);
+        nbttagcompound.setBoolean("Leashed", this.bE);
+        if (this.leashHolder != null) {
+            NBTTagCompound nbttagcompound3 = new NBTTagCompound();
+
+            if (this.leashHolder instanceof EntityLiving) {
+                UUID uuid = this.leashHolder.getUniqueID();
+
+                nbttagcompound3.a("UUID", uuid);
+            } else if (this.leashHolder instanceof EntityHanging) {
+                BlockPosition blockposition = ((EntityHanging) this.leashHolder).getBlockPosition();
+
+                nbttagcompound3.setInt("X", blockposition.getX());
+                nbttagcompound3.setInt("Y", blockposition.getY());
+                nbttagcompound3.setInt("Z", blockposition.getZ());
+            }
+
+            nbttagcompound.set("Leash", nbttagcompound3);
+        }
+
+        nbttagcompound.setBoolean("LeftHanded", this.cX());
+        if (this.bC != null) {
+            nbttagcompound.setString("DeathLootTable", this.bC.toString());
+            if (this.bD != 0L) {
+                nbttagcompound.setLong("DeathLootTableSeed", this.bD);
+            }
+        }
+
+        if (this.hasAI()) {
+            nbttagcompound.setBoolean("NoAI", this.hasAI());
+        }
+
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        super.a(nbttagcompound);
+
+        // CraftBukkit start - If looting or persistence is false only use it if it was set after we started using it
+        if (nbttagcompound.hasKeyOfType("CanPickUpLoot", 1)) {
+            boolean data = nbttagcompound.getBoolean("CanPickUpLoot");
+            if (isLevelAtLeast(nbttagcompound, 1) || data) {
+                this.l(data);
+            }
+        }
+
+        boolean data = nbttagcompound.getBoolean("PersistenceRequired");
+        if (isLevelAtLeast(nbttagcompound, 1) || data) {
+            this.persistent = data;
+        }
+        // CraftBukkit end
+        NBTTagList nbttaglist;
+        int i;
+
+        if (nbttagcompound.hasKeyOfType("ArmorItems", 9)) {
+            nbttaglist = nbttagcompound.getList("ArmorItems", 10);
+
+            for (i = 0; i < this.by.length; ++i) {
+                this.by[i] = ItemStack.createStack(nbttaglist.get(i));
+            }
+        }
+
+        if (nbttagcompound.hasKeyOfType("HandItems", 9)) {
+            nbttaglist = nbttagcompound.getList("HandItems", 10);
+
+            for (i = 0; i < this.bx.length; ++i) {
+                this.bx[i] = ItemStack.createStack(nbttaglist.get(i));
+            }
+        }
+
+        if (nbttagcompound.hasKeyOfType("ArmorDropChances", 9)) {
+            nbttaglist = nbttagcompound.getList("ArmorDropChances", 5);
+
+            for (i = 0; i < nbttaglist.size(); ++i) {
+                this.dropChanceArmor[i] = nbttaglist.f(i);
+            }
+        }
+
+        if (nbttagcompound.hasKeyOfType("HandDropChances", 9)) {
+            nbttaglist = nbttagcompound.getList("HandDropChances", 5);
+
+            for (i = 0; i < nbttaglist.size(); ++i) {
+                this.dropChanceHand[i] = nbttaglist.f(i);
+            }
+        }
+
+        this.bE = nbttagcompound.getBoolean("Leashed");
+        if (this.bE && nbttagcompound.hasKeyOfType("Leash", 10)) {
+            this.bG = nbttagcompound.getCompound("Leash");
+        }
+
+        this.o(nbttagcompound.getBoolean("LeftHanded"));
+        if (nbttagcompound.hasKeyOfType("DeathLootTable", 8)) {
+            this.bC = new MinecraftKey(nbttagcompound.getString("DeathLootTable"));
+            this.bD = nbttagcompound.getLong("DeathLootTableSeed");
+        }
+
+        this.setAI(nbttagcompound.getBoolean("NoAI"));
+    }
+
+    @Nullable
+    protected MinecraftKey J() {
+        return null;
+    }
+
+    protected void a(boolean flag, int i, DamageSource damagesource) {
+        MinecraftKey minecraftkey = this.bC;
+
+        if (minecraftkey == null) {
+            minecraftkey = this.J();
+        }
+
+        if (minecraftkey != null) {
+            LootTable loottable = this.world.ak().a(minecraftkey);
+
+            this.bC = null;
+            LootTableInfo.a loottableinfo_a = (new LootTableInfo.a((WorldServer) this.world)).a((Entity) this).a(damagesource);
+
+            if (flag && this.killer != null) {
+                loottableinfo_a = loottableinfo_a.a(this.killer).a(this.killer.dg());
+            }
+
+            List list = loottable.a(this.bD == 0L ? this.random : new Random(this.bD), loottableinfo_a.a());
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                ItemStack itemstack = (ItemStack) iterator.next();
+
+                this.a(itemstack, 0.0F);
+            }
+
+            this.dropEquipment(flag, i);
+        } else {
+            super.a(flag, i, damagesource);
+        }
+
+    }
+
+    public void o(float f) {
+        this.bg = f;
+    }
+
+    public void p(float f) {
+        this.bf = f;
+    }
+
+    public void l(float f) {
+        super.l(f);
+        this.o(f);
+    }
+
+    public void n() {
+        super.n();
+        this.world.methodProfiler.a("looting");
+        if (!this.world.isClientSide && this.cR() && !this.aV && this.world.getGameRules().getBoolean("mobGriefing")) {
+            List list = this.world.a(EntityItem.class, this.getBoundingBox().grow(1.0D, 0.0D, 1.0D));
+            Iterator iterator = list.iterator();
+
+            while (iterator.hasNext()) {
+                EntityItem entityitem = (EntityItem) iterator.next();
+
+                if (!entityitem.dead && entityitem.getItemStack() != null && !entityitem.t()) {
+                    this.a(entityitem);
+                }
+            }
+        }
+
+        this.world.methodProfiler.b();
+    }
+
+    protected void a(EntityItem entityitem) {
+        ItemStack itemstack = entityitem.getItemStack();
+        EnumItemSlot enumitemslot = d(itemstack);
+        boolean flag = true;
+        ItemStack itemstack1 = this.getEquipment(enumitemslot);
+
+        if (itemstack1 != null) {
+            if (enumitemslot.a() == EnumItemSlot.Function.HAND) {
+                if (itemstack.getItem() instanceof ItemSword && !(itemstack1.getItem() instanceof ItemSword)) {
+                    flag = true;
+                } else if (itemstack.getItem() instanceof ItemSword && itemstack1.getItem() instanceof ItemSword) {
+                    ItemSword itemsword = (ItemSword) itemstack.getItem();
+                    ItemSword itemsword1 = (ItemSword) itemstack1.getItem();
+
+                    if (itemsword.g() == itemsword1.g()) {
+                        flag = itemstack.getData() > itemstack1.getData() || itemstack.hasTag() && !itemstack1.hasTag();
+                    } else {
+                        flag = itemsword.g() > itemsword1.g();
+                    }
+                } else if (itemstack.getItem() instanceof ItemBow && itemstack1.getItem() instanceof ItemBow) {
+                    flag = itemstack.hasTag() && !itemstack1.hasTag();
+                } else {
+                    flag = false;
+                }
+            } else if (itemstack.getItem() instanceof ItemArmor && !(itemstack1.getItem() instanceof ItemArmor)) {
+                flag = true;
+            } else if (itemstack.getItem() instanceof ItemArmor && itemstack1.getItem() instanceof ItemArmor) {
+                ItemArmor itemarmor = (ItemArmor) itemstack.getItem();
+                ItemArmor itemarmor1 = (ItemArmor) itemstack1.getItem();
+
+                if (itemarmor.d == itemarmor1.d) {
+                    flag = itemstack.getData() > itemstack1.getData() || itemstack.hasTag() && !itemstack1.hasTag();
+                } else {
+                    flag = itemarmor.d > itemarmor1.d;
+                }
+            } else {
+                flag = false;
+            }
+        }
+
+        if (flag && this.c(itemstack)) {
+            double d0;
+
+            switch (EntityInsentient.SyntheticClass_1.a[enumitemslot.a().ordinal()]) {
+            case 1:
+                d0 = (double) this.dropChanceHand[enumitemslot.b()];
+                break;
+
+            case 2:
+                d0 = (double) this.dropChanceArmor[enumitemslot.b()];
+                break;
+
+            default:
+                d0 = 0.0D;
+            }
+
+            if (itemstack1 != null && (double) (this.random.nextFloat() - 0.1F) < d0) {
+                this.a(itemstack1, 0.0F);
+            }
+
+            if (itemstack.getItem() == Items.DIAMOND && entityitem.n() != null) {
+                EntityHuman entityhuman = this.world.a(entityitem.n());
+
+                if (entityhuman != null) {
+                    entityhuman.b((Statistic) AchievementList.x);
+                }
+            }
+
+            this.setSlot(enumitemslot, itemstack);
+            switch (EntityInsentient.SyntheticClass_1.a[enumitemslot.a().ordinal()]) {
+            case 1:
+                this.dropChanceHand[enumitemslot.b()] = 2.0F;
+                break;
+
+            case 2:
+                this.dropChanceArmor[enumitemslot.b()] = 2.0F;
+            }
+
+            this.persistent = true;
+            this.receive(entityitem, 1);
+            entityitem.die();
+        }
+
+    }
+
+    protected boolean c(ItemStack itemstack) {
+        return true;
+    }
+
+    protected boolean isTypeNotPersistent() {
+        return true;
+    }
+
+    protected void L() {
+        if (this.persistent) {
+            this.ticksFarFromPlayer = 0;
+        } else {
+            EntityHuman entityhuman = this.world.findNearbyPlayer(this, -1.0D);
+
+            if (entityhuman != null) {
+                double d0 = entityhuman.locX - this.locX;
+                double d1 = entityhuman.locY - this.locY;
+                double d2 = entityhuman.locZ - this.locZ;
+                double d3 = d0 * d0 + d1 * d1 + d2 * d2;
+
+                if (d3 > 16384.0D) { // CraftBukkit - remove isTypeNotPersistent() check
+                    this.die();
+                }
+
+                if (this.ticksFarFromPlayer > 600 && this.random.nextInt(800) == 0 && d3 > 1024.0D) { // CraftBukkit - remove isTypeNotPersistent() check
+                    this.die();
+                } else if (d3 < 1024.0D) {
+                    this.ticksFarFromPlayer = 0;
+                }
+            }
+
+        }
+    }
+
+    protected final void doTick() {
+        ++this.ticksFarFromPlayer;
+        this.world.methodProfiler.a("checkDespawn");
+        this.L();
+        this.world.methodProfiler.b();
+        // Spigot Start
+        if ( this.fromMobSpawner )
+        {
+            return;
+        }
+        // Spigot End
+        this.world.methodProfiler.a("sensing");
+        this.bw.a();
+        this.world.methodProfiler.b();
+        this.world.methodProfiler.a("targetSelector");
+        this.targetSelector.a();
+        this.world.methodProfiler.b();
+        this.world.methodProfiler.a("goalSelector");
+        try {
+            this.goalSelector.a();
+        } catch (Exception ex) {
+            ;
+        }
+        this.world.methodProfiler.b();
+        this.world.methodProfiler.a("navigation");
+        try {
+            this.navigation.l();
+        } catch (Exception ex) {
+            ;
+        }
+        this.world.methodProfiler.b();
+        this.world.methodProfiler.a("mob tick");
+        this.M();
+        this.world.methodProfiler.b();
+        if (this.isPassenger() && this.bB() instanceof EntityInsentient) {
+            EntityInsentient entityinsentient = (EntityInsentient) this.bB();
+
+            entityinsentient.getNavigation().a(this.getNavigation().k(), 1.5D);
+            entityinsentient.getControllerMove().a(this.getControllerMove());
+        }
+
+        this.world.methodProfiler.a("controls");
+        this.world.methodProfiler.a("move");
+        this.moveController.c();
+        this.world.methodProfiler.c("look");
+        this.lookController.a();
+        this.world.methodProfiler.c("jump");
+        this.g.b();
+        this.world.methodProfiler.b();
+        this.world.methodProfiler.b();
+    }
+
+    protected void M() {}
+
+    public int N() {
+        return 40;
+    }
+
+    public int cJ() {
+        return 10;
+    }
+
+    public void a(Entity entity, float f, float f1) {
+        double d0 = entity.locX - this.locX;
+        double d1 = entity.locZ - this.locZ;
+        double d2;
+
+        if (entity instanceof EntityLiving) {
+            EntityLiving entityliving = (EntityLiving) entity;
+
+            d2 = entityliving.locY + (double) entityliving.getHeadHeight() - (this.locY + (double) this.getHeadHeight());
+        } else {
+            d2 = (entity.getBoundingBox().b + entity.getBoundingBox().e) / 2.0D - (this.locY + (double) this.getHeadHeight());
+        }
+
+        double d3 = (double) MathHelper.sqrt(d0 * d0 + d1 * d1);
+        float f2 = (float) (MathHelper.b(d1, d0) * 57.2957763671875D) - 90.0F;
+        float f3 = (float) (-(MathHelper.b(d2, d3) * 57.2957763671875D));
+
+        this.pitch = this.b(this.pitch, f3, f1);
+        this.yaw = this.b(this.yaw, f2, f);
+    }
+
+    private float b(float f, float f1, float f2) {
+        float f3 = MathHelper.g(f1 - f);
+
+        if (f3 > f2) {
+            f3 = f2;
+        }
+
+        if (f3 < -f2) {
+            f3 = -f2;
+        }
+
+        return f + f3;
+    }
+
+    public boolean cK() {
+        IBlockData iblockdata = this.world.getType((new BlockPosition(this)).down());
+
+        return iblockdata.a((Entity) this);
+    }
+
+    public boolean canSpawn() {
+        return !this.world.containsLiquid(this.getBoundingBox()) && this.world.getCubes(this, this.getBoundingBox()).isEmpty() && this.world.a(this.getBoundingBox(), (Entity) this);
+    }
+
+    public int cO() {
+        return 4;
+    }
+
+    public int aY() {
+        if (this.getGoalTarget() == null) {
+            return 3;
+        } else {
+            int i = (int) (this.getHealth() - this.getMaxHealth() * 0.33F);
+
+            i -= (3 - this.world.getDifficulty().a()) * 4;
+            if (i < 0) {
+                i = 0;
+            }
+
+            return i + 3;
+        }
+    }
+
+    public Iterable<ItemStack> aG() {
+        return Arrays.asList(this.bx);
+    }
+
+    public Iterable<ItemStack> getArmorItems() {
+        return Arrays.asList(this.by);
+    }
+
+    @Nullable
+    public ItemStack getEquipment(EnumItemSlot enumitemslot) {
+        ItemStack itemstack = null;
+
+        switch (EntityInsentient.SyntheticClass_1.a[enumitemslot.a().ordinal()]) {
+        case 1:
+            itemstack = this.bx[enumitemslot.b()];
+            break;
+
+        case 2:
+            itemstack = this.by[enumitemslot.b()];
+        }
+
+        return itemstack;
+    }
+
+    public void setSlot(EnumItemSlot enumitemslot, @Nullable ItemStack itemstack) {
+        switch (EntityInsentient.SyntheticClass_1.a[enumitemslot.a().ordinal()]) {
+        case 1:
+            this.bx[enumitemslot.b()] = itemstack;
+            break;
+
+        case 2:
+            this.by[enumitemslot.b()] = itemstack;
+        }
+
+    }
+
+    protected void dropEquipment(boolean flag, int i) {
+        EnumItemSlot[] aenumitemslot = EnumItemSlot.values();
+        int j = aenumitemslot.length;
+
+        for (int k = 0; k < j; ++k) {
+            EnumItemSlot enumitemslot = aenumitemslot[k];
+            ItemStack itemstack = this.getEquipment(enumitemslot);
+            double d0;
+
+            switch (EntityInsentient.SyntheticClass_1.a[enumitemslot.a().ordinal()]) {
+            case 1:
+                d0 = (double) this.dropChanceHand[enumitemslot.b()];
+                break;
+
+            case 2:
+                d0 = (double) this.dropChanceArmor[enumitemslot.b()];
+                break;
+
+            default:
+                d0 = 0.0D;
+            }
+
+            boolean flag1 = d0 > 1.0D;
+
+            if (itemstack != null && (flag || flag1) && (double) (this.random.nextFloat() - (float) i * 0.01F) < d0) {
+                if (!flag1 && itemstack.e()) {
+                    int l = Math.max(itemstack.j() - 25, 1);
+                    int i1 = itemstack.j() - this.random.nextInt(this.random.nextInt(l) + 1);
+
+                    if (i1 > l) {
+                        i1 = l;
+                    }
+
+                    if (i1 < 1) {
+                        i1 = 1;
+                    }
+
+                    itemstack.setData(i1);
+                }
+
+                this.a(itemstack, 0.0F);
+            }
+        }
+
+    }
+
+    protected void a(DifficultyDamageScaler difficultydamagescaler) {
+        if (this.random.nextFloat() < 0.15F * difficultydamagescaler.d()) {
+            int i = this.random.nextInt(2);
+            float f = this.world.getDifficulty() == EnumDifficulty.HARD ? 0.1F : 0.25F;
+
+            if (this.random.nextFloat() < 0.095F) {
+                ++i;
+            }
+
+            if (this.random.nextFloat() < 0.095F) {
+                ++i;
+            }
+
+            if (this.random.nextFloat() < 0.095F) {
+                ++i;
+            }
+
+            boolean flag = true;
+            EnumItemSlot[] aenumitemslot = EnumItemSlot.values();
+            int j = aenumitemslot.length;
+
+            for (int k = 0; k < j; ++k) {
+                EnumItemSlot enumitemslot = aenumitemslot[k];
+
+                if (enumitemslot.a() == EnumItemSlot.Function.ARMOR) {
+                    ItemStack itemstack = this.getEquipment(enumitemslot);
+
+                    if (!flag && this.random.nextFloat() < f) {
+                        break;
+                    }
+
+                    flag = false;
+                    if (itemstack == null) {
+                        Item item = a(enumitemslot, i);
+
+                        if (item != null) {
+                            this.setSlot(enumitemslot, new ItemStack(item));
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    public static EnumItemSlot d(ItemStack itemstack) {
+        return itemstack.getItem() != Item.getItemOf(Blocks.PUMPKIN) && itemstack.getItem() != Items.SKULL ? (itemstack.getItem() instanceof ItemArmor ? ((ItemArmor) itemstack.getItem()).c : (itemstack.getItem() == Items.cR ? EnumItemSlot.CHEST : (itemstack.getItem() == Items.SHIELD ? EnumItemSlot.OFFHAND : EnumItemSlot.MAINHAND))) : EnumItemSlot.HEAD;
+    }
+
+    public static Item a(EnumItemSlot enumitemslot, int i) {
+        switch (EntityInsentient.SyntheticClass_1.b[enumitemslot.ordinal()]) {
+        case 1:
+            if (i == 0) {
+                return Items.LEATHER_HELMET;
+            } else if (i == 1) {
+                return Items.GOLDEN_HELMET;
+            } else if (i == 2) {
+                return Items.CHAINMAIL_HELMET;
+            } else if (i == 3) {
+                return Items.IRON_HELMET;
+            } else if (i == 4) {
+                return Items.DIAMOND_HELMET;
+            }
+
+        case 2:
+            if (i == 0) {
+                return Items.LEATHER_CHESTPLATE;
+            } else if (i == 1) {
+                return Items.GOLDEN_CHESTPLATE;
+            } else if (i == 2) {
+                return Items.CHAINMAIL_CHESTPLATE;
+            } else if (i == 3) {
+                return Items.IRON_CHESTPLATE;
+            } else if (i == 4) {
+                return Items.DIAMOND_CHESTPLATE;
+            }
+
+        case 3:
+            if (i == 0) {
+                return Items.LEATHER_LEGGINGS;
+            } else if (i == 1) {
+                return Items.GOLDEN_LEGGINGS;
+            } else if (i == 2) {
+                return Items.CHAINMAIL_LEGGINGS;
+            } else if (i == 3) {
+                return Items.IRON_LEGGINGS;
+            } else if (i == 4) {
+                return Items.DIAMOND_LEGGINGS;
+            }
+
+        case 4:
+            if (i == 0) {
+                return Items.LEATHER_BOOTS;
+            } else if (i == 1) {
+                return Items.GOLDEN_BOOTS;
+            } else if (i == 2) {
+                return Items.CHAINMAIL_BOOTS;
+            } else if (i == 3) {
+                return Items.IRON_BOOTS;
+            } else if (i == 4) {
+                return Items.DIAMOND_BOOTS;
+            }
+
+        default:
+            return null;
+        }
+    }
+
+    protected void b(DifficultyDamageScaler difficultydamagescaler) {
+        float f = difficultydamagescaler.d();
+
+        if (this.getItemInMainHand() != null && this.random.nextFloat() < 0.25F * f) {
+            EnchantmentManager.a(this.random, this.getItemInMainHand(), (int) (5.0F + f * (float) this.random.nextInt(18)), false);
+        }
+
+        EnumItemSlot[] aenumitemslot = EnumItemSlot.values();
+        int i = aenumitemslot.length;
+
+        for (int j = 0; j < i; ++j) {
+            EnumItemSlot enumitemslot = aenumitemslot[j];
+
+            if (enumitemslot.a() == EnumItemSlot.Function.ARMOR) {
+                ItemStack itemstack = this.getEquipment(enumitemslot);
+
+                if (itemstack != null && this.random.nextFloat() < 0.5F * f) {
+                    EnchantmentManager.a(this.random, itemstack, (int) (5.0F + f * (float) this.random.nextInt(18)), false);
+                }
+            }
+        }
+
+    }
+
+    @Nullable
+    public GroupDataEntity prepare(DifficultyDamageScaler difficultydamagescaler, @Nullable GroupDataEntity groupdataentity) {
+        this.getAttributeInstance(GenericAttributes.FOLLOW_RANGE).b(new AttributeModifier("Random spawn bonus", this.random.nextGaussian() * 0.05D, 1));
+        if (this.random.nextFloat() < 0.05F) {
+            this.o(true);
+        } else {
+            this.o(false);
+        }
+
+        return groupdataentity;
+    }
+
+    public boolean cP() {
+        return false;
+    }
+
+    public void cQ() {
+        this.persistent = true;
+    }
+
+    public void a(EnumItemSlot enumitemslot, float f) {
+        switch (EntityInsentient.SyntheticClass_1.a[enumitemslot.a().ordinal()]) {
+        case 1:
+            this.dropChanceHand[enumitemslot.b()] = f;
+            break;
+
+        case 2:
+            this.dropChanceArmor[enumitemslot.b()] = f;
+        }
+
+    }
+
+    public boolean cR() {
+        return this.canPickUpLoot;
+    }
+
+    public void m(boolean flag) {
+        this.canPickUpLoot = flag;
+    }
+
+    public boolean isPersistent() {
+        return this.persistent;
+    }
+
+    public final boolean a(EntityHuman entityhuman, @Nullable ItemStack itemstack, EnumHand enumhand) {
+        if (this.isLeashed() && this.getLeashHolder() == entityhuman) {
+            // CraftBukkit start - fire PlayerUnleashEntityEvent
+            if (CraftEventFactory.callPlayerUnleashEntityEvent(this, entityhuman).isCancelled()) {
+                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutAttachEntity(this, this.getLeashHolder()));
+                return false;
+            }
+            // CraftBukkit end
+            this.unleash(true, !entityhuman.abilities.canInstantlyBuild);
+            return true;
+        } else if (itemstack != null && itemstack.getItem() == Items.LEAD && this.a(entityhuman)) {
+            // CraftBukkit start - fire PlayerLeashEntityEvent
+            if (CraftEventFactory.callPlayerLeashEntityEvent(this, entityhuman, entityhuman).isCancelled()) {
+                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutAttachEntity(this, this.getLeashHolder()));
+                return false;
+            }
+            // CraftBukkit end
+            this.setLeashHolder(entityhuman, true);
+            --itemstack.count;
+            return true;
+        } else {
+            return this.a(entityhuman, enumhand, itemstack) ? true : super.a(entityhuman, itemstack, enumhand);
+        }
+    }
+
+    protected boolean a(EntityHuman entityhuman, EnumHand enumhand, @Nullable ItemStack itemstack) {
+        return false;
+    }
+
+    protected void cT() {
+        if (this.bG != null) {
+            this.cY();
+        }
+
+        if (this.bE) {
+            if (!this.isAlive()) {
+                this.world.getServer().getPluginManager().callEvent(new EntityUnleashEvent(this.getBukkitEntity(), UnleashReason.PLAYER_UNLEASH)); // CraftBukkit
+                this.unleash(true, true);
+            }
+
+            if (this.leashHolder == null || this.leashHolder.dead) {
+                this.world.getServer().getPluginManager().callEvent(new EntityUnleashEvent(this.getBukkitEntity(), UnleashReason.HOLDER_GONE)); // CraftBukkit
+                this.unleash(true, true);
+            }
+        }
+    }
+
+    public void unleash(boolean flag, boolean flag1) {
+        if (this.bE) {
+            this.bE = false;
+            this.leashHolder = null;
+            if (!this.world.isClientSide && flag1) {
+                this.forceDrops = true; // CraftBukkit
+                this.a(Items.LEAD, 1);
+                this.forceDrops = false; // CraftBukkit
+            }
+
+            if (!this.world.isClientSide && flag && this.world instanceof WorldServer) {
+                ((WorldServer) this.world).getTracker().a((Entity) this, (Packet) (new PacketPlayOutAttachEntity(this, (Entity) null)));
+            }
+        }
+
+    }
+
+    public boolean a(EntityHuman entityhuman) {
+        return !this.isLeashed() && !(this instanceof IMonster);
+    }
+
+    public boolean isLeashed() {
+        return this.bE;
+    }
+
+    public Entity getLeashHolder() {
+        return this.leashHolder;
+    }
+
+    public void setLeashHolder(Entity entity, boolean flag) {
+        this.bE = true;
+        this.leashHolder = entity;
+        if (!this.world.isClientSide && flag && this.world instanceof WorldServer) {
+            ((WorldServer) this.world).getTracker().a((Entity) this, (Packet) (new PacketPlayOutAttachEntity(this, this.leashHolder)));
+        }
+
+        if (this.isPassenger()) {
+            this.stopRiding();
+        }
+
+    }
+
+    public boolean a(Entity entity, boolean flag) {
+        boolean flag1 = super.a(entity, flag);
+
+        if (flag1 && this.isLeashed()) {
+            this.unleash(true, true);
+        }
+
+        return flag1;
+    }
+
+    private void cY() {
+        if (this.bE && this.bG != null) {
+            if (this.bG.b("UUID")) {
+                UUID uuid = this.bG.a("UUID");
+                List list = this.world.a(EntityLiving.class, this.getBoundingBox().g(10.0D));
+                Iterator iterator = list.iterator();
+
+                while (iterator.hasNext()) {
+                    EntityLiving entityliving = (EntityLiving) iterator.next();
+
+                    if (entityliving.getUniqueID().equals(uuid)) {
+                        this.leashHolder = entityliving;
+                        break;
+                    }
+                }
+            } else if (this.bG.hasKeyOfType("X", 99) && this.bG.hasKeyOfType("Y", 99) && this.bG.hasKeyOfType("Z", 99)) {
+                BlockPosition blockposition = new BlockPosition(this.bG.getInt("X"), this.bG.getInt("Y"), this.bG.getInt("Z"));
+                EntityLeash entityleash = EntityLeash.b(this.world, blockposition);
+
+                if (entityleash == null) {
+                    entityleash = EntityLeash.a(this.world, blockposition);
+                }
+
+                this.leashHolder = entityleash;
+            } else {
+                this.world.getServer().getPluginManager().callEvent(new EntityUnleashEvent(this.getBukkitEntity(), UnleashReason.UNKNOWN)); // CraftBukkit
+                this.unleash(false, true);
+            }
+        }
+
+        this.bG = null;
+    }
+
+    public boolean c(int i, @Nullable ItemStack itemstack) {
+        EnumItemSlot enumitemslot;
+
+        if (i == 98) {
+            enumitemslot = EnumItemSlot.MAINHAND;
+        } else if (i == 99) {
+            enumitemslot = EnumItemSlot.OFFHAND;
+        } else if (i == 100 + EnumItemSlot.HEAD.b()) {
+            enumitemslot = EnumItemSlot.HEAD;
+        } else if (i == 100 + EnumItemSlot.CHEST.b()) {
+            enumitemslot = EnumItemSlot.CHEST;
+        } else if (i == 100 + EnumItemSlot.LEGS.b()) {
+            enumitemslot = EnumItemSlot.LEGS;
+        } else {
+            if (i != 100 + EnumItemSlot.FEET.b()) {
+                return false;
+            }
+
+            enumitemslot = EnumItemSlot.FEET;
+        }
+
+        if (itemstack != null && !b(enumitemslot, itemstack) && enumitemslot != EnumItemSlot.HEAD) {
+            return false;
+        } else {
+            this.setSlot(enumitemslot, itemstack);
+            return true;
+        }
+    }
+
+    public static boolean b(EnumItemSlot enumitemslot, ItemStack itemstack) {
+        EnumItemSlot enumitemslot1 = d(itemstack);
+
+        return enumitemslot1 == enumitemslot || enumitemslot1 == EnumItemSlot.MAINHAND && enumitemslot == EnumItemSlot.OFFHAND || enumitemslot1 == EnumItemSlot.OFFHAND && enumitemslot == EnumItemSlot.MAINHAND;
+    }
+
+    public boolean ct() {
+        return super.ct() && !this.hasAI();
+    }
+
+    public void setAI(boolean flag) {
+        byte b0 = ((Byte) this.datawatcher.get(EntityInsentient.a)).byteValue();
+
+        this.datawatcher.set(EntityInsentient.a, Byte.valueOf(flag ? (byte) (b0 | 1) : (byte) (b0 & -2)));
+    }
+
+    public void o(boolean flag) {
+        byte b0 = ((Byte) this.datawatcher.get(EntityInsentient.a)).byteValue();
+
+        this.datawatcher.set(EntityInsentient.a, Byte.valueOf(flag ? (byte) (b0 | 2) : (byte) (b0 & -3)));
+    }
+
+    public boolean hasAI() {
+        return (((Byte) this.datawatcher.get(EntityInsentient.a)).byteValue() & 1) != 0;
+    }
+
+    public boolean cX() {
+        return (((Byte) this.datawatcher.get(EntityInsentient.a)).byteValue() & 2) != 0;
+    }
+
+    public EnumMainHand getMainHand() {
+        return this.cX() ? EnumMainHand.LEFT : EnumMainHand.RIGHT;
+    }
+
+    static class SyntheticClass_1 {
+
+        static final int[] a;
+        static final int[] b = new int[EnumItemSlot.values().length];
+
+        static {
+            try {
+                EntityInsentient.SyntheticClass_1.b[EnumItemSlot.HEAD.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror) {
+                ;
+            }
+
+            try {
+                EntityInsentient.SyntheticClass_1.b[EnumItemSlot.CHEST.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror1) {
+                ;
+            }
+
+            try {
+                EntityInsentient.SyntheticClass_1.b[EnumItemSlot.LEGS.ordinal()] = 3;
+            } catch (NoSuchFieldError nosuchfielderror2) {
+                ;
+            }
+
+            try {
+                EntityInsentient.SyntheticClass_1.b[EnumItemSlot.FEET.ordinal()] = 4;
+            } catch (NoSuchFieldError nosuchfielderror3) {
+                ;
+            }
+
+            a = new int[EnumItemSlot.Function.values().length];
+
+            try {
+                EntityInsentient.SyntheticClass_1.a[EnumItemSlot.Function.HAND.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror4) {
+                ;
+            }
+
+            try {
+                EntityInsentient.SyntheticClass_1.a[EnumItemSlot.Function.ARMOR.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror5) {
+                ;
+            }
+
+        }
+    }
+
+    public static enum EnumEntityPositionType {
+
+        ON_GROUND, IN_AIR, IN_WATER;
+
+        private EnumEntityPositionType() {}
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/EntityPlayer.java src/main/java/net/minecraft/server/EntityPlayer.java
--- src_origin/main/java/net/minecraft/server/EntityPlayer.java	2016-08-25 22:39:51.469601941 +0800
+++ src/main/java/net/minecraft/server/EntityPlayer.java	2016-08-26 03:24:13.911198416 +0800
@@ -1,1299 +1,1303 @@
-package net.minecraft.server;
-
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
-import com.mojang.authlib.GameProfile;
-import io.netty.buffer.Unpooled;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import javax.annotation.Nullable;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-
-// CraftBukkit start
-import org.bukkit.Bukkit;
-import org.bukkit.WeatherType;
-import org.bukkit.craftbukkit.CraftWorld;
-import org.bukkit.craftbukkit.entity.CraftPlayer;
-import org.bukkit.craftbukkit.event.CraftEventFactory;
-import org.bukkit.craftbukkit.inventory.CraftItemStack;
-import org.bukkit.event.inventory.InventoryType;
-import org.bukkit.event.player.PlayerChangedMainHandEvent;
-import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
-import org.bukkit.inventory.MainHand;
-// CraftBukkit end
-
-public class EntityPlayer extends EntityHuman implements ICrafting {
-
-    private static final Logger bS = LogManager.getLogger();
-    public String locale = "en_US"; // Spigot private -> public
-    public PlayerConnection playerConnection;
-    public final MinecraftServer server;
-    public final PlayerInteractManager playerInteractManager;
-    public double d;
-    public double e;
-    public final List<Integer> removeQueue = Lists.newLinkedList();
-    private final ServerStatisticManager bV;
-    private float bW = Float.MIN_VALUE;
-    private int bX = Integer.MIN_VALUE;
-    private int bY = Integer.MIN_VALUE;
-    private int bZ = Integer.MIN_VALUE;
-    private int ca = Integer.MIN_VALUE;
-    private int cb = Integer.MIN_VALUE;
-    private float lastHealthSent = -1.0E8F;
-    private int cd = -99999999;
-    private boolean ce = true;
-    public int lastSentExp = -99999999;
-    public int invulnerableTicks = 60;
-    private EntityHuman.EnumChatVisibility ch;
-    private boolean ci = true;
-    private long cj = System.currentTimeMillis();
-    private Entity ck;
-    public boolean worldChangeInvuln;
-    private int containerCounter;
-    public boolean f;
-    public int ping;
-    public boolean viewingCredits;
-
-    // CraftBukkit start
-    public String displayName;
-    public IChatBaseComponent listName;
-    public org.bukkit.Location compassTarget;
-    public int newExp = 0;
-    public int newLevel = 0;
-    public int newTotalExp = 0;
-    public boolean keepLevel = false;
-    public double maxHealthCache;
-    public boolean joining = true;
-    // CraftBukkit end
-
-    public EntityPlayer(MinecraftServer minecraftserver, WorldServer worldserver, GameProfile gameprofile, PlayerInteractManager playerinteractmanager) {
-        super(worldserver, gameprofile);
-        playerinteractmanager.player = this;
-        this.playerInteractManager = playerinteractmanager;
-        BlockPosition blockposition = worldserver.getSpawn();
-
-        if (!worldserver.worldProvider.m() && worldserver.getWorldData().getGameType() != EnumGamemode.ADVENTURE) {
-            int i = Math.max(0, minecraftserver.a(worldserver));
-            int j = MathHelper.floor(worldserver.getWorldBorder().b((double) blockposition.getX(), (double) blockposition.getZ()));
-
-            if (j < i) {
-                i = j;
-            }
-
-            if (j <= 1) {
-                i = 1;
-            }
-
-            blockposition = worldserver.q(blockposition.a(this.random.nextInt(i * 2 + 1) - i, 0, this.random.nextInt(i * 2 + 1) - i));
-        }
-
-        this.server = minecraftserver;
-        this.bV = minecraftserver.getPlayerList().a((EntityHuman) this);
-        this.P = 0.0F;
-        this.setPositionRotation(blockposition, 0.0F, 0.0F);
-
-        while (!worldserver.getCubes(this, this.getBoundingBox()).isEmpty() && this.locY < 255.0D) {
-            this.setPosition(this.locX, this.locY + 1.0D, this.locZ);
-        }
-
-        // CraftBukkit start
-        this.displayName = this.getName();
-        // this.canPickUpLoot = true; TODO
-        this.maxHealthCache = this.getMaxHealth();
-        // CraftBukkit end
-    }
-
-    public void a(NBTTagCompound nbttagcompound) {
-        super.a(nbttagcompound);
-        if (nbttagcompound.hasKeyOfType("playerGameType", 99)) {
-            if (this.h().getForceGamemode()) {
-                this.playerInteractManager.setGameMode(this.h().getGamemode());
-            } else {
-                this.playerInteractManager.setGameMode(EnumGamemode.getById(nbttagcompound.getInt("playerGameType")));
-            }
-        }
-
-        this.getBukkitEntity().readExtraData(nbttagcompound); // CraftBukkit
-    }
-
-    public void b(NBTTagCompound nbttagcompound) {
-        super.b(nbttagcompound);
-        nbttagcompound.setInt("playerGameType", this.playerInteractManager.getGameMode().getId());
-        Entity entity = this.getVehicle();
-
-        if (this.bB() != null && entity != this & entity.b(EntityPlayer.class).size() == 1) {
-            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
-            NBTTagCompound nbttagcompound2 = new NBTTagCompound();
-
-            entity.d(nbttagcompound2);
-            nbttagcompound1.a("Attach", this.bB().getUniqueID());
-            nbttagcompound1.set("Entity", nbttagcompound2);
-            nbttagcompound.set("RootVehicle", nbttagcompound1);
-        }
-		this.getBukkitEntity().setExtraData(nbttagcompound); // CraftBukkit
-    }
-
-    // CraftBukkit start - World fallback code, either respawn location or global spawn
-    public void spawnIn(World world) {
-        super.spawnIn(world);
-        if (world == null) {
-            this.dead = false;
-            BlockPosition position = null;
-            if (this.spawnWorld != null && !this.spawnWorld.equals("")) {
-                CraftWorld cworld = (CraftWorld) Bukkit.getServer().getWorld(this.spawnWorld);
-                if (cworld != null && this.getBed() != null) {
-                    world = cworld.getHandle();
-                    position = EntityHuman.getBed(cworld.getHandle(), this.getBed(), false);
-                }
-            }
-            if (world == null || position == null) {
-                world = ((CraftWorld) Bukkit.getServer().getWorlds().get(0)).getHandle();
-                position = world.getSpawn();
-            }
-            this.world = world;
-            this.setPosition(position.getX() + 0.5, position.getY(), position.getZ() + 0.5);
-        }
-        this.dimension = ((WorldServer) this.world).dimension;
-        this.playerInteractManager.a((WorldServer) world);
-    }
-    // CraftBukkit end
-
-    public void levelDown(int i) {
-        super.levelDown(i);
-        this.lastSentExp = -1;
-    }
-
-    public void enchantDone(int i) {
-        super.enchantDone(i);
-        this.lastSentExp = -1;
-    }
-
-    public void syncInventory() {
-        this.activeContainer.addSlotListener(this);
-    }
-
-    public void enterCombat() {
-        super.enterCombat();
-        this.playerConnection.sendPacket(new PacketPlayOutCombatEvent(this.getCombatTracker(), PacketPlayOutCombatEvent.EnumCombatEventType.ENTER_COMBAT));
-    }
-
-    public void exitCombat() {
-        super.exitCombat();
-        this.playerConnection.sendPacket(new PacketPlayOutCombatEvent(this.getCombatTracker(), PacketPlayOutCombatEvent.EnumCombatEventType.END_COMBAT));
-    }
-
-    protected ItemCooldown l() {
-        return new ItemCooldownPlayer(this);
-    }
-
-    public void m() {
-        // CraftBukkit start
-        if (this.joining) {
-            this.joining = false;
-        }
-        // CraftBukkit end
-        this.playerInteractManager.a();
-        --this.invulnerableTicks;
-        if (this.noDamageTicks > 0) {
-            --this.noDamageTicks;
-        }
-
-        this.activeContainer.b();
-        if (!this.world.isClientSide && !this.activeContainer.a((EntityHuman) this)) {
-            this.closeInventory();
-            this.activeContainer = this.defaultContainer;
-        }
-
-        while (!this.removeQueue.isEmpty()) {
-            int i = Math.min(this.removeQueue.size(), Integer.MAX_VALUE);
-            int[] aint = new int[i];
-            Iterator iterator = this.removeQueue.iterator();
-            int j = 0;
-
-            while (iterator.hasNext() && j < i) {
-                aint[j++] = ((Integer) iterator.next()).intValue();
-                iterator.remove();
-            }
-
-            this.playerConnection.sendPacket(new PacketPlayOutEntityDestroy(aint));
-        }
-
-        Entity entity = this.getSpecatorTarget();
-
-        if (entity != this) {
-            if (entity.isAlive()) {
-                this.setLocation(entity.locX, entity.locY, entity.locZ, entity.yaw, entity.pitch);
-                this.server.getPlayerList().d(this);
-                if (this.isSneaking()) {
-                    this.setSpectatorTarget(this);
-                }
-            } else {
-                this.setSpectatorTarget(this);
-            }
-        }
-
-    }
-
-    public void k_() {
-        try {
-            super.m();
-
-            for (int i = 0; i < this.inventory.getSize(); ++i) {
-                ItemStack itemstack = this.inventory.getItem(i);
-
-                if (itemstack != null && itemstack.getItem().f()) {
-                    Packet packet = ((ItemWorldMapBase) itemstack.getItem()).a(itemstack, this.world, (EntityHuman) this);
-
-                    if (packet != null) {
-                        this.playerConnection.sendPacket(packet);
-                    }
-                }
-            }
-
-            if (this.getHealth() != this.lastHealthSent || this.cd != this.foodData.getFoodLevel() || this.foodData.getSaturationLevel() == 0.0F != this.ce) {
-                this.playerConnection.sendPacket(new PacketPlayOutUpdateHealth(this.getBukkitEntity().getScaledHealth(), this.foodData.getFoodLevel(), this.foodData.getSaturationLevel())); // CraftBukkit
-                this.lastHealthSent = this.getHealth();
-                this.cd = this.foodData.getFoodLevel();
-                this.ce = this.foodData.getSaturationLevel() == 0.0F;
-            }
-
-            if (this.getHealth() + this.getAbsorptionHearts() != this.bW) {
-                this.bW = this.getHealth() + this.getAbsorptionHearts();
-                this.a(IScoreboardCriteria.g, MathHelper.f(this.bW));
-            }
-
-            if (this.foodData.getFoodLevel() != this.bX) {
-                this.bX = this.foodData.getFoodLevel();
-                this.a(IScoreboardCriteria.h, MathHelper.f((float) this.bX));
-            }
-
-            if (this.getAirTicks() != this.bY) {
-                this.bY = this.getAirTicks();
-                this.a(IScoreboardCriteria.i, MathHelper.f((float) this.bY));
-            }
-
-            // CraftBukkit start - Force max health updates
-            if (this.maxHealthCache != this.getMaxHealth()) {
-                this.getBukkitEntity().updateScaledHealth();
-            }
-            // CraftBukkit end
-
-            if (this.getArmorStrength() != this.bZ) {
-                this.bZ = this.getArmorStrength();
-                this.a(IScoreboardCriteria.j, MathHelper.f((float) this.bZ));
-            }
-
-            if (this.expTotal != this.cb) {
-                this.cb = this.expTotal;
-                this.a(IScoreboardCriteria.k, MathHelper.f((float) this.cb));
-            }
-
-            if (this.expLevel != this.ca) {
-                this.ca = this.expLevel;
-                this.a(IScoreboardCriteria.l, MathHelper.f((float) this.ca));
-            }
-
-            if (this.expTotal != this.lastSentExp) {
-                this.lastSentExp = this.expTotal;
-                this.playerConnection.sendPacket(new PacketPlayOutExperience(this.exp, this.expTotal, this.expLevel));
-            }
-
-            if (this.ticksLived % 20 * 5 == 0 && !this.getStatisticManager().hasAchievement(AchievementList.L)) {
-                this.o();
-            }
-
-            // CraftBukkit start - initialize oldLevel and fire PlayerLevelChangeEvent
-            if (this.oldLevel == -1) {
-                this.oldLevel = this.expLevel;
-            }
-
-            if (this.oldLevel != this.expLevel) {
-                CraftEventFactory.callPlayerLevelChangeEvent(this.world.getServer().getPlayer((EntityPlayer) this), this.oldLevel, this.expLevel);
-                this.oldLevel = this.expLevel;
-            }
-            // CraftBukkit end
-        } catch (Throwable throwable) {
-            CrashReport crashreport = CrashReport.a(throwable, "Ticking player");
-            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Player being ticked");
-
-            this.appendEntityCrashDetails(crashreportsystemdetails);
-            throw new ReportedException(crashreport);
-        }
-    }
-
-    private void a(IScoreboardCriteria iscoreboardcriteria, int i) {
-        Collection collection = this.world.getServer().getScoreboardManager().getScoreboardScores(iscoreboardcriteria, this.getName(), new java.util.ArrayList<ScoreboardScore>()); // CraftBukkit - Use our scores instead
-        Iterator iterator = collection.iterator();
-
-        while (iterator.hasNext()) {
-            ScoreboardScore scoreboardscore = (ScoreboardScore) iterator.next(); // CraftBukkit - Use our scores instead
-
-            scoreboardscore.setScore(i);
-        }
-
-    }
-
-    protected void o() {
-        BiomeBase biomebase = this.world.getBiome(new BlockPosition(MathHelper.floor(this.locX), 0, MathHelper.floor(this.locZ)));
-        String s = biomebase.l();
-        AchievementSet achievementset = (AchievementSet) this.getStatisticManager().b((Statistic) AchievementList.L);
-
-        if (achievementset == null) {
-            achievementset = (AchievementSet) this.getStatisticManager().a(AchievementList.L, new AchievementSet());
-        }
-
-        achievementset.add(s);
-        if (this.getStatisticManager().b(AchievementList.L) && achievementset.size() >= BiomeBase.i.size()) {
-            HashSet hashset = Sets.newHashSet(BiomeBase.i);
-            Iterator iterator = achievementset.iterator();
-
-            while (iterator.hasNext()) {
-                String s1 = (String) iterator.next();
-                Iterator iterator1 = hashset.iterator();
-
-                while (iterator1.hasNext()) {
-                    BiomeBase biomebase1 = (BiomeBase) iterator1.next();
-
-                    if (biomebase1.l().equals(s1)) {
-                        iterator1.remove();
-                    }
-                }
-
-                if (hashset.isEmpty()) {
-                    break;
-                }
-            }
-
-            if (hashset.isEmpty()) {
-                this.b((Statistic) AchievementList.L);
-            }
-        }
-
-    }
-
-    public void die(DamageSource damagesource) {
-        boolean flag = this.world.getGameRules().getBoolean("showDeathMessages");
-
-        this.playerConnection.sendPacket(new PacketPlayOutCombatEvent(this.getCombatTracker(), PacketPlayOutCombatEvent.EnumCombatEventType.ENTITY_DIED, flag));
-        // CraftBukkit start - fire PlayerDeathEvent
-        if (this.dead) {
-            return;
-        }
-        java.util.List<org.bukkit.inventory.ItemStack> loot = new java.util.ArrayList<org.bukkit.inventory.ItemStack>();
-        boolean keepInventory = this.world.getGameRules().getBoolean("keepInventory");
-
-        if (!keepInventory) {
-            for (int i = 0; i < this.inventory.items.length; ++i) {
-                if (this.inventory.items[i] != null) {
-                    loot.add(CraftItemStack.asCraftMirror(this.inventory.items[i]));
-                }
-            }
-            for (int i = 0; i < this.inventory.armor.length; ++i) {
-                if (this.inventory.armor[i] != null) {
-                    loot.add(CraftItemStack.asCraftMirror(this.inventory.armor[i]));
-                }
-            }
-            for (int i = 0; i < this.inventory.extraSlots.length; ++i) {
-                if (this.inventory.extraSlots[i] != null) {
-                    loot.add(CraftItemStack.asCraftMirror(this.inventory.extraSlots[i]));
-                }
-            }
-        }
-
-        IChatBaseComponent chatmessage = this.getCombatTracker().getDeathMessage();
-
-        String deathmessage = chatmessage.toPlainText();
-        org.bukkit.event.entity.PlayerDeathEvent event = CraftEventFactory.callPlayerDeathEvent(this, loot, deathmessage, keepInventory);
-
-        String deathMessage = event.getDeathMessage();
-
-        if (deathMessage != null && deathMessage.length() > 0 && flag) { // TODO: allow plugins to override?
-            if (deathMessage.equals(deathmessage)) {
-                ScoreboardTeamBase scoreboardteambase = this.aQ();
-
-                if (scoreboardteambase != null && scoreboardteambase.getDeathMessageVisibility() != ScoreboardTeamBase.EnumNameTagVisibility.ALWAYS) {
-                    if (scoreboardteambase.getDeathMessageVisibility() == ScoreboardTeamBase.EnumNameTagVisibility.HIDE_FOR_OTHER_TEAMS) {
-                        this.server.getPlayerList().a((EntityHuman) this, chatmessage);
-                    } else if (scoreboardteambase.getDeathMessageVisibility() == ScoreboardTeamBase.EnumNameTagVisibility.HIDE_FOR_OWN_TEAM) {
-                        this.server.getPlayerList().b((EntityHuman) this, chatmessage);
-                    }
-                } else {
-                    this.server.getPlayerList().sendMessage(chatmessage);
-                }
-            } else {
-                this.server.getPlayerList().sendMessage(org.bukkit.craftbukkit.util.CraftChatMessage.fromString(deathMessage));
-            }
-        }
-
-        // we clean the player's inventory after the EntityDeathEvent is called so plugins can get the exact state of the inventory.
-        if (!event.getKeepInventory()) {
-            for (int i = 0; i < this.inventory.items.length; ++i) {
-                this.inventory.items[i] = null;
-            }
-            for (int i = 0; i < this.inventory.armor.length; ++i) {
-                this.inventory.armor[i] = null;
-            }
-            for (int i = 0; i < this.inventory.extraSlots.length; ++i) {
-                this.inventory.extraSlots[i] = null;
-            }
-        }
-
-        this.closeInventory();
-        this.setSpectatorTarget(this); // Remove spectated target
-        // CraftBukkit end
-
-        // CraftBukkit - Get our scores instead
-        Collection collection = this.world.getServer().getScoreboardManager().getScoreboardScores(IScoreboardCriteria.d, this.getName(), new java.util.ArrayList<ScoreboardScore>());
-        Iterator iterator = collection.iterator();
-
-        while (iterator.hasNext()) {
-            ScoreboardScore scoreboardscore = (ScoreboardScore) iterator.next(); // CraftBukkit - Use our scores instead
-
-            scoreboardscore.incrementScore();
-        }
-
-        EntityLiving entityliving = this.bZ();
-
-        if (entityliving != null) {
-            EntityTypes.MonsterEggInfo entitytypes_monsteregginfo = (EntityTypes.MonsterEggInfo) EntityTypes.eggInfo.get(EntityTypes.b((Entity) entityliving));
-
-            if (entitytypes_monsteregginfo != null) {
-                this.b(entitytypes_monsteregginfo.killedByEntityStatistic);
-            }
-
-            entityliving.b(this, this.bc);
-        }
-
-        this.b(StatisticList.A);
-        this.a(StatisticList.h);
-        this.getCombatTracker().g();
-    }
-
-    public boolean damageEntity(DamageSource damagesource, float f) {
-        if (this.isInvulnerable(damagesource)) {
-            return false;
-        } else {
-            boolean flag = this.server.aa() && this.canPvP() && "fall".equals(damagesource.translationIndex);
-
-            if (!flag && this.invulnerableTicks > 0 && damagesource != DamageSource.OUT_OF_WORLD) {
-                return false;
-            } else {
-                if (damagesource instanceof EntityDamageSource) {
-                    Entity entity = damagesource.getEntity();
-
-                    if (entity instanceof EntityHuman && !this.a((EntityHuman) entity)) {
-                        return false;
-                    }
-
-                    if (entity instanceof EntityArrow) {
-                        EntityArrow entityarrow = (EntityArrow) entity;
-
-                        if (entityarrow.shooter instanceof EntityHuman && !this.a((EntityHuman) entityarrow.shooter)) {
-                            return false;
-                        }
-                    }
-                }
-
-                return super.damageEntity(damagesource, f);
-            }
-        }
-    }
-
-    public boolean a(EntityHuman entityhuman) {
-        return !this.canPvP() ? false : super.a(entityhuman);
-    }
-
-    private boolean canPvP() {
-        // CraftBukkit - this.server.getPvP() -> this.world.pvpMode
-        return this.world.pvpMode;
-    }
-
-    @Nullable
-    public Entity c(int i) {
-        // this.worldChangeInvuln = true; // CraftBukkit - Moved down and into PlayerList#changeDimension
-        if (this.dimension == 1 && i == 1) {
-            this.worldChangeInvuln = true; // CraftBukkit - Moved down from above
-            this.world.kill(this);
-            if (!this.viewingCredits) {
-                this.viewingCredits = true;
-                if (this.a(AchievementList.D)) {
-                    this.playerConnection.sendPacket(new PacketPlayOutGameStateChange(4, 0.0F));
-                } else {
-                    this.b((Statistic) AchievementList.D);
-                    this.playerConnection.sendPacket(new PacketPlayOutGameStateChange(4, 1.0F));
-                }
-            }
-
-            return this;
-        } else {
-            if (this.dimension == 0 && i == 1) {
-                this.b((Statistic) AchievementList.C);
-                i = 1;
-            } else {
-                this.b((Statistic) AchievementList.y);
-            }
-
-            // CraftBukkit start
-            TeleportCause cause = (this.dimension == 1 || i == 1) ? TeleportCause.END_PORTAL : TeleportCause.NETHER_PORTAL;
-            this.server.getPlayerList().changeDimension(this, i, cause); // PAIL: check all this
-            // CraftBukkit end
-            this.playerConnection.sendPacket(new PacketPlayOutWorldEvent(1032, BlockPosition.ZERO, 0, false));
-            this.lastSentExp = -1;
-            this.lastHealthSent = -1.0F;
-            this.cd = -1;
-            return this;
-        }
-    }
-
-    public boolean a(EntityPlayer entityplayer) {
-        return entityplayer.isSpectator() ? this.getSpecatorTarget() == this : (this.isSpectator() ? false : super.a(entityplayer));
-    }
-
-    private void a(TileEntity tileentity) {
-        if (tileentity != null) {
-            PacketPlayOutTileEntityData packetplayouttileentitydata = tileentity.getUpdatePacket();
-
-            if (packetplayouttileentitydata != null) {
-                this.playerConnection.sendPacket(packetplayouttileentitydata);
-            }
-        }
-
-    }
-
-    public void receive(Entity entity, int i) {
-        super.receive(entity, i);
-        this.activeContainer.b();
-    }
-
-    public EntityHuman.EnumBedResult a(BlockPosition blockposition) {
-        EntityHuman.EnumBedResult entityhuman_enumbedresult = super.a(blockposition);
-
-        if (entityhuman_enumbedresult == EntityHuman.EnumBedResult.OK) {
-            this.b(StatisticList.ad);
-            PacketPlayOutBed packetplayoutbed = new PacketPlayOutBed(this, blockposition);
-
-            this.x().getTracker().a((Entity) this, (Packet) packetplayoutbed);
-            this.playerConnection.a(this.locX, this.locY, this.locZ, this.yaw, this.pitch);
-            this.playerConnection.sendPacket(packetplayoutbed);
-        }
-
-        return entityhuman_enumbedresult;
-    }
-
-    public void a(boolean flag, boolean flag1, boolean flag2) {
-        if (!this.sleeping) return; // CraftBukkit - Can't leave bed if not in one!
-        if (this.isSleeping()) {
-            this.x().getTracker().sendPacketToEntity(this, new PacketPlayOutAnimation(this, 2));
-        }
-
-        super.a(flag, flag1, flag2);
-        if (this.playerConnection != null) {
-            this.playerConnection.a(this.locX, this.locY, this.locZ, this.yaw, this.pitch);
-        }
-
-    }
-
-    public boolean a(Entity entity, boolean flag) {
-        Entity entity1 = this.bB();
-
-        if (!super.a(entity, flag)) {
-            return false;
-        } else {
-            Entity entity2 = this.bB();
-
-            if (entity2 != entity1 && this.playerConnection != null) {
-                this.playerConnection.a(this.locX, this.locY, this.locZ, this.yaw, this.pitch);
-            }
-
-            return true;
-        }
-    }
-
-    public void stopRiding() {
-        Entity entity = this.bB();
-
-        super.stopRiding();
-        Entity entity1 = this.bB();
-
-        if (entity1 != entity && this.playerConnection != null) {
-            this.playerConnection.a(this.locX, this.locY, this.locZ, this.yaw, this.pitch);
-        }
-
-    }
-
-    public boolean isInvulnerable(DamageSource damagesource) {
-        return super.isInvulnerable(damagesource) || this.K();
-    }
-
-    protected void a(double d0, boolean flag, IBlockData iblockdata, BlockPosition blockposition) {}
-
-    protected void b(BlockPosition blockposition) {
-        if (!this.isSpectator()) {
-            super.b(blockposition);
-        }
-
-    }
-
-    public void a(double d0, boolean flag) {
-        int i = MathHelper.floor(this.locX);
-        int j = MathHelper.floor(this.locY - 0.20000000298023224D);
-        int k = MathHelper.floor(this.locZ);
-        BlockPosition blockposition = new BlockPosition(i, j, k);
-        IBlockData iblockdata = this.world.getType(blockposition);
-
-        if (iblockdata.getMaterial() == Material.AIR) {
-            BlockPosition blockposition1 = blockposition.down();
-            IBlockData iblockdata1 = this.world.getType(blockposition1);
-            Block block = iblockdata1.getBlock();
-
-            if (block instanceof BlockFence || block instanceof BlockCobbleWall || block instanceof BlockFenceGate) {
-                blockposition = blockposition1;
-                iblockdata = iblockdata1;
-            }
-        }
-
-        super.a(d0, flag, iblockdata, blockposition);
-    }
-
-    public void openSign(TileEntitySign tileentitysign) {
-        tileentitysign.a((EntityHuman) this);
-        this.playerConnection.sendPacket(new PacketPlayOutOpenSignEditor(tileentitysign.getPosition()));
-    }
-
-    public int nextContainerCounter() { // CraftBukkit - void -> int
-        this.containerCounter = this.containerCounter % 100 + 1;
-        return containerCounter; // CraftBukkit
-    }
-
-    public void openTileEntity(ITileEntityContainer itileentitycontainer) {
-        // CraftBukkit start - Inventory open hook
-        Container container = CraftEventFactory.callInventoryOpenEvent(this, itileentitycontainer.createContainer(this.inventory, this));
-        if (container == null) {
-            return;
-        }
-
-        this.nextContainerCounter();
-        this.activeContainer = container;
-        this.playerConnection.sendPacket(new PacketPlayOutOpenWindow(this.containerCounter, itileentitycontainer.getContainerName(), itileentitycontainer.getScoreboardDisplayName()));
-        // CraftBukkit end
-        this.activeContainer.windowId = this.containerCounter;
-        this.activeContainer.addSlotListener(this);
-    }
-
-    public void openContainer(IInventory iinventory) {
-        // CraftBukkit start - Inventory open hook
-        // Copied from below
-        boolean cancelled = false;
-        if (iinventory instanceof ITileInventory) {
-            ITileInventory itileinventory = (ITileInventory) iinventory;
-            cancelled = itileinventory.x_() && !this.a(itileinventory.y_()) && !this.isSpectator(); // PAIL: rename
-        }
-
-        Container container;
-        if (iinventory instanceof ITileEntityContainer) {
-            container = ((ITileEntityContainer) iinventory).createContainer(this.inventory, this);
-        } else {
-            container = new ContainerChest(this.inventory, iinventory, this);
-        }
-        container = CraftEventFactory.callInventoryOpenEvent(this, container, cancelled);
-        if (container == null && !cancelled) { // Let pre-cancelled events fall through
-            iinventory.closeContainer(this);
-            return;
-        }
-        // CraftBukkit end
-
-        if (iinventory instanceof ILootable && ((ILootable) iinventory).b() != null && this.isSpectator()) {
-            this.sendMessage((new ChatMessage("container.spectatorCantOpen", new Object[0])).setChatModifier((new ChatModifier()).setColor(EnumChatFormat.RED)));
-        } else {
-            if (this.activeContainer != this.defaultContainer) {
-                this.closeInventory();
-            }
-
-            if (iinventory instanceof ITileInventory) {
-                ITileInventory itileinventory = (ITileInventory) iinventory;
-
-                if (itileinventory.x_() && !this.a(itileinventory.y_()) && !this.isSpectator()) {
-                    this.playerConnection.sendPacket(new PacketPlayOutChat(new ChatMessage("container.isLocked", new Object[] { iinventory.getScoreboardDisplayName()}), (byte) 2));
-                    this.playerConnection.sendPacket(new PacketPlayOutNamedSoundEffect(SoundEffects.W, SoundCategory.BLOCKS, this.locX, this.locY, this.locZ, 1.0F, 1.0F));
-                    iinventory.closeContainer(this); // CraftBukkit
-                    return;
-                }
-            }
-
-            this.nextContainerCounter();
-            // CraftBukkit start
-            if (iinventory instanceof ITileEntityContainer) {
-                this.activeContainer = container;
-                this.playerConnection.sendPacket(new PacketPlayOutOpenWindow(this.containerCounter, ((ITileEntityContainer) iinventory).getContainerName(), iinventory.getScoreboardDisplayName(), iinventory.getSize()));
-            } else {
-                this.activeContainer = container;
-                this.playerConnection.sendPacket(new PacketPlayOutOpenWindow(this.containerCounter, "minecraft:container", iinventory.getScoreboardDisplayName(), iinventory.getSize()));
-            }
-            // CraftBukkit end
-
-            this.activeContainer.windowId = this.containerCounter;
-            this.activeContainer.addSlotListener(this);
-        }
-    }
-
-    public void openTrade(IMerchant imerchant) {
-        // CraftBukkit start - Inventory open hook
-        Container container = CraftEventFactory.callInventoryOpenEvent(this, new ContainerMerchant(this.inventory, imerchant, this.world));
-        if (container == null) {
-            return;
-        }
-        // CraftBukkit end
-        this.nextContainerCounter();
-        this.activeContainer = container; // CraftBukkit
-        this.activeContainer.windowId = this.containerCounter;
-        this.activeContainer.addSlotListener(this);
-        InventoryMerchant inventorymerchant = ((ContainerMerchant) this.activeContainer).e();
-        IChatBaseComponent ichatbasecomponent = imerchant.getScoreboardDisplayName();
-
-        this.playerConnection.sendPacket(new PacketPlayOutOpenWindow(this.containerCounter, "minecraft:villager", ichatbasecomponent, inventorymerchant.getSize()));
-        MerchantRecipeList merchantrecipelist = imerchant.getOffers(this);
-
-        if (merchantrecipelist != null) {
-            PacketDataSerializer packetdataserializer = new PacketDataSerializer(Unpooled.buffer());
-
-            packetdataserializer.writeInt(this.containerCounter);
-            merchantrecipelist.a(packetdataserializer);
-            this.playerConnection.sendPacket(new PacketPlayOutCustomPayload("MC|TrList", packetdataserializer));
-        }
-
-    }
-
-    public void a(EntityHorse entityhorse, IInventory iinventory) {
-        // CraftBukkit start - Inventory open hook
-        Container container = CraftEventFactory.callInventoryOpenEvent(this, new ContainerHorse(this.inventory, iinventory, entityhorse, this));
-        if (container == null) {
-            iinventory.closeContainer(this);
-            return;
-        }
-        // CraftBukkit end
-        if (this.activeContainer != this.defaultContainer) {
-            this.closeInventory();
-        }
-
-        this.nextContainerCounter();
-        this.playerConnection.sendPacket(new PacketPlayOutOpenWindow(this.containerCounter, "EntityHorse", iinventory.getScoreboardDisplayName(), iinventory.getSize(), entityhorse.getId()));
-        this.activeContainer = container;
-        this.activeContainer.windowId = this.containerCounter;
-        this.activeContainer.addSlotListener(this);
-    }
-
-    public void a(ItemStack itemstack, EnumHand enumhand) {
-        Item item = itemstack.getItem();
-
-        if (item == Items.WRITTEN_BOOK) {
-            PacketDataSerializer packetdataserializer = new PacketDataSerializer(Unpooled.buffer());
-
-            packetdataserializer.a((Enum) enumhand);
-            this.playerConnection.sendPacket(new PacketPlayOutCustomPayload("MC|BOpen", packetdataserializer));
-        }
-
-    }
-
-    public void a(TileEntityCommand tileentitycommand) {
-        tileentitycommand.d(true);
-        this.a((TileEntity) tileentitycommand);
-    }
-
-    public void a(Container container, int i, ItemStack itemstack) {
-        if (!(container.getSlot(i) instanceof SlotResult)) {
-            if (!this.f) {
-                this.playerConnection.sendPacket(new PacketPlayOutSetSlot(container.windowId, i, itemstack));
-            }
-        }
-    }
-
-    public void updateInventory(Container container) {
-        this.a(container, container.a());
-    }
-
-    public void a(Container container, List<ItemStack> list) {
-        this.playerConnection.sendPacket(new PacketPlayOutWindowItems(container.windowId, list));
-        this.playerConnection.sendPacket(new PacketPlayOutSetSlot(-1, -1, this.inventory.getCarried()));
-        // CraftBukkit start - Send a Set Slot to update the crafting result slot
-        if (java.util.EnumSet.of(InventoryType.CRAFTING,InventoryType.WORKBENCH).contains(container.getBukkitView().getType())) {
-            this.playerConnection.sendPacket(new PacketPlayOutSetSlot(container.windowId, 0, container.getSlot(0).getItem()));
-        }
-        // CraftBukkit end
-    }
-
-    public void setContainerData(Container container, int i, int j) {
-        this.playerConnection.sendPacket(new PacketPlayOutWindowData(container.windowId, i, j));
-    }
-
-    public void setContainerData(Container container, IInventory iinventory) {
-        for (int i = 0; i < iinventory.g(); ++i) {
-            this.playerConnection.sendPacket(new PacketPlayOutWindowData(container.windowId, i, iinventory.getProperty(i)));
-        }
-
-    }
-
-    public void closeInventory() {
-        CraftEventFactory.handleInventoryCloseEvent(this); // CraftBukkit
-        this.playerConnection.sendPacket(new PacketPlayOutCloseWindow(this.activeContainer.windowId));
-        this.s();
-    }
-
-    public void broadcastCarriedItem() {
-        if (!this.f) {
-            this.playerConnection.sendPacket(new PacketPlayOutSetSlot(-1, -1, this.inventory.getCarried()));
-        }
-    }
-
-    public void s() {
-        this.activeContainer.b((EntityHuman) this);
-        this.activeContainer = this.defaultContainer;
-    }
-
-    public void a(float f, float f1, boolean flag, boolean flag1) {
-        if (this.isPassenger()) {
-            if (f >= -1.0F && f <= 1.0F) {
-                this.bf = f;
-            }
-
-            if (f1 >= -1.0F && f1 <= 1.0F) {
-                this.bg = f1;
-            }
-
-            this.be = flag;
-            this.setSneaking(flag1);
-        }
-
-    }
-
-    public boolean a(Achievement achievement) {
-        return this.bV.hasAchievement(achievement);
-    }
-
-    public void a(Statistic statistic, int i) {
-        if (statistic != null) {
-            this.bV.b(this, statistic, i);
-            Iterator iterator = this.getScoreboard().getObjectivesForCriteria(statistic.k()).iterator();
-
-            while (iterator.hasNext()) {
-                ScoreboardObjective scoreboardobjective = (ScoreboardObjective) iterator.next();
-
-                this.getScoreboard().getPlayerScoreForObjective(this.getName(), scoreboardobjective).addScore(i);
-            }
-
-            if (this.bV.e()) {
-                this.bV.a(this);
-            }
-
-        }
-    }
-
-    public void a(Statistic statistic) {
-        if (statistic != null) {
-            this.bV.setStatistic(this, statistic, 0);
-            Iterator iterator = this.getScoreboard().getObjectivesForCriteria(statistic.k()).iterator();
-
-            while (iterator.hasNext()) {
-                ScoreboardObjective scoreboardobjective = (ScoreboardObjective) iterator.next();
-
-                this.getScoreboard().getPlayerScoreForObjective(this.getName(), scoreboardobjective).setScore(0);
-            }
-
-            if (this.bV.e()) {
-                this.bV.a(this);
-            }
-
-        }
-    }
-
-    public void t() {
-        this.az();
-        if (this.sleeping) {
-            this.a(true, false, false);
-        }
-
-    }
-
-    public void triggerHealthUpdate() {
-        this.lastHealthSent = -1.0E8F;
-        this.lastSentExp = -1; // CraftBukkit - Added to reset
-    }
-
-    // CraftBukkit start - Support multi-line messages
-    public void sendMessage(IChatBaseComponent[] ichatbasecomponent) {
-        for (IChatBaseComponent component : ichatbasecomponent) {
-            this.sendMessage(component);
-        }
-    }
-    // CraftBukkit end
-
-    public void b(IChatBaseComponent ichatbasecomponent) {
-        this.playerConnection.sendPacket(new PacketPlayOutChat(ichatbasecomponent));
-    }
-
-    protected void v() {
-        if (this.bo != null && this.cx()) {
-            this.playerConnection.sendPacket(new PacketPlayOutEntityStatus(this, (byte) 9));
-            super.v();
-        }
-
-    }
-
-    public void copyTo(EntityHuman entityhuman, boolean flag) {
-        super.copyTo(entityhuman, flag);
-        this.lastSentExp = -1;
-        this.lastHealthSent = -1.0F;
-        this.cd = -1;
-        this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
-    }
-
-    protected void a(MobEffect mobeffect) {
-        super.a(mobeffect);
-        this.playerConnection.sendPacket(new PacketPlayOutEntityEffect(this.getId(), mobeffect));
-    }
-
-    protected void a(MobEffect mobeffect, boolean flag) {
-        super.a(mobeffect, flag);
-        this.playerConnection.sendPacket(new PacketPlayOutEntityEffect(this.getId(), mobeffect));
-    }
-
-    protected void b(MobEffect mobeffect) {
-        super.b(mobeffect);
-        this.playerConnection.sendPacket(new PacketPlayOutRemoveEntityEffect(this.getId(), mobeffect.getMobEffect()));
-    }
-
-    public void enderTeleportTo(double d0, double d1, double d2) {
-        this.playerConnection.a(d0, d1, d2, this.yaw, this.pitch);
-    }
-
-    public void a(Entity entity) {
-        this.x().getTracker().sendPacketToEntity(this, new PacketPlayOutAnimation(entity, 4));
-    }
-
-    public void b(Entity entity) {
-        this.x().getTracker().sendPacketToEntity(this, new PacketPlayOutAnimation(entity, 5));
-    }
-
-    public void updateAbilities() {
-        if (this.playerConnection != null) {
-            this.playerConnection.sendPacket(new PacketPlayOutAbilities(this.abilities));
-            this.F();
-        }
-    }
-
-    public WorldServer x() {
-        return (WorldServer) this.world;
-    }
-
-    public void a(EnumGamemode enumgamemode) {
-        getBukkitEntity().setGameMode(org.bukkit.GameMode.getByValue(enumgamemode.getId()));
-        /* CraftBukkit start - defer to our setGameMode
-        this.playerInteractManager.setGameMode(enumgamemode);
-        this.playerConnection.sendPacket(new PacketPlayOutGameStateChange(3, (float) enumgamemode.getId()));
-        if (enumgamemode == EnumGamemode.SPECTATOR) {
-            this.stopRiding();
-        } else {
-            this.setSpectatorTarget(this);
-        }
-
-        this.updateAbilities();
-        this.cv();
-        // CraftBukkit end */
-    }
-
-    public boolean isSpectator() {
-        return this.playerInteractManager.getGameMode() == EnumGamemode.SPECTATOR;
-    }
-
-    public boolean z() {
-        return this.playerInteractManager.getGameMode() == EnumGamemode.CREATIVE;
-    }
-
-    public void sendMessage(IChatBaseComponent ichatbasecomponent) {
-        this.playerConnection.sendPacket(new PacketPlayOutChat(ichatbasecomponent));
-    }
-
-    public boolean a(int i, String s) {
-        /* CraftBukkit start
-        if ("seed".equals(s) && !this.server.aa()) {
-            return true;
-        } else if (!"tell".equals(s) && !"help".equals(s) && !"me".equals(s) && !"trigger".equals(s)) {
-            if (this.server.getPlayerList().isOp(this.getProfile())) {
-                OpListEntry oplistentry = (OpListEntry) this.server.getPlayerList().getOPs().get(this.getProfile());
-
-                return oplistentry != null ? oplistentry.a() >= i : this.server.q() >= i;
-            } else {
-                return false;
-            }
-        } else {
-            return true;
-        }
-        */
-        if ("@".equals(s)) {
-            return getBukkitEntity().hasPermission("minecraft.command.selector");
-        }
-        if ("".equals(s)) {
-            return getBukkitEntity().isOp();
-        }
-        return getBukkitEntity().hasPermission("minecraft.command." + s);
-        // CraftBukkit end
-    }
-
-    public String A() {
-        String s = this.playerConnection.networkManager.getSocketAddress().toString();
-
-        s = s.substring(s.indexOf("/") + 1);
-        s = s.substring(0, s.indexOf(":"));
-        return s;
-    }
-
-    public void a(PacketPlayInSettings packetplayinsettings) {
-        // CraftBukkit start
-        if (getMainHand() != packetplayinsettings.getMainHand()) {
-            PlayerChangedMainHandEvent event = new PlayerChangedMainHandEvent(getBukkitEntity(), getMainHand() == EnumMainHand.LEFT ? MainHand.LEFT : MainHand.RIGHT);
-            this.server.server.getPluginManager().callEvent(event);
-        }
-        // CraftBukkit end
-        this.locale = packetplayinsettings.a();
-        this.ch = packetplayinsettings.c();
-        this.ci = packetplayinsettings.d();
-        this.getDataWatcher().set(EntityPlayer.br, Byte.valueOf((byte) packetplayinsettings.e()));
-        this.getDataWatcher().set(EntityPlayer.bs, Byte.valueOf((byte) (packetplayinsettings.getMainHand() == EnumMainHand.LEFT ? 0 : 1)));
-    }
-
-    public EntityHuman.EnumChatVisibility getChatFlags() {
-        return this.ch;
-    }
-
-    public void setResourcePack(String s, String s1) {
-        this.playerConnection.sendPacket(new PacketPlayOutResourcePackSend(s, s1));
-    }
-
-    public BlockPosition getChunkCoordinates() {
-        return new BlockPosition(this.locX, this.locY + 0.5D, this.locZ);
-    }
-
-    public void resetIdleTimer() {
-        this.cj = MinecraftServer.av();
-    }
-
-    public ServerStatisticManager getStatisticManager() {
-        return this.bV;
-    }
-
-    public void c(Entity entity) {
-        if (entity instanceof EntityHuman) {
-            this.playerConnection.sendPacket(new PacketPlayOutEntityDestroy(new int[] { entity.getId()}));
-        } else {
-            this.removeQueue.add(Integer.valueOf(entity.getId()));
-        }
-
-    }
-
-    public void d(Entity entity) {
-        this.removeQueue.remove(Integer.valueOf(entity.getId()));
-    }
-
-    protected void F() {
-        if (this.isSpectator()) {
-            this.bP();
-            this.setInvisible(true);
-        } else {
-            super.F();
-        }
-
-        this.x().getTracker().a(this);
-    }
-
-    public Entity getSpecatorTarget() {
-        return (Entity) (this.ck == null ? this : this.ck);
-    }
-
-    public void setSpectatorTarget(Entity entity) {
-        Entity entity1 = this.getSpecatorTarget();
-
-        this.ck = (Entity) (entity == null ? this : entity);
-        if (entity1 != this.ck) {
-            this.playerConnection.sendPacket(new PacketPlayOutCamera(this.ck));
-            this.enderTeleportTo(this.ck.locX, this.ck.locY, this.ck.locZ);
-        }
-
-    }
-
-    protected void H() {
-        if (this.portalCooldown > 0 && !this.worldChangeInvuln) {
-            --this.portalCooldown;
-        }
-
-    }
-
-    public void attack(Entity entity) {
-        if (this.playerInteractManager.getGameMode() == EnumGamemode.SPECTATOR) {
-            this.setSpectatorTarget(entity);
-        } else {
-            super.attack(entity);
-        }
-
-    }
-
-    public long I() {
-        return this.cj;
-    }
-
-    @Nullable
-    public IChatBaseComponent getPlayerListName() {
-        return listName; // CraftBukkit
-    }
-
-    public void a(EnumHand enumhand) {
-        super.a(enumhand);
-        this.de();
-    }
-
-    public boolean K() {
-        return this.worldChangeInvuln;
-    }
-
-    public void L() {
-        this.worldChangeInvuln = false;
-    }
-
-    public void M() {
-        if (!CraftEventFactory.callToggleGlideEvent(this, true).isCancelled()) // CraftBukkit
-        this.setFlag(7, true);
-    }
-
-    public void N() {
-        // CraftBukkit start
-        if (!CraftEventFactory.callToggleGlideEvent(this, false).isCancelled()) {
-            this.setFlag(7, true);
-            this.setFlag(7, false);
-        }
-        // CraftBukkit end
-    }
-
-    // CraftBukkit start - Add per-player time and weather.
-    public long timeOffset = 0;
-    public boolean relativeTime = true;
-
-    public long getPlayerTime() {
-        if (this.relativeTime) {
-            // Adds timeOffset to the current server time.
-            return this.world.getDayTime() + this.timeOffset;
-        } else {
-            // Adds timeOffset to the beginning of this day.
-            return this.world.getDayTime() - (this.world.getDayTime() % 24000) + this.timeOffset;
-        }
-    }
-
-    public WeatherType weather = null;
-
-    public WeatherType getPlayerWeather() {
-        return this.weather;
-    }
-
-    public void setPlayerWeather(WeatherType type, boolean plugin) {
-        if (!plugin && this.weather != null) {
-            return;
-        }
-
-        if (plugin) {
-            this.weather = type;
-        }
-
-        if (type == WeatherType.DOWNFALL) {
-            this.playerConnection.sendPacket(new PacketPlayOutGameStateChange(2, 0));
-        } else {
-            this.playerConnection.sendPacket(new PacketPlayOutGameStateChange(1, 0));
-        }
-    }
-
-    private float pluginRainPosition;
-    private float pluginRainPositionPrevious;
-
-    public void updateWeather(float oldRain, float newRain, float oldThunder, float newThunder) {
-        if (this.weather == null) {
-            // Vanilla
-            if (oldRain != newRain) {
-                this.playerConnection.sendPacket(new PacketPlayOutGameStateChange(7, newRain));
-            }
-        } else {
-            // Plugin
-            if (pluginRainPositionPrevious != pluginRainPosition) {
-                this.playerConnection.sendPacket(new PacketPlayOutGameStateChange(7, pluginRainPosition));
-            }
-        }
-
-        if (oldThunder != newThunder) {
-            if (weather == WeatherType.DOWNFALL || weather == null) {
-                this.playerConnection.sendPacket(new PacketPlayOutGameStateChange(8, newThunder));
-            } else {
-                this.playerConnection.sendPacket(new PacketPlayOutGameStateChange(8, 0));
-            }
-        }
-    }
-
-    public void tickWeather() {
-        if (this.weather == null) return;
-
-        pluginRainPositionPrevious = pluginRainPosition;
-        if (weather == WeatherType.DOWNFALL) {
-            pluginRainPosition += 0.01;
-        } else {
-            pluginRainPosition -= 0.01;
-        }
-
-        pluginRainPosition = MathHelper.a(pluginRainPosition, 0.0F, 1.0F);
-    }
-
-    public void resetPlayerWeather() {
-        this.weather = null;
-        this.setPlayerWeather(this.world.getWorldData().hasStorm() ? WeatherType.DOWNFALL : WeatherType.CLEAR, false);
-    }
-
-    @Override
-    public String toString() {
-        return super.toString() + "(" + this.getName() + " at " + this.locX + "," + this.locY + "," + this.locZ + ")";
-    }
-
-    public void reset() {
-        float exp = 0;
-        boolean keepInventory = this.world.getGameRules().getBoolean("keepInventory");
-
-        if (this.keepLevel || keepInventory) {
-            exp = this.exp;
-            this.newTotalExp = this.expTotal;
-            this.newLevel = this.expLevel;
-        }
-
-        this.setHealth(this.getMaxHealth());
-        this.fireTicks = 0;
-        this.fallDistance = 0;
-        this.foodData = new FoodMetaData(this);
-        this.expLevel = this.newLevel;
-        this.expTotal = this.newTotalExp;
-        this.exp = 0;
-        this.deathTicks = 0;
-        this.removeAllEffects();
-        this.updateEffects = true;
-        this.activeContainer = this.defaultContainer;
-        this.killer = null;
-        this.lastDamager = null;
-        this.combatTracker = new CombatTracker(this);
-        this.lastSentExp = -1;
-        if (this.keepLevel || keepInventory) {
-            this.exp = exp;
-        } else {
-            this.giveExp(this.newExp);
-        }
-        this.keepLevel = false;
-    }
-
-    @Override
-    public CraftPlayer getBukkitEntity() {
-        return (CraftPlayer) super.getBukkitEntity();
-    }
-    // CraftBukkit end
-}
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+import com.mojang.authlib.GameProfile;
+import io.netty.buffer.Unpooled;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import javax.annotation.Nullable;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+// CraftBukkit start
+import org.bukkit.Bukkit;
+import org.bukkit.WeatherType;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.event.inventory.InventoryType;
+import org.bukkit.event.player.PlayerChangedMainHandEvent;
+import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
+import org.bukkit.inventory.MainHand;
+// CraftBukkit end
+
+public class EntityPlayer extends EntityHuman implements ICrafting {
+
+    private static final Logger bS = LogManager.getLogger();
+    public String locale = "en_US"; // Spigot private -> public
+    public PlayerConnection playerConnection;
+    public final MinecraftServer server;
+    public final PlayerInteractManager playerInteractManager;
+    public double d;
+    public double e;
+    //public final List<Integer> removeQueue = Lists.newLinkedList();
+    public final List<Integer> removeQueue = Collections.synchronizedList(Lists.newLinkedList());
+    private final ServerStatisticManager bV;
+    private float bW = Float.MIN_VALUE;
+    private int bX = Integer.MIN_VALUE;
+    private int bY = Integer.MIN_VALUE;
+    private int bZ = Integer.MIN_VALUE;
+    private int ca = Integer.MIN_VALUE;
+    private int cb = Integer.MIN_VALUE;
+    private float lastHealthSent = -1.0E8F;
+    private int cd = -99999999;
+    private boolean ce = true;
+    public int lastSentExp = -99999999;
+    public int invulnerableTicks = 60;
+    private EntityHuman.EnumChatVisibility ch;
+    private boolean ci = true;
+    private long cj = System.currentTimeMillis();
+    private Entity ck;
+    public boolean worldChangeInvuln;
+    private int containerCounter;
+    public boolean f;
+    public int ping;
+    public boolean viewingCredits;
+
+    // CraftBukkit start
+    public String displayName;
+    public IChatBaseComponent listName;
+    public org.bukkit.Location compassTarget;
+    public int newExp = 0;
+    public int newLevel = 0;
+    public int newTotalExp = 0;
+    public boolean keepLevel = false;
+    public double maxHealthCache;
+    public boolean joining = true;
+    // CraftBukkit end
+
+    public EntityPlayer(MinecraftServer minecraftserver, WorldServer worldserver, GameProfile gameprofile, PlayerInteractManager playerinteractmanager) {
+        super(worldserver, gameprofile);
+        playerinteractmanager.player = this;
+        this.playerInteractManager = playerinteractmanager;
+        BlockPosition blockposition = worldserver.getSpawn();
+
+        if (!worldserver.worldProvider.m() && worldserver.getWorldData().getGameType() != EnumGamemode.ADVENTURE) {
+            int i = Math.max(0, minecraftserver.a(worldserver));
+            int j = MathHelper.floor(worldserver.getWorldBorder().b((double) blockposition.getX(), (double) blockposition.getZ()));
+
+            if (j < i) {
+                i = j;
+            }
+
+            if (j <= 1) {
+                i = 1;
+            }
+
+            blockposition = worldserver.q(blockposition.a(this.random.nextInt(i * 2 + 1) - i, 0, this.random.nextInt(i * 2 + 1) - i));
+        }
+
+        this.server = minecraftserver;
+        this.bV = minecraftserver.getPlayerList().a((EntityHuman) this);
+        this.P = 0.0F;
+        this.setPositionRotation(blockposition, 0.0F, 0.0F);
+
+        while (!worldserver.getCubes(this, this.getBoundingBox()).isEmpty() && this.locY < 255.0D) {
+            this.setPosition(this.locX, this.locY + 1.0D, this.locZ);
+        }
+
+        // CraftBukkit start
+        this.displayName = this.getName();
+        // this.canPickUpLoot = true; TODO
+        this.maxHealthCache = this.getMaxHealth();
+        // CraftBukkit end
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        super.a(nbttagcompound);
+        if (nbttagcompound.hasKeyOfType("playerGameType", 99)) {
+            if (this.h().getForceGamemode()) {
+                this.playerInteractManager.setGameMode(this.h().getGamemode());
+            } else {
+                this.playerInteractManager.setGameMode(EnumGamemode.getById(nbttagcompound.getInt("playerGameType")));
+            }
+        }
+
+        this.getBukkitEntity().readExtraData(nbttagcompound); // CraftBukkit
+    }
+
+    public void b(NBTTagCompound nbttagcompound) {
+        super.b(nbttagcompound);
+        nbttagcompound.setInt("playerGameType", this.playerInteractManager.getGameMode().getId());
+        Entity entity = this.getVehicle();
+
+        if (this.bB() != null && entity != this & entity.b(EntityPlayer.class).size() == 1) {
+            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+            NBTTagCompound nbttagcompound2 = new NBTTagCompound();
+
+            entity.d(nbttagcompound2);
+            nbttagcompound1.a("Attach", this.bB().getUniqueID());
+            nbttagcompound1.set("Entity", nbttagcompound2);
+            nbttagcompound.set("RootVehicle", nbttagcompound1);
+        }
+		this.getBukkitEntity().setExtraData(nbttagcompound); // CraftBukkit
+    }
+
+    // CraftBukkit start - World fallback code, either respawn location or global spawn
+    public void spawnIn(World world) {
+        super.spawnIn(world);
+        if (world == null) {
+            this.dead = false;
+            BlockPosition position = null;
+            if (this.spawnWorld != null && !this.spawnWorld.equals("")) {
+                CraftWorld cworld = (CraftWorld) Bukkit.getServer().getWorld(this.spawnWorld);
+                if (cworld != null && this.getBed() != null) {
+                    world = cworld.getHandle();
+                    position = EntityHuman.getBed(cworld.getHandle(), this.getBed(), false);
+                }
+            }
+            if (world == null || position == null) {
+                world = ((CraftWorld) Bukkit.getServer().getWorlds().get(0)).getHandle();
+                position = world.getSpawn();
+            }
+            this.world = world;
+            this.setPosition(position.getX() + 0.5, position.getY(), position.getZ() + 0.5);
+        }
+        this.dimension = ((WorldServer) this.world).dimension;
+        this.playerInteractManager.a((WorldServer) world);
+    }
+    // CraftBukkit end
+
+    public void levelDown(int i) {
+        super.levelDown(i);
+        this.lastSentExp = -1;
+    }
+
+    public void enchantDone(int i) {
+        super.enchantDone(i);
+        this.lastSentExp = -1;
+    }
+
+    public void syncInventory() {
+        this.activeContainer.addSlotListener(this);
+    }
+
+    public void enterCombat() {
+        super.enterCombat();
+        this.playerConnection.sendPacket(new PacketPlayOutCombatEvent(this.getCombatTracker(), PacketPlayOutCombatEvent.EnumCombatEventType.ENTER_COMBAT));
+    }
+
+    public void exitCombat() {
+        super.exitCombat();
+        this.playerConnection.sendPacket(new PacketPlayOutCombatEvent(this.getCombatTracker(), PacketPlayOutCombatEvent.EnumCombatEventType.END_COMBAT));
+    }
+
+    protected ItemCooldown l() {
+        return new ItemCooldownPlayer(this);
+    }
+
+    public void m() {
+        // CraftBukkit start
+        if (this.joining) {
+            this.joining = false;
+        }
+        // CraftBukkit end
+        this.playerInteractManager.a();
+        --this.invulnerableTicks;
+        if (this.noDamageTicks > 0) {
+            --this.noDamageTicks;
+        }
+
+        this.activeContainer.b();
+        if (!this.world.isClientSide && !this.activeContainer.a((EntityHuman) this)) {
+            this.closeInventory();
+            this.activeContainer = this.defaultContainer;
+        }
+
+        while (!this.removeQueue.isEmpty()) {
+            int i = Math.min(this.removeQueue.size(), Integer.MAX_VALUE);
+            int[] aint = new int[i];
+            synchronized (this.removeQueue) {
+                Iterator iterator = this.removeQueue.iterator();
+                int j = 0;
+
+                while (iterator.hasNext() && j < i) {
+                    aint[j++] = ((Integer) iterator.next()).intValue();
+                    iterator.remove();
+                }
+            }
+
+            this.playerConnection.sendPacket(new PacketPlayOutEntityDestroy(aint));
+        }
+
+        Entity entity = this.getSpecatorTarget();
+
+        if (entity != this) {
+            if (entity.isAlive()) {
+                this.setLocation(entity.locX, entity.locY, entity.locZ, entity.yaw, entity.pitch);
+                this.server.getPlayerList().d(this);
+                if (this.isSneaking()) {
+                    this.setSpectatorTarget(this);
+                }
+            } else {
+                this.setSpectatorTarget(this);
+            }
+        }
+
+    }
+
+    public void k_() {
+        try {
+            super.m();
+
+            for (int i = 0; i < this.inventory.getSize(); ++i) {
+                ItemStack itemstack = this.inventory.getItem(i);
+
+                if (itemstack != null && itemstack.getItem().f()) {
+                    Packet packet = ((ItemWorldMapBase) itemstack.getItem()).a(itemstack, this.world, (EntityHuman) this);
+
+                    if (packet != null) {
+                        this.playerConnection.sendPacket(packet);
+                    }
+                }
+            }
+
+            if (this.getHealth() != this.lastHealthSent || this.cd != this.foodData.getFoodLevel() || this.foodData.getSaturationLevel() == 0.0F != this.ce) {
+                this.playerConnection.sendPacket(new PacketPlayOutUpdateHealth(this.getBukkitEntity().getScaledHealth(), this.foodData.getFoodLevel(), this.foodData.getSaturationLevel())); // CraftBukkit
+                this.lastHealthSent = this.getHealth();
+                this.cd = this.foodData.getFoodLevel();
+                this.ce = this.foodData.getSaturationLevel() == 0.0F;
+            }
+
+            if (this.getHealth() + this.getAbsorptionHearts() != this.bW) {
+                this.bW = this.getHealth() + this.getAbsorptionHearts();
+                this.a(IScoreboardCriteria.g, MathHelper.f(this.bW));
+            }
+
+            if (this.foodData.getFoodLevel() != this.bX) {
+                this.bX = this.foodData.getFoodLevel();
+                this.a(IScoreboardCriteria.h, MathHelper.f((float) this.bX));
+            }
+
+            if (this.getAirTicks() != this.bY) {
+                this.bY = this.getAirTicks();
+                this.a(IScoreboardCriteria.i, MathHelper.f((float) this.bY));
+            }
+
+            // CraftBukkit start - Force max health updates
+            if (this.maxHealthCache != this.getMaxHealth()) {
+                this.getBukkitEntity().updateScaledHealth();
+            }
+            // CraftBukkit end
+
+            if (this.getArmorStrength() != this.bZ) {
+                this.bZ = this.getArmorStrength();
+                this.a(IScoreboardCriteria.j, MathHelper.f((float) this.bZ));
+            }
+
+            if (this.expTotal != this.cb) {
+                this.cb = this.expTotal;
+                this.a(IScoreboardCriteria.k, MathHelper.f((float) this.cb));
+            }
+
+            if (this.expLevel != this.ca) {
+                this.ca = this.expLevel;
+                this.a(IScoreboardCriteria.l, MathHelper.f((float) this.ca));
+            }
+
+            if (this.expTotal != this.lastSentExp) {
+                this.lastSentExp = this.expTotal;
+                this.playerConnection.sendPacket(new PacketPlayOutExperience(this.exp, this.expTotal, this.expLevel));
+            }
+
+            if (this.ticksLived % 20 * 5 == 0 && !this.getStatisticManager().hasAchievement(AchievementList.L)) {
+                this.o();
+            }
+
+            // CraftBukkit start - initialize oldLevel and fire PlayerLevelChangeEvent
+            if (this.oldLevel == -1) {
+                this.oldLevel = this.expLevel;
+            }
+
+            if (this.oldLevel != this.expLevel) {
+                CraftEventFactory.callPlayerLevelChangeEvent(this.world.getServer().getPlayer((EntityPlayer) this), this.oldLevel, this.expLevel);
+                this.oldLevel = this.expLevel;
+            }
+            // CraftBukkit end
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.a(throwable, "Ticking player");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Player being ticked");
+
+            this.appendEntityCrashDetails(crashreportsystemdetails);
+            throw new ReportedException(crashreport);
+        }
+    }
+
+    private void a(IScoreboardCriteria iscoreboardcriteria, int i) {
+        Collection collection = this.world.getServer().getScoreboardManager().getScoreboardScores(iscoreboardcriteria, this.getName(), new java.util.ArrayList<ScoreboardScore>()); // CraftBukkit - Use our scores instead
+        Iterator iterator = collection.iterator();
+
+        while (iterator.hasNext()) {
+            ScoreboardScore scoreboardscore = (ScoreboardScore) iterator.next(); // CraftBukkit - Use our scores instead
+
+            scoreboardscore.setScore(i);
+        }
+
+    }
+
+    protected void o() {
+        BiomeBase biomebase = this.world.getBiome(new BlockPosition(MathHelper.floor(this.locX), 0, MathHelper.floor(this.locZ)));
+        String s = biomebase.l();
+        AchievementSet achievementset = (AchievementSet) this.getStatisticManager().b((Statistic) AchievementList.L);
+
+        if (achievementset == null) {
+            achievementset = (AchievementSet) this.getStatisticManager().a(AchievementList.L, new AchievementSet());
+        }
+
+        achievementset.add(s);
+        if (this.getStatisticManager().b(AchievementList.L) && achievementset.size() >= BiomeBase.i.size()) {
+            HashSet hashset = Sets.newHashSet(BiomeBase.i);
+            Iterator iterator = achievementset.iterator();
+
+            while (iterator.hasNext()) {
+                String s1 = (String) iterator.next();
+                Iterator iterator1 = hashset.iterator();
+
+                while (iterator1.hasNext()) {
+                    BiomeBase biomebase1 = (BiomeBase) iterator1.next();
+
+                    if (biomebase1.l().equals(s1)) {
+                        iterator1.remove();
+                    }
+                }
+
+                if (hashset.isEmpty()) {
+                    break;
+                }
+            }
+
+            if (hashset.isEmpty()) {
+                this.b((Statistic) AchievementList.L);
+            }
+        }
+
+    }
+
+    public void die(DamageSource damagesource) {
+        boolean flag = this.world.getGameRules().getBoolean("showDeathMessages");
+
+        this.playerConnection.sendPacket(new PacketPlayOutCombatEvent(this.getCombatTracker(), PacketPlayOutCombatEvent.EnumCombatEventType.ENTITY_DIED, flag));
+        // CraftBukkit start - fire PlayerDeathEvent
+        if (this.dead) {
+            return;
+        }
+        java.util.List<org.bukkit.inventory.ItemStack> loot = new java.util.ArrayList<org.bukkit.inventory.ItemStack>();
+        boolean keepInventory = this.world.getGameRules().getBoolean("keepInventory");
+
+        if (!keepInventory) {
+            for (int i = 0; i < this.inventory.items.length; ++i) {
+                if (this.inventory.items[i] != null) {
+                    loot.add(CraftItemStack.asCraftMirror(this.inventory.items[i]));
+                }
+            }
+            for (int i = 0; i < this.inventory.armor.length; ++i) {
+                if (this.inventory.armor[i] != null) {
+                    loot.add(CraftItemStack.asCraftMirror(this.inventory.armor[i]));
+                }
+            }
+            for (int i = 0; i < this.inventory.extraSlots.length; ++i) {
+                if (this.inventory.extraSlots[i] != null) {
+                    loot.add(CraftItemStack.asCraftMirror(this.inventory.extraSlots[i]));
+                }
+            }
+        }
+
+        IChatBaseComponent chatmessage = this.getCombatTracker().getDeathMessage();
+
+        String deathmessage = chatmessage.toPlainText();
+        org.bukkit.event.entity.PlayerDeathEvent event = CraftEventFactory.callPlayerDeathEvent(this, loot, deathmessage, keepInventory);
+
+        String deathMessage = event.getDeathMessage();
+
+        if (deathMessage != null && deathMessage.length() > 0 && flag) { // TODO: allow plugins to override?
+            if (deathMessage.equals(deathmessage)) {
+                ScoreboardTeamBase scoreboardteambase = this.aQ();
+
+                if (scoreboardteambase != null && scoreboardteambase.getDeathMessageVisibility() != ScoreboardTeamBase.EnumNameTagVisibility.ALWAYS) {
+                    if (scoreboardteambase.getDeathMessageVisibility() == ScoreboardTeamBase.EnumNameTagVisibility.HIDE_FOR_OTHER_TEAMS) {
+                        this.server.getPlayerList().a((EntityHuman) this, chatmessage);
+                    } else if (scoreboardteambase.getDeathMessageVisibility() == ScoreboardTeamBase.EnumNameTagVisibility.HIDE_FOR_OWN_TEAM) {
+                        this.server.getPlayerList().b((EntityHuman) this, chatmessage);
+                    }
+                } else {
+                    this.server.getPlayerList().sendMessage(chatmessage);
+                }
+            } else {
+                this.server.getPlayerList().sendMessage(org.bukkit.craftbukkit.util.CraftChatMessage.fromString(deathMessage));
+            }
+        }
+
+        // we clean the player's inventory after the EntityDeathEvent is called so plugins can get the exact state of the inventory.
+        if (!event.getKeepInventory()) {
+            for (int i = 0; i < this.inventory.items.length; ++i) {
+                this.inventory.items[i] = null;
+            }
+            for (int i = 0; i < this.inventory.armor.length; ++i) {
+                this.inventory.armor[i] = null;
+            }
+            for (int i = 0; i < this.inventory.extraSlots.length; ++i) {
+                this.inventory.extraSlots[i] = null;
+            }
+        }
+
+        this.closeInventory();
+        this.setSpectatorTarget(this); // Remove spectated target
+        // CraftBukkit end
+
+        // CraftBukkit - Get our scores instead
+        Collection collection = this.world.getServer().getScoreboardManager().getScoreboardScores(IScoreboardCriteria.d, this.getName(), new java.util.ArrayList<ScoreboardScore>());
+        Iterator iterator = collection.iterator();
+
+        while (iterator.hasNext()) {
+            ScoreboardScore scoreboardscore = (ScoreboardScore) iterator.next(); // CraftBukkit - Use our scores instead
+
+            scoreboardscore.incrementScore();
+        }
+
+        EntityLiving entityliving = this.bZ();
+
+        if (entityliving != null) {
+            EntityTypes.MonsterEggInfo entitytypes_monsteregginfo = (EntityTypes.MonsterEggInfo) EntityTypes.eggInfo.get(EntityTypes.b((Entity) entityliving));
+
+            if (entitytypes_monsteregginfo != null) {
+                this.b(entitytypes_monsteregginfo.killedByEntityStatistic);
+            }
+
+            entityliving.b(this, this.bc);
+        }
+
+        this.b(StatisticList.A);
+        this.a(StatisticList.h);
+        this.getCombatTracker().g();
+    }
+
+    public boolean damageEntity(DamageSource damagesource, float f) {
+        if (this.isInvulnerable(damagesource)) {
+            return false;
+        } else {
+            boolean flag = this.server.aa() && this.canPvP() && "fall".equals(damagesource.translationIndex);
+
+            if (!flag && this.invulnerableTicks > 0 && damagesource != DamageSource.OUT_OF_WORLD) {
+                return false;
+            } else {
+                if (damagesource instanceof EntityDamageSource) {
+                    Entity entity = damagesource.getEntity();
+
+                    if (entity instanceof EntityHuman && !this.a((EntityHuman) entity)) {
+                        return false;
+                    }
+
+                    if (entity instanceof EntityArrow) {
+                        EntityArrow entityarrow = (EntityArrow) entity;
+
+                        if (entityarrow.shooter instanceof EntityHuman && !this.a((EntityHuman) entityarrow.shooter)) {
+                            return false;
+                        }
+                    }
+                }
+
+                return super.damageEntity(damagesource, f);
+            }
+        }
+    }
+
+    public boolean a(EntityHuman entityhuman) {
+        return !this.canPvP() ? false : super.a(entityhuman);
+    }
+
+    private boolean canPvP() {
+        // CraftBukkit - this.server.getPvP() -> this.world.pvpMode
+        return this.world.pvpMode;
+    }
+
+    @Nullable
+    public Entity c(int i) {
+        // this.worldChangeInvuln = true; // CraftBukkit - Moved down and into PlayerList#changeDimension
+        if (this.dimension == 1 && i == 1) {
+            this.worldChangeInvuln = true; // CraftBukkit - Moved down from above
+            this.world.kill(this);
+            if (!this.viewingCredits) {
+                this.viewingCredits = true;
+                if (this.a(AchievementList.D)) {
+                    this.playerConnection.sendPacket(new PacketPlayOutGameStateChange(4, 0.0F));
+                } else {
+                    this.b((Statistic) AchievementList.D);
+                    this.playerConnection.sendPacket(new PacketPlayOutGameStateChange(4, 1.0F));
+                }
+            }
+
+            return this;
+        } else {
+            if (this.dimension == 0 && i == 1) {
+                this.b((Statistic) AchievementList.C);
+                i = 1;
+            } else {
+                this.b((Statistic) AchievementList.y);
+            }
+
+            // CraftBukkit start
+            TeleportCause cause = (this.dimension == 1 || i == 1) ? TeleportCause.END_PORTAL : TeleportCause.NETHER_PORTAL;
+            this.server.getPlayerList().changeDimension(this, i, cause); // PAIL: check all this
+            // CraftBukkit end
+            this.playerConnection.sendPacket(new PacketPlayOutWorldEvent(1032, BlockPosition.ZERO, 0, false));
+            this.lastSentExp = -1;
+            this.lastHealthSent = -1.0F;
+            this.cd = -1;
+            return this;
+        }
+    }
+
+    public boolean a(EntityPlayer entityplayer) {
+        return entityplayer.isSpectator() ? this.getSpecatorTarget() == this : (this.isSpectator() ? false : super.a(entityplayer));
+    }
+
+    private void a(TileEntity tileentity) {
+        if (tileentity != null) {
+            PacketPlayOutTileEntityData packetplayouttileentitydata = tileentity.getUpdatePacket();
+
+            if (packetplayouttileentitydata != null) {
+                this.playerConnection.sendPacket(packetplayouttileentitydata);
+            }
+        }
+
+    }
+
+    public void receive(Entity entity, int i) {
+        super.receive(entity, i);
+        this.activeContainer.b();
+    }
+
+    public EntityHuman.EnumBedResult a(BlockPosition blockposition) {
+        EntityHuman.EnumBedResult entityhuman_enumbedresult = super.a(blockposition);
+
+        if (entityhuman_enumbedresult == EntityHuman.EnumBedResult.OK) {
+            this.b(StatisticList.ad);
+            PacketPlayOutBed packetplayoutbed = new PacketPlayOutBed(this, blockposition);
+
+            this.x().getTracker().a((Entity) this, (Packet) packetplayoutbed);
+            this.playerConnection.a(this.locX, this.locY, this.locZ, this.yaw, this.pitch);
+            this.playerConnection.sendPacket(packetplayoutbed);
+        }
+
+        return entityhuman_enumbedresult;
+    }
+
+    public void a(boolean flag, boolean flag1, boolean flag2) {
+        if (!this.sleeping) return; // CraftBukkit - Can't leave bed if not in one!
+        if (this.isSleeping()) {
+            this.x().getTracker().sendPacketToEntity(this, new PacketPlayOutAnimation(this, 2));
+        }
+
+        super.a(flag, flag1, flag2);
+        if (this.playerConnection != null) {
+            this.playerConnection.a(this.locX, this.locY, this.locZ, this.yaw, this.pitch);
+        }
+
+    }
+
+    public boolean a(Entity entity, boolean flag) {
+        Entity entity1 = this.bB();
+
+        if (!super.a(entity, flag)) {
+            return false;
+        } else {
+            Entity entity2 = this.bB();
+
+            if (entity2 != entity1 && this.playerConnection != null) {
+                this.playerConnection.a(this.locX, this.locY, this.locZ, this.yaw, this.pitch);
+            }
+
+            return true;
+        }
+    }
+
+    public void stopRiding() {
+        Entity entity = this.bB();
+
+        super.stopRiding();
+        Entity entity1 = this.bB();
+
+        if (entity1 != entity && this.playerConnection != null) {
+            this.playerConnection.a(this.locX, this.locY, this.locZ, this.yaw, this.pitch);
+        }
+
+    }
+
+    public boolean isInvulnerable(DamageSource damagesource) {
+        return super.isInvulnerable(damagesource) || this.K();
+    }
+
+    protected void a(double d0, boolean flag, IBlockData iblockdata, BlockPosition blockposition) {}
+
+    protected void b(BlockPosition blockposition) {
+        if (!this.isSpectator()) {
+            super.b(blockposition);
+        }
+
+    }
+
+    public void a(double d0, boolean flag) {
+        int i = MathHelper.floor(this.locX);
+        int j = MathHelper.floor(this.locY - 0.20000000298023224D);
+        int k = MathHelper.floor(this.locZ);
+        BlockPosition blockposition = new BlockPosition(i, j, k);
+        IBlockData iblockdata = this.world.getType(blockposition);
+
+        if (iblockdata.getMaterial() == Material.AIR) {
+            BlockPosition blockposition1 = blockposition.down();
+            IBlockData iblockdata1 = this.world.getType(blockposition1);
+            Block block = iblockdata1.getBlock();
+
+            if (block instanceof BlockFence || block instanceof BlockCobbleWall || block instanceof BlockFenceGate) {
+                blockposition = blockposition1;
+                iblockdata = iblockdata1;
+            }
+        }
+
+        super.a(d0, flag, iblockdata, blockposition);
+    }
+
+    public void openSign(TileEntitySign tileentitysign) {
+        tileentitysign.a((EntityHuman) this);
+        this.playerConnection.sendPacket(new PacketPlayOutOpenSignEditor(tileentitysign.getPosition()));
+    }
+
+    public int nextContainerCounter() { // CraftBukkit - void -> int
+        this.containerCounter = this.containerCounter % 100 + 1;
+        return containerCounter; // CraftBukkit
+    }
+
+    public void openTileEntity(ITileEntityContainer itileentitycontainer) {
+        // CraftBukkit start - Inventory open hook
+        Container container = CraftEventFactory.callInventoryOpenEvent(this, itileentitycontainer.createContainer(this.inventory, this));
+        if (container == null) {
+            return;
+        }
+
+        this.nextContainerCounter();
+        this.activeContainer = container;
+        this.playerConnection.sendPacket(new PacketPlayOutOpenWindow(this.containerCounter, itileentitycontainer.getContainerName(), itileentitycontainer.getScoreboardDisplayName()));
+        // CraftBukkit end
+        this.activeContainer.windowId = this.containerCounter;
+        this.activeContainer.addSlotListener(this);
+    }
+
+    public void openContainer(IInventory iinventory) {
+        // CraftBukkit start - Inventory open hook
+        // Copied from below
+        boolean cancelled = false;
+        if (iinventory instanceof ITileInventory) {
+            ITileInventory itileinventory = (ITileInventory) iinventory;
+            cancelled = itileinventory.x_() && !this.a(itileinventory.y_()) && !this.isSpectator(); // PAIL: rename
+        }
+
+        Container container;
+        if (iinventory instanceof ITileEntityContainer) {
+            container = ((ITileEntityContainer) iinventory).createContainer(this.inventory, this);
+        } else {
+            container = new ContainerChest(this.inventory, iinventory, this);
+        }
+        container = CraftEventFactory.callInventoryOpenEvent(this, container, cancelled);
+        if (container == null && !cancelled) { // Let pre-cancelled events fall through
+            iinventory.closeContainer(this);
+            return;
+        }
+        // CraftBukkit end
+
+        if (iinventory instanceof ILootable && ((ILootable) iinventory).b() != null && this.isSpectator()) {
+            this.sendMessage((new ChatMessage("container.spectatorCantOpen", new Object[0])).setChatModifier((new ChatModifier()).setColor(EnumChatFormat.RED)));
+        } else {
+            if (this.activeContainer != this.defaultContainer) {
+                this.closeInventory();
+            }
+
+            if (iinventory instanceof ITileInventory) {
+                ITileInventory itileinventory = (ITileInventory) iinventory;
+
+                if (itileinventory.x_() && !this.a(itileinventory.y_()) && !this.isSpectator()) {
+                    this.playerConnection.sendPacket(new PacketPlayOutChat(new ChatMessage("container.isLocked", new Object[] { iinventory.getScoreboardDisplayName()}), (byte) 2));
+                    this.playerConnection.sendPacket(new PacketPlayOutNamedSoundEffect(SoundEffects.W, SoundCategory.BLOCKS, this.locX, this.locY, this.locZ, 1.0F, 1.0F));
+                    iinventory.closeContainer(this); // CraftBukkit
+                    return;
+                }
+            }
+
+            this.nextContainerCounter();
+            // CraftBukkit start
+            if (iinventory instanceof ITileEntityContainer) {
+                this.activeContainer = container;
+                this.playerConnection.sendPacket(new PacketPlayOutOpenWindow(this.containerCounter, ((ITileEntityContainer) iinventory).getContainerName(), iinventory.getScoreboardDisplayName(), iinventory.getSize()));
+            } else {
+                this.activeContainer = container;
+                this.playerConnection.sendPacket(new PacketPlayOutOpenWindow(this.containerCounter, "minecraft:container", iinventory.getScoreboardDisplayName(), iinventory.getSize()));
+            }
+            // CraftBukkit end
+
+            this.activeContainer.windowId = this.containerCounter;
+            this.activeContainer.addSlotListener(this);
+        }
+    }
+
+    public void openTrade(IMerchant imerchant) {
+        // CraftBukkit start - Inventory open hook
+        Container container = CraftEventFactory.callInventoryOpenEvent(this, new ContainerMerchant(this.inventory, imerchant, this.world));
+        if (container == null) {
+            return;
+        }
+        // CraftBukkit end
+        this.nextContainerCounter();
+        this.activeContainer = container; // CraftBukkit
+        this.activeContainer.windowId = this.containerCounter;
+        this.activeContainer.addSlotListener(this);
+        InventoryMerchant inventorymerchant = ((ContainerMerchant) this.activeContainer).e();
+        IChatBaseComponent ichatbasecomponent = imerchant.getScoreboardDisplayName();
+
+        this.playerConnection.sendPacket(new PacketPlayOutOpenWindow(this.containerCounter, "minecraft:villager", ichatbasecomponent, inventorymerchant.getSize()));
+        MerchantRecipeList merchantrecipelist = imerchant.getOffers(this);
+
+        if (merchantrecipelist != null) {
+            PacketDataSerializer packetdataserializer = new PacketDataSerializer(Unpooled.buffer());
+
+            packetdataserializer.writeInt(this.containerCounter);
+            merchantrecipelist.a(packetdataserializer);
+            this.playerConnection.sendPacket(new PacketPlayOutCustomPayload("MC|TrList", packetdataserializer));
+        }
+
+    }
+
+    public void a(EntityHorse entityhorse, IInventory iinventory) {
+        // CraftBukkit start - Inventory open hook
+        Container container = CraftEventFactory.callInventoryOpenEvent(this, new ContainerHorse(this.inventory, iinventory, entityhorse, this));
+        if (container == null) {
+            iinventory.closeContainer(this);
+            return;
+        }
+        // CraftBukkit end
+        if (this.activeContainer != this.defaultContainer) {
+            this.closeInventory();
+        }
+
+        this.nextContainerCounter();
+        this.playerConnection.sendPacket(new PacketPlayOutOpenWindow(this.containerCounter, "EntityHorse", iinventory.getScoreboardDisplayName(), iinventory.getSize(), entityhorse.getId()));
+        this.activeContainer = container;
+        this.activeContainer.windowId = this.containerCounter;
+        this.activeContainer.addSlotListener(this);
+    }
+
+    public void a(ItemStack itemstack, EnumHand enumhand) {
+        Item item = itemstack.getItem();
+
+        if (item == Items.WRITTEN_BOOK) {
+            PacketDataSerializer packetdataserializer = new PacketDataSerializer(Unpooled.buffer());
+
+            packetdataserializer.a((Enum) enumhand);
+            this.playerConnection.sendPacket(new PacketPlayOutCustomPayload("MC|BOpen", packetdataserializer));
+        }
+
+    }
+
+    public void a(TileEntityCommand tileentitycommand) {
+        tileentitycommand.d(true);
+        this.a((TileEntity) tileentitycommand);
+    }
+
+    public void a(Container container, int i, ItemStack itemstack) {
+        if (!(container.getSlot(i) instanceof SlotResult)) {
+            if (!this.f) {
+                this.playerConnection.sendPacket(new PacketPlayOutSetSlot(container.windowId, i, itemstack));
+            }
+        }
+    }
+
+    public void updateInventory(Container container) {
+        this.a(container, container.a());
+    }
+
+    public void a(Container container, List<ItemStack> list) {
+        this.playerConnection.sendPacket(new PacketPlayOutWindowItems(container.windowId, list));
+        this.playerConnection.sendPacket(new PacketPlayOutSetSlot(-1, -1, this.inventory.getCarried()));
+        // CraftBukkit start - Send a Set Slot to update the crafting result slot
+        if (java.util.EnumSet.of(InventoryType.CRAFTING,InventoryType.WORKBENCH).contains(container.getBukkitView().getType())) {
+            this.playerConnection.sendPacket(new PacketPlayOutSetSlot(container.windowId, 0, container.getSlot(0).getItem()));
+        }
+        // CraftBukkit end
+    }
+
+    public void setContainerData(Container container, int i, int j) {
+        this.playerConnection.sendPacket(new PacketPlayOutWindowData(container.windowId, i, j));
+    }
+
+    public void setContainerData(Container container, IInventory iinventory) {
+        for (int i = 0; i < iinventory.g(); ++i) {
+            this.playerConnection.sendPacket(new PacketPlayOutWindowData(container.windowId, i, iinventory.getProperty(i)));
+        }
+
+    }
+
+    public void closeInventory() {
+        CraftEventFactory.handleInventoryCloseEvent(this); // CraftBukkit
+        this.playerConnection.sendPacket(new PacketPlayOutCloseWindow(this.activeContainer.windowId));
+        this.s();
+    }
+
+    public void broadcastCarriedItem() {
+        if (!this.f) {
+            this.playerConnection.sendPacket(new PacketPlayOutSetSlot(-1, -1, this.inventory.getCarried()));
+        }
+    }
+
+    public void s() {
+        this.activeContainer.b((EntityHuman) this);
+        this.activeContainer = this.defaultContainer;
+    }
+
+    public void a(float f, float f1, boolean flag, boolean flag1) {
+        if (this.isPassenger()) {
+            if (f >= -1.0F && f <= 1.0F) {
+                this.bf = f;
+            }
+
+            if (f1 >= -1.0F && f1 <= 1.0F) {
+                this.bg = f1;
+            }
+
+            this.be = flag;
+            this.setSneaking(flag1);
+        }
+
+    }
+
+    public boolean a(Achievement achievement) {
+        return this.bV.hasAchievement(achievement);
+    }
+
+    public void a(Statistic statistic, int i) {
+        if (statistic != null) {
+            this.bV.b(this, statistic, i);
+            Iterator iterator = this.getScoreboard().getObjectivesForCriteria(statistic.k()).iterator();
+
+            while (iterator.hasNext()) {
+                ScoreboardObjective scoreboardobjective = (ScoreboardObjective) iterator.next();
+
+                this.getScoreboard().getPlayerScoreForObjective(this.getName(), scoreboardobjective).addScore(i);
+            }
+
+            if (this.bV.e()) {
+                this.bV.a(this);
+            }
+
+        }
+    }
+
+    public void a(Statistic statistic) {
+        if (statistic != null) {
+            this.bV.setStatistic(this, statistic, 0);
+            Iterator iterator = this.getScoreboard().getObjectivesForCriteria(statistic.k()).iterator();
+
+            while (iterator.hasNext()) {
+                ScoreboardObjective scoreboardobjective = (ScoreboardObjective) iterator.next();
+
+                this.getScoreboard().getPlayerScoreForObjective(this.getName(), scoreboardobjective).setScore(0);
+            }
+
+            if (this.bV.e()) {
+                this.bV.a(this);
+            }
+
+        }
+    }
+
+    public void t() {
+        this.az();
+        if (this.sleeping) {
+            this.a(true, false, false);
+        }
+
+    }
+
+    public void triggerHealthUpdate() {
+        this.lastHealthSent = -1.0E8F;
+        this.lastSentExp = -1; // CraftBukkit - Added to reset
+    }
+
+    // CraftBukkit start - Support multi-line messages
+    public void sendMessage(IChatBaseComponent[] ichatbasecomponent) {
+        for (IChatBaseComponent component : ichatbasecomponent) {
+            this.sendMessage(component);
+        }
+    }
+    // CraftBukkit end
+
+    public void b(IChatBaseComponent ichatbasecomponent) {
+        this.playerConnection.sendPacket(new PacketPlayOutChat(ichatbasecomponent));
+    }
+
+    protected void v() {
+        if (this.bo != null && this.cx()) {
+            this.playerConnection.sendPacket(new PacketPlayOutEntityStatus(this, (byte) 9));
+            super.v();
+        }
+
+    }
+
+    public void copyTo(EntityHuman entityhuman, boolean flag) {
+        super.copyTo(entityhuman, flag);
+        this.lastSentExp = -1;
+        this.lastHealthSent = -1.0F;
+        this.cd = -1;
+        this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
+    }
+
+    protected void a(MobEffect mobeffect) {
+        super.a(mobeffect);
+        this.playerConnection.sendPacket(new PacketPlayOutEntityEffect(this.getId(), mobeffect));
+    }
+
+    protected void a(MobEffect mobeffect, boolean flag) {
+        super.a(mobeffect, flag);
+        this.playerConnection.sendPacket(new PacketPlayOutEntityEffect(this.getId(), mobeffect));
+    }
+
+    protected void b(MobEffect mobeffect) {
+        super.b(mobeffect);
+        this.playerConnection.sendPacket(new PacketPlayOutRemoveEntityEffect(this.getId(), mobeffect.getMobEffect()));
+    }
+
+    public void enderTeleportTo(double d0, double d1, double d2) {
+        this.playerConnection.a(d0, d1, d2, this.yaw, this.pitch);
+    }
+
+    public void a(Entity entity) {
+        this.x().getTracker().sendPacketToEntity(this, new PacketPlayOutAnimation(entity, 4));
+    }
+
+    public void b(Entity entity) {
+        this.x().getTracker().sendPacketToEntity(this, new PacketPlayOutAnimation(entity, 5));
+    }
+
+    public void updateAbilities() {
+        if (this.playerConnection != null) {
+            this.playerConnection.sendPacket(new PacketPlayOutAbilities(this.abilities));
+            this.F();
+        }
+    }
+
+    public WorldServer x() {
+        return (WorldServer) this.world;
+    }
+
+    public void a(EnumGamemode enumgamemode) {
+        getBukkitEntity().setGameMode(org.bukkit.GameMode.getByValue(enumgamemode.getId()));
+        /* CraftBukkit start - defer to our setGameMode
+        this.playerInteractManager.setGameMode(enumgamemode);
+        this.playerConnection.sendPacket(new PacketPlayOutGameStateChange(3, (float) enumgamemode.getId()));
+        if (enumgamemode == EnumGamemode.SPECTATOR) {
+            this.stopRiding();
+        } else {
+            this.setSpectatorTarget(this);
+        }
+
+        this.updateAbilities();
+        this.cv();
+        // CraftBukkit end */
+    }
+
+    public boolean isSpectator() {
+        return this.playerInteractManager.getGameMode() == EnumGamemode.SPECTATOR;
+    }
+
+    public boolean z() {
+        return this.playerInteractManager.getGameMode() == EnumGamemode.CREATIVE;
+    }
+
+    public void sendMessage(IChatBaseComponent ichatbasecomponent) {
+        this.playerConnection.sendPacket(new PacketPlayOutChat(ichatbasecomponent));
+    }
+
+    public boolean a(int i, String s) {
+        /* CraftBukkit start
+        if ("seed".equals(s) && !this.server.aa()) {
+            return true;
+        } else if (!"tell".equals(s) && !"help".equals(s) && !"me".equals(s) && !"trigger".equals(s)) {
+            if (this.server.getPlayerList().isOp(this.getProfile())) {
+                OpListEntry oplistentry = (OpListEntry) this.server.getPlayerList().getOPs().get(this.getProfile());
+
+                return oplistentry != null ? oplistentry.a() >= i : this.server.q() >= i;
+            } else {
+                return false;
+            }
+        } else {
+            return true;
+        }
+        */
+        if ("@".equals(s)) {
+            return getBukkitEntity().hasPermission("minecraft.command.selector");
+        }
+        if ("".equals(s)) {
+            return getBukkitEntity().isOp();
+        }
+        return getBukkitEntity().hasPermission("minecraft.command." + s);
+        // CraftBukkit end
+    }
+
+    public String A() {
+        String s = this.playerConnection.networkManager.getSocketAddress().toString();
+
+        s = s.substring(s.indexOf("/") + 1);
+        s = s.substring(0, s.indexOf(":"));
+        return s;
+    }
+
+    public void a(PacketPlayInSettings packetplayinsettings) {
+        // CraftBukkit start
+        if (getMainHand() != packetplayinsettings.getMainHand()) {
+            PlayerChangedMainHandEvent event = new PlayerChangedMainHandEvent(getBukkitEntity(), getMainHand() == EnumMainHand.LEFT ? MainHand.LEFT : MainHand.RIGHT);
+            this.server.server.getPluginManager().callEvent(event);
+        }
+        // CraftBukkit end
+        this.locale = packetplayinsettings.a();
+        this.ch = packetplayinsettings.c();
+        this.ci = packetplayinsettings.d();
+        this.getDataWatcher().set(EntityPlayer.br, Byte.valueOf((byte) packetplayinsettings.e()));
+        this.getDataWatcher().set(EntityPlayer.bs, Byte.valueOf((byte) (packetplayinsettings.getMainHand() == EnumMainHand.LEFT ? 0 : 1)));
+    }
+
+    public EntityHuman.EnumChatVisibility getChatFlags() {
+        return this.ch;
+    }
+
+    public void setResourcePack(String s, String s1) {
+        this.playerConnection.sendPacket(new PacketPlayOutResourcePackSend(s, s1));
+    }
+
+    public BlockPosition getChunkCoordinates() {
+        return new BlockPosition(this.locX, this.locY + 0.5D, this.locZ);
+    }
+
+    public void resetIdleTimer() {
+        this.cj = MinecraftServer.av();
+    }
+
+    public ServerStatisticManager getStatisticManager() {
+        return this.bV;
+    }
+
+    public void c(Entity entity) {
+        if (entity instanceof EntityHuman) {
+            this.playerConnection.sendPacket(new PacketPlayOutEntityDestroy(new int[] { entity.getId()}));
+        } else {
+            this.removeQueue.add(Integer.valueOf(entity.getId()));
+        }
+
+    }
+
+    public void d(Entity entity) {
+        this.removeQueue.remove(Integer.valueOf(entity.getId()));
+    }
+
+    protected void F() {
+        if (this.isSpectator()) {
+            this.bP();
+            this.setInvisible(true);
+        } else {
+            super.F();
+        }
+
+        this.x().getTracker().a(this);
+    }
+
+    public Entity getSpecatorTarget() {
+        return (Entity) (this.ck == null ? this : this.ck);
+    }
+
+    public void setSpectatorTarget(Entity entity) {
+        Entity entity1 = this.getSpecatorTarget();
+
+        this.ck = (Entity) (entity == null ? this : entity);
+        if (entity1 != this.ck) {
+            this.playerConnection.sendPacket(new PacketPlayOutCamera(this.ck));
+            this.enderTeleportTo(this.ck.locX, this.ck.locY, this.ck.locZ);
+        }
+
+    }
+
+    protected void H() {
+        if (this.portalCooldown > 0 && !this.worldChangeInvuln) {
+            --this.portalCooldown;
+        }
+
+    }
+
+    public void attack(Entity entity) {
+        if (this.playerInteractManager.getGameMode() == EnumGamemode.SPECTATOR) {
+            this.setSpectatorTarget(entity);
+        } else {
+            super.attack(entity);
+        }
+
+    }
+
+    public long I() {
+        return this.cj;
+    }
+
+    @Nullable
+    public IChatBaseComponent getPlayerListName() {
+        return listName; // CraftBukkit
+    }
+
+    public void a(EnumHand enumhand) {
+        super.a(enumhand);
+        this.de();
+    }
+
+    public boolean K() {
+        return this.worldChangeInvuln;
+    }
+
+    public void L() {
+        this.worldChangeInvuln = false;
+    }
+
+    public void M() {
+        if (!CraftEventFactory.callToggleGlideEvent(this, true).isCancelled()) // CraftBukkit
+        this.setFlag(7, true);
+    }
+
+    public void N() {
+        // CraftBukkit start
+        if (!CraftEventFactory.callToggleGlideEvent(this, false).isCancelled()) {
+            this.setFlag(7, true);
+            this.setFlag(7, false);
+        }
+        // CraftBukkit end
+    }
+
+    // CraftBukkit start - Add per-player time and weather.
+    public long timeOffset = 0;
+    public boolean relativeTime = true;
+
+    public long getPlayerTime() {
+        if (this.relativeTime) {
+            // Adds timeOffset to the current server time.
+            return this.world.getDayTime() + this.timeOffset;
+        } else {
+            // Adds timeOffset to the beginning of this day.
+            return this.world.getDayTime() - (this.world.getDayTime() % 24000) + this.timeOffset;
+        }
+    }
+
+    public WeatherType weather = null;
+
+    public WeatherType getPlayerWeather() {
+        return this.weather;
+    }
+
+    public void setPlayerWeather(WeatherType type, boolean plugin) {
+        if (!plugin && this.weather != null) {
+            return;
+        }
+
+        if (plugin) {
+            this.weather = type;
+        }
+
+        if (type == WeatherType.DOWNFALL) {
+            this.playerConnection.sendPacket(new PacketPlayOutGameStateChange(2, 0));
+        } else {
+            this.playerConnection.sendPacket(new PacketPlayOutGameStateChange(1, 0));
+        }
+    }
+
+    private float pluginRainPosition;
+    private float pluginRainPositionPrevious;
+
+    public void updateWeather(float oldRain, float newRain, float oldThunder, float newThunder) {
+        if (this.weather == null) {
+            // Vanilla
+            if (oldRain != newRain) {
+                this.playerConnection.sendPacket(new PacketPlayOutGameStateChange(7, newRain));
+            }
+        } else {
+            // Plugin
+            if (pluginRainPositionPrevious != pluginRainPosition) {
+                this.playerConnection.sendPacket(new PacketPlayOutGameStateChange(7, pluginRainPosition));
+            }
+        }
+
+        if (oldThunder != newThunder) {
+            if (weather == WeatherType.DOWNFALL || weather == null) {
+                this.playerConnection.sendPacket(new PacketPlayOutGameStateChange(8, newThunder));
+            } else {
+                this.playerConnection.sendPacket(new PacketPlayOutGameStateChange(8, 0));
+            }
+        }
+    }
+
+    public void tickWeather() {
+        if (this.weather == null) return;
+
+        pluginRainPositionPrevious = pluginRainPosition;
+        if (weather == WeatherType.DOWNFALL) {
+            pluginRainPosition += 0.01;
+        } else {
+            pluginRainPosition -= 0.01;
+        }
+
+        pluginRainPosition = MathHelper.a(pluginRainPosition, 0.0F, 1.0F);
+    }
+
+    public void resetPlayerWeather() {
+        this.weather = null;
+        this.setPlayerWeather(this.world.getWorldData().hasStorm() ? WeatherType.DOWNFALL : WeatherType.CLEAR, false);
+    }
+
+    @Override
+    public String toString() {
+        return super.toString() + "(" + this.getName() + " at " + this.locX + "," + this.locY + "," + this.locZ + ")";
+    }
+
+    public void reset() {
+        float exp = 0;
+        boolean keepInventory = this.world.getGameRules().getBoolean("keepInventory");
+
+        if (this.keepLevel || keepInventory) {
+            exp = this.exp;
+            this.newTotalExp = this.expTotal;
+            this.newLevel = this.expLevel;
+        }
+
+        this.setHealth(this.getMaxHealth());
+        this.fireTicks = 0;
+        this.fallDistance = 0;
+        this.foodData = new FoodMetaData(this);
+        this.expLevel = this.newLevel;
+        this.expTotal = this.newTotalExp;
+        this.exp = 0;
+        this.deathTicks = 0;
+        this.removeAllEffects();
+        this.updateEffects = true;
+        this.activeContainer = this.defaultContainer;
+        this.killer = null;
+        this.lastDamager = null;
+        this.combatTracker = new CombatTracker(this);
+        this.lastSentExp = -1;
+        if (this.keepLevel || keepInventory) {
+            this.exp = exp;
+        } else {
+            this.giveExp(this.newExp);
+        }
+        this.keepLevel = false;
+    }
+
+    @Override
+    public CraftPlayer getBukkitEntity() {
+        return (CraftPlayer) super.getBukkitEntity();
+    }
+    // CraftBukkit end
+}
diff -Naur src_origin/main/java/net/minecraft/server/EntityTracker.java src/main/java/net/minecraft/server/EntityTracker.java
--- src_origin/main/java/net/minecraft/server/EntityTracker.java	2016-08-25 22:39:51.573601950 +0800
+++ src/main/java/net/minecraft/server/EntityTracker.java	2016-08-26 03:24:14.019198426 +0800
@@ -1,301 +1,321 @@
-package net.minecraft.server;
-
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
-import java.util.ArrayList;
-import java.util.Iterator;
-import java.util.Set;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-
-public class EntityTracker {
-
-    private static final Logger a = LogManager.getLogger();
-    private final WorldServer world;
-    private final Set<EntityTrackerEntry> c = Sets.newHashSet();
-    public final IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
-    private int e;
-
-    public EntityTracker(WorldServer worldserver) {
-        this.world = worldserver;
-        this.e = worldserver.getMinecraftServer().getPlayerList().d();
-    }
-
-    public static long a(double d0) {
-        return MathHelper.d(d0 * 4096.0D);
-    }
-
-    public void track(Entity entity) {
-        if (entity instanceof EntityPlayer) {
-            this.addEntity(entity, 512, 2);
-            EntityPlayer entityplayer = (EntityPlayer) entity;
-            Iterator iterator = this.c.iterator();
-
-            while (iterator.hasNext()) {
-                EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
-
-                if (entitytrackerentry.b() != entityplayer) {
-                    entitytrackerentry.updatePlayer(entityplayer);
-                }
-            }
-        } else if (entity instanceof EntityFishingHook) {
-            this.addEntity(entity, 64, 5, true);
-        } else if (entity instanceof EntityArrow) {
-            this.addEntity(entity, 64, 20, false);
-        } else if (entity instanceof EntitySmallFireball) {
-            this.addEntity(entity, 64, 10, false);
-        } else if (entity instanceof EntityFireball) {
-            this.addEntity(entity, 64, 10, false);
-        } else if (entity instanceof EntitySnowball) {
-            this.addEntity(entity, 64, 10, true);
-        } else if (entity instanceof EntityEnderPearl) {
-            this.addEntity(entity, 64, 10, true);
-        } else if (entity instanceof EntityEnderSignal) {
-            this.addEntity(entity, 64, 4, true);
-        } else if (entity instanceof EntityEgg) {
-            this.addEntity(entity, 64, 10, true);
-        } else if (entity instanceof EntityPotion) {
-            this.addEntity(entity, 64, 10, true);
-        } else if (entity instanceof EntityThrownExpBottle) {
-            this.addEntity(entity, 64, 10, true);
-        } else if (entity instanceof EntityFireworks) {
-            this.addEntity(entity, 64, 10, true);
-        } else if (entity instanceof EntityItem) {
-            this.addEntity(entity, 64, 20, true);
-        } else if (entity instanceof EntityMinecartAbstract) {
-            this.addEntity(entity, 80, 3, true);
-        } else if (entity instanceof EntityBoat) {
-            this.addEntity(entity, 80, 3, true);
-        } else if (entity instanceof EntitySquid) {
-            this.addEntity(entity, 64, 3, true);
-        } else if (entity instanceof EntityWither) {
-            this.addEntity(entity, 80, 3, false);
-        } else if (entity instanceof EntityShulkerBullet) {
-            this.addEntity(entity, 80, 3, true);
-        } else if (entity instanceof EntityBat) {
-            this.addEntity(entity, 80, 3, false);
-        } else if (entity instanceof EntityEnderDragon) {
-            this.addEntity(entity, 160, 3, true);
-        } else if (entity instanceof IAnimal) {
-            this.addEntity(entity, 80, 3, true);
-        } else if (entity instanceof EntityTNTPrimed) {
-            this.addEntity(entity, 160, 10, true);
-        } else if (entity instanceof EntityFallingBlock) {
-            this.addEntity(entity, 160, 20, true);
-        } else if (entity instanceof EntityHanging) {
-            this.addEntity(entity, 160, Integer.MAX_VALUE, false);
-        } else if (entity instanceof EntityArmorStand) {
-            this.addEntity(entity, 160, 3, true);
-        } else if (entity instanceof EntityExperienceOrb) {
-            this.addEntity(entity, 160, 20, true);
-        } else if (entity instanceof EntityAreaEffectCloud) {
-            this.addEntity(entity, 160, Integer.MAX_VALUE, true);
-        } else if (entity instanceof EntityEnderCrystal) {
-            this.addEntity(entity, 256, Integer.MAX_VALUE, false);
-        }
-
-    }
-
-    public void addEntity(Entity entity, int i, int j) {
-        this.addEntity(entity, i, j, false);
-    }
-
-    public void addEntity(Entity entity, int i, final int j, boolean flag) {
-        org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
-        i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
-        try {
-            if (this.trackedEntities.b(entity.getId())) {
-                throw new IllegalStateException("Entity is already tracked!");
-            }
-
-            EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, this.e, j, flag);
-
-            this.c.add(entitytrackerentry);
-            this.trackedEntities.a(entity.getId(), entitytrackerentry);
-            entitytrackerentry.scanPlayers(this.world.players);
-        } catch (Throwable throwable) {
-            CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
-            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity To Track");
-
-            crashreportsystemdetails.a("Tracking range", (Object) (i + " blocks"));
-            final int finalI = i; // CraftBukkit - fix decompile error
-            crashreportsystemdetails.a("Update interval", new CrashReportCallable() {
-                public String a() throws Exception {
-                    String s = "Once per " + finalI + " ticks"; // CraftBukkit
-
-                    if (finalI == Integer.MAX_VALUE) { // CraftBukkit
-                        s = "Maximum (" + s + ")";
-                    }
-
-                    return s;
-                }
-
-                public Object call() throws Exception {
-                    return this.a();
-                }
-            });
-            entity.appendEntityCrashDetails(crashreportsystemdetails);
-            ((EntityTrackerEntry) this.trackedEntities.get(entity.getId())).b().appendEntityCrashDetails(crashreport.a("Entity That Is Already Tracked"));
-
-            try {
-                throw new ReportedException(crashreport);
-            } catch (ReportedException reportedexception) {
-                EntityTracker.a.error("\"Silently\" catching entity tracking error.", reportedexception);
-            }
-        }
-
-    }
-
-    public void untrackEntity(Entity entity) {
-        org.spigotmc.AsyncCatcher.catchOp( "entity untrack"); // Spigot
-        if (entity instanceof EntityPlayer) {
-            EntityPlayer entityplayer = (EntityPlayer) entity;
-            Iterator iterator = this.c.iterator();
-
-            while (iterator.hasNext()) {
-                EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
-
-                entitytrackerentry.a(entityplayer);
-            }
-        }
-
-        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
-
-        if (entitytrackerentry1 != null) {
-            this.c.remove(entitytrackerentry1);
-            entitytrackerentry1.a();
-        }
-
-    }
-
-    public void updatePlayers() {
-        ArrayList arraylist = Lists.newArrayList();
-        Iterator iterator = this.c.iterator();
-
-        while (iterator.hasNext()) {
-            EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
-
-            entitytrackerentry.track(this.world.players);
-            if (entitytrackerentry.b) {
-                Entity entity = entitytrackerentry.b();
-
-                if (entity instanceof EntityPlayer) {
-                    arraylist.add((EntityPlayer) entity);
-                }
-            }
-        }
-
-        for (int i = 0; i < arraylist.size(); ++i) {
-            EntityPlayer entityplayer = (EntityPlayer) arraylist.get(i);
-            Iterator iterator1 = this.c.iterator();
-
-            while (iterator1.hasNext()) {
-                EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) iterator1.next();
-
-                if (entitytrackerentry1.b() != entityplayer) {
-                    entitytrackerentry1.updatePlayer(entityplayer);
-                }
-            }
-        }
-
-    }
-
-    public void a(EntityPlayer entityplayer) {
-        Iterator iterator = this.c.iterator();
-
-        while (iterator.hasNext()) {
-            EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
-
-            if (entitytrackerentry.b() == entityplayer) {
-                entitytrackerentry.scanPlayers(this.world.players);
-            } else {
-                entitytrackerentry.updatePlayer(entityplayer);
-            }
-        }
-
-    }
-
-    public void a(Entity entity, Packet<?> packet) {
-        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
-
-        if (entitytrackerentry != null) {
-            entitytrackerentry.broadcast(packet);
-        }
-
-    }
-
-    public void sendPacketToEntity(Entity entity, Packet<?> packet) {
-        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
-
-        if (entitytrackerentry != null) {
-            entitytrackerentry.broadcastIncludingSelf(packet);
-        }
-
-    }
-
-    public void untrackPlayer(EntityPlayer entityplayer) {
-        Iterator iterator = this.c.iterator();
-
-        while (iterator.hasNext()) {
-            EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
-
-            entitytrackerentry.clear(entityplayer);
-        }
-
-    }
-
-    public void a(EntityPlayer entityplayer, Chunk chunk) {
-        ArrayList arraylist = Lists.newArrayList();
-        ArrayList arraylist1 = Lists.newArrayList();
-        Iterator iterator = this.c.iterator();
-
-        while (iterator.hasNext()) {
-            EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
-            Entity entity = entitytrackerentry.b();
-
-            if (entity != entityplayer && entity.ac == chunk.locX && entity.ae == chunk.locZ) {
-                entitytrackerentry.updatePlayer(entityplayer);
-                if (entity instanceof EntityInsentient && ((EntityInsentient) entity).getLeashHolder() != null) {
-                    arraylist.add(entity);
-                }
-
-                if (!entity.bx().isEmpty()) {
-                    arraylist1.add(entity);
-                }
-            }
-        }
-
-        Entity entity1;
-
-        if (!arraylist.isEmpty()) {
-            iterator = arraylist.iterator();
-
-            while (iterator.hasNext()) {
-                entity1 = (Entity) iterator.next();
-                entityplayer.playerConnection.sendPacket(new PacketPlayOutAttachEntity(entity1, ((EntityInsentient) entity1).getLeashHolder()));
-            }
-        }
-
-        if (!arraylist1.isEmpty()) {
-            iterator = arraylist1.iterator();
-
-            while (iterator.hasNext()) {
-                entity1 = (Entity) iterator.next();
-                entityplayer.playerConnection.sendPacket(new PacketPlayOutMount(entity1));
-            }
-        }
-
-    }
-
-    public void a(int i) {
-        this.e = (i - 1) * 16;
-        Iterator iterator = this.c.iterator();
-
-        while (iterator.hasNext()) {
-            EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
-
-            entitytrackerentry.a(this.e);
-        }
-
-    }
-}
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.Set;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class EntityTracker {
+
+    private static final Logger a = LogManager.getLogger();
+    private final WorldServer world;
+    //private final Set<EntityTrackerEntry> c = Sets.newHashSet();
+    private final Set<EntityTrackerEntry> c = Collections.synchronizedSet(Sets.newHashSet());
+    //public final IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    public final Map<Integer, EntityTrackerEntry> trackedEntities = Maps.newConcurrentMap();
+    private int e;
+
+    public EntityTracker(WorldServer worldserver) {
+        this.world = worldserver;
+        this.e = worldserver.getMinecraftServer().getPlayerList().d();
+    }
+
+    public static long a(double d0) {
+        return MathHelper.d(d0 * 4096.0D);
+    }
+
+    public void track(Entity entity) {
+        if (entity instanceof EntityPlayer) {
+            this.addEntity(entity, 512, 2);
+            EntityPlayer entityplayer = (EntityPlayer) entity;
+            Iterator iterator = this.c.iterator();
+
+            while (iterator.hasNext()) {
+                EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
+
+                if (entitytrackerentry.b() != entityplayer) {
+                    entitytrackerentry.updatePlayer(entityplayer);
+                }
+            }
+        } else if (entity instanceof EntityFishingHook) {
+            this.addEntity(entity, 64, 5, true);
+        } else if (entity instanceof EntityArrow) {
+            this.addEntity(entity, 64, 20, false);
+        } else if (entity instanceof EntitySmallFireball) {
+            this.addEntity(entity, 64, 10, false);
+        } else if (entity instanceof EntityFireball) {
+            this.addEntity(entity, 64, 10, false);
+        } else if (entity instanceof EntitySnowball) {
+            this.addEntity(entity, 64, 10, true);
+        } else if (entity instanceof EntityEnderPearl) {
+            this.addEntity(entity, 64, 10, true);
+        } else if (entity instanceof EntityEnderSignal) {
+            this.addEntity(entity, 64, 4, true);
+        } else if (entity instanceof EntityEgg) {
+            this.addEntity(entity, 64, 10, true);
+        } else if (entity instanceof EntityPotion) {
+            this.addEntity(entity, 64, 10, true);
+        } else if (entity instanceof EntityThrownExpBottle) {
+            this.addEntity(entity, 64, 10, true);
+        } else if (entity instanceof EntityFireworks) {
+            this.addEntity(entity, 64, 10, true);
+        } else if (entity instanceof EntityItem) {
+            this.addEntity(entity, 64, 20, true);
+        } else if (entity instanceof EntityMinecartAbstract) {
+            this.addEntity(entity, 80, 3, true);
+        } else if (entity instanceof EntityBoat) {
+            this.addEntity(entity, 80, 3, true);
+        } else if (entity instanceof EntitySquid) {
+            this.addEntity(entity, 64, 3, true);
+        } else if (entity instanceof EntityWither) {
+            this.addEntity(entity, 80, 3, false);
+        } else if (entity instanceof EntityShulkerBullet) {
+            this.addEntity(entity, 80, 3, true);
+        } else if (entity instanceof EntityBat) {
+            this.addEntity(entity, 80, 3, false);
+        } else if (entity instanceof EntityEnderDragon) {
+            this.addEntity(entity, 160, 3, true);
+        } else if (entity instanceof IAnimal) {
+            this.addEntity(entity, 80, 3, true);
+        } else if (entity instanceof EntityTNTPrimed) {
+            this.addEntity(entity, 160, 10, true);
+        } else if (entity instanceof EntityFallingBlock) {
+            this.addEntity(entity, 160, 20, true);
+        } else if (entity instanceof EntityHanging) {
+            this.addEntity(entity, 160, Integer.MAX_VALUE, false);
+        } else if (entity instanceof EntityArmorStand) {
+            this.addEntity(entity, 160, 3, true);
+        } else if (entity instanceof EntityExperienceOrb) {
+            this.addEntity(entity, 160, 20, true);
+        } else if (entity instanceof EntityAreaEffectCloud) {
+            this.addEntity(entity, 160, Integer.MAX_VALUE, true);
+        } else if (entity instanceof EntityEnderCrystal) {
+            this.addEntity(entity, 256, Integer.MAX_VALUE, false);
+        }
+
+    }
+
+    public void addEntity(Entity entity, int i, int j) {
+        this.addEntity(entity, i, j, false);
+    }
+
+    public void addEntity(Entity entity, int i, final int j, boolean flag) {
+        org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
+        i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
+        try {
+            if (this.trackedEntities.containsKey(entity.getId())) {
+                //throw new IllegalStateException("Entity is already tracked!");
+                this.trackedEntities.remove(entity.getId());
+            }
+            /*
+            if (this.trackedEntities.b(entity.getId())) {
+                //throw new IllegalStateException("Entity is already tracked!");
+                this.trackedEntities.d(entity.getId());
+            }*/
+
+            EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, this.e, j, flag);
+
+            this.c.add(entitytrackerentry);
+            //this.trackedEntities.a(entity.getId(), entitytrackerentry);
+            this.trackedEntities.put(entity.getId(), entitytrackerentry);
+            entitytrackerentry.scanPlayers(this.world.players);
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity To Track");
+
+            crashreportsystemdetails.a("Tracking range", (Object) (i + " blocks"));
+            final int finalI = i; // CraftBukkit - fix decompile error
+            crashreportsystemdetails.a("Update interval", new CrashReportCallable() {
+                public String a() throws Exception {
+                    String s = "Once per " + finalI + " ticks"; // CraftBukkit
+
+                    if (finalI == Integer.MAX_VALUE) { // CraftBukkit
+                        s = "Maximum (" + s + ")";
+                    }
+
+                    return s;
+                }
+
+                public Object call() throws Exception {
+                    return this.a();
+                }
+            });
+            entity.appendEntityCrashDetails(crashreportsystemdetails);
+            ((EntityTrackerEntry) this.trackedEntities.get(entity.getId())).b().appendEntityCrashDetails(crashreport.a("Entity That Is Already Tracked"));
+
+            try {
+                throw new ReportedException(crashreport);
+            } catch (ReportedException reportedexception) {
+                EntityTracker.a.error("\"Silently\" catching entity tracking error.", reportedexception);
+            }
+        }
+
+    }
+
+    public void untrackEntity(Entity entity) {
+        org.spigotmc.AsyncCatcher.catchOp( "entity untrack"); // Spigot
+        if (entity instanceof EntityPlayer) {
+            EntityPlayer entityplayer = (EntityPlayer) entity;
+            synchronized (this.c) {
+                Iterator iterator = this.c.iterator();
+
+                while (iterator.hasNext()) {
+                    EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
+
+                    entitytrackerentry.a(entityplayer);
+                }
+            }
+        }
+
+        //EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
+        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.remove(entity.getId());
+
+        if (entitytrackerentry1 != null) {
+            this.c.remove(entitytrackerentry1);
+            entitytrackerentry1.a();
+        }
+
+    }
+
+    public void updatePlayers() {
+        ArrayList arraylist = Lists.newArrayList();
+        synchronized (this.c) {
+            Iterator iterator = this.c.iterator();
+
+            while (iterator.hasNext()) {
+                EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
+
+                entitytrackerentry.track(this.world.players);
+                if (entitytrackerentry.b) {
+                    Entity entity = entitytrackerentry.b();
+
+                    if (entity instanceof EntityPlayer) {
+                        arraylist.add((EntityPlayer) entity);
+                    }
+                }
+            }
+
+            for (int i = 0; i < arraylist.size(); ++i) {
+                EntityPlayer entityplayer = (EntityPlayer) arraylist.get(i);
+                Iterator iterator1 = this.c.iterator();
+
+                while (iterator1.hasNext()) {
+                    EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) iterator1.next();
+
+                    if (entitytrackerentry1.b() != entityplayer) {
+                        entitytrackerentry1.updatePlayer(entityplayer);
+                    }
+                }
+            }
+        }
+    }
+
+    public void a(EntityPlayer entityplayer) {
+        synchronized (this.c) {
+            Iterator iterator = this.c.iterator();
+
+            while (iterator.hasNext()) {
+                EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
+
+                if (entitytrackerentry.b() == entityplayer) {
+                    entitytrackerentry.scanPlayers(this.world.players);
+                } else {
+                    entitytrackerentry.updatePlayer(entityplayer);
+                }
+            }
+        }
+
+    }
+
+    public void a(Entity entity, Packet<?> packet) {
+        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+
+        if (entitytrackerentry != null) {
+            entitytrackerentry.broadcast(packet);
+        }
+
+    }
+
+    public void sendPacketToEntity(Entity entity, Packet<?> packet) {
+        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+
+        if (entitytrackerentry != null) {
+            entitytrackerentry.broadcastIncludingSelf(packet);
+        }
+
+    }
+
+    public void untrackPlayer(EntityPlayer entityplayer) {
+        Iterator iterator = this.c.iterator();
+
+        while (iterator.hasNext()) {
+            EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
+
+            entitytrackerentry.clear(entityplayer);
+        }
+
+    }
+
+    public void a(EntityPlayer entityplayer, Chunk chunk) {
+        ArrayList arraylist = Lists.newArrayList();
+        ArrayList arraylist1 = Lists.newArrayList();
+        synchronized (this.c) {
+            Iterator iterator = this.c.iterator();
+
+            while (iterator.hasNext()) {
+                EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
+                Entity entity = entitytrackerentry.b();
+
+                if (entity != entityplayer && entity.ac == chunk.locX && entity.ae == chunk.locZ) {
+                    entitytrackerentry.updatePlayer(entityplayer);
+                    if (entity instanceof EntityInsentient && ((EntityInsentient) entity).getLeashHolder() != null) {
+                        arraylist.add(entity);
+                    }
+
+                    if (!entity.bx().isEmpty()) {
+                        arraylist1.add(entity);
+                    }
+                }
+            }
+
+            Entity entity1;
+
+            if (!arraylist.isEmpty()) {
+                iterator = arraylist.iterator();
+
+                while (iterator.hasNext()) {
+                    entity1 = (Entity) iterator.next();
+                    entityplayer.playerConnection.sendPacket(new PacketPlayOutAttachEntity(entity1, ((EntityInsentient) entity1).getLeashHolder()));
+                }
+            }
+
+            if (!arraylist1.isEmpty()) {
+                iterator = arraylist1.iterator();
+
+                while (iterator.hasNext()) {
+                    entity1 = (Entity) iterator.next();
+                    entityplayer.playerConnection.sendPacket(new PacketPlayOutMount(entity1));
+                }
+            }
+        }
+
+    }
+
+    public void a(int i) {
+        this.e = (i - 1) * 16;
+        Iterator iterator = this.c.iterator();
+
+        while (iterator.hasNext()) {
+            EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
+
+            entitytrackerentry.a(this.e);
+        }
+
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2016-08-25 22:39:51.972601988 +0800
+++ src/main/java/net/minecraft/server/MinecraftServer.java	2016-08-26 03:24:14.416198463 +0800
@@ -1,1545 +1,1557 @@
-package net.minecraft.server;
-
-import com.google.common.base.Charsets;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
-import com.google.common.util.concurrent.Futures;
-import com.google.common.util.concurrent.ListenableFuture;
-import com.google.common.util.concurrent.ListenableFutureTask;
-import com.mojang.authlib.GameProfile;
-import com.mojang.authlib.GameProfileRepository;
-import com.mojang.authlib.minecraft.MinecraftSessionService;
-import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
-import io.netty.buffer.ByteBuf;
-import io.netty.buffer.ByteBufOutputStream;
-import io.netty.buffer.Unpooled;
-import io.netty.handler.codec.base64.Base64;
-import java.awt.GraphicsEnvironment;
-import java.awt.image.BufferedImage;
-import java.io.File;
-import java.io.IOException;
-import java.net.Proxy;
-import java.security.KeyPair;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Date;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Queue;
-import java.util.Random;
-import java.util.UUID;
-import java.util.concurrent.Callable;
-import java.util.concurrent.Executors;
-import java.util.concurrent.FutureTask;
-import javax.annotation.Nullable;
-import javax.imageio.ImageIO;
-import org.apache.commons.lang3.Validate;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-// CraftBukkit start
-import jline.console.ConsoleReader;
-import joptsimple.OptionSet;
-import org.bukkit.Bukkit;
-import org.bukkit.craftbukkit.CraftServer;
-import org.bukkit.craftbukkit.Main;
-// CraftBukkit end
-import org.bukkit.craftbukkit.SpigotTimings; // Spigot
-
-public abstract class MinecraftServer implements Runnable, ICommandListener, IAsyncTaskHandler, IMojangStatistics {
-
-    public static final Logger LOGGER = LogManager.getLogger();
-    public static final File a = new File("usercache.json");
-    public Convertable convertable;
-    private final MojangStatisticsGenerator m = new MojangStatisticsGenerator("server", this, av());
-    public File universe;
-    private final List<ITickable> o = Lists.newArrayList();
-    public final ICommandHandler b;
-    public final MethodProfiler methodProfiler = new MethodProfiler();
-    private ServerConnection p; // Spigot
-    private final ServerPing q = new ServerPing();
-    private final Random r = new Random();
-    private final DataConverterManager dataConverterManager;
-    private String serverIp;
-    private int u = -1;
-    public WorldServer[] worldServer;
-    private PlayerList v;
-    private boolean isRunning = true;
-    private boolean isStopped;
-    private int ticks;
-    protected final Proxy e;
-    public String f;
-    public int g;
-    private boolean onlineMode;
-    private boolean spawnAnimals;
-    private boolean spawnNPCs;
-    private boolean pvpMode;
-    private boolean allowFlight;
-    private String motd;
-    private int F;
-    private int G;
-    public final long[] h = new long[100];
-    public long[][] i;
-    private KeyPair H;
-    private String I;
-    private String J;
-    private boolean demoMode;
-    private boolean M;
-    private String N = "";
-    private String O = "";
-    private boolean P;
-    private long Q;
-    private String R;
-    private boolean S;
-    private boolean T;
-    private final YggdrasilAuthenticationService U;
-    private final MinecraftSessionService V;
-    private final GameProfileRepository W;
-    private final UserCache X;
-    private long Y;
-    protected final Queue<FutureTask<?>> j = new java.util.concurrent.ConcurrentLinkedQueue<FutureTask<?>>(); // Spigot, PAIL: Rename
-    private Thread serverThread;
-    private long aa = av();
-
-    // CraftBukkit start
-    public List<WorldServer> worlds = new ArrayList<WorldServer>();
-    public org.bukkit.craftbukkit.CraftServer server;
-    public OptionSet options;
-    public org.bukkit.command.ConsoleCommandSender console;
-    public org.bukkit.command.RemoteConsoleCommandSender remoteConsole;
-    public ConsoleReader reader;
-    public static int currentTick = (int) (System.currentTimeMillis() / 50);
-    public final Thread primaryThread;
-    public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
-    public int autosavePeriod;
-    // CraftBukkit end
-    // Spigot start
-    private static final int TPS = 20;
-    private static final int TICK_TIME = 1000000000 / TPS;
-    private static final int SAMPLE_INTERVAL = 100;
-    public final double[] recentTps = new double[ 3 ];
-    // Spigot end
-
-    public MinecraftServer(OptionSet options, Proxy proxy, DataConverterManager dataconvertermanager, YggdrasilAuthenticationService yggdrasilauthenticationservice, MinecraftSessionService minecraftsessionservice, GameProfileRepository gameprofilerepository, UserCache usercache) {
-        io.netty.util.ResourceLeakDetector.setEnabled( false ); // Spigot - disable
-        this.e = proxy;
-        this.U = yggdrasilauthenticationservice;
-        this.V = minecraftsessionservice;
-        this.W = gameprofilerepository;
-        this.X = usercache;
-        // this.universe = file; // CraftBukkit
-        // this.p = new ServerConnection(this); // Spigot
-        this.b = this.i();
-        // this.convertable = new WorldLoaderServer(file); // CraftBukkit - moved to DedicatedServer.init
-        this.dataConverterManager = dataconvertermanager;
-        // CraftBukkit start
-        this.options = options;
-        // Try to see if we're actually running in a terminal, disable jline if not
-        if (System.console() == null && System.getProperty("jline.terminal") == null) {
-            System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
-            Main.useJline = false;
-        }
-
-        try {
-            reader = new ConsoleReader(System.in, System.out);
-            reader.setExpandEvents(false); // Avoid parsing exceptions for uncommonly used event designators
-        } catch (Throwable e) {
-            try {
-                // Try again with jline disabled for Windows users without C++ 2008 Redistributable
-                System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
-                System.setProperty("user.language", "en");
-                Main.useJline = false;
-                reader = new ConsoleReader(System.in, System.out);
-                reader.setExpandEvents(false);
-            } catch (IOException ex) {
-                LOGGER.warn((String) null, ex);
-            }
-        }
-        Runtime.getRuntime().addShutdownHook(new org.bukkit.craftbukkit.util.ServerShutdownThread(this));
-
-        this.serverThread = primaryThread = new Thread(this, "Server thread"); // Moved from main
-    }
-
-    public abstract PropertyManager getPropertyManager();
-    // CraftBukkit end
-
-    protected CommandDispatcher i() {
-        return new CommandDispatcher(this);
-    }
-
-    public abstract boolean init() throws IOException;
-
-    protected void a(String s) {
-        if (this.getConvertable().isConvertable(s)) {
-            MinecraftServer.LOGGER.info("Converting map!");
-            this.b("menu.convertingLevel");
-            this.getConvertable().convert(s, new IProgressUpdate() {
-                private long b = System.currentTimeMillis();
-
-                public void a(String s) {}
-
-                public void a(int i) {
-                    if (System.currentTimeMillis() - this.b >= 1000L) {
-                        this.b = System.currentTimeMillis();
-                        MinecraftServer.LOGGER.info("Converting... {}%", new Object[] { Integer.valueOf(i)});
-                    }
-
-                }
-
-                public void c(String s) {}
-            });
-        }
-
-    }
-
-    protected synchronized void b(String s) {
-        this.R = s;
-    }
-
-    public void a(String s, String s1, long i, WorldType worldtype, String s2) {
-        this.a(s);
-        this.b("menu.loadingLevel");
-        this.worldServer = new WorldServer[3];
-        /* CraftBukkit start - Remove ticktime arrays and worldsettings
-        this.i = new long[this.worldServer.length][100];
-        IDataManager idatamanager = this.convertable.a(s, true);
-
-        this.a(this.S(), idatamanager);
-        WorldData worlddata = idatamanager.getWorldData();
-        WorldSettings worldsettings;
-
-        if (worlddata == null) {
-            if (this.V()) {
-                worldsettings = DemoWorldServer.a;
-            } else {
-                worldsettings = new WorldSettings(i, this.getGamemode(), this.getGenerateStructures(), this.isHardcore(), worldtype);
-                worldsettings.setGeneratorSettings(s2);
-                if (this.M) {
-                    worldsettings.a();
-                }
-            }
-
-            worlddata = new WorldData(worldsettings, s1);
-        } else {
-            worlddata.a(s1);
-            worldsettings = new WorldSettings(worlddata);
-        }
-        */
-        int worldCount = 3;
-
-        for (int j = 0; j < worldCount; ++j) {
-            WorldServer world;
-            byte dimension = 0;
-
-            if (j == 1) {
-                if (getAllowNether()) {
-                    dimension = -1;
-                } else {
-                    continue;
-                }
-            }
-
-            if (j == 2) {
-                if (server.getAllowEnd()) {
-                    dimension = 1;
-                } else {
-                    continue;
-                }
-            }
-
-            String worldType = org.bukkit.World.Environment.getEnvironment(dimension).toString().toLowerCase();
-            String name = (dimension == 0) ? s : s + "_" + worldType;
-
-            org.bukkit.generator.ChunkGenerator gen = this.server.getGenerator(name);
-            WorldSettings worldsettings = new WorldSettings(i, this.getGamemode(), this.getGenerateStructures(), this.isHardcore(), worldtype);
-            worldsettings.setGeneratorSettings(s2);
-
-            if (j == 0) {
-                IDataManager idatamanager = new ServerNBTManager(server.getWorldContainer(), s1, true, this.dataConverterManager);
-                WorldData worlddata = idatamanager.getWorldData();
-                if (worlddata == null) {
-                    worlddata = new WorldData(worldsettings, s1);
-                }
-                worlddata.checkName(s1); // CraftBukkit - Migration did not rewrite the level.dat; This forces 1.8 to take the last loaded world as respawn (in this case the end)
-                if (this.V()) {
-                    world = (WorldServer) (new DemoWorldServer(this, idatamanager, worlddata, dimension, this.methodProfiler)).b();
-                } else {
-                    world = (WorldServer) (new WorldServer(this, idatamanager, worlddata, dimension, this.methodProfiler, org.bukkit.World.Environment.getEnvironment(dimension), gen)).b();
-                }
-
-                world.a(worldsettings);
-                this.server.scoreboardManager = new org.bukkit.craftbukkit.scoreboard.CraftScoreboardManager(this, world.getScoreboard());
-            } else {
-                String dim = "DIM" + dimension;
-
-                File newWorld = new File(new File(name), dim);
-                File oldWorld = new File(new File(s), dim);
-
-                if ((!newWorld.isDirectory()) && (oldWorld.isDirectory())) {
-                    MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder required ----");
-                    MinecraftServer.LOGGER.info("Unfortunately due to the way that Minecraft implemented multiworld support in 1.6, Bukkit requires that you move your " + worldType + " folder to a new location in order to operate correctly.");
-                    MinecraftServer.LOGGER.info("We will move this folder for you, but it will mean that you need to move it back should you wish to stop using Bukkit in the future.");
-                    MinecraftServer.LOGGER.info("Attempting to move " + oldWorld + " to " + newWorld + "...");
-
-                    if (newWorld.exists()) {
-                        MinecraftServer.LOGGER.warn("A file or folder already exists at " + newWorld + "!");
-                        MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder failed ----");
-                    } else if (newWorld.getParentFile().mkdirs()) {
-                        if (oldWorld.renameTo(newWorld)) {
-                            MinecraftServer.LOGGER.info("Success! To restore " + worldType + " in the future, simply move " + newWorld + " to " + oldWorld);
-                            // Migrate world data too.
-                            try {
-                                com.google.common.io.Files.copy(new File(new File(s), "level.dat"), new File(new File(name), "level.dat"));
-                                org.apache.commons.io.FileUtils.copyDirectory(new File(new File(s), "data"), new File(new File(name), "data"));
-                            } catch (IOException exception) {
-                                MinecraftServer.LOGGER.warn("Unable to migrate world data.");
-                            }
-                            MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder complete ----");
-                        } else {
-                            MinecraftServer.LOGGER.warn("Could not move folder " + oldWorld + " to " + newWorld + "!");
-                            MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder failed ----");
-                        }
-                    } else {
-                        MinecraftServer.LOGGER.warn("Could not create path for " + newWorld + "!");
-                        MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder failed ----");
-                    }
-                }
-
-                IDataManager idatamanager = new ServerNBTManager(server.getWorldContainer(), name, true, this.dataConverterManager);
-                // world =, b0 to dimension, s1 to name, added Environment and gen
-                WorldData worlddata = idatamanager.getWorldData();
-                if (worlddata == null) {
-                    worlddata = new WorldData(worldsettings, name);
-                }
-                worlddata.checkName(name); // CraftBukkit - Migration did not rewrite the level.dat; This forces 1.8 to take the last loaded world as respawn (in this case the end)
-                world = (WorldServer) new SecondaryWorldServer(this, idatamanager, dimension, this.worlds.get(0), this.methodProfiler, worlddata, org.bukkit.World.Environment.getEnvironment(dimension), gen).b();
-            }
-
-            this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldInitEvent(world.getWorld()));
-
-            world.addIWorldAccess(new WorldManager(this, world));
-            if (!this.R()) {
-                world.getWorldData().setGameType(this.getGamemode());
-            }
-
-            worlds.add(world);
-            getPlayerList().setPlayerFileData(worlds.toArray(new WorldServer[worlds.size()]));
-        }
-        // CraftBukkit end
-        this.v.setPlayerFileData(this.worldServer);
-        this.a(this.getDifficulty());
-        this.l();
-    }
-
-    protected void l() {
-        boolean flag = true;
-        boolean flag1 = true;
-        boolean flag2 = true;
-        boolean flag3 = true;
-        int i = 0;
-
-        this.b("menu.generatingTerrain");
-        boolean flag4 = false;
-
-        // CraftBukkit start - fire WorldLoadEvent and handle whether or not to keep the spawn in memory
-        for (int m = 0; m < worlds.size(); m++) {
-            WorldServer worldserver = this.worlds.get(m);
-            MinecraftServer.LOGGER.info("Preparing start region for level " + m + " (Seed: " + worldserver.getSeed() + ")");
-
-            if (!worldserver.getWorld().getKeepSpawnInMemory()) {
-                continue;
-            }
-
-            BlockPosition blockposition = worldserver.getSpawn();
-            long j = av();
-            i = 0;
-
-            for (int k = -192; k <= 192 && this.isRunning(); k += 16) {
-                for (int l = -192; l <= 192 && this.isRunning(); l += 16) {
-                    long i1 = av();
-
-                    if (i1 - j > 1000L) {
-                        this.a_("Preparing spawn area", i * 100 / 625);
-                        j = i1;
-                    }
-
-                    ++i;
-                    worldserver.getChunkProviderServer().getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
-                }
-            }
-        }
-
-        for (WorldServer world : this.worlds) {
-            this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldLoadEvent(world.getWorld()));
-        }
-        // CraftBukkit end
-        this.t();
-    }
-
-    protected void a(String s, IDataManager idatamanager) {
-        File file = new File(idatamanager.getDirectory(), "resources.zip");
-
-        if (file.isFile()) {
-            this.setResourcePack("level://" + s + "/" + "resources.zip", "");
-        }
-
-    }
-
-    public abstract boolean getGenerateStructures();
-
-    public abstract EnumGamemode getGamemode();
-
-    public abstract EnumDifficulty getDifficulty();
-
-    public abstract boolean isHardcore();
-
-    public abstract int q();
-
-    public abstract boolean r();
-
-    public abstract boolean s();
-
-    protected void a_(String s, int i) {
-        this.f = s;
-        this.g = i;
-        MinecraftServer.LOGGER.info("{}: {}%", new Object[] { s, Integer.valueOf(i)});
-    }
-
-    protected void t() {
-        this.f = null;
-        this.g = 0;
-        this.server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.POSTWORLD); // CraftBukkit
-    }
-
-    protected void saveChunks(boolean flag) {
-        WorldServer[] aworldserver = this.worldServer;
-        int i = aworldserver.length;
-
-        // CraftBukkit start
-        for (int j = 0; j < worlds.size(); ++j) {
-            WorldServer worldserver = worlds.get(j);
-            // CraftBukkit end
-
-            if (worldserver != null) {
-                if (!flag) {
-                    MinecraftServer.LOGGER.info("Saving chunks for level \'{}\'/{}", new Object[] { worldserver.getWorldData().getName(), worldserver.worldProvider.getDimensionManager().b()});
-                }
-
-                try {
-                    worldserver.save(true, (IProgressUpdate) null);
-                    worldserver.saveLevel(); // CraftBukkit
-                } catch (ExceptionWorldConflict exceptionworldconflict) {
-                    MinecraftServer.LOGGER.warn(exceptionworldconflict.getMessage());
-                }
-            }
-        }
-
-    }
-
-    // CraftBukkit start
-    private boolean hasStopped = false;
-    private final Object stopLock = new Object();
-    // CraftBukkit end
-
-    public void stop() throws ExceptionWorldConflict { // CraftBukkit - added throws
-        // CraftBukkit start - prevent double stopping on multiple threads
-        synchronized(stopLock) {
-            if (hasStopped) return;
-            hasStopped = true;
-        }
-        // CraftBukkit end
-        MinecraftServer.LOGGER.info("Stopping server");
-        // CraftBukkit start
-        if (this.server != null) {
-            this.server.disablePlugins();
-        }
-        // CraftBukkit end
-        if (this.am() != null) {
-            this.am().b();
-        }
-
-        if (this.v != null) {
-            MinecraftServer.LOGGER.info("Saving players");
-            this.v.savePlayers();
-            this.v.u();
-            try { Thread.sleep(100); } catch (InterruptedException ex) {} // CraftBukkit - SPIGOT-625 - give server at least a chance to send packets
-        }
-
-        if (this.worldServer != null) {
-            MinecraftServer.LOGGER.info("Saving worlds");
-            WorldServer[] aworldserver = this.worldServer;
-            int i = aworldserver.length;
-
-            int j;
-            WorldServer worldserver;
-
-            for (j = 0; j < i; ++j) {
-                worldserver = aworldserver[j];
-                if (worldserver != null) {
-                    worldserver.savingDisabled = false;
-                }
-            }
-
-            this.saveChunks(false);
-            aworldserver = this.worldServer;
-            i = aworldserver.length;
-
-            /* CraftBukkit start - Handled in saveChunks
-            for (j = 0; j < i; ++j) {
-                worldserver = aworldserver[j];
-                if (worldserver != null) {
-                    worldserver.saveLevel();
-                }
-            }
-            // CraftBukkit end */
-        }
-
-        if (this.m.d()) {
-            this.m.e();
-        }
-
-        // Spigot start
-        if (org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly) {
-            LOGGER.info("Saving usercache.json");
-            this.X.c();
-        }
-        // Spigot end
-    }
-
-    public String getServerIp() {
-        return this.serverIp;
-    }
-
-    public void c(String s) {
-        this.serverIp = s;
-    }
-
-    public boolean isRunning() {
-        return this.isRunning;
-    }
-
-    public void safeShutdown() {
-        this.isRunning = false;
-    }
-
-    // Spigot Start
-    private static double calcTps(double avg, double exp, double tps)
-    {
-        return ( avg * exp ) + ( tps * ( 1 - exp ) );
-    }
-    // Spigot End
- 
-    public void run() {
-        try {
-            if (this.init()) {
-                this.aa = av();
-                long i = 0L;
-
-                this.q.setMOTD(new ChatComponentText(this.motd));
-                this.q.setServerInfo(new ServerPing.ServerData("1.10.2", 210));
-                this.a(this.q);
-
-                // Spigot start
-                Arrays.fill( recentTps, 20 );
-                long lastTick = System.nanoTime(), catchupTime = 0, curTime, wait, tickSection = lastTick;
-                while (this.isRunning) {
-                    curTime = System.nanoTime();
-                    wait = TICK_TIME - (curTime - lastTick) - catchupTime;
-                    if (wait > 0) {
-                        Thread.sleep(wait / 1000000);
-                        catchupTime = 0;
-                        continue;
-                    } else {
-                        catchupTime = Math.min(1000000000, Math.abs(wait));
-                    }
-
-                    if ( MinecraftServer.currentTick++ % SAMPLE_INTERVAL == 0 )
-                    {
-                        double currentTps = 1E9 / ( curTime - tickSection ) * SAMPLE_INTERVAL;
-                        recentTps[0] = calcTps( recentTps[0], 0.92, currentTps ); // 1/exp(5sec/1min)
-                        recentTps[1] = calcTps( recentTps[1], 0.9835, currentTps ); // 1/exp(5sec/5min)
-                        recentTps[2] = calcTps( recentTps[2], 0.9945, currentTps ); // 1/exp(5sec/15min)
-                        tickSection = curTime;
-                    }
-                    lastTick = curTime;
-
-                    this.C();
-                    this.P = true;
-                }
-                // Spigot end
-            } else {
-                this.a((CrashReport) null);
-            }
-        } catch (Throwable throwable) {
-            MinecraftServer.LOGGER.error("Encountered an unexpected exception", throwable);
-            // Spigot Start
-            if ( throwable.getCause() != null )
-            {
-                MinecraftServer.LOGGER.error( "\tCause of unexpected exception was", throwable.getCause() );
-            }
-            // Spigot End
-            CrashReport crashreport = null;
-
-            if (throwable instanceof ReportedException) {
-                crashreport = this.b(((ReportedException) throwable).a());
-            } else {
-                crashreport = this.b(new CrashReport("Exception in server tick loop", throwable));
-            }
-
-            File file = new File(new File(this.A(), "crash-reports"), "crash-" + (new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss")).format(new Date()) + "-server.txt");
-
-            if (crashreport.a(file)) {
-                MinecraftServer.LOGGER.error("This crash report has been saved to: {}", new Object[] { file.getAbsolutePath()});
-            } else {
-                MinecraftServer.LOGGER.error("We were unable to save this crash report to disk.");
-            }
-
-            this.a(crashreport);
-        } finally {
-            try {
-                org.spigotmc.WatchdogThread.doStop();
-                this.isStopped = true;
-                this.stop();
-            } catch (Throwable throwable1) {
-                MinecraftServer.LOGGER.error("Exception stopping the server", throwable1);
-            } finally {
-                // CraftBukkit start - Restore terminal to original settings
-                try {
-                    reader.getTerminal().restore();
-                } catch (Exception ignored) {
-                }
-                // CraftBukkit end
-                this.B();
-            }
-
-        }
-
-    }
-
-    public void a(ServerPing serverping) {
-        File file = this.d("server-icon.png");
-
-        if (!file.exists()) {
-            file = this.getConvertable().b(this.S(), "icon.png");
-        }
-
-        if (file.isFile()) {
-            ByteBuf bytebuf = Unpooled.buffer();
-
-            try {
-                BufferedImage bufferedimage = ImageIO.read(file);
-
-                Validate.validState(bufferedimage.getWidth() == 64, "Must be 64 pixels wide", new Object[0]);
-                Validate.validState(bufferedimage.getHeight() == 64, "Must be 64 pixels high", new Object[0]);
-                ImageIO.write(bufferedimage, "PNG", new ByteBufOutputStream(bytebuf));
-                ByteBuf bytebuf1 = Base64.encode(bytebuf);
-
-                serverping.setFavicon("data:image/png;base64," + bytebuf1.toString(Charsets.UTF_8));
-            } catch (Exception exception) {
-                MinecraftServer.LOGGER.error("Couldn\'t load server icon", exception);
-            } finally {
-                bytebuf.release();
-            }
-        }
-
-    }
-
-    public File A() {
-        return new File(".");
-    }
-
-    public void a(CrashReport crashreport) {}
-
-    public void B() {}
-
-    protected void C() throws ExceptionWorldConflict { // CraftBukkit - added throws
-        SpigotTimings.serverTickTimer.startTiming(); // Spigot
-        long i = System.nanoTime();
-
-        ++this.ticks;
-        if (this.S) {
-            this.S = false;
-            this.methodProfiler.a = true;
-            this.methodProfiler.a();
-        }
-
-        this.methodProfiler.a("root");
-        this.D();
-        if (i - this.Y >= 5000000000L) {
-            this.Y = i;
-            this.q.setPlayerSample(new ServerPing.ServerPingPlayerSample(this.I(), this.H()));
-            GameProfile[] agameprofile = new GameProfile[Math.min(this.H(), 12)];
-            int j = MathHelper.nextInt(this.r, 0, this.H() - agameprofile.length);
-
-            for (int k = 0; k < agameprofile.length; ++k) {
-                agameprofile[k] = ((EntityPlayer) this.v.v().get(j + k)).getProfile();
-            }
-
-            Collections.shuffle(Arrays.asList(agameprofile));
-            this.q.b().a(agameprofile);
-        }
-
-        if (autosavePeriod > 0 && this.ticks % autosavePeriod == 0) { // CraftBukkit
-            SpigotTimings.worldSaveTimer.startTiming(); // Spigot
-            this.methodProfiler.a("save");
-            this.v.savePlayers();
-            // Spigot Start
-            // We replace this with saving each individual world as this.saveChunks(...) is broken,
-            // and causes the main thread to sleep for random amounts of time depending on chunk activity
-            // Also pass flag to only save modified chunks
-            server.playerCommandState = true;
-            for (World world : worlds) {
-                world.getWorld().save(false);
-            }
-            server.playerCommandState = false;
-            // this.saveChunks(true);
-            // Spigot End
-            this.methodProfiler.b();
-            SpigotTimings.worldSaveTimer.stopTiming(); // Spigot
-        }
-
-        this.methodProfiler.a("tallying");
-        this.h[this.ticks % 100] = System.nanoTime() - i;
-        this.methodProfiler.b();
-        this.methodProfiler.a("snooper");
-        if (getSnooperEnabled() && !this.m.d() && this.ticks > 100) {  // Spigot
-            this.m.a();
-        }
-
-        if (getSnooperEnabled() && this.ticks % 6000 == 0) { // Spigot
-            this.m.b();
-        }
-
-        this.methodProfiler.b();
-        this.methodProfiler.b();
-        org.spigotmc.WatchdogThread.tick(); // Spigot
-        SpigotTimings.serverTickTimer.stopTiming(); // Spigot
-        org.spigotmc.CustomTimingsHandler.tick(); // Spigot
-    }
-
-    public void D() {
-        SpigotTimings.schedulerTimer.startTiming(); // Spigot
-        this.server.getScheduler().mainThreadHeartbeat(this.ticks); // CraftBukkit
-        SpigotTimings.schedulerTimer.stopTiming(); // Spigot
-        this.methodProfiler.a("jobs");
-        Queue queue = this.j;
-
-        // Spigot start
-        FutureTask<?> entry;
-        int count = this.j.size();
-        while (count-- > 0 && (entry = this.j.poll()) != null) {
-            SystemUtils.a(entry, MinecraftServer.LOGGER);
-         }
-        // Spigot end
-
-        this.methodProfiler.c("levels");
-
-        // CraftBukkit start
-        // Run tasks that are waiting on processing
-        SpigotTimings.processQueueTimer.startTiming(); // Spigot
-        while (!processQueue.isEmpty()) {
-            processQueue.remove().run();
-        }
-        SpigotTimings.processQueueTimer.stopTiming(); // Spigot
-
-        SpigotTimings.chunkIOTickTimer.startTiming(); // Spigot
-        org.bukkit.craftbukkit.chunkio.ChunkIOExecutor.tick();
-        SpigotTimings.chunkIOTickTimer.stopTiming(); // Spigot
-
-        SpigotTimings.timeUpdateTimer.startTiming(); // Spigot
-        // Send time updates to everyone, it will get the right time from the world the player is in.
-        if (this.ticks % 20 == 0) {
-            for (int i = 0; i < this.getPlayerList().players.size(); ++i) {
-                EntityPlayer entityplayer = (EntityPlayer) this.getPlayerList().players.get(i);
-                entityplayer.playerConnection.sendPacket(new PacketPlayOutUpdateTime(entityplayer.world.getTime(), entityplayer.getPlayerTime(), entityplayer.world.getGameRules().getBoolean("doDaylightCycle"))); // Add support for per player time
-            }
-        }
-        SpigotTimings.timeUpdateTimer.stopTiming(); // Spigot
-
-        int i;
-
-        for (i = 0; i < this.worlds.size(); ++i) { // CraftBukkit
-            long j = System.nanoTime();
-
-            // if (i == 0 || this.getAllowNether()) {
-                WorldServer worldserver = this.worlds.get(i);
-
-                this.methodProfiler.a(worldserver.getWorldData().getName());
-                /* Drop global time updates
-                if (this.ticks % 20 == 0) {
-                    this.methodProfiler.a("timeSync");
-                    this.v.a((Packet) (new PacketPlayOutUpdateTime(worldserver.getTime(), worldserver.getDayTime(), worldserver.getGameRules().getBoolean("doDaylightCycle"))), worldserver.worldProvider.getDimensionManager().getDimensionID());
-                    this.methodProfiler.b();
-                }
-                // CraftBukkit end */
-
-                this.methodProfiler.a("tick");
-
-                CrashReport crashreport;
-
-                try {
-                    worldserver.timings.doTick.startTiming(); // Spigot
-                    worldserver.doTick();
-                    worldserver.timings.doTick.stopTiming(); // Spigot
-                } catch (Throwable throwable) {
-                    // Spigot Start
-                    try {
-                    crashreport = CrashReport.a(throwable, "Exception ticking world");
-                    } catch (Throwable t){
-                        throw new RuntimeException("Error generating crash report", t);
-                    }
-                    // Spigot End
-                    worldserver.a(crashreport);
-                    throw new ReportedException(crashreport);
-                }
-
-                try {
-                    worldserver.timings.tickEntities.startTiming(); // Spigot
-                    worldserver.tickEntities();
-                    worldserver.timings.tickEntities.stopTiming(); // Spigot
-                } catch (Throwable throwable1) {
-                    // Spigot Start
-                    try {
-                    crashreport = CrashReport.a(throwable1, "Exception ticking world entities");
-                    } catch (Throwable t){
-                        throw new RuntimeException("Error generating crash report", t);
-                    }
-                    // Spigot End
-                    worldserver.a(crashreport);
-                    throw new ReportedException(crashreport);
-                }
-
-                this.methodProfiler.b();
-                this.methodProfiler.a("tracker");
-                worldserver.timings.tracker.startTiming(); // Spigot
-                worldserver.getTracker().updatePlayers();
-                worldserver.timings.tracker.stopTiming(); // Spigot
-                this.methodProfiler.b();
-                this.methodProfiler.b();
-            // } // CraftBukkit
-
-            // this.i[i][this.ticks % 100] = System.nanoTime() - j; // CraftBukkit
-        }
-
-        this.methodProfiler.c("connection");
-        SpigotTimings.connectionTimer.startTiming(); // Spigot
-        this.am().c();
-        SpigotTimings.connectionTimer.stopTiming(); // Spigot
-        this.methodProfiler.c("players");
-        SpigotTimings.playerListTimer.startTiming(); // Spigot
-        this.v.tick();
-        SpigotTimings.playerListTimer.stopTiming(); // Spigot
-        this.methodProfiler.c("tickables");
-
-        SpigotTimings.tickablesTimer.startTiming(); // Spigot
-        for (i = 0; i < this.o.size(); ++i) {
-            ((ITickable) this.o.get(i)).E_();
-        }
-        SpigotTimings.tickablesTimer.stopTiming(); // Spigot
-
-        this.methodProfiler.b();
-    }
-
-    public boolean getAllowNether() {
-        return true;
-    }
-
-    public void a(ITickable itickable) {
-        this.o.add(itickable);
-    }
-
-    public static void main(final OptionSet options) { // CraftBukkit - replaces main(String[] astring)
-        DispenserRegistry.c();
-
-        try {
-            /* CraftBukkit start - Replace everything
-            boolean flag = true;
-            String s = null;
-            String s1 = ".";
-            String s2 = null;
-            boolean flag1 = false;
-            boolean flag2 = false;
-            int i = -1;
-
-            for (int j = 0; j < astring.length; ++j) {
-                String s3 = astring[j];
-                String s4 = j == astring.length - 1 ? null : astring[j + 1];
-                boolean flag3 = false;
-
-                if (!"nogui".equals(s3) && !"--nogui".equals(s3)) {
-                    if ("--port".equals(s3) && s4 != null) {
-                        flag3 = true;
-
-                        try {
-                            i = Integer.parseInt(s4);
-                        } catch (NumberFormatException numberformatexception) {
-                            ;
-                        }
-                    } else if ("--singleplayer".equals(s3) && s4 != null) {
-                        flag3 = true;
-                        s = s4;
-                    } else if ("--universe".equals(s3) && s4 != null) {
-                        flag3 = true;
-                        s1 = s4;
-                    } else if ("--world".equals(s3) && s4 != null) {
-                        flag3 = true;
-                        s2 = s4;
-                    } else if ("--demo".equals(s3)) {
-                        flag1 = true;
-                    } else if ("--bonusChest".equals(s3)) {
-                        flag2 = true;
-                    }
-                } else {
-                    flag = false;
-                }
-
-                if (flag3) {
-                    ++j;
-                }
-            }
-            */ // CraftBukkit end
-
-            String s1 = "."; // PAIL?
-            YggdrasilAuthenticationService yggdrasilauthenticationservice = new YggdrasilAuthenticationService(Proxy.NO_PROXY, UUID.randomUUID().toString());
-            MinecraftSessionService minecraftsessionservice = yggdrasilauthenticationservice.createMinecraftSessionService();
-            GameProfileRepository gameprofilerepository = yggdrasilauthenticationservice.createProfileRepository();
-            UserCache usercache = new UserCache(gameprofilerepository, new File(s1, MinecraftServer.a.getName()));
-            final DedicatedServer dedicatedserver = new DedicatedServer(options, DataConverterRegistry.a(), yggdrasilauthenticationservice, minecraftsessionservice, gameprofilerepository, usercache);
-
-            /* CraftBukkit start
-            if (s != null) {
-                dedicatedserver.i(s);
-            }
-
-            if (s2 != null) {
-                dedicatedserver.setWorld(s2);
-            }
-
-            if (i >= 0) {
-                dedicatedserver.setPort(i);
-            }
-
-            if (flag1) {
-                dedicatedserver.b(true);
-            }
-
-            if (flag2) {
-                dedicatedserver.c(true);
-            }
-
-            if (flag && !GraphicsEnvironment.isHeadless()) {
-                dedicatedserver.aN();
-            }
-
-            dedicatedserver.F();
-            Runtime.getRuntime().addShutdownHook(new Thread("Server Shutdown Thread") {
-                public void run() {
-                    dedicatedserver.stop();
-                }
-            });
-            */
-
-            if (options.has("port")) {
-                int port = (Integer) options.valueOf("port");
-                if (port > 0) {
-                    dedicatedserver.setPort(port);
-                }
-            }
-
-            if (options.has("universe")) {
-                dedicatedserver.universe = (File) options.valueOf("universe");
-            }
-
-            if (options.has("world")) {
-                dedicatedserver.setWorld((String) options.valueOf("world"));
-            }
-
-            dedicatedserver.primaryThread.start();
-            // CraftBukkit end
-        } catch (Exception exception) {
-            MinecraftServer.LOGGER.fatal("Failed to start the minecraft server", exception);
-        }
-
-    }
-
-    public void F() {
-        /* CraftBukkit start - prevent abuse
-        this.serverThread = new Thread(this, "Server thread");
-        this.serverThread.start();
-        // CraftBukkit end */
-    }
-
-    public File d(String s) {
-        return new File(this.A(), s);
-    }
-
-    public void info(String s) {
-        MinecraftServer.LOGGER.info(s);
-    }
-
-    public void warning(String s) {
-        MinecraftServer.LOGGER.warn(s);
-    }
-
-    public WorldServer getWorldServer(int i) {
-        // CraftBukkit start
-        for (WorldServer world : worlds) {
-            if (world.dimension == i) {
-                return world;
-            }
-        }
-        return worlds.get(0);
-        // CraftBukkit end
-    }
-
-    public String getVersion() {
-        return "1.10.2";
-    }
-
-    public int H() {
-        return this.v.getPlayerCount();
-    }
-
-    public int I() {
-        return this.v.getMaxPlayers();
-    }
-
-    public String[] getPlayers() {
-        return this.v.f();
-    }
-
-    public GameProfile[] K() {
-        return this.v.g();
-    }
-
-    public boolean isDebugging() {
-        return this.getPropertyManager().getBoolean("debug", false); // CraftBukkit - don't hardcode
-    }
-
-    public void g(String s) {
-        MinecraftServer.LOGGER.error(s);
-    }
-
-    public void h(String s) {
-        if (this.isDebugging()) {
-            MinecraftServer.LOGGER.info(s);
-        }
-
-    }
-
-    public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
-    }
-
-    public CrashReport b(CrashReport crashreport) {
-        crashreport.g().a("Profiler Position", new CrashReportCallable() {
-            public String a() throws Exception {
-                return MinecraftServer.this.methodProfiler.a ? MinecraftServer.this.methodProfiler.c() : "N/A (disabled)";
-            }
-
-            public Object call() throws Exception {
-                return this.a();
-            }
-        });
-        if (this.v != null) {
-            crashreport.g().a("Player Count", new CrashReportCallable() {
-                public String a() {
-                    return MinecraftServer.this.v.getPlayerCount() + " / " + MinecraftServer.this.v.getMaxPlayers() + "; " + MinecraftServer.this.v.v();
-                }
-
-                public Object call() throws Exception {
-                    return this.a();
-                }
-            });
-        }
-
-        return crashreport;
-    }
-
-    public List<String> tabCompleteCommand(ICommandListener icommandlistener, String s, @Nullable BlockPosition blockposition, boolean flag) {
-        /* CraftBukkit start - Allow tab-completion of Bukkit commands
-        ArrayList arraylist = Lists.newArrayList();
-        boolean flag1 = s.startsWith("/");
-
-        if (flag1) {
-            s = s.substring(1);
-        }
-
-        if (!flag1 && !flag) {
-            String[] astring = s.split(" ", -1);
-            String s1 = astring[astring.length - 1];
-            String[] astring1 = this.v.f();
-            int i = astring1.length;
-
-            for (int j = 0; j < i; ++j) {
-                String s2 = astring1[j];
-
-                if (CommandAbstract.a(s1, s2)) {
-                    arraylist.add(s2);
-                }
-            }
-
-            return arraylist;
-        } else {
-            boolean flag2 = !s.contains(" ");
-            List list = this.b.a(icommandlistener, s, blockposition);
-
-            if (!list.isEmpty()) {
-                Iterator iterator = list.iterator();
-
-                while (iterator.hasNext()) {
-                    String s3 = (String) iterator.next();
-
-                    if (flag2) {
-                        arraylist.add("/" + s3);
-                    } else {
-                        arraylist.add(s3);
-                    }
-                }
-            }
-
-            return arraylist;
-        }
-        */
-        return server.tabComplete(icommandlistener, s, blockposition);
-        // CraftBukkit end
-    }
-
-    public boolean M() {
-        return true; // CraftBukkit
-    }
-
-    public String getName() {
-        return "Server";
-    }
-
-    public void sendMessage(IChatBaseComponent ichatbasecomponent) {
-        MinecraftServer.LOGGER.info(ichatbasecomponent.toPlainText());
-    }
-
-    public boolean a(int i, String s) {
-        return true;
-    }
-
-    public ICommandHandler getCommandHandler() {
-        return this.b;
-    }
-
-    public KeyPair O() {
-        return this.H;
-    }
-
-    public int P() {
-        return this.u;
-    }
-
-    public void setPort(int i) {
-        this.u = i;
-    }
-
-    public String Q() {
-        return this.I;
-    }
-
-    public void i(String s) {
-        this.I = s;
-    }
-
-    public boolean R() {
-        return this.I != null;
-    }
-
-    public String S() {
-        return this.J;
-    }
-
-    public void setWorld(String s) {
-        this.J = s;
-    }
-
-    public void a(KeyPair keypair) {
-        this.H = keypair;
-    }
-
-    public void a(EnumDifficulty enumdifficulty) {
-        // CraftBukkit start
-        // WorldServer[] aworldserver = this.worldServer;
-        int i = this.worlds.size();
-
-        for (int j = 0; j < i; ++j) {
-            WorldServer worldserver = this.worlds.get(j);
-            // CraftBukkit end
-
-            if (worldserver != null) {
-                if (worldserver.getWorldData().isHardcore()) {
-                    worldserver.getWorldData().setDifficulty(EnumDifficulty.HARD);
-                    worldserver.setSpawnFlags(true, true);
-                } else if (this.R()) {
-                    worldserver.getWorldData().setDifficulty(enumdifficulty);
-                    worldserver.setSpawnFlags(worldserver.getDifficulty() != EnumDifficulty.PEACEFUL, true);
-                } else {
-                    worldserver.getWorldData().setDifficulty(enumdifficulty);
-                    worldserver.setSpawnFlags(this.getSpawnMonsters(), this.spawnAnimals);
-                }
-            }
-        }
-
-    }
-
-    public boolean getSpawnMonsters() {
-        return true;
-    }
-
-    public boolean V() {
-        return this.demoMode;
-    }
-
-    public void b(boolean flag) {
-        this.demoMode = flag;
-    }
-
-    public void c(boolean flag) {
-        this.M = flag;
-    }
-
-    public Convertable getConvertable() {
-        return this.convertable;
-    }
-
-    public String getResourcePack() {
-        return this.N;
-    }
-
-    public String getResourcePackHash() {
-        return this.O;
-    }
-
-    public void setResourcePack(String s, String s1) {
-        this.N = s;
-        this.O = s1;
-    }
-
-    public void a(MojangStatisticsGenerator mojangstatisticsgenerator) {
-        mojangstatisticsgenerator.a("whitelist_enabled", Boolean.valueOf(false));
-        mojangstatisticsgenerator.a("whitelist_count", Integer.valueOf(0));
-        if (this.v != null) {
-            mojangstatisticsgenerator.a("players_current", Integer.valueOf(this.H()));
-            mojangstatisticsgenerator.a("players_max", Integer.valueOf(this.I()));
-            mojangstatisticsgenerator.a("players_seen", Integer.valueOf(this.v.getSeenPlayers().length));
-        }
-
-        mojangstatisticsgenerator.a("uses_auth", Boolean.valueOf(this.onlineMode));
-        mojangstatisticsgenerator.a("gui_state", this.ao() ? "enabled" : "disabled");
-        mojangstatisticsgenerator.a("run_time", Long.valueOf((av() - mojangstatisticsgenerator.g()) / 60L * 1000L));
-        mojangstatisticsgenerator.a("avg_tick_ms", Integer.valueOf((int) (MathHelper.a(this.h) * 1.0E-6D)));
-        int i = 0;
-
-        if (this.worldServer != null) {
-            // CraftBukkit start
-            for (int j = 0; j < this.worlds.size(); ++j) {
-                WorldServer worldserver = this.worlds.get(j);
-                if (worldserver != null) {
-                    // CraftBukkit end
-                    WorldData worlddata = worldserver.getWorldData();
-
-                    mojangstatisticsgenerator.a("world[" + i + "][dimension]", Integer.valueOf(worldserver.worldProvider.getDimensionManager().getDimensionID()));
-                    mojangstatisticsgenerator.a("world[" + i + "][mode]", worlddata.getGameType());
-                    mojangstatisticsgenerator.a("world[" + i + "][difficulty]", worldserver.getDifficulty());
-                    mojangstatisticsgenerator.a("world[" + i + "][hardcore]", Boolean.valueOf(worlddata.isHardcore()));
-                    mojangstatisticsgenerator.a("world[" + i + "][generator_name]", worlddata.getType().name());
-                    mojangstatisticsgenerator.a("world[" + i + "][generator_version]", Integer.valueOf(worlddata.getType().getVersion()));
-                    mojangstatisticsgenerator.a("world[" + i + "][height]", Integer.valueOf(this.F));
-                    mojangstatisticsgenerator.a("world[" + i + "][chunks_loaded]", Integer.valueOf(worldserver.getChunkProviderServer().g()));
-                    ++i;
-                }
-            }
-        }
-
-        mojangstatisticsgenerator.a("worlds", Integer.valueOf(i));
-    }
-
-    public void b(MojangStatisticsGenerator mojangstatisticsgenerator) {
-        mojangstatisticsgenerator.b("singleplayer", Boolean.valueOf(this.R()));
-        mojangstatisticsgenerator.b("server_brand", this.getServerModName());
-        mojangstatisticsgenerator.b("gui_supported", GraphicsEnvironment.isHeadless() ? "headless" : "supported");
-        mojangstatisticsgenerator.b("dedicated", Boolean.valueOf(this.aa()));
-    }
-
-    public boolean getSnooperEnabled() {
-        return true;
-    }
-
-    public abstract boolean aa();
-
-    public boolean getOnlineMode() {
-        return server.getOnlineMode(); // CraftBukkit
-    }
-
-    public void setOnlineMode(boolean flag) {
-        this.onlineMode = flag;
-    }
-
-    public boolean getSpawnAnimals() {
-        return this.spawnAnimals;
-    }
-
-    public void setSpawnAnimals(boolean flag) {
-        this.spawnAnimals = flag;
-    }
-
-    public boolean getSpawnNPCs() {
-        return this.spawnNPCs;
-    }
-
-    public abstract boolean ae();
-
-    public void setSpawnNPCs(boolean flag) {
-        this.spawnNPCs = flag;
-    }
-
-    public boolean getPVP() {
-        return this.pvpMode;
-    }
-
-    public void setPVP(boolean flag) {
-        this.pvpMode = flag;
-    }
-
-    public boolean getAllowFlight() {
-        return this.allowFlight;
-    }
-
-    public void setAllowFlight(boolean flag) {
-        this.allowFlight = flag;
-    }
-
-    public abstract boolean getEnableCommandBlock();
-
-    public String getMotd() {
-        return this.motd;
-    }
-
-    public void setMotd(String s) {
-        this.motd = s;
-    }
-
-    public int getMaxBuildHeight() {
-        return this.F;
-    }
-
-    public void c(int i) {
-        this.F = i;
-    }
-
-    public boolean isStopped() {
-        return this.isStopped;
-    }
-
-    public PlayerList getPlayerList() {
-        return this.v;
-    }
-
-    public void a(PlayerList playerlist) {
-        this.v = playerlist;
-    }
-
-    public void setGamemode(EnumGamemode enumgamemode) {
-        // CraftBukkit start
-        for (int i = 0; i < this.worlds.size(); ++i) {
-            worlds.get(i).getWorldData().setGameType(enumgamemode);
-        }
-
-    }
-
-    // Spigot Start
-    public ServerConnection getServerConnection()
-    {
-        return this.p;
-    }
-    // Spigot End
-    public ServerConnection am() {
-        return this.p == null ? this.p = new ServerConnection(this) : this.p; // Spigot
-    }
-
-    public boolean ao() {
-        return false;
-    }
-
-    public abstract String a(EnumGamemode enumgamemode, boolean flag);
-
-    public int ap() {
-        return this.ticks;
-    }
-
-    public void aq() {
-        this.S = true;
-    }
-
-    public BlockPosition getChunkCoordinates() {
-        return BlockPosition.ZERO;
-    }
-
-    public Vec3D d() {
-        return Vec3D.a;
-    }
-
-    public World getWorld() {
-        return this.worlds.get(0); // CraftBukkit
-    }
-
-    public Entity f() {
-        return null;
-    }
-
-    public int getSpawnProtection() {
-        return 16;
-    }
-
-    public boolean a(World world, BlockPosition blockposition, EntityHuman entityhuman) {
-        return false;
-    }
-
-    public void setForceGamemode(boolean flag) {
-        this.T = flag;
-    }
-
-    public boolean getForceGamemode() {
-        return this.T;
-    }
-
-    public Proxy au() {
-        return this.e;
-    }
-
-    public static long av() {
-        return System.currentTimeMillis();
-    }
-
-    public int getIdleTimeout() {
-        return this.G;
-    }
-
-    public void setIdleTimeout(int i) {
-        this.G = i;
-    }
-
-    public IChatBaseComponent getScoreboardDisplayName() {
-        return new ChatComponentText(this.getName());
-    }
-
-    public boolean ax() {
-        return true;
-    }
-
-    public MinecraftSessionService ay() {
-        return this.V;
-    }
-
-    public GameProfileRepository getGameProfileRepository() {
-        return this.W;
-    }
-
-    public UserCache getUserCache() {
-        return this.X;
-    }
-
-    public ServerPing getServerPing() {
-        return this.q;
-    }
-
-    public void aC() {
-        this.Y = 0L;
-    }
-
-    @Nullable
-    public Entity a(UUID uuid) {
-        WorldServer[] aworldserver = this.worldServer;
-        int i = aworldserver.length;
-
-        // CraftBukkit start
-        for (int j = 0; j < worlds.size(); ++j) {
-            WorldServer worldserver = worlds.get(j);
-            // CraftBukkit end
-
-            if (worldserver != null) {
-                Entity entity = worldserver.getEntity(uuid);
-
-                if (entity != null) {
-                    return entity;
-                }
-            }
-        }
-
-        return null;
-    }
-
-    public boolean getSendCommandFeedback() {
-        return worlds.get(0).getGameRules().getBoolean("sendCommandFeedback");
-    }
-
-    public void a(CommandObjectiveExecutor.EnumCommandResult commandobjectiveexecutor_enumcommandresult, int i) {}
-
-    public MinecraftServer h() {
-        return this;
-    }
-
-    public int aD() {
-        return 29999984;
-    }
-
-    public <V> ListenableFuture<V> a(Callable<V> callable) {
-        Validate.notNull(callable);
-        if (!this.isMainThread()) { // CraftBukkit && !this.isStopped()) {
-            ListenableFutureTask listenablefuturetask = ListenableFutureTask.create(callable);
-            Queue queue = this.j;
-
-            // Spigot start
-            this.j.add(listenablefuturetask);
-            return listenablefuturetask;
-            // Spigot end
-        } else {
-            try {
-                return Futures.immediateFuture(callable.call());
-            } catch (Exception exception) {
-                return Futures.immediateFailedCheckedFuture(exception);
-            }
-        }
-    }
-
-    public ListenableFuture<Object> postToMainThread(Runnable runnable) {
-        Validate.notNull(runnable);
-        return this.a(Executors.callable(runnable));
-    }
-
-    public boolean isMainThread() {
-        return Thread.currentThread() == this.serverThread;
-    }
-
-    public int aF() {
-        return 256;
-    }
-
-    public long aG() {
-        return this.aa;
-    }
-
-    public Thread aH() {
-        return this.serverThread;
-    }
-
-    public DataConverterManager getDataConverterManager() {
-        return this.dataConverterManager;
-    }
-
-    public int a(@Nullable WorldServer worldserver) {
-        return worldserver != null ? worldserver.getGameRules().c("spawnRadius") : 10;
-    }
-
-    // CraftBukkit start
-    @Deprecated
-    public static MinecraftServer getServer() {
-        return (Bukkit.getServer() instanceof CraftServer) ? ((CraftServer) Bukkit.getServer()).getServer() : null;
-    }
-    // CraftBukkit end
-}
+package net.minecraft.server;
+
+import com.google.common.base.Charsets;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
+import com.google.common.util.concurrent.Futures;
+import com.google.common.util.concurrent.ListenableFuture;
+import com.google.common.util.concurrent.ListenableFutureTask;
+import com.mojang.authlib.GameProfile;
+import com.mojang.authlib.GameProfileRepository;
+import com.mojang.authlib.minecraft.MinecraftSessionService;
+import com.mojang.authlib.yggdrasil.YggdrasilAuthenticationService;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufOutputStream;
+import io.netty.buffer.Unpooled;
+import io.netty.handler.codec.base64.Base64;
+import java.awt.GraphicsEnvironment;
+import java.awt.image.BufferedImage;
+import java.io.File;
+import java.io.IOException;
+import java.net.Proxy;
+import java.security.KeyPair;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Queue;
+import java.util.Random;
+import java.util.UUID;
+import java.util.concurrent.Callable;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ForkJoinTask;
+import java.util.concurrent.FutureTask;
+import java.util.logging.Level;
+import javax.annotation.Nullable;
+import javax.imageio.ImageIO;
+import org.apache.commons.lang3.Validate;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+// CraftBukkit start
+import jline.console.ConsoleReader;
+import joptsimple.OptionSet;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.Main;
+// CraftBukkit end
+import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.spigotmc.SpigotWorldConfig;
+
+public abstract class MinecraftServer implements Runnable, ICommandListener, IAsyncTaskHandler, IMojangStatistics {
+
+    public static final Logger LOGGER = LogManager.getLogger();
+    public static final File a = new File("usercache.json");
+    public Convertable convertable;
+    private final MojangStatisticsGenerator m = new MojangStatisticsGenerator("server", this, av());
+    public File universe;
+    private final List<ITickable> o = Lists.newArrayList();
+    public final ICommandHandler b;
+    public final MethodProfiler methodProfiler = new MethodProfiler();
+    private ServerConnection p; // Spigot
+    private final ServerPing q = new ServerPing();
+    private final Random r = new Random();
+    private final DataConverterManager dataConverterManager;
+    private String serverIp;
+    private int u = -1;
+    public WorldServer[] worldServer;
+    private PlayerList v;
+    private boolean isRunning = true;
+    private boolean isStopped;
+    private int ticks;
+    protected final Proxy e;
+    public String f;
+    public int g;
+    private boolean onlineMode;
+    private boolean spawnAnimals;
+    private boolean spawnNPCs;
+    private boolean pvpMode;
+    private boolean allowFlight;
+    private String motd;
+    private int F;
+    private int G;
+    public final long[] h = new long[100];
+    public long[][] i;
+    private KeyPair H;
+    private String I;
+    private String J;
+    private boolean demoMode;
+    private boolean M;
+    private String N = "";
+    private String O = "";
+    private boolean P;
+    private long Q;
+    private String R;
+    private boolean S;
+    private boolean T;
+    private final YggdrasilAuthenticationService U;
+    private final MinecraftSessionService V;
+    private final GameProfileRepository W;
+    private final UserCache X;
+    private long Y;
+    protected final Queue<FutureTask<?>> j = new java.util.concurrent.ConcurrentLinkedQueue<FutureTask<?>>(); // Spigot, PAIL: Rename
+    private Thread serverThread;
+    private long aa = av();
+
+    // CraftBukkit start
+    public List<WorldServer> worlds = new ArrayList<WorldServer>();
+    public org.bukkit.craftbukkit.CraftServer server;
+    public OptionSet options;
+    public org.bukkit.command.ConsoleCommandSender console;
+    public org.bukkit.command.RemoteConsoleCommandSender remoteConsole;
+    public ConsoleReader reader;
+    public static int currentTick = (int) (System.currentTimeMillis() / 50);
+    public final Thread primaryThread;
+    public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
+    public int autosavePeriod;
+    // CraftBukkit end
+    // Spigot start
+    private static final int TPS = 20;
+    private static final int TICK_TIME = 1000000000 / TPS;
+    private static final int SAMPLE_INTERVAL = 100;
+    public final double[] recentTps = new double[ 3 ];
+    // Spigot end
+
+    public MinecraftServer(OptionSet options, Proxy proxy, DataConverterManager dataconvertermanager, YggdrasilAuthenticationService yggdrasilauthenticationservice, MinecraftSessionService minecraftsessionservice, GameProfileRepository gameprofilerepository, UserCache usercache) {
+        io.netty.util.ResourceLeakDetector.setEnabled( false ); // Spigot - disable
+        this.e = proxy;
+        this.U = yggdrasilauthenticationservice;
+        this.V = minecraftsessionservice;
+        this.W = gameprofilerepository;
+        this.X = usercache;
+        // this.universe = file; // CraftBukkit
+        // this.p = new ServerConnection(this); // Spigot
+        this.b = this.i();
+        // this.convertable = new WorldLoaderServer(file); // CraftBukkit - moved to DedicatedServer.init
+        this.dataConverterManager = dataconvertermanager;
+        // CraftBukkit start
+        this.options = options;
+        // Try to see if we're actually running in a terminal, disable jline if not
+        if (System.console() == null && System.getProperty("jline.terminal") == null) {
+            System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
+            Main.useJline = false;
+        }
+
+        try {
+            reader = new ConsoleReader(System.in, System.out);
+            reader.setExpandEvents(false); // Avoid parsing exceptions for uncommonly used event designators
+        } catch (Throwable e) {
+            try {
+                // Try again with jline disabled for Windows users without C++ 2008 Redistributable
+                System.setProperty("jline.terminal", "jline.UnsupportedTerminal");
+                System.setProperty("user.language", "en");
+                Main.useJline = false;
+                reader = new ConsoleReader(System.in, System.out);
+                reader.setExpandEvents(false);
+            } catch (IOException ex) {
+                LOGGER.warn((String) null, ex);
+            }
+        }
+        Runtime.getRuntime().addShutdownHook(new org.bukkit.craftbukkit.util.ServerShutdownThread(this));
+
+        this.serverThread = primaryThread = new Thread(this, "Server thread"); // Moved from main
+    }
+
+    public abstract PropertyManager getPropertyManager();
+    // CraftBukkit end
+
+    protected CommandDispatcher i() {
+        return new CommandDispatcher(this);
+    }
+
+    public abstract boolean init() throws IOException;
+
+    protected void a(String s) {
+        if (this.getConvertable().isConvertable(s)) {
+            MinecraftServer.LOGGER.info("Converting map!");
+            this.b("menu.convertingLevel");
+            this.getConvertable().convert(s, new IProgressUpdate() {
+                private long b = System.currentTimeMillis();
+
+                public void a(String s) {}
+
+                public void a(int i) {
+                    if (System.currentTimeMillis() - this.b >= 1000L) {
+                        this.b = System.currentTimeMillis();
+                        MinecraftServer.LOGGER.info("Converting... {}%", new Object[] { Integer.valueOf(i)});
+                    }
+
+                }
+
+                public void c(String s) {}
+            });
+        }
+
+    }
+
+    protected synchronized void b(String s) {
+        this.R = s;
+    }
+
+    public void a(String s, String s1, long i, WorldType worldtype, String s2) {
+        this.a(s);
+        this.b("menu.loadingLevel");
+        this.worldServer = new WorldServer[3];
+        /* CraftBukkit start - Remove ticktime arrays and worldsettings
+        this.i = new long[this.worldServer.length][100];
+        IDataManager idatamanager = this.convertable.a(s, true);
+
+        this.a(this.S(), idatamanager);
+        WorldData worlddata = idatamanager.getWorldData();
+        WorldSettings worldsettings;
+
+        if (worlddata == null) {
+            if (this.V()) {
+                worldsettings = DemoWorldServer.a;
+            } else {
+                worldsettings = new WorldSettings(i, this.getGamemode(), this.getGenerateStructures(), this.isHardcore(), worldtype);
+                worldsettings.setGeneratorSettings(s2);
+                if (this.M) {
+                    worldsettings.a();
+                }
+            }
+
+            worlddata = new WorldData(worldsettings, s1);
+        } else {
+            worlddata.a(s1);
+            worldsettings = new WorldSettings(worlddata);
+        }
+        */
+        int worldCount = 3;
+
+        for (int j = 0; j < worldCount; ++j) {
+            WorldServer world;
+            byte dimension = 0;
+
+            if (j == 1) {
+                if (getAllowNether()) {
+                    dimension = -1;
+                } else {
+                    continue;
+                }
+            }
+
+            if (j == 2) {
+                if (server.getAllowEnd()) {
+                    dimension = 1;
+                } else {
+                    continue;
+                }
+            }
+
+            String worldType = org.bukkit.World.Environment.getEnvironment(dimension).toString().toLowerCase();
+            String name = (dimension == 0) ? s : s + "_" + worldType;
+
+            org.bukkit.generator.ChunkGenerator gen = this.server.getGenerator(name);
+            WorldSettings worldsettings = new WorldSettings(i, this.getGamemode(), this.getGenerateStructures(), this.isHardcore(), worldtype);
+            worldsettings.setGeneratorSettings(s2);
+
+            if (j == 0) {
+                IDataManager idatamanager = new ServerNBTManager(server.getWorldContainer(), s1, true, this.dataConverterManager);
+                WorldData worlddata = idatamanager.getWorldData();
+                if (worlddata == null) {
+                    worlddata = new WorldData(worldsettings, s1);
+                }
+                worlddata.checkName(s1); // CraftBukkit - Migration did not rewrite the level.dat; This forces 1.8 to take the last loaded world as respawn (in this case the end)
+                if (this.V()) {
+                    world = (WorldServer) (new DemoWorldServer(this, idatamanager, worlddata, dimension, this.methodProfiler)).b();
+                } else {
+                    world = (WorldServer) (new WorldServer(this, idatamanager, worlddata, dimension, this.methodProfiler, org.bukkit.World.Environment.getEnvironment(dimension), gen)).b();
+                }
+
+                world.a(worldsettings);
+                this.server.scoreboardManager = new org.bukkit.craftbukkit.scoreboard.CraftScoreboardManager(this, world.getScoreboard());
+            } else {
+                String dim = "DIM" + dimension;
+
+                File newWorld = new File(new File(name), dim);
+                File oldWorld = new File(new File(s), dim);
+
+                if ((!newWorld.isDirectory()) && (oldWorld.isDirectory())) {
+                    MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder required ----");
+                    MinecraftServer.LOGGER.info("Unfortunately due to the way that Minecraft implemented multiworld support in 1.6, Bukkit requires that you move your " + worldType + " folder to a new location in order to operate correctly.");
+                    MinecraftServer.LOGGER.info("We will move this folder for you, but it will mean that you need to move it back should you wish to stop using Bukkit in the future.");
+                    MinecraftServer.LOGGER.info("Attempting to move " + oldWorld + " to " + newWorld + "...");
+
+                    if (newWorld.exists()) {
+                        MinecraftServer.LOGGER.warn("A file or folder already exists at " + newWorld + "!");
+                        MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder failed ----");
+                    } else if (newWorld.getParentFile().mkdirs()) {
+                        if (oldWorld.renameTo(newWorld)) {
+                            MinecraftServer.LOGGER.info("Success! To restore " + worldType + " in the future, simply move " + newWorld + " to " + oldWorld);
+                            // Migrate world data too.
+                            try {
+                                com.google.common.io.Files.copy(new File(new File(s), "level.dat"), new File(new File(name), "level.dat"));
+                                org.apache.commons.io.FileUtils.copyDirectory(new File(new File(s), "data"), new File(new File(name), "data"));
+                            } catch (IOException exception) {
+                                MinecraftServer.LOGGER.warn("Unable to migrate world data.");
+                            }
+                            MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder complete ----");
+                        } else {
+                            MinecraftServer.LOGGER.warn("Could not move folder " + oldWorld + " to " + newWorld + "!");
+                            MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder failed ----");
+                        }
+                    } else {
+                        MinecraftServer.LOGGER.warn("Could not create path for " + newWorld + "!");
+                        MinecraftServer.LOGGER.info("---- Migration of old " + worldType + " folder failed ----");
+                    }
+                }
+
+                IDataManager idatamanager = new ServerNBTManager(server.getWorldContainer(), name, true, this.dataConverterManager);
+                // world =, b0 to dimension, s1 to name, added Environment and gen
+                WorldData worlddata = idatamanager.getWorldData();
+                if (worlddata == null) {
+                    worlddata = new WorldData(worldsettings, name);
+                }
+                worlddata.checkName(name); // CraftBukkit - Migration did not rewrite the level.dat; This forces 1.8 to take the last loaded world as respawn (in this case the end)
+                world = (WorldServer) new SecondaryWorldServer(this, idatamanager, dimension, this.worlds.get(0), this.methodProfiler, worlddata, org.bukkit.World.Environment.getEnvironment(dimension), gen).b();
+            }
+
+            this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldInitEvent(world.getWorld()));
+
+            world.addIWorldAccess(new WorldManager(this, world));
+            if (!this.R()) {
+                world.getWorldData().setGameType(this.getGamemode());
+            }
+
+            worlds.add(world);
+            getPlayerList().setPlayerFileData(worlds.toArray(new WorldServer[worlds.size()]));
+        }
+        // CraftBukkit end
+        this.v.setPlayerFileData(this.worldServer);
+        this.a(this.getDifficulty());
+        this.l();
+    }
+
+    protected void l() {
+        boolean flag = true;
+        boolean flag1 = true;
+        boolean flag2 = true;
+        boolean flag3 = true;
+        int i = 0;
+
+        this.b("menu.generatingTerrain");
+        boolean flag4 = false;
+
+        // CraftBukkit start - fire WorldLoadEvent and handle whether or not to keep the spawn in memory
+        for (int m = 0; m < worlds.size(); m++) {
+            WorldServer worldserver = this.worlds.get(m);
+            MinecraftServer.LOGGER.info("Preparing start region for level " + m + " (Seed: " + worldserver.getSeed() + ")");
+
+            if (!worldserver.getWorld().getKeepSpawnInMemory()) {
+                continue;
+            }
+
+            BlockPosition blockposition = worldserver.getSpawn();
+            long j = av();
+            i = 0;
+
+            for (int k = -192; k <= 192 && this.isRunning(); k += 16) {
+                for (int l = -192; l <= 192 && this.isRunning(); l += 16) {
+                    long i1 = av();
+
+                    if (i1 - j > 1000L) {
+                        this.a_("Preparing spawn area", i * 100 / 625);
+                        j = i1;
+                    }
+
+                    ++i;
+                    worldserver.getChunkProviderServer().getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                }
+            }
+        }
+
+        for (WorldServer world : this.worlds) {
+            this.server.getPluginManager().callEvent(new org.bukkit.event.world.WorldLoadEvent(world.getWorld()));
+        }
+        // CraftBukkit end
+        this.t();
+    }
+
+    protected void a(String s, IDataManager idatamanager) {
+        File file = new File(idatamanager.getDirectory(), "resources.zip");
+
+        if (file.isFile()) {
+            this.setResourcePack("level://" + s + "/" + "resources.zip", "");
+        }
+
+    }
+
+    public abstract boolean getGenerateStructures();
+
+    public abstract EnumGamemode getGamemode();
+
+    public abstract EnumDifficulty getDifficulty();
+
+    public abstract boolean isHardcore();
+
+    public abstract int q();
+
+    public abstract boolean r();
+
+    public abstract boolean s();
+
+    protected void a_(String s, int i) {
+        this.f = s;
+        this.g = i;
+        MinecraftServer.LOGGER.info("{}: {}%", new Object[] { s, Integer.valueOf(i)});
+    }
+
+    protected void t() {
+        this.f = null;
+        this.g = 0;
+        this.server.enablePlugins(org.bukkit.plugin.PluginLoadOrder.POSTWORLD); // CraftBukkit
+    }
+
+    protected void saveChunks(boolean flag) {
+        WorldServer[] aworldserver = this.worldServer;
+        int i = aworldserver.length;
+
+        // CraftBukkit start
+        for (int j = 0; j < worlds.size(); ++j) {
+            WorldServer worldserver = worlds.get(j);
+            // CraftBukkit end
+
+            if (worldserver != null) {
+                if (!flag) {
+                    MinecraftServer.LOGGER.info("Saving chunks for level \'{}\'/{}", new Object[] { worldserver.getWorldData().getName(), worldserver.worldProvider.getDimensionManager().b()});
+                }
+
+                try {
+                    worldserver.save(true, (IProgressUpdate) null);
+                    worldserver.saveLevel(); // CraftBukkit
+                } catch (ExceptionWorldConflict exceptionworldconflict) {
+                    MinecraftServer.LOGGER.warn(exceptionworldconflict.getMessage());
+                }
+            }
+        }
+
+    }
+
+    // CraftBukkit start
+    private boolean hasStopped = false;
+    private final Object stopLock = new Object();
+    // CraftBukkit end
+
+    public void stop() throws ExceptionWorldConflict { // CraftBukkit - added throws
+        // CraftBukkit start - prevent double stopping on multiple threads
+        synchronized(stopLock) {
+            if (hasStopped) return;
+            hasStopped = true;
+        }
+        // CraftBukkit end
+        MinecraftServer.LOGGER.info("Stopping server");
+        // CraftBukkit start
+        if (this.server != null) {
+            this.server.disablePlugins();
+        }
+        // CraftBukkit end
+        if (this.am() != null) {
+            this.am().b();
+        }
+
+        if (this.v != null) {
+            MinecraftServer.LOGGER.info("Saving players");
+            this.v.savePlayers();
+            this.v.u();
+            try { Thread.sleep(100); } catch (InterruptedException ex) {} // CraftBukkit - SPIGOT-625 - give server at least a chance to send packets
+        }
+
+        if (this.worldServer != null) {
+            MinecraftServer.LOGGER.info("Saving worlds");
+            WorldServer[] aworldserver = this.worldServer;
+            int i = aworldserver.length;
+
+            int j;
+            WorldServer worldserver;
+
+            for (j = 0; j < i; ++j) {
+                worldserver = aworldserver[j];
+                if (worldserver != null) {
+                    worldserver.savingDisabled = false;
+                }
+            }
+
+            this.saveChunks(false);
+            aworldserver = this.worldServer;
+            i = aworldserver.length;
+
+            /* CraftBukkit start - Handled in saveChunks
+            for (j = 0; j < i; ++j) {
+                worldserver = aworldserver[j];
+                if (worldserver != null) {
+                    worldserver.saveLevel();
+                }
+            }
+            // CraftBukkit end */
+        }
+
+        if (this.m.d()) {
+            this.m.e();
+        }
+
+        // Spigot start
+        if (org.spigotmc.SpigotConfig.saveUserCacheOnStopOnly) {
+            LOGGER.info("Saving usercache.json");
+            this.X.c();
+        }
+        // Spigot end
+    }
+
+    public String getServerIp() {
+        return this.serverIp;
+    }
+
+    public void c(String s) {
+        this.serverIp = s;
+    }
+
+    public boolean isRunning() {
+        return this.isRunning;
+    }
+
+    public void safeShutdown() {
+        this.isRunning = false;
+    }
+
+    // Spigot Start
+    private static double calcTps(double avg, double exp, double tps)
+    {
+        return ( avg * exp ) + ( tps * ( 1 - exp ) );
+    }
+    // Spigot End
+ 
+    public void run() {
+        try {
+            if (this.init()) {
+                this.aa = av();
+                long i = 0L;
+
+                this.q.setMOTD(new ChatComponentText(this.motd));
+                this.q.setServerInfo(new ServerPing.ServerData("1.10.2", 210));
+                this.a(this.q);
+
+                // Spigot start
+                Arrays.fill( recentTps, 20 );
+                long lastTick = System.nanoTime(), catchupTime = 0, curTime, wait, tickSection = lastTick;
+                while (this.isRunning) {
+                    curTime = System.nanoTime();
+                    wait = TICK_TIME - (curTime - lastTick) - catchupTime;
+                    if (wait > 0) {
+                        Thread.sleep(wait / 1000000);
+                        catchupTime = 0;
+                        continue;
+                    } else {
+                        catchupTime = Math.min(1000000000, Math.abs(wait));
+                    }
+
+                    if ( MinecraftServer.currentTick++ % SAMPLE_INTERVAL == 0 )
+                    {
+                        double currentTps = 1E9 / ( curTime - tickSection ) * SAMPLE_INTERVAL;
+                        recentTps[0] = calcTps( recentTps[0], 0.92, currentTps ); // 1/exp(5sec/1min)
+                        recentTps[1] = calcTps( recentTps[1], 0.9835, currentTps ); // 1/exp(5sec/5min)
+                        recentTps[2] = calcTps( recentTps[2], 0.9945, currentTps ); // 1/exp(5sec/15min)
+                        tickSection = curTime;
+                    }
+                    lastTick = curTime;
+
+                    this.C();
+                    this.P = true;
+                }
+                // Spigot end
+            } else {
+                this.a((CrashReport) null);
+            }
+        } catch (Throwable throwable) {
+            MinecraftServer.LOGGER.error("Encountered an unexpected exception", throwable);
+            // Spigot Start
+            if ( throwable.getCause() != null )
+            {
+                MinecraftServer.LOGGER.error( "\tCause of unexpected exception was", throwable.getCause() );
+            }
+            // Spigot End
+            CrashReport crashreport = null;
+
+            if (throwable instanceof ReportedException) {
+                crashreport = this.b(((ReportedException) throwable).a());
+            } else {
+                crashreport = this.b(new CrashReport("Exception in server tick loop", throwable));
+            }
+
+            File file = new File(new File(this.A(), "crash-reports"), "crash-" + (new SimpleDateFormat("yyyy-MM-dd_HH.mm.ss")).format(new Date()) + "-server.txt");
+
+            if (crashreport.a(file)) {
+                MinecraftServer.LOGGER.error("This crash report has been saved to: {}", new Object[] { file.getAbsolutePath()});
+            } else {
+                MinecraftServer.LOGGER.error("We were unable to save this crash report to disk.");
+            }
+
+            this.a(crashreport);
+        } finally {
+            try {
+                org.spigotmc.WatchdogThread.doStop();
+                this.isStopped = true;
+                this.stop();
+            } catch (Throwable throwable1) {
+                MinecraftServer.LOGGER.error("Exception stopping the server", throwable1);
+            } finally {
+                // CraftBukkit start - Restore terminal to original settings
+                try {
+                    reader.getTerminal().restore();
+                } catch (Exception ignored) {
+                }
+                // CraftBukkit end
+                this.B();
+            }
+
+        }
+
+    }
+
+    public void a(ServerPing serverping) {
+        File file = this.d("server-icon.png");
+
+        if (!file.exists()) {
+            file = this.getConvertable().b(this.S(), "icon.png");
+        }
+
+        if (file.isFile()) {
+            ByteBuf bytebuf = Unpooled.buffer();
+
+            try {
+                BufferedImage bufferedimage = ImageIO.read(file);
+
+                Validate.validState(bufferedimage.getWidth() == 64, "Must be 64 pixels wide", new Object[0]);
+                Validate.validState(bufferedimage.getHeight() == 64, "Must be 64 pixels high", new Object[0]);
+                ImageIO.write(bufferedimage, "PNG", new ByteBufOutputStream(bytebuf));
+                ByteBuf bytebuf1 = Base64.encode(bytebuf);
+
+                serverping.setFavicon("data:image/png;base64," + bytebuf1.toString(Charsets.UTF_8));
+            } catch (Exception exception) {
+                MinecraftServer.LOGGER.error("Couldn\'t load server icon", exception);
+            } finally {
+                bytebuf.release();
+            }
+        }
+
+    }
+
+    public File A() {
+        return new File(".");
+    }
+
+    public void a(CrashReport crashreport) {}
+
+    public void B() {}
+
+    protected void C() throws ExceptionWorldConflict { // CraftBukkit - added throws
+        SpigotTimings.serverTickTimer.startTiming(); // Spigot
+        long i = System.nanoTime();
+
+        ++this.ticks;
+        if (this.S) {
+            this.S = false;
+            this.methodProfiler.a = true;
+            this.methodProfiler.a();
+        }
+
+        this.methodProfiler.a("root");
+        this.D();
+        if (i - this.Y >= 5000000000L) {
+            this.Y = i;
+            this.q.setPlayerSample(new ServerPing.ServerPingPlayerSample(this.I(), this.H()));
+            GameProfile[] agameprofile = new GameProfile[Math.min(this.H(), 12)];
+            int j = MathHelper.nextInt(this.r, 0, this.H() - agameprofile.length);
+
+            for (int k = 0; k < agameprofile.length; ++k) {
+                agameprofile[k] = ((EntityPlayer) this.v.v().get(j + k)).getProfile();
+            }
+
+            Collections.shuffle(Arrays.asList(agameprofile));
+            this.q.b().a(agameprofile);
+        }
+
+        if (autosavePeriod > 0 && this.ticks % autosavePeriod == 0) { // CraftBukkit
+            SpigotTimings.worldSaveTimer.startTiming(); // Spigot
+            //try to fork this
+            this.methodProfiler.a("save");
+            this.v.savePlayers();
+            // Spigot Start
+            // We replace this with saving each individual world as this.saveChunks(...) is broken,
+            // and causes the main thread to sleep for random amounts of time depending on chunk activity
+            // Also pass flag to only save modified chunks
+            server.playerCommandState = true;
+            this.worlds.parallelStream().forEach(world -> world.getWorld().save(false));
+            /*for (World world : worlds) {
+                world.getWorld().save(false);
+            }*/
+            server.playerCommandState = false;
+            // this.saveChunks(true);
+            // Spigot End
+            this.methodProfiler.b();
+            SpigotTimings.worldSaveTimer.stopTiming(); // Spigot
+        }
+
+        this.methodProfiler.a("tallying");
+        this.h[this.ticks % 100] = System.nanoTime() - i;
+        this.methodProfiler.b();
+        this.methodProfiler.a("snooper");
+        if (getSnooperEnabled() && !this.m.d() && this.ticks > 100) {  // Spigot
+            this.m.a();
+        }
+
+        if (getSnooperEnabled() && this.ticks % 6000 == 0) { // Spigot
+            this.m.b();
+        }
+
+        this.methodProfiler.b();
+        this.methodProfiler.b();
+        org.spigotmc.WatchdogThread.tick(); // Spigot
+        SpigotTimings.serverTickTimer.stopTiming(); // Spigot
+        org.spigotmc.CustomTimingsHandler.tick(); // Spigot
+    }
+
+    public void D() {
+        SpigotTimings.schedulerTimer.startTiming(); // Spigot
+        this.server.getScheduler().mainThreadHeartbeat(this.ticks); // CraftBukkit
+        SpigotTimings.schedulerTimer.stopTiming(); // Spigot
+        this.methodProfiler.a("jobs");
+        Queue queue = this.j;
+
+        // Spigot start
+        FutureTask<?> entry;
+        int count = this.j.size();
+        while (count-- > 0 && (entry = this.j.poll()) != null) {
+            SystemUtils.a(entry, MinecraftServer.LOGGER);
+         }
+        // Spigot end
+
+        this.methodProfiler.c("levels");
+
+        // CraftBukkit start
+        // Run tasks that are waiting on processing
+        SpigotTimings.processQueueTimer.startTiming(); // Spigot
+        while (!processQueue.isEmpty()) {
+            processQueue.remove().run();
+        }
+        SpigotTimings.processQueueTimer.stopTiming(); // Spigot
+
+        SpigotTimings.chunkIOTickTimer.startTiming(); // Spigot
+        org.bukkit.craftbukkit.chunkio.ChunkIOExecutor.tick();
+        SpigotTimings.chunkIOTickTimer.stopTiming(); // Spigot
+
+        SpigotTimings.timeUpdateTimer.startTiming(); // Spigot
+        // Send time updates to everyone, it will get the right time from the world the player is in.
+        if (this.ticks % 20 == 0) {
+            for (int i = 0; i < this.getPlayerList().players.size(); ++i) {
+                EntityPlayer entityplayer = (EntityPlayer) this.getPlayerList().players.get(i);
+                entityplayer.playerConnection.sendPacket(new PacketPlayOutUpdateTime(entityplayer.world.getTime(), entityplayer.getPlayerTime(), entityplayer.world.getGameRules().getBoolean("doDaylightCycle"))); // Add support for per player time
+            }
+        }
+        SpigotTimings.timeUpdateTimer.stopTiming(); // Spigot
+
+        int i;
+
+        for (i = 0; i < this.worlds.size(); ++i) { // CraftBukkit
+            long j = System.nanoTime();
+
+            // if (i == 0 || this.getAllowNether()) {
+                WorldServer worldserver = this.worlds.get(i);
+
+                this.methodProfiler.a(worldserver.getWorldData().getName());
+                /* Drop global time updates
+                if (this.ticks % 20 == 0) {
+                    this.methodProfiler.a("timeSync");
+                    this.v.a((Packet) (new PacketPlayOutUpdateTime(worldserver.getTime(), worldserver.getDayTime(), worldserver.getGameRules().getBoolean("doDaylightCycle"))), worldserver.worldProvider.getDimensionManager().getDimensionID());
+                    this.methodProfiler.b();
+                }
+                // CraftBukkit end */
+
+                this.methodProfiler.a("tick");
+
+                CrashReport crashreport;
+
+                try {
+                    worldserver.timings.doTick.startTiming(); // Spigot
+                    worldserver.doTick();
+                    worldserver.timings.doTick.stopTiming(); // Spigot
+                } catch (Throwable throwable) {
+                    // Spigot Start
+                    try {
+                    crashreport = CrashReport.a(throwable, "Exception ticking world");
+                    } catch (Throwable t){
+                        throw new RuntimeException("Error generating crash report", t);
+                    }
+                    // Spigot End
+                    worldserver.a(crashreport);
+                    throw new ReportedException(crashreport);
+                }
+
+                try {
+                    worldserver.timings.tickEntities.startTiming(); // Spigot
+                    worldserver.tickEntities();
+                    worldserver.timings.tickEntities.stopTiming(); // Spigot
+                } catch (Throwable throwable1) {
+                    // Spigot Start
+                    try {
+                    crashreport = CrashReport.a(throwable1, "Exception ticking world entities");
+                    } catch (Throwable t){
+                        throw new RuntimeException("Error generating crash report", t);
+                    }
+                    // Spigot End
+                    worldserver.a(crashreport);
+                    throw new ReportedException(crashreport);
+                }
+
+                this.methodProfiler.b();
+                this.methodProfiler.a("tracker");
+                worldserver.timings.tracker.startTiming(); // Spigot
+                worldserver.getTracker().updatePlayers();
+                worldserver.timings.tracker.stopTiming(); // Spigot
+                this.methodProfiler.b();
+                this.methodProfiler.b();
+            // } // CraftBukkit
+
+            // this.i[i][this.ticks % 100] = System.nanoTime() - j; // CraftBukkit
+        }
+
+        this.methodProfiler.c("connection");
+        SpigotTimings.connectionTimer.startTiming(); // Spigot
+        this.am().c();
+        SpigotTimings.connectionTimer.stopTiming(); // Spigot
+        this.methodProfiler.c("players");
+        SpigotTimings.playerListTimer.startTiming(); // Spigot
+        this.v.tick();
+        SpigotTimings.playerListTimer.stopTiming(); // Spigot
+        this.methodProfiler.c("tickables");
+
+        SpigotTimings.tickablesTimer.startTiming(); // Spigot
+        this.o.parallelStream().forEach(it -> {
+            ((ITickable) it).E_();
+        });
+        /*
+        for (i = 0; i < this.o.size(); ++i) {
+            ((ITickable) this.o.get(i)).E_();
+        }*/
+        SpigotTimings.tickablesTimer.stopTiming(); // Spigot
+
+        this.methodProfiler.b();
+    }
+
+    public boolean getAllowNether() {
+        return true;
+    }
+
+    public void a(ITickable itickable) {
+        this.o.add(itickable);
+    }
+
+    public static void main(final OptionSet options) { // CraftBukkit - replaces main(String[] astring)
+        DispenserRegistry.c();
+
+        try {
+            /* CraftBukkit start - Replace everything
+            boolean flag = true;
+            String s = null;
+            String s1 = ".";
+            String s2 = null;
+            boolean flag1 = false;
+            boolean flag2 = false;
+            int i = -1;
+
+            for (int j = 0; j < astring.length; ++j) {
+                String s3 = astring[j];
+                String s4 = j == astring.length - 1 ? null : astring[j + 1];
+                boolean flag3 = false;
+
+                if (!"nogui".equals(s3) && !"--nogui".equals(s3)) {
+                    if ("--port".equals(s3) && s4 != null) {
+                        flag3 = true;
+
+                        try {
+                            i = Integer.parseInt(s4);
+                        } catch (NumberFormatException numberformatexception) {
+                            ;
+                        }
+                    } else if ("--singleplayer".equals(s3) && s4 != null) {
+                        flag3 = true;
+                        s = s4;
+                    } else if ("--universe".equals(s3) && s4 != null) {
+                        flag3 = true;
+                        s1 = s4;
+                    } else if ("--world".equals(s3) && s4 != null) {
+                        flag3 = true;
+                        s2 = s4;
+                    } else if ("--demo".equals(s3)) {
+                        flag1 = true;
+                    } else if ("--bonusChest".equals(s3)) {
+                        flag2 = true;
+                    }
+                } else {
+                    flag = false;
+                }
+
+                if (flag3) {
+                    ++j;
+                }
+            }
+            */ // CraftBukkit end
+
+            String s1 = "."; // PAIL?
+            YggdrasilAuthenticationService yggdrasilauthenticationservice = new YggdrasilAuthenticationService(Proxy.NO_PROXY, UUID.randomUUID().toString());
+            MinecraftSessionService minecraftsessionservice = yggdrasilauthenticationservice.createMinecraftSessionService();
+            GameProfileRepository gameprofilerepository = yggdrasilauthenticationservice.createProfileRepository();
+            UserCache usercache = new UserCache(gameprofilerepository, new File(s1, MinecraftServer.a.getName()));
+            final DedicatedServer dedicatedserver = new DedicatedServer(options, DataConverterRegistry.a(), yggdrasilauthenticationservice, minecraftsessionservice, gameprofilerepository, usercache);
+
+            /* CraftBukkit start
+            if (s != null) {
+                dedicatedserver.i(s);
+            }
+
+            if (s2 != null) {
+                dedicatedserver.setWorld(s2);
+            }
+
+            if (i >= 0) {
+                dedicatedserver.setPort(i);
+            }
+
+            if (flag1) {
+                dedicatedserver.b(true);
+            }
+
+            if (flag2) {
+                dedicatedserver.c(true);
+            }
+
+            if (flag && !GraphicsEnvironment.isHeadless()) {
+                dedicatedserver.aN();
+            }
+
+            dedicatedserver.F();
+            Runtime.getRuntime().addShutdownHook(new Thread("Server Shutdown Thread") {
+                public void run() {
+                    dedicatedserver.stop();
+                }
+            });
+            */
+
+            if (options.has("port")) {
+                int port = (Integer) options.valueOf("port");
+                if (port > 0) {
+                    dedicatedserver.setPort(port);
+                }
+            }
+
+            if (options.has("universe")) {
+                dedicatedserver.universe = (File) options.valueOf("universe");
+            }
+
+            if (options.has("world")) {
+                dedicatedserver.setWorld((String) options.valueOf("world"));
+            }
+
+            dedicatedserver.primaryThread.start();
+            // CraftBukkit end
+        } catch (Exception exception) {
+            MinecraftServer.LOGGER.fatal("Failed to start the minecraft server", exception);
+        }
+
+    }
+
+    public void F() {
+        /* CraftBukkit start - prevent abuse
+        this.serverThread = new Thread(this, "Server thread");
+        this.serverThread.start();
+        // CraftBukkit end */
+    }
+
+    public File d(String s) {
+        return new File(this.A(), s);
+    }
+
+    public void info(String s) {
+        MinecraftServer.LOGGER.info(s);
+    }
+
+    public void warning(String s) {
+        MinecraftServer.LOGGER.warn(s);
+    }
+
+    public WorldServer getWorldServer(int i) {
+        // CraftBukkit start
+        for (WorldServer world : worlds) {
+            if (world.dimension == i) {
+                return world;
+            }
+        }
+        return worlds.get(0);
+        // CraftBukkit end
+    }
+
+    public String getVersion() {
+        return "1.10.2";
+    }
+
+    public int H() {
+        return this.v.getPlayerCount();
+    }
+
+    public int I() {
+        return this.v.getMaxPlayers();
+    }
+
+    public String[] getPlayers() {
+        return this.v.f();
+    }
+
+    public GameProfile[] K() {
+        return this.v.g();
+    }
+
+    public boolean isDebugging() {
+        return this.getPropertyManager().getBoolean("debug", false); // CraftBukkit - don't hardcode
+    }
+
+    public void g(String s) {
+        MinecraftServer.LOGGER.error(s);
+    }
+
+    public void h(String s) {
+        if (this.isDebugging()) {
+            MinecraftServer.LOGGER.info(s);
+        }
+
+    }
+
+    public String getServerModName() {
+        //return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "HOSE"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+    }
+
+    public CrashReport b(CrashReport crashreport) {
+        crashreport.g().a("Profiler Position", new CrashReportCallable() {
+            public String a() throws Exception {
+                return MinecraftServer.this.methodProfiler.a ? MinecraftServer.this.methodProfiler.c() : "N/A (disabled)";
+            }
+
+            public Object call() throws Exception {
+                return this.a();
+            }
+        });
+        if (this.v != null) {
+            crashreport.g().a("Player Count", new CrashReportCallable() {
+                public String a() {
+                    return MinecraftServer.this.v.getPlayerCount() + " / " + MinecraftServer.this.v.getMaxPlayers() + "; " + MinecraftServer.this.v.v();
+                }
+
+                public Object call() throws Exception {
+                    return this.a();
+                }
+            });
+        }
+
+        return crashreport;
+    }
+
+    public List<String> tabCompleteCommand(ICommandListener icommandlistener, String s, @Nullable BlockPosition blockposition, boolean flag) {
+        /* CraftBukkit start - Allow tab-completion of Bukkit commands
+        ArrayList arraylist = Lists.newArrayList();
+        boolean flag1 = s.startsWith("/");
+
+        if (flag1) {
+            s = s.substring(1);
+        }
+
+        if (!flag1 && !flag) {
+            String[] astring = s.split(" ", -1);
+            String s1 = astring[astring.length - 1];
+            String[] astring1 = this.v.f();
+            int i = astring1.length;
+
+            for (int j = 0; j < i; ++j) {
+                String s2 = astring1[j];
+
+                if (CommandAbstract.a(s1, s2)) {
+                    arraylist.add(s2);
+                }
+            }
+
+            return arraylist;
+        } else {
+            boolean flag2 = !s.contains(" ");
+            List list = this.b.a(icommandlistener, s, blockposition);
+
+            if (!list.isEmpty()) {
+                Iterator iterator = list.iterator();
+
+                while (iterator.hasNext()) {
+                    String s3 = (String) iterator.next();
+
+                    if (flag2) {
+                        arraylist.add("/" + s3);
+                    } else {
+                        arraylist.add(s3);
+                    }
+                }
+            }
+
+            return arraylist;
+        }
+        */
+        return server.tabComplete(icommandlistener, s, blockposition);
+        // CraftBukkit end
+    }
+
+    public boolean M() {
+        return true; // CraftBukkit
+    }
+
+    public String getName() {
+        //return "Server";
+        return org.bukkit.ChatColor.GREEN + "Server";
+    }
+
+    public void sendMessage(IChatBaseComponent ichatbasecomponent) {
+        MinecraftServer.LOGGER.info(ichatbasecomponent.toPlainText());
+    }
+
+    public boolean a(int i, String s) {
+        return true;
+    }
+
+    public ICommandHandler getCommandHandler() {
+        return this.b;
+    }
+
+    public KeyPair O() {
+        return this.H;
+    }
+
+    public int P() {
+        return this.u;
+    }
+
+    public void setPort(int i) {
+        this.u = i;
+    }
+
+    public String Q() {
+        return this.I;
+    }
+
+    public void i(String s) {
+        this.I = s;
+    }
+
+    public boolean R() {
+        return this.I != null;
+    }
+
+    public String S() {
+        return this.J;
+    }
+
+    public void setWorld(String s) {
+        this.J = s;
+    }
+
+    public void a(KeyPair keypair) {
+        this.H = keypair;
+    }
+
+    public void a(EnumDifficulty enumdifficulty) {
+        // CraftBukkit start
+        // WorldServer[] aworldserver = this.worldServer;
+        int i = this.worlds.size();
+
+        for (int j = 0; j < i; ++j) {
+            WorldServer worldserver = this.worlds.get(j);
+            // CraftBukkit end
+
+            if (worldserver != null) {
+                if (worldserver.getWorldData().isHardcore()) {
+                    worldserver.getWorldData().setDifficulty(EnumDifficulty.HARD);
+                    worldserver.setSpawnFlags(true, true);
+                } else if (this.R()) {
+                    worldserver.getWorldData().setDifficulty(enumdifficulty);
+                    worldserver.setSpawnFlags(worldserver.getDifficulty() != EnumDifficulty.PEACEFUL, true);
+                } else {
+                    worldserver.getWorldData().setDifficulty(enumdifficulty);
+                    worldserver.setSpawnFlags(this.getSpawnMonsters(), this.spawnAnimals);
+                }
+            }
+        }
+
+    }
+
+    public boolean getSpawnMonsters() {
+        return true;
+    }
+
+    public boolean V() {
+        return this.demoMode;
+    }
+
+    public void b(boolean flag) {
+        this.demoMode = flag;
+    }
+
+    public void c(boolean flag) {
+        this.M = flag;
+    }
+
+    public Convertable getConvertable() {
+        return this.convertable;
+    }
+
+    public String getResourcePack() {
+        return this.N;
+    }
+
+    public String getResourcePackHash() {
+        return this.O;
+    }
+
+    public void setResourcePack(String s, String s1) {
+        this.N = s;
+        this.O = s1;
+    }
+
+    public void a(MojangStatisticsGenerator mojangstatisticsgenerator) {
+        mojangstatisticsgenerator.a("whitelist_enabled", Boolean.valueOf(false));
+        mojangstatisticsgenerator.a("whitelist_count", Integer.valueOf(0));
+        if (this.v != null) {
+            mojangstatisticsgenerator.a("players_current", Integer.valueOf(this.H()));
+            mojangstatisticsgenerator.a("players_max", Integer.valueOf(this.I()));
+            mojangstatisticsgenerator.a("players_seen", Integer.valueOf(this.v.getSeenPlayers().length));
+        }
+
+        mojangstatisticsgenerator.a("uses_auth", Boolean.valueOf(this.onlineMode));
+        mojangstatisticsgenerator.a("gui_state", this.ao() ? "enabled" : "disabled");
+        mojangstatisticsgenerator.a("run_time", Long.valueOf((av() - mojangstatisticsgenerator.g()) / 60L * 1000L));
+        mojangstatisticsgenerator.a("avg_tick_ms", Integer.valueOf((int) (MathHelper.a(this.h) * 1.0E-6D)));
+        int i = 0;
+
+        if (this.worldServer != null) {
+            // CraftBukkit start
+            for (int j = 0; j < this.worlds.size(); ++j) {
+                WorldServer worldserver = this.worlds.get(j);
+                if (worldserver != null) {
+                    // CraftBukkit end
+                    WorldData worlddata = worldserver.getWorldData();
+
+                    mojangstatisticsgenerator.a("world[" + i + "][dimension]", Integer.valueOf(worldserver.worldProvider.getDimensionManager().getDimensionID()));
+                    mojangstatisticsgenerator.a("world[" + i + "][mode]", worlddata.getGameType());
+                    mojangstatisticsgenerator.a("world[" + i + "][difficulty]", worldserver.getDifficulty());
+                    mojangstatisticsgenerator.a("world[" + i + "][hardcore]", Boolean.valueOf(worlddata.isHardcore()));
+                    mojangstatisticsgenerator.a("world[" + i + "][generator_name]", worlddata.getType().name());
+                    mojangstatisticsgenerator.a("world[" + i + "][generator_version]", Integer.valueOf(worlddata.getType().getVersion()));
+                    mojangstatisticsgenerator.a("world[" + i + "][height]", Integer.valueOf(this.F));
+                    mojangstatisticsgenerator.a("world[" + i + "][chunks_loaded]", Integer.valueOf(worldserver.getChunkProviderServer().g()));
+                    ++i;
+                }
+            }
+        }
+
+        mojangstatisticsgenerator.a("worlds", Integer.valueOf(i));
+    }
+
+    public void b(MojangStatisticsGenerator mojangstatisticsgenerator) {
+        mojangstatisticsgenerator.b("singleplayer", Boolean.valueOf(this.R()));
+        mojangstatisticsgenerator.b("server_brand", this.getServerModName());
+        mojangstatisticsgenerator.b("gui_supported", GraphicsEnvironment.isHeadless() ? "headless" : "supported");
+        mojangstatisticsgenerator.b("dedicated", Boolean.valueOf(this.aa()));
+    }
+
+    public boolean getSnooperEnabled() {
+        return true;
+    }
+
+    public abstract boolean aa();
+
+    public boolean getOnlineMode() {
+        return server.getOnlineMode(); // CraftBukkit
+    }
+
+    public void setOnlineMode(boolean flag) {
+        this.onlineMode = flag;
+    }
+
+    public boolean getSpawnAnimals() {
+        return this.spawnAnimals;
+    }
+
+    public void setSpawnAnimals(boolean flag) {
+        this.spawnAnimals = flag;
+    }
+
+    public boolean getSpawnNPCs() {
+        return this.spawnNPCs;
+    }
+
+    public abstract boolean ae();
+
+    public void setSpawnNPCs(boolean flag) {
+        this.spawnNPCs = flag;
+    }
+
+    public boolean getPVP() {
+        return this.pvpMode;
+    }
+
+    public void setPVP(boolean flag) {
+        this.pvpMode = flag;
+    }
+
+    public boolean getAllowFlight() {
+        return this.allowFlight;
+    }
+
+    public void setAllowFlight(boolean flag) {
+        this.allowFlight = flag;
+    }
+
+    public abstract boolean getEnableCommandBlock();
+
+    public String getMotd() {
+        return this.motd;
+    }
+
+    public void setMotd(String s) {
+        this.motd = s;
+    }
+
+    public int getMaxBuildHeight() {
+        return this.F;
+    }
+
+    public void c(int i) {
+        this.F = i;
+    }
+
+    public boolean isStopped() {
+        return this.isStopped;
+    }
+
+    public PlayerList getPlayerList() {
+        return this.v;
+    }
+
+    public void a(PlayerList playerlist) {
+        this.v = playerlist;
+    }
+
+    public void setGamemode(EnumGamemode enumgamemode) {
+        // CraftBukkit start
+        for (int i = 0; i < this.worlds.size(); ++i) {
+            worlds.get(i).getWorldData().setGameType(enumgamemode);
+        }
+
+    }
+
+    // Spigot Start
+    public ServerConnection getServerConnection()
+    {
+        return this.p;
+    }
+    // Spigot End
+    public ServerConnection am() {
+        return this.p == null ? this.p = new ServerConnection(this) : this.p; // Spigot
+    }
+
+    public boolean ao() {
+        return false;
+    }
+
+    public abstract String a(EnumGamemode enumgamemode, boolean flag);
+
+    public int ap() {
+        return this.ticks;
+    }
+
+    public void aq() {
+        this.S = true;
+    }
+
+    public BlockPosition getChunkCoordinates() {
+        return BlockPosition.ZERO;
+    }
+
+    public Vec3D d() {
+        return Vec3D.a;
+    }
+
+    public World getWorld() {
+        return this.worlds.get(0); // CraftBukkit
+    }
+
+    public Entity f() {
+        return null;
+    }
+
+    public int getSpawnProtection() {
+        return 16;
+    }
+
+    public boolean a(World world, BlockPosition blockposition, EntityHuman entityhuman) {
+        return false;
+    }
+
+    public void setForceGamemode(boolean flag) {
+        this.T = flag;
+    }
+
+    public boolean getForceGamemode() {
+        return this.T;
+    }
+
+    public Proxy au() {
+        return this.e;
+    }
+
+    public static long av() {
+        return System.currentTimeMillis();
+    }
+
+    public int getIdleTimeout() {
+        return this.G;
+    }
+
+    public void setIdleTimeout(int i) {
+        this.G = i;
+    }
+
+    public IChatBaseComponent getScoreboardDisplayName() {
+        return new ChatComponentText(this.getName());
+    }
+
+    public boolean ax() {
+        return true;
+    }
+
+    public MinecraftSessionService ay() {
+        return this.V;
+    }
+
+    public GameProfileRepository getGameProfileRepository() {
+        return this.W;
+    }
+
+    public UserCache getUserCache() {
+        return this.X;
+    }
+
+    public ServerPing getServerPing() {
+        return this.q;
+    }
+
+    public void aC() {
+        this.Y = 0L;
+    }
+
+    @Nullable
+    public Entity a(UUID uuid) {
+        WorldServer[] aworldserver = this.worldServer;
+        int i = aworldserver.length;
+
+        // CraftBukkit start
+        for (int j = 0; j < worlds.size(); ++j) {
+            WorldServer worldserver = worlds.get(j);
+            // CraftBukkit end
+
+            if (worldserver != null) {
+                Entity entity = worldserver.getEntity(uuid);
+
+                if (entity != null) {
+                    return entity;
+                }
+            }
+        }
+
+        return null;
+    }
+
+    public boolean getSendCommandFeedback() {
+        return worlds.get(0).getGameRules().getBoolean("sendCommandFeedback");
+    }
+
+    public void a(CommandObjectiveExecutor.EnumCommandResult commandobjectiveexecutor_enumcommandresult, int i) {}
+
+    public MinecraftServer h() {
+        return this;
+    }
+
+    public int aD() {
+        return 29999984;
+    }
+
+    public <V> ListenableFuture<V> a(Callable<V> callable) {
+        Validate.notNull(callable);
+        if (!this.isMainThread()) { // CraftBukkit && !this.isStopped()) {
+            ListenableFutureTask listenablefuturetask = ListenableFutureTask.create(callable);
+            Queue queue = this.j;
+
+            // Spigot start
+            this.j.add(listenablefuturetask);
+            //SpigotWorldConfig.missionpool_executor.execute(listenablefuturetask);
+            return listenablefuturetask;
+            // Spigot end
+        } else {
+            try {
+                return Futures.immediateFuture(callable.call());
+            } catch (Exception exception) {
+                return Futures.immediateFailedCheckedFuture(exception);
+            }
+        }
+    }
+
+    public ListenableFuture<Object> postToMainThread(Runnable runnable) {
+        Validate.notNull(runnable);
+        return this.a(Executors.callable(runnable));
+    }
+
+    public boolean isMainThread() {
+        return Thread.currentThread() == this.serverThread;
+    }
+
+    public int aF() {
+        return 256;
+    }
+
+    public long aG() {
+        return this.aa;
+    }
+
+    public Thread aH() {
+        return this.serverThread;
+    }
+
+    public DataConverterManager getDataConverterManager() {
+        return this.dataConverterManager;
+    }
+
+    public int a(@Nullable WorldServer worldserver) {
+        return worldserver != null ? worldserver.getGameRules().c("spawnRadius") : 10;
+    }
+
+    // CraftBukkit start
+    @Deprecated
+    public static MinecraftServer getServer() {
+        return (Bukkit.getServer() instanceof CraftServer) ? ((CraftServer) Bukkit.getServer()).getServer() : null;
+    }
+    // CraftBukkit end
+}
diff -Naur src_origin/main/java/net/minecraft/server/NavigationAbstract.java src/main/java/net/minecraft/server/NavigationAbstract.java
--- src_origin/main/java/net/minecraft/server/NavigationAbstract.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/NavigationAbstract.java	2016-08-26 03:24:14.447198466 +0800
@@ -0,0 +1,280 @@
+package net.minecraft.server;
+
+import javax.annotation.Nullable;
+
+public abstract class NavigationAbstract {
+
+    protected EntityInsentient a;
+    protected World b;
+    @Nullable
+    protected PathEntity c;
+    protected double d;
+    private final AttributeInstance f;
+    private int g;
+    private int h;
+    private Vec3D i;
+    private Vec3D j;
+    private long k;
+    private long l;
+    private double m;
+    private float n;
+    private boolean o;
+    private long p;
+    protected PathfinderAbstract e;
+    private BlockPosition q;
+    private final Pathfinder r;
+
+    public NavigationAbstract(EntityInsentient entityinsentient, World world) {
+        this.i = Vec3D.a;
+        this.j = Vec3D.a;
+        this.n = 0.5F;
+        this.a = entityinsentient;
+        this.b = world;
+        this.f = entityinsentient.getAttributeInstance(GenericAttributes.FOLLOW_RANGE);
+        this.r = this.a();
+    }
+
+    protected abstract Pathfinder a();
+
+    public void a(double d0) {
+        this.d = d0;
+    }
+
+    public float h() {
+        return (float) this.f.getValue();
+    }
+
+    public boolean i() {
+        return this.o;
+    }
+
+    public void j() {
+        if (this.b.getTime() - this.p > 20L) {
+            if (this.q != null) {
+                this.c = null;
+                this.c = this.a(this.q);
+                this.p = this.b.getTime();
+                this.o = false;
+            }
+        } else {
+            this.o = true;
+        }
+
+    }
+
+    @Nullable
+    public final PathEntity a(double d0, double d1, double d2) {
+        return this.a(new BlockPosition(d0, d1, d2));
+    }
+
+    @Nullable
+    public PathEntity a(BlockPosition blockposition) {
+        if (!this.b() || this.a == null) {
+            return null;
+        } else if (this.c != null && !this.c.b() && blockposition.equals(this.q)) {
+            return this.c;
+        } else {
+            this.q = blockposition;
+            float f = this.h();
+
+            this.b.methodProfiler.a("pathfind");
+            BlockPosition blockposition1 = new BlockPosition(this.a);
+            int i = (int) (f + 8.0F);
+            ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+            PathEntity pathentity = this.r.a(chunkcache, this.a, this.q, f);
+
+            this.b.methodProfiler.b();
+            return pathentity;
+        }
+    }
+
+    @Nullable
+    public PathEntity a(Entity entity) {
+        if (!this.b()) {
+            return null;
+        } else {
+            BlockPosition blockposition = new BlockPosition(entity);
+
+            if (this.c != null && !this.c.b() && blockposition.equals(this.q)) {
+                return this.c;
+            } else {
+                this.q = blockposition;
+                float f = this.h();
+
+                this.b.methodProfiler.a("pathfind");
+                BlockPosition blockposition1 = (new BlockPosition(this.a)).up();
+                int i = (int) (f + 16.0F);
+                ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+                PathEntity pathentity = this.r.a(chunkcache, this.a, entity, f);
+
+                this.b.methodProfiler.b();
+                return pathentity;
+            }
+        }
+    }
+
+    public boolean a(double d0, double d1, double d2, double d3) {
+        return this.a(this.a(d0, d1, d2), d3);
+    }
+
+    public boolean a(Entity entity, double d0) {
+        PathEntity pathentity = this.a(entity);
+
+        return pathentity != null && this.a(pathentity, d0);
+    }
+
+    public boolean a(@Nullable PathEntity pathentity, double d0) {
+        if (pathentity == null) {
+            this.c = null;
+            return false;
+        } else {
+            if (!pathentity.a(this.c)) {
+                this.c = pathentity;
+            }
+
+            this.d();
+            if (this.c.d() == 0) {
+                return false;
+            } else {
+                this.d = d0;
+                Vec3D vec3d = this.c();
+
+                this.h = this.g;
+                this.i = vec3d;
+                return true;
+            }
+        }
+    }
+
+    @Nullable
+    public PathEntity k() {
+        return this.c;
+    }
+
+    public void l() {
+        ++this.g;
+        if (this.o) {
+            this.j();
+        }
+
+        if (!this.n()) {
+            Vec3D vec3d;
+
+            if (this.b()) {
+                this.m();
+            } else if (this.c != null && this.c.e() < this.c.d()) {
+                vec3d = this.c();
+                Vec3D vec3d1 = this.c.a(this.a, this.c.e());
+
+                if (vec3d.y > vec3d1.y && !this.a.onGround && MathHelper.floor(vec3d.x) == MathHelper.floor(vec3d1.x) && MathHelper.floor(vec3d.z) == MathHelper.floor(vec3d1.z)) {
+                    this.c.c(this.c.e() + 1);
+                }
+            }
+
+            if (!this.n()) {
+                vec3d = this.c.a((Entity) this.a);
+                if (vec3d != null) {
+                    BlockPosition blockposition = (new BlockPosition(vec3d)).down();
+                    AxisAlignedBB axisalignedbb = this.b.getType(blockposition).c(this.b, blockposition);
+
+                    vec3d = vec3d.a(0.0D, 1.0D - axisalignedbb.e, 0.0D);
+                    this.a.getControllerMove().a(vec3d.x, vec3d.y, vec3d.z, this.d);
+                }
+            }
+        }
+    }
+
+    protected void m() {
+        Vec3D vec3d = this.c();
+        int i = this.c.d();
+
+        for (int j = this.c.e(); j < this.c.d(); ++j) {
+            if ((double) this.c.a(j).b != Math.floor(vec3d.y)) {
+                i = j;
+                break;
+            }
+        }
+
+        this.n = this.a.width > 0.75F ? this.a.width / 2.0F : 0.75F - this.a.width / 2.0F;
+        Vec3D vec3d1 = this.c.f();
+
+        if (MathHelper.e((float) (this.a.locX - (vec3d1.x + 0.5D))) < this.n && MathHelper.e((float) (this.a.locZ - (vec3d1.z + 0.5D))) < this.n && Math.abs(this.a.locY - vec3d1.y) < 1.0D) {
+            this.c.c(this.c.e() + 1);
+        }
+
+        int k = MathHelper.f(this.a.width);
+        int l = MathHelper.f(this.a.length);
+        int i1 = k;
+
+        for (int j1 = i - 1; j1 >= this.c.e(); --j1) {
+            if (this.a(vec3d, this.c.a(this.a, j1), k, l, i1)) {
+                this.c.c(j1);
+                break;
+            }
+        }
+
+        this.a(vec3d);
+    }
+
+    protected void a(Vec3D vec3d) {
+        if (this.g - this.h > 100) {
+            if (vec3d.distanceSquared(this.i) < 2.25D) {
+                this.o();
+            }
+
+            this.h = this.g;
+            this.i = vec3d;
+        }
+
+        if (this.c != null && !this.c.b()) {
+            Vec3D vec3d1 = this.c.f();
+
+            if (vec3d1.equals(this.j)) {
+                this.k += System.currentTimeMillis() - this.l;
+            } else {
+                this.j = vec3d1;
+                double d0 = vec3d.f(this.j);
+
+                this.m = this.a.cp() > 0.0F ? d0 / (double) this.a.cp() * 1000.0D : 0.0D;
+            }
+
+            if (this.m > 0.0D && (double) this.k > this.m * 3.0D) {
+                this.j = Vec3D.a;
+                this.k = 0L;
+                this.m = 0.0D;
+                this.o();
+            }
+
+            this.l = System.currentTimeMillis();
+        }
+
+    }
+
+    public boolean n() {
+        return this.c == null || this.c.b();
+    }
+
+    public void o() {
+        this.c = null;
+    }
+
+    protected abstract Vec3D c();
+
+    protected abstract boolean b();
+
+    protected boolean p() {
+        return this.a.isInWater() || this.a.ao();
+    }
+
+    protected void d() {}
+
+    protected abstract boolean a(Vec3D vec3d, Vec3D vec3d1, int i, int j, int k);
+
+    public boolean b(BlockPosition blockposition) {
+        return this.b.getType(blockposition.down()).b();
+    }
+
+    public PathfinderAbstract q() {
+        return this.e;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/NavigationListener.java src/main/java/net/minecraft/server/NavigationListener.java
--- src_origin/main/java/net/minecraft/server/NavigationListener.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/NavigationListener.java	2016-08-26 03:24:14.446198466 +0800
@@ -0,0 +1,91 @@
+package net.minecraft.server;
+
+//import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
+//import java.util.List;
+import java.util.Queue;
+import javax.annotation.Nullable;
+
+public class NavigationListener implements IWorldAccess {
+
+    //private final List<NavigationAbstract> a = Lists.newArrayList();
+    private final Queue<NavigationAbstract> a = Queues.newConcurrentLinkedQueue();
+
+    public NavigationListener() {}
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, IBlockData iblockdata1, int i) {
+        if (this.a(world, blockposition, iblockdata, iblockdata1)) {
+            this.a.parallelStream().filter(navigationabstract -> navigationabstract != null && !navigationabstract.i()).forEach(navigationabstract -> {
+                PathEntity pathentity = navigationabstract.k();
+
+                if (pathentity != null && !pathentity.b() && pathentity.d() != 0) {
+                    PathPoint pathpoint = navigationabstract.c.c();
+                    double d0 = blockposition.distanceSquared(((double) pathpoint.a + navigationabstract.a.locX) / 2.0D, ((double) pathpoint.b + navigationabstract.a.locY) / 2.0D, ((double) pathpoint.c + navigationabstract.a.locZ) / 2.0D);
+                    int l = (pathentity.d() - pathentity.e()) * (pathentity.d() - pathentity.e());
+
+                    if (d0 < (double) l) {
+                        navigationabstract.j();
+                    }
+                }
+            });
+            
+            /*int j = 0;
+            
+            for (int k = this.a.size(); j < k; ++j) {
+                NavigationAbstract navigationabstract = (NavigationAbstract) this.a.get(j);
+
+                if (navigationabstract != null && !navigationabstract.i()) {
+                    PathEntity pathentity = navigationabstract.k();
+
+                    if (pathentity != null && !pathentity.b() && pathentity.d() != 0) {
+                        PathPoint pathpoint = navigationabstract.c.c();
+                        double d0 = blockposition.distanceSquared(((double) pathpoint.a + navigationabstract.a.locX) / 2.0D, ((double) pathpoint.b + navigationabstract.a.locY) / 2.0D, ((double) pathpoint.c + navigationabstract.a.locZ) / 2.0D);
+                        int l = (pathentity.d() - pathentity.e()) * (pathentity.d() - pathentity.e());
+
+                        if (d0 < (double) l) {
+                            navigationabstract.j();
+                        }
+                    }
+                }
+            }*/
+
+        }
+    }
+
+    protected boolean a(World world, BlockPosition blockposition, IBlockData iblockdata, IBlockData iblockdata1) {
+        AxisAlignedBB axisalignedbb = iblockdata.d(world, blockposition);
+        AxisAlignedBB axisalignedbb1 = iblockdata1.d(world, blockposition);
+
+        return axisalignedbb != axisalignedbb1 && (axisalignedbb == null || !axisalignedbb.equals(axisalignedbb1));
+    }
+
+    public void a(BlockPosition blockposition) {}
+
+    public void a(int i, int j, int k, int l, int i1, int j1) {}
+
+    public void a(@Nullable EntityHuman entityhuman, SoundEffect soundeffect, SoundCategory soundcategory, double d0, double d1, double d2, float f, float f1) {}
+
+    public void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {}
+
+    public void a(Entity entity) {
+        if (entity instanceof EntityInsentient) {
+            this.a.add(((EntityInsentient) entity).getNavigation());
+        }
+
+    }
+
+    public void b(Entity entity) {
+        if (entity instanceof EntityInsentient) {
+            this.a.remove(((EntityInsentient) entity).getNavigation());
+        }
+
+    }
+
+    public void a(SoundEffect soundeffect, BlockPosition blockposition) {}
+
+    public void a(int i, BlockPosition blockposition, int j) {}
+
+    public void a(EntityHuman entityhuman, int i, BlockPosition blockposition, int j) {}
+
+    public void b(int i, BlockPosition blockposition, int j) {}
+}
diff -Naur src_origin/main/java/net/minecraft/server/PersistentVillage.java src/main/java/net/minecraft/server/PersistentVillage.java
--- src_origin/main/java/net/minecraft/server/PersistentVillage.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/PersistentVillage.java	2016-08-26 03:24:14.687198489 +0800
@@ -0,0 +1,271 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+
+public class PersistentVillage extends PersistentBase {
+
+    private World world;
+    //private final List<BlockPosition> c = Lists.newArrayList();
+    private final List<BlockPosition> c = Collections.synchronizedList(Lists.newArrayList());
+    private final List<VillageDoor> d = Lists.newArrayList();
+    private final List<Village> villages = Lists.newArrayList();
+    private int time;
+
+    public PersistentVillage(String s) {
+        super(s);
+    }
+
+    public PersistentVillage(World world) {
+        super(a(world.worldProvider));
+        this.world = world;
+        this.c();
+    }
+
+    public void a(World world) {
+        this.world = world;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(world);
+        }
+
+    }
+
+    public void a(BlockPosition blockposition) {
+        if (this.c.size() <= 64) {
+            if (!this.e(blockposition)) {
+                this.c.add(blockposition);
+            }
+
+        }
+    }
+
+    public void tick() {
+        ++this.time;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(this.time);
+        }
+
+        this.e();
+        this.f();
+        this.g();
+        if (this.time % 400 == 0) {
+            this.c();
+        }
+
+    }
+
+    private void e() {
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            if (village.g()) {
+                iterator.remove();
+                this.c();
+            }
+        }
+
+    }
+
+    public List<Village> getVillages() {
+        return this.villages;
+    }
+
+    public Village getClosestVillage(BlockPosition blockposition, int i) {
+        Village village = null;
+        double d0 = 3.4028234663852886E38D;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village1 = (Village) iterator.next();
+            double d1 = village1.a().n(blockposition);
+
+            if (d1 < d0) {
+                float f = (float) (i + village1.b());
+
+                if (d1 <= (double) (f * f)) {
+                    village = village1;
+                    d0 = d1;
+                }
+            }
+        }
+
+        return village;
+    }
+
+    private void f() {
+        if (!this.c.isEmpty()) {
+            this.b((BlockPosition) this.c.remove(0));
+        }
+    }
+
+    private void g() {
+        for (int i = 0; i < this.d.size(); ++i) {
+            VillageDoor villagedoor = (VillageDoor) this.d.get(i);
+            Village village = this.getClosestVillage(villagedoor.d(), 32);
+
+            if (village == null) {
+                village = new Village(this.world);
+                this.villages.add(village);
+                this.c();
+            }
+
+            village.a(villagedoor);
+        }
+
+        this.d.clear();
+    }
+
+    private void b(BlockPosition blockposition) {
+        boolean flag = true;
+        boolean flag1 = true;
+        boolean flag2 = true;
+
+        for (int i = -16; i < 16; ++i) {
+            for (int j = -4; j < 4; ++j) {
+                for (int k = -16; k < 16; ++k) {
+                    BlockPosition blockposition1 = blockposition.a(i, j, k);
+
+                    if (this.f(blockposition1)) {
+                        VillageDoor villagedoor = this.c(blockposition1);
+
+                        if (villagedoor == null) {
+                            this.d(blockposition1);
+                        } else {
+                            villagedoor.a(this.time);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    private VillageDoor c(BlockPosition blockposition) {
+        Iterator iterator = this.d.iterator();
+
+        VillageDoor villagedoor;
+
+        do {
+            if (!iterator.hasNext()) {
+                iterator = this.villages.iterator();
+
+                VillageDoor villagedoor1;
+
+                do {
+                    if (!iterator.hasNext()) {
+                        return null;
+                    }
+
+                    Village village = (Village) iterator.next();
+
+                    villagedoor1 = village.e(blockposition);
+                } while (villagedoor1 == null);
+
+                return villagedoor1;
+            }
+
+            villagedoor = (VillageDoor) iterator.next();
+        } while (villagedoor.d().getX() != blockposition.getX() || villagedoor.d().getZ() != blockposition.getZ() || Math.abs(villagedoor.d().getY() - blockposition.getY()) > 1);
+
+        return villagedoor;
+    }
+
+    private void d(BlockPosition blockposition) {
+        EnumDirection enumdirection = BlockDoor.f(this.world, blockposition);
+        EnumDirection enumdirection1 = enumdirection.opposite();
+        int i = this.a(blockposition, enumdirection, 5);
+        int j = this.a(blockposition, enumdirection1, i + 1);
+
+        if (i != j) {
+            this.d.add(new VillageDoor(blockposition, i < j ? enumdirection : enumdirection1, this.time));
+        }
+
+    }
+
+    private int a(BlockPosition blockposition, EnumDirection enumdirection, int i) {
+        int j = 0;
+
+        for (int k = 1; k <= 5; ++k) {
+            if (this.world.h(blockposition.shift(enumdirection, k))) {
+                ++j;
+                if (j >= i) {
+                    return j;
+                }
+            }
+        }
+
+        return j;
+    }
+
+    private boolean e(BlockPosition blockposition) {
+        synchronized (this.c) {
+            Iterator iterator = this.c.iterator();
+
+            BlockPosition blockposition1;
+
+            do {
+                if (!iterator.hasNext()) {
+                    return false;
+                }
+
+                blockposition1 = (BlockPosition) iterator.next();
+            } while (!blockposition1.equals(blockposition));
+
+            return true;
+        }
+    }
+
+    private boolean f(BlockPosition blockposition) {
+        IBlockData iblockdata = this.world.getType(blockposition);
+        Block block = iblockdata.getBlock();
+
+        return block instanceof BlockDoor ? iblockdata.getMaterial() == Material.WOOD : false;
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        this.time = nbttagcompound.getInt("Tick");
+        NBTTagList nbttaglist = nbttagcompound.getList("Villages", 10);
+
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound1 = nbttaglist.get(i);
+            Village village = new Village();
+
+            village.a(nbttagcompound1);
+            this.villages.add(village);
+        }
+
+    }
+
+    public NBTTagCompound b(NBTTagCompound nbttagcompound) {
+        nbttagcompound.setInt("Tick", this.time);
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+            village.b(nbttagcompound1);
+            nbttaglist.add(nbttagcompound1);
+        }
+
+        nbttagcompound.set("Villages", nbttaglist);
+        return nbttagcompound;
+    }
+
+    public static String a(WorldProvider worldprovider) {
+        return "villages" + worldprovider.getDimensionManager().c();
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/PlayerChunkMap.java src/main/java/net/minecraft/server/PlayerChunkMap.java
--- src_origin/main/java/net/minecraft/server/PlayerChunkMap.java	2016-08-25 22:39:52.237602012 +0800
+++ src/main/java/net/minecraft/server/PlayerChunkMap.java	2016-08-26 03:24:14.708198491 +0800
@@ -1,483 +1,484 @@
-package net.minecraft.server;
-
-import com.google.common.base.Predicate;
-import com.google.common.collect.AbstractIterator;
-import com.google.common.collect.ComparisonChain;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
-import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
-import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Set;
-import javax.annotation.Nullable;
-
-// CraftBukkit start
-import java.util.LinkedList;
-// CraftBukkit end
-
-public class PlayerChunkMap {
-
-    private static final Predicate<EntityPlayer> a = new Predicate() {
-        public boolean a(@Nullable EntityPlayer entityplayer) {
-            return entityplayer != null && !entityplayer.isSpectator();
-        }
-
-        public boolean apply(Object object) {
-            return this.a((EntityPlayer) object);
-        }
-    };
-    private static final Predicate<EntityPlayer> b = new Predicate() {
-        public boolean a(@Nullable EntityPlayer entityplayer) {
-            return entityplayer != null && (!entityplayer.isSpectator() || entityplayer.x().getGameRules().getBoolean("spectatorsGenerateChunks"));
-        }
-
-        public boolean apply(Object object) {
-            return this.a((EntityPlayer) object);
-        }
-    };
-    private final WorldServer world;
-    private final List<EntityPlayer> managedPlayers = Lists.newArrayList();
-    private final Long2ObjectMap<PlayerChunk> e = new Long2ObjectOpenHashMap(4096);
-    private final Set<PlayerChunk> f = Sets.newHashSet();
-    private final List<PlayerChunk> g = Lists.newLinkedList();
-    private final List<PlayerChunk> h = Lists.newLinkedList();
-    private final List<PlayerChunk> i = Lists.newArrayList();
-    private int j;
-    private long k;
-    private boolean l = true;
-    private boolean m = true;
-    private boolean wasNotEmpty; // CraftBukkit - add field
-
-    public PlayerChunkMap(WorldServer worldserver, int viewDistance /* Spigot */) {
-        this.world = worldserver;
-        this.a(viewDistance); // Spigot
-    }
-
-    public WorldServer getWorld() {
-        return this.world;
-    }
-
-    public Iterator<Chunk> b() {
-        final Iterator iterator = this.i.iterator();
-
-        return new AbstractIterator() {
-            protected Chunk a() {
-                while (true) {
-                    if (iterator.hasNext()) {
-                        PlayerChunk playerchunk = (PlayerChunk) iterator.next();
-                        Chunk chunk = playerchunk.f();
-
-                        if (chunk == null) {
-                            continue;
-                        }
-
-                        if (!chunk.v() && chunk.isDone()) {
-                            return chunk;
-                        }
-
-                        if (!chunk.j()) {
-                            return chunk;
-                        }
-
-                        if (!playerchunk.a(128.0D, PlayerChunkMap.a)) {
-                            continue;
-                        }
-
-                        return chunk;
-                    }
-
-                    return (Chunk) this.endOfData();
-                }
-            }
-
-            protected Object computeNext() {
-                return this.a();
-            }
-        };
-    }
-
-    public void flush() {
-        long i = this.world.getTime();
-        int j;
-        PlayerChunk playerchunk;
-
-        if (i - this.k > 8000L) {
-            this.k = i;
-
-            for (j = 0; j < this.i.size(); ++j) {
-                playerchunk = (PlayerChunk) this.i.get(j);
-                playerchunk.d();
-                playerchunk.c();
-            }
-        }
-
-        if (!this.f.isEmpty()) {
-            Iterator iterator = this.f.iterator();
-
-            while (iterator.hasNext()) {
-                playerchunk = (PlayerChunk) iterator.next();
-                playerchunk.d();
-            }
-
-            this.f.clear();
-        }
-
-        if (this.l && i % 4L == 0L) {
-            this.l = false;
-            Collections.sort(this.h, new Comparator() {
-                public int a(PlayerChunk playerchunk, PlayerChunk playerchunk1) {
-                    return ComparisonChain.start().compare(playerchunk.g(), playerchunk1.g()).result();
-                }
-
-                public int compare(Object object, Object object1) {
-                    return this.a((PlayerChunk) object, (PlayerChunk) object1);
-                }
-            });
-        }
-
-        if (this.m && i % 4L == 2L) {
-            this.m = false;
-            Collections.sort(this.g, new Comparator() {
-                public int a(PlayerChunk playerchunk, PlayerChunk playerchunk1) {
-                    return ComparisonChain.start().compare(playerchunk.g(), playerchunk1.g()).result();
-                }
-
-                public int compare(Object object, Object object1) {
-                    return this.a((PlayerChunk) object, (PlayerChunk) object1);
-                }
-            });
-        }
-
-        if (!this.h.isEmpty()) {
-            long k = System.nanoTime() + 50000000L;
-            int l = 49;
-            Iterator iterator1 = this.h.iterator();
-
-            while (iterator1.hasNext()) {
-                PlayerChunk playerchunk1 = (PlayerChunk) iterator1.next();
-
-                if (playerchunk1.f() == null) {
-                    boolean flag = playerchunk1.a(PlayerChunkMap.b);
-
-                    if (playerchunk1.a(flag)) {
-                        iterator1.remove();
-                        if (playerchunk1.b()) {
-                            this.g.remove(playerchunk1);
-                        }
-
-                        --l;
-                        if (l < 0 || System.nanoTime() > k) {
-                            break;
-                        }
-                    }
-                }
-            }
-        }
-
-        if (!this.g.isEmpty()) {
-            j = 81;
-            Iterator iterator2 = this.g.iterator();
-
-            while (iterator2.hasNext()) {
-                PlayerChunk playerchunk2 = (PlayerChunk) iterator2.next();
-
-                if (playerchunk2.b()) {
-                    iterator2.remove();
-                    --j;
-                    if (j < 0) {
-                        break;
-                    }
-                }
-            }
-        }
-
-        if (this.managedPlayers.isEmpty()) {
-            WorldProvider worldprovider = this.world.worldProvider;
-
-            if (!worldprovider.e()) {
-                this.world.getChunkProviderServer().b();
-            }
-        }
-
-    }
-
-    public boolean a(int i, int j) {
-        long k = d(i, j);
-
-        return this.e.get(k) != null;
-    }
-
-    @Nullable
-    public PlayerChunk getChunk(int i, int j) {
-        return (PlayerChunk) this.e.get(d(i, j));
-    }
-
-    private PlayerChunk c(int i, int j) {
-        long k = d(i, j);
-        PlayerChunk playerchunk = (PlayerChunk) this.e.get(k);
-
-        if (playerchunk == null) {
-            playerchunk = new PlayerChunk(this, i, j);
-            this.e.put(k, playerchunk);
-            this.i.add(playerchunk);
-            if (playerchunk.f() == null) {
-                this.h.add(playerchunk);
-            }
-
-            if (!playerchunk.b()) {
-                this.g.add(playerchunk);
-            }
-        }
-
-        return playerchunk;
-    }
-
-    // CraftBukkit start - add method
-    public final boolean isChunkInUse(int x, int z) {
-        PlayerChunk pi = getChunk(x, z);
-        if (pi != null) {
-            return (pi.c.size() > 0);
-        }
-        return false;
-    }
-    // CraftBukkit end
-
-    public void flagDirty(BlockPosition blockposition) {
-        int i = blockposition.getX() >> 4;
-        int j = blockposition.getZ() >> 4;
-        PlayerChunk playerchunk = this.getChunk(i, j);
-
-        if (playerchunk != null) {
-            playerchunk.a(blockposition.getX() & 15, blockposition.getY(), blockposition.getZ() & 15);
-        }
-
-    }
-
-    public void addPlayer(EntityPlayer entityplayer) {
-        int i = (int) entityplayer.locX >> 4;
-        int j = (int) entityplayer.locZ >> 4;
-
-        entityplayer.d = entityplayer.locX;
-        entityplayer.e = entityplayer.locZ;
-
-
-        // CraftBukkit start - Load nearby chunks first
-        List<ChunkCoordIntPair> chunkList = new LinkedList<ChunkCoordIntPair>();
-
-        for (int k = i - this.j; k <= i + this.j; ++k) {
-            for (int l = j - this.j; l <= j + this.j; ++l) {
-                chunkList.add(new ChunkCoordIntPair(k, l));
-            }
-        }
-
-        Collections.sort(chunkList, new ChunkCoordComparator(entityplayer));
-        for (ChunkCoordIntPair pair : chunkList) {
-            this.c(pair.x, pair.z).a(entityplayer);
-        }
-        // CraftBukkit end
-
-        this.managedPlayers.add(entityplayer);
-        this.e();
-    }
-
-    public void removePlayer(EntityPlayer entityplayer) {
-        int i = (int) entityplayer.d >> 4;
-        int j = (int) entityplayer.e >> 4;
-
-        for (int k = i - this.j; k <= i + this.j; ++k) {
-            for (int l = j - this.j; l <= j + this.j; ++l) {
-                PlayerChunk playerchunk = this.getChunk(k, l);
-
-                if (playerchunk != null) {
-                    playerchunk.b(entityplayer);
-                }
-            }
-        }
-
-        this.managedPlayers.remove(entityplayer);
-        this.e();
-    }
-
-    private boolean a(int i, int j, int k, int l, int i1) {
-        int j1 = i - k;
-        int k1 = j - l;
-
-        return j1 >= -i1 && j1 <= i1 ? k1 >= -i1 && k1 <= i1 : false;
-    }
-
-    public void movePlayer(EntityPlayer entityplayer) {
-        int i = (int) entityplayer.locX >> 4;
-        int j = (int) entityplayer.locZ >> 4;
-        double d0 = entityplayer.d - entityplayer.locX;
-        double d1 = entityplayer.e - entityplayer.locZ;
-        double d2 = d0 * d0 + d1 * d1;
-
-        if (d2 >= 64.0D) {
-            int k = (int) entityplayer.d >> 4;
-            int l = (int) entityplayer.e >> 4;
-            int i1 = this.j;
-            int j1 = i - k;
-            int k1 = j - l;
-
-            List<ChunkCoordIntPair> chunksToLoad = new LinkedList<ChunkCoordIntPair>(); // CraftBukkit
-
-            if (j1 != 0 || k1 != 0) {
-                for (int l1 = i - i1; l1 <= i + i1; ++l1) {
-                    for (int i2 = j - i1; i2 <= j + i1; ++i2) {
-                        if (!this.a(l1, i2, k, l, i1)) {
-                            // this.c(l1, i2).a(entityplayer);
-                            chunksToLoad.add(new ChunkCoordIntPair(l1, i2)); // CraftBukkit
-                        }
-
-                        if (!this.a(l1 - j1, i2 - k1, i, j, i1)) {
-                            PlayerChunk playerchunk = this.getChunk(l1 - j1, i2 - k1);
-
-                            if (playerchunk != null) {
-                                playerchunk.b(entityplayer);
-                            }
-                        }
-                    }
-                }
-
-                entityplayer.d = entityplayer.locX;
-                entityplayer.e = entityplayer.locZ;
-                this.e();
-
-                // CraftBukkit start - send nearest chunks first
-                Collections.sort(chunksToLoad, new ChunkCoordComparator(entityplayer));
-                for (ChunkCoordIntPair pair : chunksToLoad) {
-                    this.c(pair.x, pair.z).a(entityplayer);
-                }
-                // CraftBukkit end
-            }
-        }
-    }
-
-    public boolean a(EntityPlayer entityplayer, int i, int j) {
-        PlayerChunk playerchunk = this.getChunk(i, j);
-
-        return playerchunk != null && playerchunk.d(entityplayer) && playerchunk.e();
-    }
-
-    public void a(int i) {
-        i = MathHelper.clamp(i, 3, 32);
-        if (i != this.j) {
-            int j = i - this.j;
-            ArrayList arraylist = Lists.newArrayList(this.managedPlayers);
-            Iterator iterator = arraylist.iterator();
-
-            while (iterator.hasNext()) {
-                EntityPlayer entityplayer = (EntityPlayer) iterator.next();
-                int k = (int) entityplayer.locX >> 4;
-                int l = (int) entityplayer.locZ >> 4;
-                int i1;
-                int j1;
-
-                if (j > 0) {
-                    for (i1 = k - i; i1 <= k + i; ++i1) {
-                        for (j1 = l - i; j1 <= l + i; ++j1) {
-                            PlayerChunk playerchunk = this.c(i1, j1);
-
-                            if (!playerchunk.d(entityplayer)) {
-                                playerchunk.a(entityplayer);
-                            }
-                        }
-                    }
-                } else {
-                    for (i1 = k - this.j; i1 <= k + this.j; ++i1) {
-                        for (j1 = l - this.j; j1 <= l + this.j; ++j1) {
-                            if (!this.a(i1, j1, k, l, i)) {
-                                this.c(i1, j1).b(entityplayer);
-                            }
-                        }
-                    }
-                }
-            }
-
-            this.j = i;
-            this.e();
-        }
-    }
-
-    private void e() {
-        this.l = true;
-        this.m = true;
-    }
-
-    public static int getFurthestViewableBlock(int i) {
-        return i * 16 - 16;
-    }
-
-    private static long d(int i, int j) {
-        return (long) i + 2147483647L | (long) j + 2147483647L << 32;
-    }
-
-    public void a(PlayerChunk playerchunk) {
-        this.f.add(playerchunk);
-    }
-
-    public void b(PlayerChunk playerchunk) {
-        ChunkCoordIntPair chunkcoordintpair = playerchunk.a();
-        long i = d(chunkcoordintpair.x, chunkcoordintpair.z);
-
-        playerchunk.c();
-        this.e.remove(i);
-        this.i.remove(playerchunk);
-        this.f.remove(playerchunk);
-        this.g.remove(playerchunk);
-        this.h.remove(playerchunk);
-        Chunk chunk = playerchunk.f();
-
-        if (chunk != null) {
-            this.getWorld().getChunkProviderServer().unload(chunk);
-        }
-
-    }
-
-    // CraftBukkit start - Sorter to load nearby chunks first
-    private static class ChunkCoordComparator implements java.util.Comparator<ChunkCoordIntPair> {
-        private int x;
-        private int z;
-
-        public ChunkCoordComparator (EntityPlayer entityplayer) {
-            x = (int) entityplayer.locX >> 4;
-            z = (int) entityplayer.locZ >> 4;
-        }
-
-        public int compare(ChunkCoordIntPair a, ChunkCoordIntPair b) {
-            if (a.equals(b)) {
-                return 0;
-            }
-
-            // Subtract current position to set center point
-            int ax = a.x - this.x;
-            int az = a.z - this.z;
-            int bx = b.x - this.x;
-            int bz = b.z - this.z;
-
-            int result = ((ax - bx) * (ax + bx)) + ((az - bz) * (az + bz));
-            if (result != 0) {
-                return result;
-            }
-
-            if (ax < 0) {
-                if (bx < 0) {
-                    return bz - az;
-                } else {
-                    return -1;
-                }
-            } else {
-                if (bx < 0) {
-                    return 1;
-                } else {
-                    return az - bz;
-                }
-            }
-        }
-    }
-    // CraftBukkit end
-}
+package net.minecraft.server;
+
+import com.google.common.base.Predicate;
+import com.google.common.collect.AbstractIterator;
+import com.google.common.collect.ComparisonChain;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Sets;
+import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
+import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.Nullable;
+
+// CraftBukkit start
+import java.util.LinkedList;
+// CraftBukkit end
+
+public class PlayerChunkMap {
+
+    private static final Predicate<EntityPlayer> a = new Predicate() {
+        public boolean a(@Nullable EntityPlayer entityplayer) {
+            return entityplayer != null && !entityplayer.isSpectator();
+        }
+
+        public boolean apply(Object object) {
+            return this.a((EntityPlayer) object);
+        }
+    };
+    private static final Predicate<EntityPlayer> b = new Predicate() {
+        public boolean a(@Nullable EntityPlayer entityplayer) {
+            return entityplayer != null && (!entityplayer.isSpectator() || entityplayer.x().getGameRules().getBoolean("spectatorsGenerateChunks"));
+        }
+
+        public boolean apply(Object object) {
+            return this.a((EntityPlayer) object);
+        }
+    };
+    private final WorldServer world;
+    private final List<EntityPlayer> managedPlayers = Lists.newArrayList();
+    private final Long2ObjectMap<PlayerChunk> e = new Long2ObjectOpenHashMap(4096);
+    //private final Set<PlayerChunk> f = Sets.newHashSet();
+    private final Set<PlayerChunk> f = Sets.newConcurrentHashSet();
+    private final List<PlayerChunk> g = Lists.newLinkedList();
+    private final List<PlayerChunk> h = Lists.newLinkedList();
+    private final List<PlayerChunk> i = Lists.newArrayList();
+    private int j;
+    private long k;
+    private boolean l = true;
+    private boolean m = true;
+    private boolean wasNotEmpty; // CraftBukkit - add field
+
+    public PlayerChunkMap(WorldServer worldserver, int viewDistance /* Spigot */) {
+        this.world = worldserver;
+        this.a(viewDistance); // Spigot
+    }
+
+    public WorldServer getWorld() {
+        return this.world;
+    }
+
+    public Iterator<Chunk> b() {
+        final Iterator iterator = this.i.iterator();
+
+        return new AbstractIterator() {
+            protected Chunk a() {
+                while (true) {
+                    if (iterator.hasNext()) {
+                        PlayerChunk playerchunk = (PlayerChunk) iterator.next();
+                        Chunk chunk = playerchunk.f();
+
+                        if (chunk == null) {
+                            continue;
+                        }
+
+                        if (!chunk.v() && chunk.isDone()) {
+                            return chunk;
+                        }
+
+                        if (!chunk.j()) {
+                            return chunk;
+                        }
+
+                        if (!playerchunk.a(128.0D, PlayerChunkMap.a)) {
+                            continue;
+                        }
+
+                        return chunk;
+                    }
+
+                    return (Chunk) this.endOfData();
+                }
+            }
+
+            protected Object computeNext() {
+                return this.a();
+            }
+        };
+    }
+
+    public void flush() {
+        long i = this.world.getTime();
+        int j;
+        PlayerChunk playerchunk;
+
+        if (i - this.k > 8000L) {
+            this.k = i;
+
+            for (j = 0; j < this.i.size(); ++j) {
+                playerchunk = (PlayerChunk) this.i.get(j);
+                playerchunk.d();
+                playerchunk.c();
+            }
+        }
+
+        if (!this.f.isEmpty()) {
+            Iterator iterator = this.f.iterator();
+
+            while (iterator.hasNext()) {
+                playerchunk = (PlayerChunk) iterator.next();
+                playerchunk.d();
+            }
+
+            this.f.clear();
+        }
+
+        if (this.l && i % 4L == 0L) {
+            this.l = false;
+            Collections.sort(this.h, new Comparator() {
+                public int a(PlayerChunk playerchunk, PlayerChunk playerchunk1) {
+                    return ComparisonChain.start().compare(playerchunk.g(), playerchunk1.g()).result();
+                }
+
+                public int compare(Object object, Object object1) {
+                    return this.a((PlayerChunk) object, (PlayerChunk) object1);
+                }
+            });
+        }
+
+        if (this.m && i % 4L == 2L) {
+            this.m = false;
+            Collections.sort(this.g, new Comparator() {
+                public int a(PlayerChunk playerchunk, PlayerChunk playerchunk1) {
+                    return ComparisonChain.start().compare(playerchunk.g(), playerchunk1.g()).result();
+                }
+
+                public int compare(Object object, Object object1) {
+                    return this.a((PlayerChunk) object, (PlayerChunk) object1);
+                }
+            });
+        }
+
+        if (!this.h.isEmpty()) {
+            long k = System.nanoTime() + 50000000L;
+            int l = 49;
+            Iterator iterator1 = this.h.iterator();
+
+            while (iterator1.hasNext()) {
+                PlayerChunk playerchunk1 = (PlayerChunk) iterator1.next();
+
+                if (playerchunk1.f() == null) {
+                    boolean flag = playerchunk1.a(PlayerChunkMap.b);
+
+                    if (playerchunk1.a(flag)) {
+                        iterator1.remove();
+                        if (playerchunk1.b()) {
+                            this.g.remove(playerchunk1);
+                        }
+
+                        --l;
+                        if (l < 0 || System.nanoTime() > k) {
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+
+        if (!this.g.isEmpty()) {
+            j = 81;
+            Iterator iterator2 = this.g.iterator();
+
+            while (iterator2.hasNext()) {
+                PlayerChunk playerchunk2 = (PlayerChunk) iterator2.next();
+
+                if (playerchunk2.b()) {
+                    iterator2.remove();
+                    --j;
+                    if (j < 0) {
+                        break;
+                    }
+                }
+            }
+        }
+
+        if (this.managedPlayers.isEmpty()) {
+            WorldProvider worldprovider = this.world.worldProvider;
+
+            if (!worldprovider.e()) {
+                this.world.getChunkProviderServer().b();
+            }
+        }
+
+    }
+
+    public boolean a(int i, int j) {
+        long k = d(i, j);
+
+        return this.e.get(k) != null;
+    }
+
+    @Nullable
+    public PlayerChunk getChunk(int i, int j) {
+        return (PlayerChunk) this.e.get(d(i, j));
+    }
+
+    private PlayerChunk c(int i, int j) {
+        long k = d(i, j);
+        PlayerChunk playerchunk = (PlayerChunk) this.e.get(k);
+
+        if (playerchunk == null) {
+            playerchunk = new PlayerChunk(this, i, j);
+            this.e.put(k, playerchunk);
+            this.i.add(playerchunk);
+            if (playerchunk.f() == null) {
+                this.h.add(playerchunk);
+            }
+
+            if (!playerchunk.b()) {
+                this.g.add(playerchunk);
+            }
+        }
+
+        return playerchunk;
+    }
+
+    // CraftBukkit start - add method
+    public final boolean isChunkInUse(int x, int z) {
+        PlayerChunk pi = getChunk(x, z);
+        if (pi != null) {
+            return (pi.c.size() > 0);
+        }
+        return false;
+    }
+    // CraftBukkit end
+
+    public void flagDirty(BlockPosition blockposition) {
+        int i = blockposition.getX() >> 4;
+        int j = blockposition.getZ() >> 4;
+        PlayerChunk playerchunk = this.getChunk(i, j);
+
+        if (playerchunk != null) {
+            playerchunk.a(blockposition.getX() & 15, blockposition.getY(), blockposition.getZ() & 15);
+        }
+
+    }
+
+    public void addPlayer(EntityPlayer entityplayer) {
+        int i = (int) entityplayer.locX >> 4;
+        int j = (int) entityplayer.locZ >> 4;
+
+        entityplayer.d = entityplayer.locX;
+        entityplayer.e = entityplayer.locZ;
+
+
+        // CraftBukkit start - Load nearby chunks first
+        List<ChunkCoordIntPair> chunkList = new LinkedList<ChunkCoordIntPair>();
+
+        for (int k = i - this.j; k <= i + this.j; ++k) {
+            for (int l = j - this.j; l <= j + this.j; ++l) {
+                chunkList.add(new ChunkCoordIntPair(k, l));
+            }
+        }
+
+        Collections.sort(chunkList, new ChunkCoordComparator(entityplayer));
+        for (ChunkCoordIntPair pair : chunkList) {
+            this.c(pair.x, pair.z).a(entityplayer);
+        }
+        // CraftBukkit end
+
+        this.managedPlayers.add(entityplayer);
+        this.e();
+    }
+
+    public void removePlayer(EntityPlayer entityplayer) {
+        int i = (int) entityplayer.d >> 4;
+        int j = (int) entityplayer.e >> 4;
+
+        for (int k = i - this.j; k <= i + this.j; ++k) {
+            for (int l = j - this.j; l <= j + this.j; ++l) {
+                PlayerChunk playerchunk = this.getChunk(k, l);
+
+                if (playerchunk != null) {
+                    playerchunk.b(entityplayer);
+                }
+            }
+        }
+
+        this.managedPlayers.remove(entityplayer);
+        this.e();
+    }
+
+    private boolean a(int i, int j, int k, int l, int i1) {
+        int j1 = i - k;
+        int k1 = j - l;
+
+        return j1 >= -i1 && j1 <= i1 ? k1 >= -i1 && k1 <= i1 : false;
+    }
+
+    public void movePlayer(EntityPlayer entityplayer) {
+        int i = (int) entityplayer.locX >> 4;
+        int j = (int) entityplayer.locZ >> 4;
+        double d0 = entityplayer.d - entityplayer.locX;
+        double d1 = entityplayer.e - entityplayer.locZ;
+        double d2 = d0 * d0 + d1 * d1;
+
+        if (d2 >= 64.0D) {
+            int k = (int) entityplayer.d >> 4;
+            int l = (int) entityplayer.e >> 4;
+            int i1 = this.j;
+            int j1 = i - k;
+            int k1 = j - l;
+
+            List<ChunkCoordIntPair> chunksToLoad = new LinkedList<ChunkCoordIntPair>(); // CraftBukkit
+
+            if (j1 != 0 || k1 != 0) {
+                for (int l1 = i - i1; l1 <= i + i1; ++l1) {
+                    for (int i2 = j - i1; i2 <= j + i1; ++i2) {
+                        if (!this.a(l1, i2, k, l, i1)) {
+                            // this.c(l1, i2).a(entityplayer);
+                            chunksToLoad.add(new ChunkCoordIntPair(l1, i2)); // CraftBukkit
+                        }
+
+                        if (!this.a(l1 - j1, i2 - k1, i, j, i1)) {
+                            PlayerChunk playerchunk = this.getChunk(l1 - j1, i2 - k1);
+
+                            if (playerchunk != null) {
+                                playerchunk.b(entityplayer);
+                            }
+                        }
+                    }
+                }
+
+                entityplayer.d = entityplayer.locX;
+                entityplayer.e = entityplayer.locZ;
+                this.e();
+
+                // CraftBukkit start - send nearest chunks first
+                Collections.sort(chunksToLoad, new ChunkCoordComparator(entityplayer));
+                for (ChunkCoordIntPair pair : chunksToLoad) {
+                    this.c(pair.x, pair.z).a(entityplayer);
+                }
+                // CraftBukkit end
+            }
+        }
+    }
+
+    public boolean a(EntityPlayer entityplayer, int i, int j) {
+        PlayerChunk playerchunk = this.getChunk(i, j);
+
+        return playerchunk != null && playerchunk.d(entityplayer) && playerchunk.e();
+    }
+
+    public void a(int i) {
+        i = MathHelper.clamp(i, 3, 32);
+        if (i != this.j) {
+            int j = i - this.j;
+            ArrayList arraylist = Lists.newArrayList(this.managedPlayers);
+            Iterator iterator = arraylist.iterator();
+
+            while (iterator.hasNext()) {
+                EntityPlayer entityplayer = (EntityPlayer) iterator.next();
+                int k = (int) entityplayer.locX >> 4;
+                int l = (int) entityplayer.locZ >> 4;
+                int i1;
+                int j1;
+
+                if (j > 0) {
+                    for (i1 = k - i; i1 <= k + i; ++i1) {
+                        for (j1 = l - i; j1 <= l + i; ++j1) {
+                            PlayerChunk playerchunk = this.c(i1, j1);
+
+                            if (!playerchunk.d(entityplayer)) {
+                                playerchunk.a(entityplayer);
+                            }
+                        }
+                    }
+                } else {
+                    for (i1 = k - this.j; i1 <= k + this.j; ++i1) {
+                        for (j1 = l - this.j; j1 <= l + this.j; ++j1) {
+                            if (!this.a(i1, j1, k, l, i)) {
+                                this.c(i1, j1).b(entityplayer);
+                            }
+                        }
+                    }
+                }
+            }
+
+            this.j = i;
+            this.e();
+        }
+    }
+
+    private void e() {
+        this.l = true;
+        this.m = true;
+    }
+
+    public static int getFurthestViewableBlock(int i) {
+        return i * 16 - 16;
+    }
+
+    private static long d(int i, int j) {
+        return (long) i + 2147483647L | (long) j + 2147483647L << 32;
+    }
+
+    public void a(PlayerChunk playerchunk) {
+        this.f.add(playerchunk);
+    }
+
+    public void b(PlayerChunk playerchunk) {
+        ChunkCoordIntPair chunkcoordintpair = playerchunk.a();
+        long i = d(chunkcoordintpair.x, chunkcoordintpair.z);
+
+        playerchunk.c();
+        this.e.remove(i);
+        this.i.remove(playerchunk);
+        this.f.remove(playerchunk);
+        this.g.remove(playerchunk);
+        this.h.remove(playerchunk);
+        Chunk chunk = playerchunk.f();
+
+        if (chunk != null) {
+            this.getWorld().getChunkProviderServer().unload(chunk);
+        }
+
+    }
+
+    // CraftBukkit start - Sorter to load nearby chunks first
+    private static class ChunkCoordComparator implements java.util.Comparator<ChunkCoordIntPair> {
+        private int x;
+        private int z;
+
+        public ChunkCoordComparator (EntityPlayer entityplayer) {
+            x = (int) entityplayer.locX >> 4;
+            z = (int) entityplayer.locZ >> 4;
+        }
+
+        public int compare(ChunkCoordIntPair a, ChunkCoordIntPair b) {
+            if (a.equals(b)) {
+                return 0;
+            }
+
+            // Subtract current position to set center point
+            int ax = a.x - this.x;
+            int az = a.z - this.z;
+            int bx = b.x - this.x;
+            int bz = b.z - this.z;
+
+            int result = ((ax - bx) * (ax + bx)) + ((az - bz) * (az + bz));
+            if (result != 0) {
+                return result;
+            }
+
+            if (ax < 0) {
+                if (bx < 0) {
+                    return bz - az;
+                } else {
+                    return -1;
+                }
+            } else {
+                if (bx < 0) {
+                    return 1;
+                } else {
+                    return az - bz;
+                }
+            }
+        }
+    }
+    // CraftBukkit end
+}
diff -Naur src_origin/main/java/net/minecraft/server/PlayerList.java src/main/java/net/minecraft/server/PlayerList.java
--- src_origin/main/java/net/minecraft/server/PlayerList.java	2016-08-25 22:39:52.303602019 +0800
+++ src/main/java/net/minecraft/server/PlayerList.java	2016-08-26 03:24:14.769198496 +0800
@@ -1,1368 +1,1370 @@
-package net.minecraft.server;
-
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
-import com.mojang.authlib.GameProfile;
-import io.netty.buffer.Unpooled;
-import java.io.File;
-import java.net.SocketAddress;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.UUID;
-import javax.annotation.Nullable;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-
-// CraftBukkit start
-import org.bukkit.craftbukkit.CraftServer;
-import org.bukkit.craftbukkit.CraftWorld;
-import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
-
-import org.bukkit.Bukkit;
-import org.bukkit.Location;
-import org.bukkit.TravelAgent;
-import org.bukkit.craftbukkit.util.CraftChatMessage;
-import org.bukkit.entity.Player;
-import org.bukkit.event.player.PlayerChangedWorldEvent;
-import org.bukkit.event.player.PlayerPortalEvent;
-import org.bukkit.event.player.PlayerJoinEvent;
-import org.bukkit.event.player.PlayerLoginEvent;
-import org.bukkit.event.player.PlayerQuitEvent;
-import org.bukkit.event.player.PlayerRespawnEvent;
-import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
-import org.bukkit.util.Vector;
-import org.spigotmc.event.player.PlayerSpawnLocationEvent;
-// CraftBukkit end
-
-public abstract class PlayerList {
-
-    public static final File a = new File("banned-players.json");
-    public static final File b = new File("banned-ips.json");
-    public static final File c = new File("ops.json");
-    public static final File d = new File("whitelist.json");
-    private static final Logger f = LogManager.getLogger();
-    private static final SimpleDateFormat g = new SimpleDateFormat("yyyy-MM-dd \'at\' HH:mm:ss z");
-    private final MinecraftServer server;
-    public final List<EntityPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
-    private final Map<UUID, EntityPlayer> j = Maps.newHashMap();
-    private final GameProfileBanList k;
-    private final IpBanList l;
-    private final OpList operators;
-    private final WhiteList whitelist;
-    private final Map<UUID, ServerStatisticManager> o;
-    public IPlayerFileData playerFileData;
-    private boolean hasWhitelist;
-    protected int maxPlayers;
-    private int r;
-    private EnumGamemode s;
-    private boolean t;
-    private int u;
-
-    // CraftBukkit start
-    private CraftServer cserver;
-    private final Map<String,EntityPlayer> playersByName = new org.spigotmc.CaseInsensitiveMap<EntityPlayer>();
-
-    public PlayerList(MinecraftServer minecraftserver) {
-        this.cserver = minecraftserver.server = new CraftServer(minecraftserver, this);
-        minecraftserver.console = org.bukkit.craftbukkit.command.ColouredConsoleSender.getInstance();
-        minecraftserver.reader.addCompleter(new org.bukkit.craftbukkit.command.ConsoleCommandCompleter(minecraftserver.server));
-        // CraftBukkit end
-
-        this.k = new GameProfileBanList(PlayerList.a);
-        this.l = new IpBanList(PlayerList.b);
-        this.operators = new OpList(PlayerList.c);
-        this.whitelist = new WhiteList(PlayerList.d);
-        this.o = Maps.newHashMap();
-        this.server = minecraftserver;
-        this.k.a(false);
-        this.l.a(false);
-        this.maxPlayers = 8;
-    }
-
-    public void a(NetworkManager networkmanager, EntityPlayer entityplayer) {
-        GameProfile gameprofile = entityplayer.getProfile();
-        UserCache usercache = this.server.getUserCache();
-        GameProfile gameprofile1 = usercache.a(gameprofile.getId());
-        String s = gameprofile1 == null ? gameprofile.getName() : gameprofile1.getName();
-
-        usercache.a(gameprofile);
-        NBTTagCompound nbttagcompound = this.a(entityplayer);
-        // CraftBukkit start - Better rename detection
-        if (nbttagcompound != null && nbttagcompound.hasKey("bukkit")) {
-            NBTTagCompound bukkit = nbttagcompound.getCompound("bukkit");
-            s = bukkit.hasKeyOfType("lastKnownName", 8) ? bukkit.getString("lastKnownName") : s;
-        }
-        // CraftBukkit end
-
-        entityplayer.spawnIn(this.server.getWorldServer(entityplayer.dimension));
-        entityplayer.playerInteractManager.a((WorldServer) entityplayer.world);
-        String s1 = "local";
-
-        if (networkmanager.getSocketAddress() != null) {
-            s1 = networkmanager.getSocketAddress().toString();
-        }
-
-        // Spigot start - spawn location event
-        Player bukkitPlayer = entityplayer.getBukkitEntity();
-        PlayerSpawnLocationEvent ev = new PlayerSpawnLocationEvent(bukkitPlayer, bukkitPlayer.getLocation());
-        Bukkit.getPluginManager().callEvent(ev);
-
-        Location loc = ev.getSpawnLocation();
-        WorldServer world = ((CraftWorld) loc.getWorld()).getHandle();
-
-        entityplayer.spawnIn(world);
-        entityplayer.setPosition(loc.getX(), loc.getY(), loc.getZ());
-        entityplayer.setYawPitch(loc.getYaw(), loc.getPitch()); 
-        // Spigot end
-
-        // CraftBukkit - Moved message to after join
-        // PlayerList.f.info("{}[{}] logged in with entity id {} at ({}, {}, {})", new Object[] { entityplayer.getName(), s1, Integer.valueOf(entityplayer.getId()), Double.valueOf(entityplayer.locX), Double.valueOf(entityplayer.locY), Double.valueOf(entityplayer.locZ)});
-        WorldServer worldserver = this.server.getWorldServer(entityplayer.dimension);
-        WorldData worlddata = worldserver.getWorldData();
-        BlockPosition blockposition = worldserver.getSpawn();
-
-        this.a(entityplayer, (EntityPlayer) null, worldserver);
-        PlayerConnection playerconnection = new PlayerConnection(this.server, networkmanager, entityplayer);
-
-        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getDimensionID(), worldserver.getDifficulty(), this.getMaxPlayers(), worlddata.getType(), worldserver.getGameRules().getBoolean("reducedDebugInfo")));
-        entityplayer.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
-        playerconnection.sendPacket(new PacketPlayOutCustomPayload("MC|Brand", (new PacketDataSerializer(Unpooled.buffer())).a(this.getServer().getServerModName())));
-        playerconnection.sendPacket(new PacketPlayOutServerDifficulty(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
-        playerconnection.sendPacket(new PacketPlayOutSpawnPosition(blockposition));
-        playerconnection.sendPacket(new PacketPlayOutAbilities(entityplayer.abilities));
-        playerconnection.sendPacket(new PacketPlayOutHeldItemSlot(entityplayer.inventory.itemInHandIndex));
-        this.f(entityplayer);
-        entityplayer.getStatisticManager().d();
-        entityplayer.getStatisticManager().updateStatistics(entityplayer);
-        this.sendScoreboard((ScoreboardServer) worldserver.getScoreboard(), entityplayer);
-        this.server.aC();
-        // CraftBukkit start - login message is handled in the event
-        // ChatMessage chatmessage;
-
-        String joinMessage;
-        if (entityplayer.getName().equalsIgnoreCase(s)) {
-            // chatmessage = new ChatMessage("multiplayer.player.joined", new Object[] { entityplayer.getScoreboardDisplayName()});
-            joinMessage = "\u00A7e" + LocaleI18n.a("multiplayer.player.joined", entityplayer.getName());
-        } else {
-            // chatmessage = new ChatMessage("multiplayer.player.joined.renamed", new Object[] { entityplayer.getScoreboardDisplayName(), s});
-            joinMessage = "\u00A7e" + LocaleI18n.a("multiplayer.player.joined.renamed", entityplayer.getName(), s);
-        }
-
-        // chatmessage.getChatModifier().setColor(EnumChatFormat.YELLOW);
-        // this.sendMessage(chatmessage);
-        this.onPlayerJoin(entityplayer, joinMessage);
-        // CraftBukkit end
-        worldserver = server.getWorldServer(entityplayer.dimension);  // CraftBukkit - Update in case join event changed it
-        playerconnection.a(entityplayer.locX, entityplayer.locY, entityplayer.locZ, entityplayer.yaw, entityplayer.pitch);
-        this.b(entityplayer, worldserver);
-        if (!this.server.getResourcePack().isEmpty()) {
-            entityplayer.setResourcePack(this.server.getResourcePack(), this.server.getResourcePackHash());
-        }
-
-        Iterator iterator = entityplayer.getEffects().iterator();
-
-        while (iterator.hasNext()) {
-            MobEffect mobeffect = (MobEffect) iterator.next();
-
-            playerconnection.sendPacket(new PacketPlayOutEntityEffect(entityplayer.getId(), mobeffect));
-        }
-
-        if (nbttagcompound != null) {
-            if (nbttagcompound.hasKeyOfType("RootVehicle", 10)) {
-                NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("RootVehicle");
-                Entity entity = ChunkRegionLoader.a(nbttagcompound1.getCompound("Entity"), worldserver, true);
-
-                if (entity != null) {
-                    UUID uuid = nbttagcompound1.a("Attach");
-                    Iterator iterator1;
-                    Entity entity1;
-
-                    if (entity.getUniqueID().equals(uuid)) {
-                        entityplayer.a(entity, true);
-                    } else {
-                        iterator1 = entity.by().iterator();
-
-                        while (iterator1.hasNext()) {
-                            entity1 = (Entity) iterator1.next();
-                            if (entity1.getUniqueID().equals(uuid)) {
-                                entityplayer.a(entity1, true);
-                                break;
-                            }
-                        }
-                    }
-
-                    if (!entityplayer.isPassenger()) {
-                        PlayerList.f.warn("Couldn\'t reattach entity to player");
-                        worldserver.removeEntity(entity);
-                        iterator1 = entity.by().iterator();
-
-                        while (iterator1.hasNext()) {
-                            entity1 = (Entity) iterator1.next();
-                            worldserver.removeEntity(entity1);
-                        }
-                    }
-                }
-            } else if (nbttagcompound.hasKeyOfType("Riding", 10)) {
-                Entity entity2 = ChunkRegionLoader.a(nbttagcompound.getCompound("Riding"), worldserver, true);
-
-                if (entity2 != null) {
-                    entityplayer.a(entity2, true);
-                }
-            }
-        }
-
-        entityplayer.syncInventory();
-        // CraftBukkit - Moved from above, added world
-        PlayerList.f.info(entityplayer.getName() + "[" + s1 + "] logged in with entity id " + entityplayer.getId() + " at ([" + entityplayer.world.worldData.getName() + "]" + entityplayer.locX + ", " + entityplayer.locY + ", " + entityplayer.locZ + ")");
-    }
-
-    public void sendScoreboard(ScoreboardServer scoreboardserver, EntityPlayer entityplayer) {
-        HashSet hashset = Sets.newHashSet();
-        Iterator iterator = scoreboardserver.getTeams().iterator();
-
-        while (iterator.hasNext()) {
-            ScoreboardTeam scoreboardteam = (ScoreboardTeam) iterator.next();
-
-            entityplayer.playerConnection.sendPacket(new PacketPlayOutScoreboardTeam(scoreboardteam, 0));
-        }
-
-        for (int i = 0; i < 19; ++i) {
-            ScoreboardObjective scoreboardobjective = scoreboardserver.getObjectiveForSlot(i);
-
-            if (scoreboardobjective != null && !hashset.contains(scoreboardobjective)) {
-                List list = scoreboardserver.getScoreboardScorePacketsForObjective(scoreboardobjective);
-                Iterator iterator1 = list.iterator();
-
-                while (iterator1.hasNext()) {
-                    Packet packet = (Packet) iterator1.next();
-
-                    entityplayer.playerConnection.sendPacket(packet);
-                }
-
-                hashset.add(scoreboardobjective);
-            }
-        }
-
-    }
-
-    public void setPlayerFileData(WorldServer[] aworldserver) {
-        if (playerFileData != null) return; // CraftBukkit
-        this.playerFileData = aworldserver[0].getDataManager().getPlayerFileData();
-        aworldserver[0].getWorldBorder().a(new IWorldBorderListener() {
-            public void a(WorldBorder worldborder, double d0) {
-                PlayerList.this.sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_SIZE), worldborder.world);
-            }
-
-            public void a(WorldBorder worldborder, double d0, double d1, long i) {
-                PlayerList.this.sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.LERP_SIZE), worldborder.world);
-            }
-
-            public void a(WorldBorder worldborder, double d0, double d1) {
-                PlayerList.this.sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_CENTER), worldborder.world);
-            }
-
-            public void a(WorldBorder worldborder, int i) {
-                PlayerList.this.sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_WARNING_TIME), worldborder.world);
-            }
-
-            public void b(WorldBorder worldborder, int i) {
-                PlayerList.this.sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_WARNING_BLOCKS), worldborder.world);
-            }
-
-            public void b(WorldBorder worldborder, double d0) {}
-
-            public void c(WorldBorder worldborder, double d0) {}
-        });
-    }
-
-    public void a(EntityPlayer entityplayer, WorldServer worldserver) {
-        WorldServer worldserver1 = entityplayer.x();
-
-        if (worldserver != null) {
-            worldserver.getPlayerChunkMap().removePlayer(entityplayer);
-        }
-
-        worldserver1.getPlayerChunkMap().addPlayer(entityplayer);
-        worldserver1.getChunkProviderServer().getChunkAt((int) entityplayer.locX >> 4, (int) entityplayer.locZ >> 4);
-    }
-
-    public int d() {
-        return PlayerChunkMap.getFurthestViewableBlock(this.s());
-    }
-
-    public NBTTagCompound a(EntityPlayer entityplayer) {
-        NBTTagCompound nbttagcompound = this.server.worlds.get(0).getWorldData().h(); // CraftBukkit
-        NBTTagCompound nbttagcompound1;
-
-        if (entityplayer.getName().equals(this.server.Q()) && nbttagcompound != null) {
-            nbttagcompound1 = this.server.getDataConverterManager().a((DataConverterType) DataConverterTypes.PLAYER, nbttagcompound);
-            entityplayer.f(nbttagcompound1);
-            PlayerList.f.debug("loading single player");
-        } else {
-            nbttagcompound1 = this.playerFileData.load(entityplayer);
-        }
-
-        return nbttagcompound1;
-    }
-
-    protected void savePlayerFile(EntityPlayer entityplayer) {
-        this.playerFileData.save(entityplayer);
-        ServerStatisticManager serverstatisticmanager = (ServerStatisticManager) this.o.get(entityplayer.getUniqueID());
-
-        if (serverstatisticmanager != null) {
-            serverstatisticmanager.b();
-        }
-
-    }
-
-    public void onPlayerJoin(EntityPlayer entityplayer, String joinMessage) { // CraftBukkit added param
-        this.players.add(entityplayer);
-        this.playersByName.put(entityplayer.getName(), entityplayer); // Spigot
-        this.j.put(entityplayer.getUniqueID(), entityplayer);
-        // this.sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, new EntityPlayer[] { entityplayer})); // CraftBukkit - replaced with loop below
-        WorldServer worldserver = this.server.getWorldServer(entityplayer.dimension);
-
-        // CraftBukkit start
-        PlayerJoinEvent playerJoinEvent = new PlayerJoinEvent(cserver.getPlayer(entityplayer), joinMessage);
-        cserver.getPluginManager().callEvent(playerJoinEvent);
-
-        joinMessage = playerJoinEvent.getJoinMessage();
-
-        if (joinMessage != null && joinMessage.length() > 0) {
-            for (IChatBaseComponent line : org.bukkit.craftbukkit.util.CraftChatMessage.fromString(joinMessage)) {
-                server.getPlayerList().sendAll(new PacketPlayOutChat(line));
-            }
-        }
-
-        ChunkIOExecutor.adjustPoolSize(getPlayerCount());
-        // CraftBukkit end
-
-        // CraftBukkit start - sendAll above replaced with this loop
-        PacketPlayOutPlayerInfo packet = new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, entityplayer);
-
-        for (int i = 0; i < this.players.size(); ++i) {
-            EntityPlayer entityplayer1 = (EntityPlayer) this.players.get(i);
-
-            if (entityplayer1.getBukkitEntity().canSee(entityplayer.getBukkitEntity())) {
-                entityplayer1.playerConnection.sendPacket(packet);
-            }
-
-            if (!entityplayer.getBukkitEntity().canSee(entityplayer1.getBukkitEntity())) {
-                continue;
-            }
-
-            entityplayer.playerConnection.sendPacket(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, new EntityPlayer[] { entityplayer1}));
-        }
-        // CraftBukkit end
-
-        // CraftBukkit start - Only add if the player wasn't moved in the event
-        if (entityplayer.world == worldserver && !worldserver.players.contains(entityplayer)) {
-            worldserver.addEntity(entityplayer);
-            this.a(entityplayer, (WorldServer) null);
-        }
-        // CraftBukkit end
-    }
-
-    public void d(EntityPlayer entityplayer) {
-        entityplayer.x().getPlayerChunkMap().movePlayer(entityplayer);
-    }
-
-    public String disconnect(EntityPlayer entityplayer) { // CraftBukkit - return string
-        WorldServer worldserver = entityplayer.x();
-
-        entityplayer.b(StatisticList.f);
-
-        // CraftBukkit start - Quitting must be before we do final save of data, in case plugins need to modify it
-        org.bukkit.craftbukkit.event.CraftEventFactory.handleInventoryCloseEvent(entityplayer);
-
-        PlayerQuitEvent playerQuitEvent = new PlayerQuitEvent(cserver.getPlayer(entityplayer), "\u00A7e" + entityplayer.getName() + " left the game");
-        cserver.getPluginManager().callEvent(playerQuitEvent);
-        entityplayer.getBukkitEntity().disconnect(playerQuitEvent.getQuitMessage());
-
-        entityplayer.k_();// SPIGOT-924 // PAIL: rename - playerTick
-        // CraftBukkit end
-
-        this.savePlayerFile(entityplayer);
-        if (entityplayer.isPassenger()) {
-            Entity entity = entityplayer.getVehicle();
-
-            if (entity.b(EntityPlayer.class).size() == 1) {
-                PlayerList.f.debug("Removing player mount");
-                entityplayer.stopRiding();
-                worldserver.removeEntity(entity);
-                Iterator iterator = entity.by().iterator();
-
-                while (iterator.hasNext()) {
-                    Entity entity1 = (Entity) iterator.next();
-
-                    worldserver.removeEntity(entity1);
-                }
-
-                worldserver.getChunkAt(entityplayer.ac, entityplayer.ae).e();
-            }
-        }
-
-        worldserver.kill(entityplayer);
-        worldserver.getPlayerChunkMap().removePlayer(entityplayer);
-        this.players.remove(entityplayer);
-        this.playersByName.remove(entityplayer.getName()); // Spigot
-        UUID uuid = entityplayer.getUniqueID();
-        EntityPlayer entityplayer1 = (EntityPlayer) this.j.get(uuid);
-
-        if (entityplayer1 == entityplayer) {
-            this.j.remove(uuid);
-            this.o.remove(uuid);
-        }
-
-        // CraftBukkit start
-        //  this.sendAll(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.REMOVE_PLAYER, new EntityPlayer[] { entityplayer}));
-        PacketPlayOutPlayerInfo packet = new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.REMOVE_PLAYER, entityplayer);
-        for (int i = 0; i < players.size(); i++) {
-            EntityPlayer entityplayer2 = (EntityPlayer) this.players.get(i);
-
-            if (entityplayer2.getBukkitEntity().canSee(entityplayer.getBukkitEntity())) {
-                entityplayer2.playerConnection.sendPacket(packet);
-            } else {
-                entityplayer2.getBukkitEntity().removeDisconnectingPlayer(entityplayer.getBukkitEntity());
-            }
-        }
-        // This removes the scoreboard (and player reference) for the specific player in the manager
-        cserver.getScoreboardManager().removePlayer(entityplayer.getBukkitEntity());
-        // CraftBukkit end
-
-        ChunkIOExecutor.adjustPoolSize(this.getPlayerCount()); // CraftBukkit
-
-        return playerQuitEvent.getQuitMessage(); // CraftBukkit
-    }
-
-    // CraftBukkit start - Whole method, SocketAddress to LoginListener, added hostname to signature, return EntityPlayer
-    public EntityPlayer attemptLogin(LoginListener loginlistener, GameProfile gameprofile, String hostname) {
-        // Moved from processLogin
-        UUID uuid = EntityHuman.a(gameprofile);
-        ArrayList arraylist = Lists.newArrayList();
-
-        EntityPlayer entityplayer;
-
-        for (int i = 0; i < this.players.size(); ++i) {
-            entityplayer = (EntityPlayer) this.players.get(i);
-            if (entityplayer.getUniqueID().equals(uuid)) {
-                arraylist.add(entityplayer);
-            }
-        }
-
-        Iterator iterator = arraylist.iterator();
-
-        while (iterator.hasNext()) {
-            entityplayer = (EntityPlayer) iterator.next();
-            savePlayerFile(entityplayer); // CraftBukkit - Force the player's inventory to be saved
-            entityplayer.playerConnection.disconnect("You logged in from another location");
-        }
-
-        // Instead of kicking then returning, we need to store the kick reason
-        // in the event, check with plugins to see if it's ok, and THEN kick
-        // depending on the outcome.
-        SocketAddress socketaddress = loginlistener.networkManager.getSocketAddress();
-
-        EntityPlayer entity = new EntityPlayer(server, server.getWorldServer(0), gameprofile, new PlayerInteractManager(server.getWorldServer(0)));
-        Player player = entity.getBukkitEntity();
-        PlayerLoginEvent event = new PlayerLoginEvent(player, hostname, ((java.net.InetSocketAddress) socketaddress).getAddress(), ((java.net.InetSocketAddress) loginlistener.networkManager.getRawAddress()).getAddress());
-        String s;
-
-        if (getProfileBans().isBanned(gameprofile) && !getProfileBans().get(gameprofile).hasExpired()) {
-            GameProfileBanEntry gameprofilebanentry = (GameProfileBanEntry) this.k.get(gameprofile);
-
-            s = "You are banned from this server!\nReason: " + gameprofilebanentry.getReason();
-            if (gameprofilebanentry.getExpires() != null) {
-                s = s + "\nYour ban will be removed on " + PlayerList.g.format(gameprofilebanentry.getExpires());
-            }
-
-            // return s;
-            if (!gameprofilebanentry.hasExpired()) event.disallow(PlayerLoginEvent.Result.KICK_BANNED, s); // Spigot
-        } else if (!this.isWhitelisted(gameprofile)) {
-            // return "You are not white-listed on this server!";
-            event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, org.spigotmc.SpigotConfig.whitelistMessage); // Spigot
-        } else if (getIPBans().isBanned(socketaddress) && !getIPBans().get(socketaddress).hasExpired()) {
-            IpBanEntry ipbanentry = this.l.get(socketaddress);
-
-            s = "Your IP address is banned from this server!\nReason: " + ipbanentry.getReason();
-            if (ipbanentry.getExpires() != null) {
-                s = s + "\nYour ban will be removed on " + PlayerList.g.format(ipbanentry.getExpires());
-            }
-
-            // return s;
-            event.disallow(PlayerLoginEvent.Result.KICK_BANNED, s);
-        } else {
-            // return this.players.size() >= this.maxPlayers && !this.f(gameprofile) ? "The server is full!" : null;
-            if (this.players.size() >= this.maxPlayers && !this.f(gameprofile)) {
-                event.disallow(PlayerLoginEvent.Result.KICK_FULL, org.spigotmc.SpigotConfig.serverFullMessage); // Spigot
-            }
-        }
-
-        cserver.getPluginManager().callEvent(event);
-        if (event.getResult() != PlayerLoginEvent.Result.ALLOWED) {
-            loginlistener.disconnect(event.getKickMessage());
-            return null;
-        }
-        return entity;
-    }
-
-    public EntityPlayer processLogin(GameProfile gameprofile, EntityPlayer player) { // CraftBukkit - added EntityPlayer
-        /* CraftBukkit startMoved up
-        UUID uuid = EntityHuman.a(gameprofile);
-        ArrayList arraylist = Lists.newArrayList();
-
-        for (int i = 0; i < this.players.size(); ++i) {
-            EntityPlayer entityplayer = (EntityPlayer) this.players.get(i);
-
-            if (entityplayer.getUniqueID().equals(uuid)) {
-                arraylist.add(entityplayer);
-            }
-        }
-
-        EntityPlayer entityplayer1 = (EntityPlayer) this.j.get(gameprofile.getId());
-
-        if (entityplayer1 != null && !arraylist.contains(entityplayer1)) {
-            arraylist.add(entityplayer1);
-        }
-
-        Iterator iterator = arraylist.iterator();
-
-        while (iterator.hasNext()) {
-            EntityPlayer entityplayer2 = (EntityPlayer) iterator.next();
-
-            entityplayer2.playerConnection.disconnect("You logged in from another location");
-        }
-
-        Object object;
-
-        if (this.server.V()) {
-            object = new DemoPlayerInteractManager(this.server.getWorldServer(0));
-        } else {
-            object = new PlayerInteractManager(this.server.getWorldServer(0));
-        }
-
-        return new EntityPlayer(this.server, this.server.getWorldServer(0), gameprofile, (PlayerInteractManager) object);
-        */
-        return player;
-        // CraftBukkit end
-    }
-
-    // CraftBukkit start
-    public EntityPlayer moveToWorld(EntityPlayer entityplayer, int i, boolean flag) {
-        return this.moveToWorld(entityplayer, i, flag, null, true);
-    }
-
-    public EntityPlayer moveToWorld(EntityPlayer entityplayer, int i, boolean flag, Location location, boolean avoidSuffocation) {
-        entityplayer.x().getTracker().untrackPlayer(entityplayer);
-        // entityplayer.x().getTracker().untrackEntity(entityplayer); // CraftBukkit
-        entityplayer.x().getPlayerChunkMap().removePlayer(entityplayer);
-        this.players.remove(entityplayer);
-        this.playersByName.remove(entityplayer.getName()); // Spigot
-        this.server.getWorldServer(entityplayer.dimension).removeEntity(entityplayer);
-        BlockPosition blockposition = entityplayer.getBed();
-        boolean flag1 = entityplayer.isRespawnForced();
-
-        /* CraftBukkit start
-        entityplayer.dimension = i;
-        Object object;
-
-        if (this.server.V()) {
-            object = new DemoPlayerInteractManager(this.server.getWorldServer(entityplayer.dimension));
-        } else {
-            object = new PlayerInteractManager(this.server.getWorldServer(entityplayer.dimension));
-        }
-
-        EntityPlayer entityplayer1 = new EntityPlayer(this.server, this.server.getWorldServer(entityplayer.dimension), entityplayer.getProfile(), (PlayerInteractManager) object);
-        // */
-        EntityPlayer entityplayer1 = entityplayer;
-        org.bukkit.World fromWorld = entityplayer.getBukkitEntity().getWorld();
-        entityplayer.viewingCredits = false;
-        // CraftBukkit end
-
-        entityplayer1.playerConnection = entityplayer.playerConnection;
-        entityplayer1.copyTo(entityplayer, flag);
-        entityplayer1.h(entityplayer.getId());
-        entityplayer1.v(entityplayer);
-        entityplayer1.a(entityplayer.getMainHand());
-        Iterator iterator = entityplayer.P().iterator();
-
-        while (iterator.hasNext()) {
-            String s = (String) iterator.next();
-
-            entityplayer1.a(s);
-        }
-
-        // WorldServer worldserver = this.server.getWorldServer(entityplayer.dimension);  // CraftBukkit - handled later
-
-        // this.a(entityplayer1, entityplayer, worldserver); // CraftBukkit - removed
-        BlockPosition blockposition1;
-
-        // CraftBukkit start - fire PlayerRespawnEvent
-        if (location == null) {
-            boolean isBedSpawn = false;
-            CraftWorld cworld = (CraftWorld) this.server.server.getWorld(entityplayer.spawnWorld);
-            if (cworld != null && blockposition != null) {
-                blockposition1 = EntityHuman.getBed(cworld.getHandle(), blockposition, flag1);
-                if (blockposition1 != null) {
-                    isBedSpawn = true;
-                    location = new Location(cworld, (double) ((float) blockposition1.getX() + 0.5F), (double) ((float) blockposition1.getY() + 0.1F), (double) ((float) blockposition1.getZ() + 0.5F));
-                } else {
-                    entityplayer1.setRespawnPosition(null, true);
-                    entityplayer1.playerConnection.sendPacket(new PacketPlayOutGameStateChange(0, 0.0F));
-                }
-            }
-
-            if (location == null) {
-                cworld = (CraftWorld) this.server.server.getWorlds().get(0);
-                blockposition = cworld.getHandle().getSpawn();
-                location = new Location(cworld, (double) ((float) blockposition.getX() + 0.5F), (double) ((float) blockposition.getY() + 0.1F), (double) ((float) blockposition.getZ() + 0.5F));
-            }
-
-            Player respawnPlayer = cserver.getPlayer(entityplayer1);
-            PlayerRespawnEvent respawnEvent = new PlayerRespawnEvent(respawnPlayer, location, isBedSpawn);
-            cserver.getPluginManager().callEvent(respawnEvent);
-            // Spigot Start
-            if (entityplayer.playerConnection.isDisconnected()) {
-                return entityplayer;
-            }
-            // Spigot End
-
-            location = respawnEvent.getRespawnLocation();
-            entityplayer.reset();
-        } else {
-            location.setWorld(server.getWorldServer(i).getWorld());
-        }
-        WorldServer worldserver = ((CraftWorld) location.getWorld()).getHandle();
-        entityplayer1.setLocation(location.getX(), location.getY(), location.getZ(), location.getYaw(), location.getPitch());
-        // CraftBukkit end
-
-        worldserver.getChunkProviderServer().getChunkAt((int) entityplayer1.locX >> 4, (int) entityplayer1.locZ >> 4);
-
-        while (avoidSuffocation && !worldserver.getCubes(entityplayer1, entityplayer1.getBoundingBox()).isEmpty() && entityplayer1.locY < 256.0D) {
-            entityplayer1.setPosition(entityplayer1.locX, entityplayer1.locY + 1.0D, entityplayer1.locZ);
-        }
-        // CraftBukkit start
-        byte actualDimension = (byte) (worldserver.getWorld().getEnvironment().getId());
-        // Force the client to refresh their chunk cache
-        if (fromWorld.getEnvironment() == worldserver.getWorld().getEnvironment()) {
-            entityplayer1.playerConnection.sendPacket(new PacketPlayOutRespawn((byte) (actualDimension >= 0 ? -1 : 0), worldserver.getDifficulty(), worldserver.getWorldData().getType(), entityplayer.playerInteractManager.getGameMode()));
-        }
-
-        entityplayer1.playerConnection.sendPacket(new PacketPlayOutRespawn(actualDimension, worldserver.getDifficulty(), worldserver.getWorldData().getType(), entityplayer1.playerInteractManager.getGameMode()));
-        entityplayer1.spawnIn(worldserver);
-        entityplayer1.dead = false;
-        entityplayer1.playerConnection.teleport(new Location(worldserver.getWorld(), entityplayer1.locX, entityplayer1.locY, entityplayer1.locZ, entityplayer1.yaw, entityplayer1.pitch));
-        entityplayer1.setSneaking(false);
-        blockposition1 = worldserver.getSpawn();
-        // entityplayer1.playerConnection.a(entityplayer1.locX, entityplayer1.locY, entityplayer1.locZ, entityplayer1.yaw, entityplayer1.pitch);
-        entityplayer1.playerConnection.sendPacket(new PacketPlayOutSpawnPosition(blockposition1));
-        entityplayer1.playerConnection.sendPacket(new PacketPlayOutExperience(entityplayer1.exp, entityplayer1.expTotal, entityplayer1.expLevel));
-        this.b(entityplayer1, worldserver);
-        this.f(entityplayer1);
-        if (!entityplayer.playerConnection.isDisconnected()) {
-            worldserver.getPlayerChunkMap().addPlayer(entityplayer1);
-            worldserver.addEntity(entityplayer1);
-            this.players.add(entityplayer1);
-            this.playersByName.put(entityplayer1.getName(), entityplayer1); // Spigot
-            this.j.put(entityplayer1.getUniqueID(), entityplayer1);
-        }
-        // entityplayer1.syncInventory();
-        entityplayer1.setHealth(entityplayer1.getHealth());
-        // Added from changeDimension
-        updateClient(entityplayer); // Update health, etc...
-        entityplayer.updateAbilities();
-        for (Object o1 : entityplayer.getEffects()) {
-            MobEffect mobEffect = (MobEffect) o1;
-            entityplayer.playerConnection.sendPacket(new PacketPlayOutEntityEffect(entityplayer.getId(), mobEffect));
-        }
-
-        // Don't fire on respawn
-        if (fromWorld != location.getWorld()) {
-            PlayerChangedWorldEvent event = new PlayerChangedWorldEvent(entityplayer.getBukkitEntity(), fromWorld);
-            server.server.getPluginManager().callEvent(event);
-        }
-
-        // Save player file again if they were disconnected
-        if (entityplayer.playerConnection.isDisconnected()) {
-            this.savePlayerFile(entityplayer);
-        }
-        // CraftBukkit end
-        return entityplayer1;
-    }
-
-    // CraftBukkit start - Replaced the standard handling of portals with a more customised method.
-    public void changeDimension(EntityPlayer entityplayer, int i, TeleportCause cause) {
-        WorldServer exitWorld = null;
-        if (entityplayer.dimension < CraftWorld.CUSTOM_DIMENSION_OFFSET) { // plugins must specify exit from custom Bukkit worlds
-            // only target existing worlds (compensate for allow-nether/allow-end as false)
-            for (WorldServer world : this.server.worlds) {
-                if (world.dimension == i) {
-                    exitWorld = world;
-                }
-            }
-        }
-
-        Location enter = entityplayer.getBukkitEntity().getLocation();
-        Location exit = null;
-        boolean useTravelAgent = false; // don't use agent for custom worlds or return from THE_END
-        if (exitWorld != null) {
-            if ((cause == TeleportCause.END_PORTAL) && (i == 0)) {
-                // THE_END -> NORMAL; use bed if available, otherwise default spawn
-                exit = ((org.bukkit.craftbukkit.entity.CraftPlayer) entityplayer.getBukkitEntity()).getBedSpawnLocation();
-                if (exit == null || ((CraftWorld) exit.getWorld()).getHandle().dimension != 0) {
-                    exit = exitWorld.getWorld().getSpawnLocation();
-                }
-            } else {
-                // NORMAL <-> NETHER or NORMAL -> THE_END
-                exit = this.calculateTarget(enter, exitWorld);
-                useTravelAgent = true;
-            }
-        }
-
-        TravelAgent agent = exit != null ? (TravelAgent) ((CraftWorld) exit.getWorld()).getHandle().getTravelAgent() : org.bukkit.craftbukkit.CraftTravelAgent.DEFAULT; // return arbitrary TA to compensate for implementation dependent plugins
-        PlayerPortalEvent event = new PlayerPortalEvent(entityplayer.getBukkitEntity(), enter, exit, agent, cause);
-        event.useTravelAgent(useTravelAgent);
-        Bukkit.getServer().getPluginManager().callEvent(event);
-        if (event.isCancelled() || event.getTo() == null) {
-            return;
-        }
-
-        exit = event.useTravelAgent() ? event.getPortalTravelAgent().findOrCreate(event.getTo()) : event.getTo();
-        if (exit == null) {
-            return;
-        }
-        exitWorld = ((CraftWorld) exit.getWorld()).getHandle();
-
-        org.bukkit.event.player.PlayerTeleportEvent tpEvent = new org.bukkit.event.player.PlayerTeleportEvent(entityplayer.getBukkitEntity(), enter, exit, cause);
-        Bukkit.getServer().getPluginManager().callEvent(tpEvent);
-        if (tpEvent.isCancelled() || tpEvent.getTo() == null) {
-            return;
-        }
-
-        Vector velocity = entityplayer.getBukkitEntity().getVelocity();
-        exitWorld.getTravelAgent().adjustExit(entityplayer, exit, velocity);
-
-        entityplayer.worldChangeInvuln = true; // CraftBukkit - Set teleport invulnerability only if player changing worlds
-        this.moveToWorld(entityplayer, exitWorld.dimension, true, exit, false); // Vanilla doesn't check for suffocation when handling portals, so neither should we
-        if (entityplayer.motX != velocity.getX() || entityplayer.motY != velocity.getY() || entityplayer.motZ != velocity.getZ()) {
-            entityplayer.getBukkitEntity().setVelocity(velocity);
-        }
-    }
-
-    public void f(EntityPlayer entityplayer) {
-        GameProfile gameprofile = entityplayer.getProfile();
-        int i = this.isOp(gameprofile) ? this.operators.a(gameprofile) : 0;
-
-        i = this.server.R() && this.server.worldServer[0].getWorldData().u() ? 4 : i;
-        i = this.t ? 4 : i;
-        this.b(entityplayer, i);
-    }
-
-    public void a(EntityPlayer entityplayer, int i) {
-        int j = entityplayer.dimension;
-        WorldServer worldserver = this.server.getWorldServer(entityplayer.dimension);
-
-        entityplayer.dimension = i;
-        WorldServer worldserver1 = this.server.getWorldServer(entityplayer.dimension);
-
-        entityplayer.playerConnection.sendPacket(new PacketPlayOutRespawn(entityplayer.dimension, entityplayer.world.getDifficulty(), entityplayer.world.getWorldData().getType(), entityplayer.playerInteractManager.getGameMode()));
-        this.f(entityplayer);
-        worldserver.removeEntity(entityplayer);
-        entityplayer.dead = false;
-        this.changeWorld(entityplayer, j, worldserver, worldserver1);
-        this.a(entityplayer, worldserver);
-        entityplayer.playerConnection.a(entityplayer.locX, entityplayer.locY, entityplayer.locZ, entityplayer.yaw, entityplayer.pitch);
-        entityplayer.playerInteractManager.a(worldserver1);
-        entityplayer.playerConnection.sendPacket(new PacketPlayOutAbilities(entityplayer.abilities));
-        this.b(entityplayer, worldserver1);
-        this.updateClient(entityplayer);
-        Iterator iterator = entityplayer.getEffects().iterator();
-
-        while (iterator.hasNext()) {
-            MobEffect mobeffect = (MobEffect) iterator.next();
-
-            entityplayer.playerConnection.sendPacket(new PacketPlayOutEntityEffect(entityplayer.getId(), mobeffect));
-        }
-
-    }
-
-    public void changeWorld(Entity entity, int i, WorldServer worldserver, WorldServer worldserver1) {
-        // CraftBukkit start - Split into modular functions
-        Location exit = calculateTarget(entity.getBukkitEntity().getLocation(), worldserver1);
-        repositionEntity(entity, exit, true);
-    }
-
-    // Copy of original changeWorld(Entity, int, WorldServer, WorldServer) method with only location calculation logic
-    public Location calculateTarget(Location enter, World target) {
-        WorldServer worldserver = ((CraftWorld) enter.getWorld()).getHandle();
-        WorldServer worldserver1 = ((CraftWorld) target.getWorld()).getHandle();
-        int i = worldserver.dimension;
-
-        double y = enter.getY();
-        float yaw = enter.getYaw();
-        float pitch = enter.getPitch();
-        double d0 = enter.getX();
-        double d1 = enter.getZ();
-         double d2 = 8.0D;
-        /*
-        double d0 = entity.locX;
-        double d1 = entity.locZ;
-        double d2 = 8.0D;
-        float f = entity.yaw;
-
-        worldserver.methodProfiler.a("moving");
-        */
-        if (worldserver1.dimension == -1) {
-            d0 = MathHelper.a(d0 / d2, worldserver1.getWorldBorder().b()+ 16.0D, worldserver1.getWorldBorder().d() - 16.0D);
-            d1 = MathHelper.a(d1 / d2, worldserver1.getWorldBorder().c() + 16.0D, worldserver1.getWorldBorder().e() - 16.0D);
-            /*
-            entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
-            if (entity.isAlive()) {
-                worldserver.entityJoinedWorld(entity, false);
-            }
-            */
-        } else if (worldserver1.dimension == 0) {
-            d0 = MathHelper.a(d0 * d2, worldserver1.getWorldBorder().b() + 16.0D, worldserver1.getWorldBorder().d() - 16.0D);
-            d1 = MathHelper.a(d1 * d2, worldserver1.getWorldBorder().c() + 16.0D, worldserver1.getWorldBorder().e() - 16.0D);
-            /*
-            entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
-            if (entity.isAlive()) {
-                worldserver.entityJoinedWorld(entity, false);
-            }
-            */
-        } else {
-            BlockPosition blockposition;
-
-            if (i == 1) {
-                // use default NORMAL world spawn instead of target
-                worldserver1 = this.server.worlds.get(0);
-                blockposition = worldserver1.getSpawn();
-            } else {
-                blockposition = worldserver1.getDimensionSpawn();
-            }
-
-            d0 = (double) blockposition.getX();
-            y = (double) blockposition.getY();
-            d1 = (double) blockposition.getZ();
-            /*
-            entity.setPositionRotation(d0, entity.locY, d1, 90.0F, 0.0F);
-            if (entity.isAlive()) {
-                worldserver.entityJoinedWorld(entity, false);
-            }
-            */
-        }
-
-        // worldserver.methodProfiler.b();
-        if (i != 1) {
-            worldserver.methodProfiler.a("placing");
-            d0 = (double) MathHelper.clamp((int) d0, -29999872, 29999872);
-            d1 = (double) MathHelper.clamp((int) d1, -29999872, 29999872);
-            /*
-            if (entity.isAlive()) {
-                entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
-                worldserver1.getTravelAgent().a(entity, f);
-                worldserver1.addEntity(entity);
-                worldserver1.entityJoinedWorld(entity, false);
-            }
-
-            worldserver.methodProfiler.b();
-            */
-        }
-
-        // entity.spawnIn(worldserver1);
-        return new Location(worldserver1.getWorld(), d0, y, d1, yaw, pitch);
-    }
-
-    // copy of original a(Entity, int, WorldServer, WorldServer) method with only entity repositioning logic
-    public void repositionEntity(Entity entity, Location exit, boolean portal) {
-        WorldServer worldserver = (WorldServer) entity.world;
-        WorldServer worldserver1 = ((CraftWorld) exit.getWorld()).getHandle();
-        int i = worldserver.dimension;
-
-        /*
-        double d0 = entity.locX;
-        double d1 = entity.locZ;
-        double d2 = 8.0D;
-        float f = entity.yaw;
-
-        worldserver.methodProfiler.a("moving");
-        */
-        entity.setPositionRotation(exit.getX(), exit.getY(), exit.getZ(), exit.getYaw(), exit.getPitch());
-        if (entity.isAlive()) {
-            worldserver.entityJoinedWorld(entity, false);
-        }
-        /*
-        if (entity.dimension == -1) {
-            d0 = MathHelper.a(d0 / 8.0D, worldserver1.getWorldBorder().b() + 16.0D, worldserver1.getWorldBorder().d() - 16.0D);
-            d1 = MathHelper.a(d1 / 8.0D, worldserver1.getWorldBorder().c() + 16.0D, worldserver1.getWorldBorder().e() - 16.0D);
-            entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
-            if (entity.isAlive()) {
-                worldserver.entityJoinedWorld(entity, false);
-            }
-        } else if (entity.dimension == 0) {
-            d0 = MathHelper.a(d0 * 8.0D, worldserver1.getWorldBorder().b() + 16.0D, worldserver1.getWorldBorder().d() - 16.0D);
-            d1 = MathHelper.a(d1 * 8.0D, worldserver1.getWorldBorder().c() + 16.0D, worldserver1.getWorldBorder().e() - 16.0D);
-            entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
-            if (entity.isAlive()) {
-                worldserver.entityJoinedWorld(entity, false);
-            }
-        } else {
-            BlockPosition blockposition;
-
-            if (i == 1) {
-                // use default NORMAL world spawn instead of target
-                worldserver1 = this.server.worlds.get(0);
-                blockposition = worldserver1.getSpawn();
-            } else {
-                blockposition = worldserver1.getDimensionSpawn();
-            }
-
-            d0 = (double) blockposition.getX();
-            entity.locY = (double) blockposition.getY();
-            d1 = (double) blockposition.getZ();
-            entity.setPositionRotation(d0, entity.locY, d1, 90.0F, 0.0F);
-            if (entity.isAlive()) {
-                worldserver.entityJoinedWorld(entity, false);
-            }
-        }
-        */
-
-        worldserver.methodProfiler.b();
-        if (i != 1) {
-            worldserver.methodProfiler.a("placing");
-            /*
-            d0 = (double) MathHelper.clamp((int) d0, -29999872, 29999872);
-            d1 = (double) MathHelper.clamp((int) d1, -29999872, 29999872);
-            */
-            if (entity.isAlive()) {
-                // entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
-                // worldserver1.getTravelAgent().a(entity, f);
-                if (portal) {
-                    Vector velocity = entity.getBukkitEntity().getVelocity();
-                    worldserver1.getTravelAgent().adjustExit(entity, exit, velocity);
-                    entity.setPositionRotation(exit.getX(), exit.getY(), exit.getZ(), exit.getYaw(), exit.getPitch());
-                    if (entity.motX != velocity.getX() || entity.motY != velocity.getY() || entity.motZ != velocity.getZ()) {
-                        entity.getBukkitEntity().setVelocity(velocity);
-                    }
-                }
-                // worldserver1.addEntity(entity);
-                worldserver1.entityJoinedWorld(entity, false);
-            }
-
-            worldserver.methodProfiler.b();
-        }
-
-        entity.spawnIn(worldserver1);
-        // CraftBukkit end
-    }
-
-    public void tick() {
-        if (++this.u > 600) {
-            this.sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.UPDATE_LATENCY, this.players));
-            this.u = 0;
-        }
-
-    }
-
-    public void sendAll(Packet<?> packet) {
-        for (int i = 0; i < this.players.size(); ++i) {
-            ((EntityPlayer) this.players.get(i)).playerConnection.sendPacket(packet);
-        }
-
-    }
-
-    // CraftBukkit start - add a world/entity limited version
-    public void sendAll(Packet packet, EntityHuman entityhuman) {
-        for (int i = 0; i < this.players.size(); ++i) {
-            EntityPlayer entityplayer =  this.players.get(i);
-            if (entityhuman != null && entityhuman instanceof EntityPlayer && !entityplayer.getBukkitEntity().canSee(((EntityPlayer) entityhuman).getBukkitEntity())) {
-                continue;
-            }
-            ((EntityPlayer) this.players.get(i)).playerConnection.sendPacket(packet);
-        }
-    }
-
-    public void sendAll(Packet packet, World world) {
-        for (int i = 0; i < world.players.size(); ++i) {
-            ((EntityPlayer) world.players.get(i)).playerConnection.sendPacket(packet);
-        }
-
-    }
-    // CraftBukkit end
-
-    public void a(Packet<?> packet, int i) {
-        for (int j = 0; j < this.players.size(); ++j) {
-            EntityPlayer entityplayer = (EntityPlayer) this.players.get(j);
-
-            if (entityplayer.dimension == i) {
-                entityplayer.playerConnection.sendPacket(packet);
-            }
-        }
-
-    }
-
-    public void a(EntityHuman entityhuman, IChatBaseComponent ichatbasecomponent) {
-        ScoreboardTeamBase scoreboardteambase = entityhuman.aQ();
-
-        if (scoreboardteambase != null) {
-            Collection collection = scoreboardteambase.getPlayerNameSet();
-            Iterator iterator = collection.iterator();
-
-            while (iterator.hasNext()) {
-                String s = (String) iterator.next();
-                EntityPlayer entityplayer = this.getPlayer(s);
-
-                if (entityplayer != null && entityplayer != entityhuman) {
-                    entityplayer.sendMessage(ichatbasecomponent);
-                }
-            }
-
-        }
-    }
-
-    public void b(EntityHuman entityhuman, IChatBaseComponent ichatbasecomponent) {
-        ScoreboardTeamBase scoreboardteambase = entityhuman.aQ();
-
-        if (scoreboardteambase == null) {
-            this.sendMessage(ichatbasecomponent);
-        } else {
-            for (int i = 0; i < this.players.size(); ++i) {
-                EntityPlayer entityplayer = (EntityPlayer) this.players.get(i);
-
-                if (entityplayer.aQ() != scoreboardteambase) {
-                    entityplayer.sendMessage(ichatbasecomponent);
-                }
-            }
-
-        }
-    }
-
-    public String b(boolean flag) {
-        String s = "";
-        ArrayList arraylist = Lists.newArrayList(this.players);
-
-        for (int i = 0; i < arraylist.size(); ++i) {
-            if (i > 0) {
-                s = s + ", ";
-            }
-
-            s = s + ((EntityPlayer) arraylist.get(i)).getName();
-            if (flag) {
-                s = s + " (" + ((EntityPlayer) arraylist.get(i)).bf() + ")";
-            }
-        }
-
-        return s;
-    }
-
-    public String[] f() {
-        String[] astring = new String[this.players.size()];
-
-        for (int i = 0; i < this.players.size(); ++i) {
-            astring[i] = ((EntityPlayer) this.players.get(i)).getName();
-        }
-
-        return astring;
-    }
-
-    public GameProfile[] g() {
-        GameProfile[] agameprofile = new GameProfile[this.players.size()];
-
-        for (int i = 0; i < this.players.size(); ++i) {
-            agameprofile[i] = ((EntityPlayer) this.players.get(i)).getProfile();
-        }
-
-        return agameprofile;
-    }
-
-    public GameProfileBanList getProfileBans() {
-        return this.k;
-    }
-
-    public IpBanList getIPBans() {
-        return this.l;
-    }
-
-    public void addOp(GameProfile gameprofile) {
-        int i = this.server.q();
-
-        this.operators.add(new OpListEntry(gameprofile, this.server.q(), this.operators.b(gameprofile)));
-        this.b(this.a(gameprofile.getId()), i);
-        // CraftBukkit start
-        Player player = server.server.getPlayer(gameprofile.getId());
-        if (player != null) {
-           player.recalculatePermissions();
-        }
-        // CraftBukkit end
-    }
-
-    public void removeOp(GameProfile gameprofile) {
-        this.operators.remove(gameprofile);
-        this.b(this.a(gameprofile.getId()), 0);
-        // CraftBukkit start
-        Player player = server.server.getPlayer(gameprofile.getId());
-        if (player != null) {
-            player.recalculatePermissions();
-        }
-        // CraftBukkit end
-    }
-
-    private void b(EntityPlayer entityplayer, int i) {
-        if (entityplayer != null && entityplayer.playerConnection != null) {
-            byte b0;
-
-            if (i <= 0) {
-                b0 = 24;
-            } else if (i >= 4) {
-                b0 = 28;
-            } else {
-                b0 = (byte) (24 + i);
-            }
-
-            entityplayer.playerConnection.sendPacket(new PacketPlayOutEntityStatus(entityplayer, b0));
-        }
-
-    }
-
-    public boolean isWhitelisted(GameProfile gameprofile) {
-        return !this.hasWhitelist || this.operators.d(gameprofile) || this.whitelist.d(gameprofile);
-    }
-
-    public boolean isOp(GameProfile gameprofile) {
-        return this.operators.d(gameprofile) || this.server.R() && this.server.worlds.get(0).getWorldData().u() && this.server.Q().equalsIgnoreCase(gameprofile.getName()) || this.t; // CraftBukkit
-    }
-
-    @Nullable
-    public EntityPlayer getPlayer(String s) {
-        return this.playersByName.get(s); // Spigot
-    }
-
-    public void sendPacketNearby(@Nullable EntityHuman entityhuman, double d0, double d1, double d2, double d3, int i, Packet<?> packet) {
-        for (int j = 0; j < this.players.size(); ++j) {
-            EntityPlayer entityplayer = (EntityPlayer) this.players.get(j);
-
-            // CraftBukkit start - Test if player receiving packet can see the source of the packet
-            if (entityhuman != null && entityhuman instanceof EntityPlayer && !entityplayer.getBukkitEntity().canSee(((EntityPlayer) entityhuman).getBukkitEntity())) {
-               continue;
-            }
-            // CraftBukkit end
-
-            if (entityplayer != entityhuman && entityplayer.dimension == i) {
-                double d4 = d0 - entityplayer.locX;
-                double d5 = d1 - entityplayer.locY;
-                double d6 = d2 - entityplayer.locZ;
-
-                if (d4 * d4 + d5 * d5 + d6 * d6 < d3 * d3) {
-                    entityplayer.playerConnection.sendPacket(packet);
-                }
-            }
-        }
-
-    }
-
-    public void savePlayers() {
-        for (int i = 0; i < this.players.size(); ++i) {
-            this.savePlayerFile((EntityPlayer) this.players.get(i));
-        }
-
-    }
-
-    public void addWhitelist(GameProfile gameprofile) {
-        this.whitelist.add(new WhiteListEntry(gameprofile));
-    }
-
-    public void removeWhitelist(GameProfile gameprofile) {
-        this.whitelist.remove(gameprofile);
-    }
-
-    public WhiteList getWhitelist() {
-        return this.whitelist;
-    }
-
-    public String[] getWhitelisted() {
-        return this.whitelist.getEntries();
-    }
-
-    public OpList getOPs() {
-        return this.operators;
-    }
-
-    public String[] n() {
-        return this.operators.getEntries();
-    }
-
-    public void reloadWhitelist() {}
-
-    public void b(EntityPlayer entityplayer, WorldServer worldserver) {
-        WorldBorder worldborder = entityplayer.world.getWorldBorder(); // CraftBukkit
-
-        entityplayer.playerConnection.sendPacket(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.INITIALIZE));
-        entityplayer.playerConnection.sendPacket(new PacketPlayOutUpdateTime(worldserver.getTime(), worldserver.getDayTime(), worldserver.getGameRules().getBoolean("doDaylightCycle")));
-        if (worldserver.W()) {
-            // CraftBukkit start - handle player weather
-            // entityplayer.playerConnection.sendPacket(new PacketPlayOutGameStateChange(1, 0.0F));
-            // entityplayer.playerConnection.sendPacket(new PacketPlayOutGameStateChange(7, worldserver.j(1.0F)));
-            // entityplayer.playerConnection.sendPacket(new PacketPlayOutGameStateChange(8, worldserver.h(1.0F)));
-            entityplayer.setPlayerWeather(org.bukkit.WeatherType.DOWNFALL, false);
-            entityplayer.updateWeather(-worldserver.o, worldserver.o, -worldserver.q, worldserver.q);
-            // CraftBukkit end
-        }
-
-    }
-
-    public void updateClient(EntityPlayer entityplayer) {
-        entityplayer.updateInventory(entityplayer.defaultContainer);
-        // entityplayer.triggerHealthUpdate();
-        entityplayer.getBukkitEntity().updateScaledHealth(); // CraftBukkit - Update scaled health on respawn and worldchange
-        entityplayer.playerConnection.sendPacket(new PacketPlayOutHeldItemSlot(entityplayer.inventory.itemInHandIndex));
-    }
-
-    public int getPlayerCount() {
-        return this.players.size();
-    }
-
-    public int getMaxPlayers() {
-        return this.maxPlayers;
-    }
-
-    public String[] getSeenPlayers() {
-        return this.server.worlds.get(0).getDataManager().getPlayerFileData().getSeenPlayers(); // CraftBukkit
-    }
-
-    public boolean getHasWhitelist() {
-        return this.hasWhitelist;
-    }
-
-    public void setHasWhitelist(boolean flag) {
-        this.hasWhitelist = flag;
-    }
-
-    public List<EntityPlayer> b(String s) {
-        ArrayList arraylist = Lists.newArrayList();
-        Iterator iterator = this.players.iterator();
-
-        while (iterator.hasNext()) {
-            EntityPlayer entityplayer = (EntityPlayer) iterator.next();
-
-            if (entityplayer.A().equals(s)) {
-                arraylist.add(entityplayer);
-            }
-        }
-
-        return arraylist;
-    }
-
-    public int s() {
-        return this.r;
-    }
-
-    public MinecraftServer getServer() {
-        return this.server;
-    }
-
-    public NBTTagCompound t() {
-        return null;
-    }
-
-    private void a(EntityPlayer entityplayer, EntityPlayer entityplayer1, World world) {
-        if (entityplayer1 != null) {
-            entityplayer.playerInteractManager.setGameMode(entityplayer1.playerInteractManager.getGameMode());
-        } else if (this.s != null) {
-            entityplayer.playerInteractManager.setGameMode(this.s);
-        }
-
-        entityplayer.playerInteractManager.b(world.getWorldData().getGameType());
-    }
-
-    public void u() {
-        // CraftBukkit start - disconnect safely
-        for (EntityPlayer player : this.players) {
-            player.playerConnection.disconnect(this.server.server.getShutdownMessage()); // CraftBukkit - add custom shutdown message
-        }
-        // CraftBukkit end
-
-    }
-
-    // CraftBukkit start
-    public void sendMessage(IChatBaseComponent[] iChatBaseComponents) {
-        for (IChatBaseComponent component : iChatBaseComponents) {
-            sendMessage(component, true);
-        }
-    }
-    // CraftBukkit end
-
-    public void sendMessage(IChatBaseComponent ichatbasecomponent, boolean flag) {
-        this.server.sendMessage(ichatbasecomponent);
-        int i = flag ? 1 : 0;
-
-        // CraftBukkit start - we run this through our processor first so we can get web links etc
-        this.sendAll(new PacketPlayOutChat(CraftChatMessage.fixComponent(ichatbasecomponent), (byte) i));
-        // CraftBukkit end
-    }
-
-    public void sendMessage(IChatBaseComponent ichatbasecomponent) {
-        this.sendMessage(ichatbasecomponent, true);
-    }
-
-    public ServerStatisticManager a(EntityHuman entityhuman) {
-        UUID uuid = entityhuman.getUniqueID();
-        ServerStatisticManager serverstatisticmanager = uuid == null ? null : (ServerStatisticManager) this.o.get(uuid);
-
-        if (serverstatisticmanager == null) {
-            File file = new File(this.server.getWorldServer(0).getDataManager().getDirectory(), "stats");
-            File file1 = new File(file, uuid + ".json");
-
-            if (!file1.exists()) {
-                File file2 = new File(file, entityhuman.getName() + ".json");
-
-                if (file2.exists() && file2.isFile()) {
-                    file2.renameTo(file1);
-                }
-            }
-
-            serverstatisticmanager = new ServerStatisticManager(this.server, file1);
-            serverstatisticmanager.a();
-            this.o.put(uuid, serverstatisticmanager);
-        }
-
-        return serverstatisticmanager;
-    }
-
-    public void a(int i) {
-        this.r = i;
-        if (this.server.worldServer != null) {
-            WorldServer[] aworldserver = this.server.worldServer;
-            int j = aworldserver.length;
-
-            // CraftBukkit start
-            for (int k = 0; k < server.worlds.size(); ++k) {
-                WorldServer worldserver = server.worlds.get(0);
-                // CraftBukkit end
-
-                if (worldserver != null) {
-                    worldserver.getPlayerChunkMap().a(i);
-                    worldserver.getTracker().a(i);
-                }
-            }
-
-        }
-    }
-
-    public List<EntityPlayer> v() {
-        return this.players;
-    }
-
-    public EntityPlayer a(UUID uuid) {
-        return (EntityPlayer) this.j.get(uuid);
-    }
-
-    public boolean f(GameProfile gameprofile) {
-        return false;
-    }
-}
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import com.mojang.authlib.GameProfile;
+import io.netty.buffer.Unpooled;
+import java.io.File;
+import java.net.SocketAddress;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import javax.annotation.Nullable;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+// CraftBukkit start
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
+
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.TravelAgent;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
+import org.bukkit.entity.Player;
+import org.bukkit.event.player.PlayerChangedWorldEvent;
+import org.bukkit.event.player.PlayerPortalEvent;
+import org.bukkit.event.player.PlayerJoinEvent;
+import org.bukkit.event.player.PlayerLoginEvent;
+import org.bukkit.event.player.PlayerQuitEvent;
+import org.bukkit.event.player.PlayerRespawnEvent;
+import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
+import org.bukkit.util.Vector;
+import org.spigotmc.event.player.PlayerSpawnLocationEvent;
+// CraftBukkit end
+
+public abstract class PlayerList {
+
+    public static final File a = new File("banned-players.json");
+    public static final File b = new File("banned-ips.json");
+    public static final File c = new File("ops.json");
+    public static final File d = new File("whitelist.json");
+    private static final Logger f = LogManager.getLogger();
+    private static final SimpleDateFormat g = new SimpleDateFormat("yyyy-MM-dd \'at\' HH:mm:ss z");
+    private final MinecraftServer server;
+    public final List<EntityPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
+    private final Map<UUID, EntityPlayer> j = Maps.newHashMap();
+    private final GameProfileBanList k;
+    private final IpBanList l;
+    private final OpList operators;
+    private final WhiteList whitelist;
+    private final Map<UUID, ServerStatisticManager> o;
+    public IPlayerFileData playerFileData;
+    private boolean hasWhitelist;
+    protected int maxPlayers;
+    private int r;
+    private EnumGamemode s;
+    private boolean t;
+    private int u;
+
+    // CraftBukkit start
+    private CraftServer cserver;
+    private final Map<String,EntityPlayer> playersByName = new org.spigotmc.CaseInsensitiveMap<EntityPlayer>();
+
+    public PlayerList(MinecraftServer minecraftserver) {
+        this.cserver = minecraftserver.server = new CraftServer(minecraftserver, this);
+        minecraftserver.console = org.bukkit.craftbukkit.command.ColouredConsoleSender.getInstance();
+        minecraftserver.reader.addCompleter(new org.bukkit.craftbukkit.command.ConsoleCommandCompleter(minecraftserver.server));
+        // CraftBukkit end
+
+        this.k = new GameProfileBanList(PlayerList.a);
+        this.l = new IpBanList(PlayerList.b);
+        this.operators = new OpList(PlayerList.c);
+        this.whitelist = new WhiteList(PlayerList.d);
+        this.o = Maps.newHashMap();
+        this.server = minecraftserver;
+        this.k.a(false);
+        this.l.a(false);
+        this.maxPlayers = 8;
+    }
+
+    public void a(NetworkManager networkmanager, EntityPlayer entityplayer) {
+        GameProfile gameprofile = entityplayer.getProfile();
+        UserCache usercache = this.server.getUserCache();
+        GameProfile gameprofile1 = usercache.a(gameprofile.getId());
+        String s = gameprofile1 == null ? gameprofile.getName() : gameprofile1.getName();
+
+        usercache.a(gameprofile);
+        NBTTagCompound nbttagcompound = this.a(entityplayer);
+        // CraftBukkit start - Better rename detection
+        if (nbttagcompound != null && nbttagcompound.hasKey("bukkit")) {
+            NBTTagCompound bukkit = nbttagcompound.getCompound("bukkit");
+            s = bukkit.hasKeyOfType("lastKnownName", 8) ? bukkit.getString("lastKnownName") : s;
+        }
+        // CraftBukkit end
+
+        entityplayer.spawnIn(this.server.getWorldServer(entityplayer.dimension));
+        entityplayer.playerInteractManager.a((WorldServer) entityplayer.world);
+        String s1 = "local";
+
+        if (networkmanager.getSocketAddress() != null) {
+            s1 = networkmanager.getSocketAddress().toString();
+        }
+
+        // Spigot start - spawn location event
+        Player bukkitPlayer = entityplayer.getBukkitEntity();
+        PlayerSpawnLocationEvent ev = new PlayerSpawnLocationEvent(bukkitPlayer, bukkitPlayer.getLocation());
+        Bukkit.getPluginManager().callEvent(ev);
+
+        Location loc = ev.getSpawnLocation();
+        WorldServer world = ((CraftWorld) loc.getWorld()).getHandle();
+
+        entityplayer.spawnIn(world);
+        entityplayer.setPosition(loc.getX(), loc.getY(), loc.getZ());
+        entityplayer.setYawPitch(loc.getYaw(), loc.getPitch()); 
+        // Spigot end
+
+        // CraftBukkit - Moved message to after join
+        // PlayerList.f.info("{}[{}] logged in with entity id {} at ({}, {}, {})", new Object[] { entityplayer.getName(), s1, Integer.valueOf(entityplayer.getId()), Double.valueOf(entityplayer.locX), Double.valueOf(entityplayer.locY), Double.valueOf(entityplayer.locZ)});
+        WorldServer worldserver = this.server.getWorldServer(entityplayer.dimension);
+        WorldData worlddata = worldserver.getWorldData();
+        BlockPosition blockposition = worldserver.getSpawn();
+
+        this.a(entityplayer, (EntityPlayer) null, worldserver);
+        PlayerConnection playerconnection = new PlayerConnection(this.server, networkmanager, entityplayer);
+
+        playerconnection.sendPacket(new PacketPlayOutLogin(entityplayer.getId(), entityplayer.playerInteractManager.getGameMode(), worlddata.isHardcore(), worldserver.worldProvider.getDimensionManager().getDimensionID(), worldserver.getDifficulty(), this.getMaxPlayers(), worlddata.getType(), worldserver.getGameRules().getBoolean("reducedDebugInfo")));
+        entityplayer.getBukkitEntity().sendSupportedChannels(); // CraftBukkit
+        playerconnection.sendPacket(new PacketPlayOutCustomPayload("MC|Brand", (new PacketDataSerializer(Unpooled.buffer())).a(this.getServer().getServerModName())));
+        playerconnection.sendPacket(new PacketPlayOutServerDifficulty(worlddata.getDifficulty(), worlddata.isDifficultyLocked()));
+        playerconnection.sendPacket(new PacketPlayOutSpawnPosition(blockposition));
+        playerconnection.sendPacket(new PacketPlayOutAbilities(entityplayer.abilities));
+        playerconnection.sendPacket(new PacketPlayOutHeldItemSlot(entityplayer.inventory.itemInHandIndex));
+        this.f(entityplayer);
+        entityplayer.getStatisticManager().d();
+        entityplayer.getStatisticManager().updateStatistics(entityplayer);
+        this.sendScoreboard((ScoreboardServer) worldserver.getScoreboard(), entityplayer);
+        this.server.aC();
+        // CraftBukkit start - login message is handled in the event
+        // ChatMessage chatmessage;
+
+        String joinMessage;
+        if (entityplayer.getName().equalsIgnoreCase(s)) {
+            // chatmessage = new ChatMessage("multiplayer.player.joined", new Object[] { entityplayer.getScoreboardDisplayName()});
+            joinMessage = "\u00A7e" + LocaleI18n.a("multiplayer.player.joined", entityplayer.getName());
+        } else {
+            // chatmessage = new ChatMessage("multiplayer.player.joined.renamed", new Object[] { entityplayer.getScoreboardDisplayName(), s});
+            joinMessage = "\u00A7e" + LocaleI18n.a("multiplayer.player.joined.renamed", entityplayer.getName(), s);
+        }
+
+        // chatmessage.getChatModifier().setColor(EnumChatFormat.YELLOW);
+        // this.sendMessage(chatmessage);
+        this.onPlayerJoin(entityplayer, joinMessage);
+        // CraftBukkit end
+        worldserver = server.getWorldServer(entityplayer.dimension);  // CraftBukkit - Update in case join event changed it
+        playerconnection.a(entityplayer.locX, entityplayer.locY, entityplayer.locZ, entityplayer.yaw, entityplayer.pitch);
+        this.b(entityplayer, worldserver);
+        if (!this.server.getResourcePack().isEmpty()) {
+            entityplayer.setResourcePack(this.server.getResourcePack(), this.server.getResourcePackHash());
+        }
+
+        Iterator iterator = entityplayer.getEffects().iterator();
+
+        while (iterator.hasNext()) {
+            MobEffect mobeffect = (MobEffect) iterator.next();
+
+            playerconnection.sendPacket(new PacketPlayOutEntityEffect(entityplayer.getId(), mobeffect));
+        }
+
+        if (nbttagcompound != null) {
+            if (nbttagcompound.hasKeyOfType("RootVehicle", 10)) {
+                NBTTagCompound nbttagcompound1 = nbttagcompound.getCompound("RootVehicle");
+                Entity entity = ChunkRegionLoader.a(nbttagcompound1.getCompound("Entity"), worldserver, true);
+
+                if (entity != null) {
+                    UUID uuid = nbttagcompound1.a("Attach");
+                    Iterator iterator1;
+                    Entity entity1;
+
+                    if (entity.getUniqueID().equals(uuid)) {
+                        entityplayer.a(entity, true);
+                    } else {
+                        iterator1 = entity.by().iterator();
+
+                        while (iterator1.hasNext()) {
+                            entity1 = (Entity) iterator1.next();
+                            if (entity1.getUniqueID().equals(uuid)) {
+                                entityplayer.a(entity1, true);
+                                break;
+                            }
+                        }
+                    }
+
+                    if (!entityplayer.isPassenger()) {
+                        PlayerList.f.warn("Couldn\'t reattach entity to player");
+                        worldserver.removeEntity(entity);
+                        iterator1 = entity.by().iterator();
+
+                        while (iterator1.hasNext()) {
+                            entity1 = (Entity) iterator1.next();
+                            worldserver.removeEntity(entity1);
+                        }
+                    }
+                }
+            } else if (nbttagcompound.hasKeyOfType("Riding", 10)) {
+                Entity entity2 = ChunkRegionLoader.a(nbttagcompound.getCompound("Riding"), worldserver, true);
+
+                if (entity2 != null) {
+                    entityplayer.a(entity2, true);
+                }
+            }
+        }
+
+        entityplayer.syncInventory();
+        // CraftBukkit - Moved from above, added world
+        PlayerList.f.info(entityplayer.getName() + "[" + s1 + "] logged in with entity id " + entityplayer.getId() + " at ([" + entityplayer.world.worldData.getName() + "]" + entityplayer.locX + ", " + entityplayer.locY + ", " + entityplayer.locZ + ")");
+    }
+
+    public void sendScoreboard(ScoreboardServer scoreboardserver, EntityPlayer entityplayer) {
+        HashSet hashset = Sets.newHashSet();
+        Iterator iterator = scoreboardserver.getTeams().iterator();
+
+        while (iterator.hasNext()) {
+            ScoreboardTeam scoreboardteam = (ScoreboardTeam) iterator.next();
+
+            entityplayer.playerConnection.sendPacket(new PacketPlayOutScoreboardTeam(scoreboardteam, 0));
+        }
+
+        for (int i = 0; i < 19; ++i) {
+            ScoreboardObjective scoreboardobjective = scoreboardserver.getObjectiveForSlot(i);
+
+            if (scoreboardobjective != null && !hashset.contains(scoreboardobjective)) {
+                List list = scoreboardserver.getScoreboardScorePacketsForObjective(scoreboardobjective);
+                Iterator iterator1 = list.iterator();
+
+                while (iterator1.hasNext()) {
+                    Packet packet = (Packet) iterator1.next();
+
+                    entityplayer.playerConnection.sendPacket(packet);
+                }
+
+                hashset.add(scoreboardobjective);
+            }
+        }
+
+    }
+
+    public void setPlayerFileData(WorldServer[] aworldserver) {
+        if (playerFileData != null) return; // CraftBukkit
+        this.playerFileData = aworldserver[0].getDataManager().getPlayerFileData();
+        aworldserver[0].getWorldBorder().a(new IWorldBorderListener() {
+            public void a(WorldBorder worldborder, double d0) {
+                PlayerList.this.sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_SIZE), worldborder.world);
+            }
+
+            public void a(WorldBorder worldborder, double d0, double d1, long i) {
+                PlayerList.this.sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.LERP_SIZE), worldborder.world);
+            }
+
+            public void a(WorldBorder worldborder, double d0, double d1) {
+                PlayerList.this.sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_CENTER), worldborder.world);
+            }
+
+            public void a(WorldBorder worldborder, int i) {
+                PlayerList.this.sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_WARNING_TIME), worldborder.world);
+            }
+
+            public void b(WorldBorder worldborder, int i) {
+                PlayerList.this.sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_WARNING_BLOCKS), worldborder.world);
+            }
+
+            public void b(WorldBorder worldborder, double d0) {}
+
+            public void c(WorldBorder worldborder, double d0) {}
+        });
+    }
+
+    public void a(EntityPlayer entityplayer, WorldServer worldserver) {
+        WorldServer worldserver1 = entityplayer.x();
+
+        if (worldserver != null) {
+            worldserver.getPlayerChunkMap().removePlayer(entityplayer);
+        }
+
+        worldserver1.getPlayerChunkMap().addPlayer(entityplayer);
+        worldserver1.getChunkProviderServer().getChunkAt((int) entityplayer.locX >> 4, (int) entityplayer.locZ >> 4);
+    }
+
+    public int d() {
+        return PlayerChunkMap.getFurthestViewableBlock(this.s());
+    }
+
+    public NBTTagCompound a(EntityPlayer entityplayer) {
+        NBTTagCompound nbttagcompound = this.server.worlds.get(0).getWorldData().h(); // CraftBukkit
+        NBTTagCompound nbttagcompound1;
+
+        if (entityplayer.getName().equals(this.server.Q()) && nbttagcompound != null) {
+            nbttagcompound1 = this.server.getDataConverterManager().a((DataConverterType) DataConverterTypes.PLAYER, nbttagcompound);
+            entityplayer.f(nbttagcompound1);
+            PlayerList.f.debug("loading single player");
+        } else {
+            nbttagcompound1 = this.playerFileData.load(entityplayer);
+        }
+
+        return nbttagcompound1;
+    }
+
+    protected void savePlayerFile(EntityPlayer entityplayer) {
+        this.playerFileData.save(entityplayer);
+        ServerStatisticManager serverstatisticmanager = (ServerStatisticManager) this.o.get(entityplayer.getUniqueID());
+
+        if (serverstatisticmanager != null) {
+            serverstatisticmanager.b();
+        }
+
+    }
+
+    public void onPlayerJoin(EntityPlayer entityplayer, String joinMessage) { // CraftBukkit added param
+        this.players.add(entityplayer);
+        this.playersByName.put(entityplayer.getName(), entityplayer); // Spigot
+        this.j.put(entityplayer.getUniqueID(), entityplayer);
+        // this.sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, new EntityPlayer[] { entityplayer})); // CraftBukkit - replaced with loop below
+        WorldServer worldserver = this.server.getWorldServer(entityplayer.dimension);
+
+        // CraftBukkit start
+        PlayerJoinEvent playerJoinEvent = new PlayerJoinEvent(cserver.getPlayer(entityplayer), joinMessage);
+        cserver.getPluginManager().callEvent(playerJoinEvent);
+
+        joinMessage = playerJoinEvent.getJoinMessage();
+
+        if (joinMessage != null && joinMessage.length() > 0) {
+            for (IChatBaseComponent line : org.bukkit.craftbukkit.util.CraftChatMessage.fromString(joinMessage)) {
+                server.getPlayerList().sendAll(new PacketPlayOutChat(line));
+            }
+        }
+
+        ChunkIOExecutor.adjustPoolSize(getPlayerCount());
+        // CraftBukkit end
+
+        // CraftBukkit start - sendAll above replaced with this loop
+        PacketPlayOutPlayerInfo packet = new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, entityplayer);
+
+        for (int i = 0; i < this.players.size(); ++i) {
+            EntityPlayer entityplayer1 = (EntityPlayer) this.players.get(i);
+
+            if (entityplayer1.getBukkitEntity().canSee(entityplayer.getBukkitEntity())) {
+                entityplayer1.playerConnection.sendPacket(packet);
+            }
+
+            if (!entityplayer.getBukkitEntity().canSee(entityplayer1.getBukkitEntity())) {
+                continue;
+            }
+
+            entityplayer.playerConnection.sendPacket(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, new EntityPlayer[] { entityplayer1}));
+        }
+        // CraftBukkit end
+
+        // CraftBukkit start - Only add if the player wasn't moved in the event
+        if (entityplayer.world == worldserver && !worldserver.players.contains(entityplayer)) {
+            worldserver.addEntity(entityplayer);
+            this.a(entityplayer, (WorldServer) null);
+        }
+        // CraftBukkit end
+    }
+
+    public void d(EntityPlayer entityplayer) {
+        entityplayer.x().getPlayerChunkMap().movePlayer(entityplayer);
+    }
+
+    public String disconnect(EntityPlayer entityplayer) { // CraftBukkit - return string
+        WorldServer worldserver = entityplayer.x();
+
+        entityplayer.b(StatisticList.f);
+
+        // CraftBukkit start - Quitting must be before we do final save of data, in case plugins need to modify it
+        org.bukkit.craftbukkit.event.CraftEventFactory.handleInventoryCloseEvent(entityplayer);
+
+        PlayerQuitEvent playerQuitEvent = new PlayerQuitEvent(cserver.getPlayer(entityplayer), "\u00A7e" + entityplayer.getName() + " left the game");
+        cserver.getPluginManager().callEvent(playerQuitEvent);
+        entityplayer.getBukkitEntity().disconnect(playerQuitEvent.getQuitMessage());
+
+        entityplayer.k_();// SPIGOT-924 // PAIL: rename - playerTick
+        // CraftBukkit end
+
+        this.savePlayerFile(entityplayer);
+        if (entityplayer.isPassenger()) {
+            Entity entity = entityplayer.getVehicle();
+
+            if (entity.b(EntityPlayer.class).size() == 1) {
+                PlayerList.f.debug("Removing player mount");
+                entityplayer.stopRiding();
+                worldserver.removeEntity(entity);
+                Iterator iterator = entity.by().iterator();
+
+                while (iterator.hasNext()) {
+                    Entity entity1 = (Entity) iterator.next();
+
+                    worldserver.removeEntity(entity1);
+                }
+
+                worldserver.getChunkAt(entityplayer.ac, entityplayer.ae).e();
+            }
+        }
+
+        worldserver.kill(entityplayer);
+        worldserver.getPlayerChunkMap().removePlayer(entityplayer);
+        this.players.remove(entityplayer);
+        this.playersByName.remove(entityplayer.getName()); // Spigot
+        UUID uuid = entityplayer.getUniqueID();
+        EntityPlayer entityplayer1 = (EntityPlayer) this.j.get(uuid);
+
+        if (entityplayer1 == entityplayer) {
+            this.j.remove(uuid);
+            this.o.remove(uuid);
+        }
+
+        // CraftBukkit start
+        //  this.sendAll(new PacketPlayOutPlayerInfo(EnumPlayerInfoAction.REMOVE_PLAYER, new EntityPlayer[] { entityplayer}));
+        PacketPlayOutPlayerInfo packet = new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.REMOVE_PLAYER, entityplayer);
+        for (int i = 0; i < players.size(); i++) {
+            EntityPlayer entityplayer2 = (EntityPlayer) this.players.get(i);
+
+            if (entityplayer2.getBukkitEntity().canSee(entityplayer.getBukkitEntity())) {
+                entityplayer2.playerConnection.sendPacket(packet);
+            } else {
+                entityplayer2.getBukkitEntity().removeDisconnectingPlayer(entityplayer.getBukkitEntity());
+            }
+        }
+        // This removes the scoreboard (and player reference) for the specific player in the manager
+        cserver.getScoreboardManager().removePlayer(entityplayer.getBukkitEntity());
+        // CraftBukkit end
+
+        ChunkIOExecutor.adjustPoolSize(this.getPlayerCount()); // CraftBukkit
+
+        return playerQuitEvent.getQuitMessage(); // CraftBukkit
+    }
+
+    // CraftBukkit start - Whole method, SocketAddress to LoginListener, added hostname to signature, return EntityPlayer
+    public EntityPlayer attemptLogin(LoginListener loginlistener, GameProfile gameprofile, String hostname) {
+        // Moved from processLogin
+        UUID uuid = EntityHuman.a(gameprofile);
+        ArrayList arraylist = Lists.newArrayList();
+
+        EntityPlayer entityplayer;
+
+        for (int i = 0; i < this.players.size(); ++i) {
+            entityplayer = (EntityPlayer) this.players.get(i);
+            if (entityplayer.getUniqueID().equals(uuid)) {
+                arraylist.add(entityplayer);
+            }
+        }
+
+        Iterator iterator = arraylist.iterator();
+
+        while (iterator.hasNext()) {
+            entityplayer = (EntityPlayer) iterator.next();
+            savePlayerFile(entityplayer); // CraftBukkit - Force the player's inventory to be saved
+            entityplayer.playerConnection.disconnect("You logged in from another location");
+        }
+
+        // Instead of kicking then returning, we need to store the kick reason
+        // in the event, check with plugins to see if it's ok, and THEN kick
+        // depending on the outcome.
+        SocketAddress socketaddress = loginlistener.networkManager.getSocketAddress();
+
+        EntityPlayer entity = new EntityPlayer(server, server.getWorldServer(0), gameprofile, new PlayerInteractManager(server.getWorldServer(0)));
+        Player player = entity.getBukkitEntity();
+        PlayerLoginEvent event = new PlayerLoginEvent(player, hostname, ((java.net.InetSocketAddress) socketaddress).getAddress(), ((java.net.InetSocketAddress) loginlistener.networkManager.getRawAddress()).getAddress());
+        String s;
+
+        if (getProfileBans().isBanned(gameprofile) && !getProfileBans().get(gameprofile).hasExpired()) {
+            GameProfileBanEntry gameprofilebanentry = (GameProfileBanEntry) this.k.get(gameprofile);
+
+            s = "You are banned from this server!\nReason: " + gameprofilebanentry.getReason();
+            if (gameprofilebanentry.getExpires() != null) {
+                s = s + "\nYour ban will be removed on " + PlayerList.g.format(gameprofilebanentry.getExpires());
+            }
+
+            // return s;
+            if (!gameprofilebanentry.hasExpired()) event.disallow(PlayerLoginEvent.Result.KICK_BANNED, s); // Spigot
+        } else if (!this.isWhitelisted(gameprofile)) {
+            // return "You are not white-listed on this server!";
+            event.disallow(PlayerLoginEvent.Result.KICK_WHITELIST, org.spigotmc.SpigotConfig.whitelistMessage); // Spigot
+        } else if (getIPBans().isBanned(socketaddress) && !getIPBans().get(socketaddress).hasExpired()) {
+            IpBanEntry ipbanentry = this.l.get(socketaddress);
+
+            s = "Your IP address is banned from this server!\nReason: " + ipbanentry.getReason();
+            if (ipbanentry.getExpires() != null) {
+                s = s + "\nYour ban will be removed on " + PlayerList.g.format(ipbanentry.getExpires());
+            }
+
+            // return s;
+            event.disallow(PlayerLoginEvent.Result.KICK_BANNED, s);
+        } else {
+            // return this.players.size() >= this.maxPlayers && !this.f(gameprofile) ? "The server is full!" : null;
+            if (this.players.size() >= this.maxPlayers && !this.f(gameprofile)) {
+                event.disallow(PlayerLoginEvent.Result.KICK_FULL, org.spigotmc.SpigotConfig.serverFullMessage); // Spigot
+            }
+        }
+
+        cserver.getPluginManager().callEvent(event);
+        if (event.getResult() != PlayerLoginEvent.Result.ALLOWED) {
+            loginlistener.disconnect(event.getKickMessage());
+            return null;
+        }
+        return entity;
+    }
+
+    public EntityPlayer processLogin(GameProfile gameprofile, EntityPlayer player) { // CraftBukkit - added EntityPlayer
+        /* CraftBukkit startMoved up
+        UUID uuid = EntityHuman.a(gameprofile);
+        ArrayList arraylist = Lists.newArrayList();
+
+        for (int i = 0; i < this.players.size(); ++i) {
+            EntityPlayer entityplayer = (EntityPlayer) this.players.get(i);
+
+            if (entityplayer.getUniqueID().equals(uuid)) {
+                arraylist.add(entityplayer);
+            }
+        }
+
+        EntityPlayer entityplayer1 = (EntityPlayer) this.j.get(gameprofile.getId());
+
+        if (entityplayer1 != null && !arraylist.contains(entityplayer1)) {
+            arraylist.add(entityplayer1);
+        }
+
+        Iterator iterator = arraylist.iterator();
+
+        while (iterator.hasNext()) {
+            EntityPlayer entityplayer2 = (EntityPlayer) iterator.next();
+
+            entityplayer2.playerConnection.disconnect("You logged in from another location");
+        }
+
+        Object object;
+
+        if (this.server.V()) {
+            object = new DemoPlayerInteractManager(this.server.getWorldServer(0));
+        } else {
+            object = new PlayerInteractManager(this.server.getWorldServer(0));
+        }
+
+        return new EntityPlayer(this.server, this.server.getWorldServer(0), gameprofile, (PlayerInteractManager) object);
+        */
+        return player;
+        // CraftBukkit end
+    }
+
+    // CraftBukkit start
+    public EntityPlayer moveToWorld(EntityPlayer entityplayer, int i, boolean flag) {
+        return this.moveToWorld(entityplayer, i, flag, null, true);
+    }
+
+    public EntityPlayer moveToWorld(EntityPlayer entityplayer, int i, boolean flag, Location location, boolean avoidSuffocation) {
+        entityplayer.x().getTracker().untrackPlayer(entityplayer);
+        // entityplayer.x().getTracker().untrackEntity(entityplayer); // CraftBukkit
+        entityplayer.x().getPlayerChunkMap().removePlayer(entityplayer);
+        this.players.remove(entityplayer);
+        this.playersByName.remove(entityplayer.getName()); // Spigot
+        this.server.getWorldServer(entityplayer.dimension).removeEntity(entityplayer);
+        BlockPosition blockposition = entityplayer.getBed();
+        boolean flag1 = entityplayer.isRespawnForced();
+
+        /* CraftBukkit start
+        entityplayer.dimension = i;
+        Object object;
+
+        if (this.server.V()) {
+            object = new DemoPlayerInteractManager(this.server.getWorldServer(entityplayer.dimension));
+        } else {
+            object = new PlayerInteractManager(this.server.getWorldServer(entityplayer.dimension));
+        }
+
+        EntityPlayer entityplayer1 = new EntityPlayer(this.server, this.server.getWorldServer(entityplayer.dimension), entityplayer.getProfile(), (PlayerInteractManager) object);
+        // */
+        EntityPlayer entityplayer1 = entityplayer;
+        org.bukkit.World fromWorld = entityplayer.getBukkitEntity().getWorld();
+        entityplayer.viewingCredits = false;
+        // CraftBukkit end
+
+        entityplayer1.playerConnection = entityplayer.playerConnection;
+        entityplayer1.copyTo(entityplayer, flag);
+        entityplayer1.h(entityplayer.getId());
+        entityplayer1.v(entityplayer);
+        entityplayer1.a(entityplayer.getMainHand());
+        Iterator iterator = entityplayer.P().iterator();
+
+        while (iterator.hasNext()) {
+            String s = (String) iterator.next();
+
+            entityplayer1.a(s);
+        }
+
+        // WorldServer worldserver = this.server.getWorldServer(entityplayer.dimension);  // CraftBukkit - handled later
+
+        // this.a(entityplayer1, entityplayer, worldserver); // CraftBukkit - removed
+        BlockPosition blockposition1;
+
+        // CraftBukkit start - fire PlayerRespawnEvent
+        if (location == null) {
+            boolean isBedSpawn = false;
+            CraftWorld cworld = (CraftWorld) this.server.server.getWorld(entityplayer.spawnWorld);
+            if (cworld != null && blockposition != null) {
+                blockposition1 = EntityHuman.getBed(cworld.getHandle(), blockposition, flag1);
+                if (blockposition1 != null) {
+                    isBedSpawn = true;
+                    location = new Location(cworld, (double) ((float) blockposition1.getX() + 0.5F), (double) ((float) blockposition1.getY() + 0.1F), (double) ((float) blockposition1.getZ() + 0.5F));
+                } else {
+                    entityplayer1.setRespawnPosition(null, true);
+                    entityplayer1.playerConnection.sendPacket(new PacketPlayOutGameStateChange(0, 0.0F));
+                }
+            }
+
+            if (location == null) {
+                cworld = (CraftWorld) this.server.server.getWorlds().get(0);
+                blockposition = cworld.getHandle().getSpawn();
+                location = new Location(cworld, (double) ((float) blockposition.getX() + 0.5F), (double) ((float) blockposition.getY() + 0.1F), (double) ((float) blockposition.getZ() + 0.5F));
+            }
+
+            Player respawnPlayer = cserver.getPlayer(entityplayer1);
+            PlayerRespawnEvent respawnEvent = new PlayerRespawnEvent(respawnPlayer, location, isBedSpawn);
+            cserver.getPluginManager().callEvent(respawnEvent);
+            // Spigot Start
+            if (entityplayer.playerConnection.isDisconnected()) {
+                return entityplayer;
+            }
+            // Spigot End
+
+            location = respawnEvent.getRespawnLocation();
+            entityplayer.reset();
+        } else {
+            location.setWorld(server.getWorldServer(i).getWorld());
+        }
+        WorldServer worldserver = ((CraftWorld) location.getWorld()).getHandle();
+        entityplayer1.setLocation(location.getX(), location.getY(), location.getZ(), location.getYaw(), location.getPitch());
+        // CraftBukkit end
+
+        worldserver.getChunkProviderServer().getChunkAt((int) entityplayer1.locX >> 4, (int) entityplayer1.locZ >> 4);
+
+        while (avoidSuffocation && !worldserver.getCubes(entityplayer1, entityplayer1.getBoundingBox()).isEmpty() && entityplayer1.locY < 256.0D) {
+            entityplayer1.setPosition(entityplayer1.locX, entityplayer1.locY + 1.0D, entityplayer1.locZ);
+        }
+        // CraftBukkit start
+        byte actualDimension = (byte) (worldserver.getWorld().getEnvironment().getId());
+        // Force the client to refresh their chunk cache
+        if (fromWorld.getEnvironment() == worldserver.getWorld().getEnvironment()) {
+            entityplayer1.playerConnection.sendPacket(new PacketPlayOutRespawn((byte) (actualDimension >= 0 ? -1 : 0), worldserver.getDifficulty(), worldserver.getWorldData().getType(), entityplayer.playerInteractManager.getGameMode()));
+        }
+
+        entityplayer1.playerConnection.sendPacket(new PacketPlayOutRespawn(actualDimension, worldserver.getDifficulty(), worldserver.getWorldData().getType(), entityplayer1.playerInteractManager.getGameMode()));
+        entityplayer1.spawnIn(worldserver);
+        entityplayer1.dead = false;
+        entityplayer1.playerConnection.teleport(new Location(worldserver.getWorld(), entityplayer1.locX, entityplayer1.locY, entityplayer1.locZ, entityplayer1.yaw, entityplayer1.pitch));
+        entityplayer1.setSneaking(false);
+        blockposition1 = worldserver.getSpawn();
+        // entityplayer1.playerConnection.a(entityplayer1.locX, entityplayer1.locY, entityplayer1.locZ, entityplayer1.yaw, entityplayer1.pitch);
+        entityplayer1.playerConnection.sendPacket(new PacketPlayOutSpawnPosition(blockposition1));
+        entityplayer1.playerConnection.sendPacket(new PacketPlayOutExperience(entityplayer1.exp, entityplayer1.expTotal, entityplayer1.expLevel));
+        this.b(entityplayer1, worldserver);
+        this.f(entityplayer1);
+        if (!entityplayer.playerConnection.isDisconnected()) {
+            worldserver.getPlayerChunkMap().addPlayer(entityplayer1);
+            worldserver.addEntity(entityplayer1);
+            this.players.add(entityplayer1);
+            this.playersByName.put(entityplayer1.getName(), entityplayer1); // Spigot
+            this.j.put(entityplayer1.getUniqueID(), entityplayer1);
+        }
+        // entityplayer1.syncInventory();
+        entityplayer1.setHealth(entityplayer1.getHealth());
+        // Added from changeDimension
+        updateClient(entityplayer); // Update health, etc...
+        entityplayer.updateAbilities();
+        for (Object o1 : entityplayer.getEffects()) {
+            MobEffect mobEffect = (MobEffect) o1;
+            entityplayer.playerConnection.sendPacket(new PacketPlayOutEntityEffect(entityplayer.getId(), mobEffect));
+        }
+
+        // Don't fire on respawn
+        if (fromWorld != location.getWorld()) {
+            PlayerChangedWorldEvent event = new PlayerChangedWorldEvent(entityplayer.getBukkitEntity(), fromWorld);
+            server.server.getPluginManager().callEvent(event);
+        }
+
+        // Save player file again if they were disconnected
+        if (entityplayer.playerConnection.isDisconnected()) {
+            this.savePlayerFile(entityplayer);
+        }
+        // CraftBukkit end
+        return entityplayer1;
+    }
+
+    // CraftBukkit start - Replaced the standard handling of portals with a more customised method.
+    public void changeDimension(EntityPlayer entityplayer, int i, TeleportCause cause) {
+        WorldServer exitWorld = null;
+        if (entityplayer.dimension < CraftWorld.CUSTOM_DIMENSION_OFFSET) { // plugins must specify exit from custom Bukkit worlds
+            // only target existing worlds (compensate for allow-nether/allow-end as false)
+            for (WorldServer world : this.server.worlds) {
+                if (world.dimension == i) {
+                    exitWorld = world;
+                }
+            }
+        }
+
+        Location enter = entityplayer.getBukkitEntity().getLocation();
+        Location exit = null;
+        boolean useTravelAgent = false; // don't use agent for custom worlds or return from THE_END
+        if (exitWorld != null) {
+            if ((cause == TeleportCause.END_PORTAL) && (i == 0)) {
+                // THE_END -> NORMAL; use bed if available, otherwise default spawn
+                exit = ((org.bukkit.craftbukkit.entity.CraftPlayer) entityplayer.getBukkitEntity()).getBedSpawnLocation();
+                if (exit == null || ((CraftWorld) exit.getWorld()).getHandle().dimension != 0) {
+                    exit = exitWorld.getWorld().getSpawnLocation();
+                }
+            } else {
+                // NORMAL <-> NETHER or NORMAL -> THE_END
+                exit = this.calculateTarget(enter, exitWorld);
+                useTravelAgent = true;
+            }
+        }
+
+        TravelAgent agent = exit != null ? (TravelAgent) ((CraftWorld) exit.getWorld()).getHandle().getTravelAgent() : org.bukkit.craftbukkit.CraftTravelAgent.DEFAULT; // return arbitrary TA to compensate for implementation dependent plugins
+        PlayerPortalEvent event = new PlayerPortalEvent(entityplayer.getBukkitEntity(), enter, exit, agent, cause);
+        event.useTravelAgent(useTravelAgent);
+        Bukkit.getServer().getPluginManager().callEvent(event);
+        if (event.isCancelled() || event.getTo() == null) {
+            return;
+        }
+
+        exit = event.useTravelAgent() ? event.getPortalTravelAgent().findOrCreate(event.getTo()) : event.getTo();
+        if (exit == null) {
+            return;
+        }
+        exitWorld = ((CraftWorld) exit.getWorld()).getHandle();
+
+        org.bukkit.event.player.PlayerTeleportEvent tpEvent = new org.bukkit.event.player.PlayerTeleportEvent(entityplayer.getBukkitEntity(), enter, exit, cause);
+        Bukkit.getServer().getPluginManager().callEvent(tpEvent);
+        if (tpEvent.isCancelled() || tpEvent.getTo() == null) {
+            return;
+        }
+
+        Vector velocity = entityplayer.getBukkitEntity().getVelocity();
+        exitWorld.getTravelAgent().adjustExit(entityplayer, exit, velocity);
+
+        entityplayer.worldChangeInvuln = true; // CraftBukkit - Set teleport invulnerability only if player changing worlds
+        this.moveToWorld(entityplayer, exitWorld.dimension, true, exit, false); // Vanilla doesn't check for suffocation when handling portals, so neither should we
+        if (entityplayer.motX != velocity.getX() || entityplayer.motY != velocity.getY() || entityplayer.motZ != velocity.getZ()) {
+            entityplayer.getBukkitEntity().setVelocity(velocity);
+        }
+    }
+
+    public void f(EntityPlayer entityplayer) {
+        GameProfile gameprofile = entityplayer.getProfile();
+        int i = this.isOp(gameprofile) ? this.operators.a(gameprofile) : 0;
+
+        i = this.server.R() && this.server.worldServer[0].getWorldData().u() ? 4 : i;
+        i = this.t ? 4 : i;
+        this.b(entityplayer, i);
+    }
+
+    public void a(EntityPlayer entityplayer, int i) {
+        int j = entityplayer.dimension;
+        WorldServer worldserver = this.server.getWorldServer(entityplayer.dimension);
+
+        entityplayer.dimension = i;
+        WorldServer worldserver1 = this.server.getWorldServer(entityplayer.dimension);
+
+        entityplayer.playerConnection.sendPacket(new PacketPlayOutRespawn(entityplayer.dimension, entityplayer.world.getDifficulty(), entityplayer.world.getWorldData().getType(), entityplayer.playerInteractManager.getGameMode()));
+        this.f(entityplayer);
+        worldserver.removeEntity(entityplayer);
+        entityplayer.dead = false;
+        this.changeWorld(entityplayer, j, worldserver, worldserver1);
+        this.a(entityplayer, worldserver);
+        entityplayer.playerConnection.a(entityplayer.locX, entityplayer.locY, entityplayer.locZ, entityplayer.yaw, entityplayer.pitch);
+        entityplayer.playerInteractManager.a(worldserver1);
+        entityplayer.playerConnection.sendPacket(new PacketPlayOutAbilities(entityplayer.abilities));
+        this.b(entityplayer, worldserver1);
+        this.updateClient(entityplayer);
+        Iterator iterator = entityplayer.getEffects().iterator();
+
+        while (iterator.hasNext()) {
+            MobEffect mobeffect = (MobEffect) iterator.next();
+
+            entityplayer.playerConnection.sendPacket(new PacketPlayOutEntityEffect(entityplayer.getId(), mobeffect));
+        }
+
+    }
+
+    public void changeWorld(Entity entity, int i, WorldServer worldserver, WorldServer worldserver1) {
+        // CraftBukkit start - Split into modular functions
+        Location exit = calculateTarget(entity.getBukkitEntity().getLocation(), worldserver1);
+        repositionEntity(entity, exit, true);
+    }
+
+    // Copy of original changeWorld(Entity, int, WorldServer, WorldServer) method with only location calculation logic
+    public Location calculateTarget(Location enter, World target) {
+        WorldServer worldserver = ((CraftWorld) enter.getWorld()).getHandle();
+        WorldServer worldserver1 = ((CraftWorld) target.getWorld()).getHandle();
+        int i = worldserver.dimension;
+
+        double y = enter.getY();
+        float yaw = enter.getYaw();
+        float pitch = enter.getPitch();
+        double d0 = enter.getX();
+        double d1 = enter.getZ();
+         double d2 = 8.0D;
+        /*
+        double d0 = entity.locX;
+        double d1 = entity.locZ;
+        double d2 = 8.0D;
+        float f = entity.yaw;
+
+        worldserver.methodProfiler.a("moving");
+        */
+        if (worldserver1.dimension == -1) {
+            d0 = MathHelper.a(d0 / d2, worldserver1.getWorldBorder().b()+ 16.0D, worldserver1.getWorldBorder().d() - 16.0D);
+            d1 = MathHelper.a(d1 / d2, worldserver1.getWorldBorder().c() + 16.0D, worldserver1.getWorldBorder().e() - 16.0D);
+            /*
+            entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
+            if (entity.isAlive()) {
+                worldserver.entityJoinedWorld(entity, false);
+            }
+            */
+        } else if (worldserver1.dimension == 0) {
+            d0 = MathHelper.a(d0 * d2, worldserver1.getWorldBorder().b() + 16.0D, worldserver1.getWorldBorder().d() - 16.0D);
+            d1 = MathHelper.a(d1 * d2, worldserver1.getWorldBorder().c() + 16.0D, worldserver1.getWorldBorder().e() - 16.0D);
+            /*
+            entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
+            if (entity.isAlive()) {
+                worldserver.entityJoinedWorld(entity, false);
+            }
+            */
+        } else {
+            BlockPosition blockposition;
+
+            if (i == 1) {
+                // use default NORMAL world spawn instead of target
+                worldserver1 = this.server.worlds.get(0);
+                blockposition = worldserver1.getSpawn();
+            } else {
+                blockposition = worldserver1.getDimensionSpawn();
+            }
+
+            d0 = (double) blockposition.getX();
+            y = (double) blockposition.getY();
+            d1 = (double) blockposition.getZ();
+            /*
+            entity.setPositionRotation(d0, entity.locY, d1, 90.0F, 0.0F);
+            if (entity.isAlive()) {
+                worldserver.entityJoinedWorld(entity, false);
+            }
+            */
+        }
+
+        // worldserver.methodProfiler.b();
+        if (i != 1) {
+            worldserver.methodProfiler.a("placing");
+            d0 = (double) MathHelper.clamp((int) d0, -29999872, 29999872);
+            d1 = (double) MathHelper.clamp((int) d1, -29999872, 29999872);
+            /*
+            if (entity.isAlive()) {
+                entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
+                worldserver1.getTravelAgent().a(entity, f);
+                worldserver1.addEntity(entity);
+                worldserver1.entityJoinedWorld(entity, false);
+            }
+
+            worldserver.methodProfiler.b();
+            */
+        }
+
+        // entity.spawnIn(worldserver1);
+        return new Location(worldserver1.getWorld(), d0, y, d1, yaw, pitch);
+    }
+
+    // copy of original a(Entity, int, WorldServer, WorldServer) method with only entity repositioning logic
+    public void repositionEntity(Entity entity, Location exit, boolean portal) {
+        WorldServer worldserver = (WorldServer) entity.world;
+        WorldServer worldserver1 = ((CraftWorld) exit.getWorld()).getHandle();
+        int i = worldserver.dimension;
+
+        /*
+        double d0 = entity.locX;
+        double d1 = entity.locZ;
+        double d2 = 8.0D;
+        float f = entity.yaw;
+
+        worldserver.methodProfiler.a("moving");
+        */
+        entity.setPositionRotation(exit.getX(), exit.getY(), exit.getZ(), exit.getYaw(), exit.getPitch());
+        if (entity.isAlive()) {
+            worldserver.entityJoinedWorld(entity, false);
+        }
+        /*
+        if (entity.dimension == -1) {
+            d0 = MathHelper.a(d0 / 8.0D, worldserver1.getWorldBorder().b() + 16.0D, worldserver1.getWorldBorder().d() - 16.0D);
+            d1 = MathHelper.a(d1 / 8.0D, worldserver1.getWorldBorder().c() + 16.0D, worldserver1.getWorldBorder().e() - 16.0D);
+            entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
+            if (entity.isAlive()) {
+                worldserver.entityJoinedWorld(entity, false);
+            }
+        } else if (entity.dimension == 0) {
+            d0 = MathHelper.a(d0 * 8.0D, worldserver1.getWorldBorder().b() + 16.0D, worldserver1.getWorldBorder().d() - 16.0D);
+            d1 = MathHelper.a(d1 * 8.0D, worldserver1.getWorldBorder().c() + 16.0D, worldserver1.getWorldBorder().e() - 16.0D);
+            entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
+            if (entity.isAlive()) {
+                worldserver.entityJoinedWorld(entity, false);
+            }
+        } else {
+            BlockPosition blockposition;
+
+            if (i == 1) {
+                // use default NORMAL world spawn instead of target
+                worldserver1 = this.server.worlds.get(0);
+                blockposition = worldserver1.getSpawn();
+            } else {
+                blockposition = worldserver1.getDimensionSpawn();
+            }
+
+            d0 = (double) blockposition.getX();
+            entity.locY = (double) blockposition.getY();
+            d1 = (double) blockposition.getZ();
+            entity.setPositionRotation(d0, entity.locY, d1, 90.0F, 0.0F);
+            if (entity.isAlive()) {
+                worldserver.entityJoinedWorld(entity, false);
+            }
+        }
+        */
+
+        worldserver.methodProfiler.b();
+        if (i != 1) {
+            worldserver.methodProfiler.a("placing");
+            /*
+            d0 = (double) MathHelper.clamp((int) d0, -29999872, 29999872);
+            d1 = (double) MathHelper.clamp((int) d1, -29999872, 29999872);
+            */
+            if (entity.isAlive()) {
+                // entity.setPositionRotation(d0, entity.locY, d1, entity.yaw, entity.pitch);
+                // worldserver1.getTravelAgent().a(entity, f);
+                if (portal) {
+                    Vector velocity = entity.getBukkitEntity().getVelocity();
+                    worldserver1.getTravelAgent().adjustExit(entity, exit, velocity);
+                    entity.setPositionRotation(exit.getX(), exit.getY(), exit.getZ(), exit.getYaw(), exit.getPitch());
+                    if (entity.motX != velocity.getX() || entity.motY != velocity.getY() || entity.motZ != velocity.getZ()) {
+                        entity.getBukkitEntity().setVelocity(velocity);
+                    }
+                }
+                // worldserver1.addEntity(entity);
+                worldserver1.entityJoinedWorld(entity, false);
+            }
+
+            worldserver.methodProfiler.b();
+        }
+
+        entity.spawnIn(worldserver1);
+        // CraftBukkit end
+    }
+
+    public void tick() {
+        if (++this.u > 600) {
+            this.sendAll(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.UPDATE_LATENCY, this.players));
+            this.u = 0;
+        }
+
+    }
+
+    public void sendAll(Packet<?> packet) {
+        for (int i = 0; i < this.players.size(); ++i) {
+            ((EntityPlayer) this.players.get(i)).playerConnection.sendPacket(packet);
+        }
+
+    }
+
+    // CraftBukkit start - add a world/entity limited version
+    public void sendAll(Packet packet, EntityHuman entityhuman) {
+        for (int i = 0; i < this.players.size(); ++i) {
+            EntityPlayer entityplayer =  this.players.get(i);
+            if (entityhuman != null && entityhuman instanceof EntityPlayer && !entityplayer.getBukkitEntity().canSee(((EntityPlayer) entityhuman).getBukkitEntity())) {
+                continue;
+            }
+            ((EntityPlayer) this.players.get(i)).playerConnection.sendPacket(packet);
+        }
+    }
+
+    public void sendAll(Packet packet, World world) {
+        for (int i = 0; i < world.players.size(); ++i) {
+            ((EntityPlayer) world.players.get(i)).playerConnection.sendPacket(packet);
+        }
+
+    }
+    // CraftBukkit end
+
+    public void a(Packet<?> packet, int i) {
+        for (int j = 0; j < this.players.size(); ++j) {
+            EntityPlayer entityplayer = (EntityPlayer) this.players.get(j);
+
+            if (entityplayer.dimension == i) {
+                entityplayer.playerConnection.sendPacket(packet);
+            }
+        }
+
+    }
+
+    public void a(EntityHuman entityhuman, IChatBaseComponent ichatbasecomponent) {
+        ScoreboardTeamBase scoreboardteambase = entityhuman.aQ();
+
+        if (scoreboardteambase != null) {
+            Collection collection = scoreboardteambase.getPlayerNameSet();
+            Iterator iterator = collection.iterator();
+
+            while (iterator.hasNext()) {
+                String s = (String) iterator.next();
+                EntityPlayer entityplayer = this.getPlayer(s);
+
+                if (entityplayer != null && entityplayer != entityhuman) {
+                    entityplayer.sendMessage(ichatbasecomponent);
+                }
+            }
+
+        }
+    }
+
+    public void b(EntityHuman entityhuman, IChatBaseComponent ichatbasecomponent) {
+        ScoreboardTeamBase scoreboardteambase = entityhuman.aQ();
+
+        if (scoreboardteambase == null) {
+            this.sendMessage(ichatbasecomponent);
+        } else {
+            for (int i = 0; i < this.players.size(); ++i) {
+                EntityPlayer entityplayer = (EntityPlayer) this.players.get(i);
+
+                if (entityplayer.aQ() != scoreboardteambase) {
+                    entityplayer.sendMessage(ichatbasecomponent);
+                }
+            }
+
+        }
+    }
+
+    public String b(boolean flag) {
+        String s = "";
+        ArrayList arraylist = Lists.newArrayList(this.players);
+
+        for (int i = 0; i < arraylist.size(); ++i) {
+            if (i > 0) {
+                s = s + ", ";
+            }
+
+            s = s + ((EntityPlayer) arraylist.get(i)).getName();
+            if (flag) {
+                s = s + " (" + ((EntityPlayer) arraylist.get(i)).bf() + ")";
+            }
+        }
+
+        return s;
+    }
+
+    public String[] f() {
+        String[] astring = new String[this.players.size()];
+
+        for (int i = 0; i < this.players.size(); ++i) {
+            astring[i] = ((EntityPlayer) this.players.get(i)).getName();
+        }
+
+        return astring;
+    }
+
+    public GameProfile[] g() {
+        GameProfile[] agameprofile = new GameProfile[this.players.size()];
+
+        for (int i = 0; i < this.players.size(); ++i) {
+            agameprofile[i] = ((EntityPlayer) this.players.get(i)).getProfile();
+        }
+
+        return agameprofile;
+    }
+
+    public GameProfileBanList getProfileBans() {
+        return this.k;
+    }
+
+    public IpBanList getIPBans() {
+        return this.l;
+    }
+
+    public void addOp(GameProfile gameprofile) {
+        int i = this.server.q();
+
+        this.operators.add(new OpListEntry(gameprofile, this.server.q(), this.operators.b(gameprofile)));
+        this.b(this.a(gameprofile.getId()), i);
+        // CraftBukkit start
+        Player player = server.server.getPlayer(gameprofile.getId());
+        if (player != null) {
+           player.recalculatePermissions();
+        }
+        // CraftBukkit end
+    }
+
+    public void removeOp(GameProfile gameprofile) {
+        this.operators.remove(gameprofile);
+        this.b(this.a(gameprofile.getId()), 0);
+        // CraftBukkit start
+        Player player = server.server.getPlayer(gameprofile.getId());
+        if (player != null) {
+            player.recalculatePermissions();
+        }
+        // CraftBukkit end
+    }
+
+    private void b(EntityPlayer entityplayer, int i) {
+        if (entityplayer != null && entityplayer.playerConnection != null) {
+            byte b0;
+
+            if (i <= 0) {
+                b0 = 24;
+            } else if (i >= 4) {
+                b0 = 28;
+            } else {
+                b0 = (byte) (24 + i);
+            }
+
+            entityplayer.playerConnection.sendPacket(new PacketPlayOutEntityStatus(entityplayer, b0));
+        }
+
+    }
+
+    public boolean isWhitelisted(GameProfile gameprofile) {
+        return !this.hasWhitelist || this.operators.d(gameprofile) || this.whitelist.d(gameprofile);
+    }
+
+    public boolean isOp(GameProfile gameprofile) {
+        return this.operators.d(gameprofile) || this.server.R() && this.server.worlds.get(0).getWorldData().u() && this.server.Q().equalsIgnoreCase(gameprofile.getName()) || this.t; // CraftBukkit
+    }
+
+    @Nullable
+    public EntityPlayer getPlayer(String s) {
+        return this.playersByName.get(s); // Spigot
+    }
+
+    public void sendPacketNearby(@Nullable EntityHuman entityhuman, double d0, double d1, double d2, double d3, int i, Packet<?> packet) {
+        for (int j = 0; j < this.players.size(); ++j) {
+            EntityPlayer entityplayer = (EntityPlayer) this.players.get(j);
+
+            // CraftBukkit start - Test if player receiving packet can see the source of the packet
+            if (entityhuman != null && entityhuman instanceof EntityPlayer && !entityplayer.getBukkitEntity().canSee(((EntityPlayer) entityhuman).getBukkitEntity())) {
+               continue;
+            }
+            // CraftBukkit end
+
+            if (entityplayer != entityhuman && entityplayer.dimension == i) {
+                double d4 = d0 - entityplayer.locX;
+                double d5 = d1 - entityplayer.locY;
+                double d6 = d2 - entityplayer.locZ;
+
+                if (d4 * d4 + d5 * d5 + d6 * d6 < d3 * d3) {
+                    entityplayer.playerConnection.sendPacket(packet);
+                }
+            }
+        }
+
+    }
+
+    public void savePlayers() {
+        this.players.parallelStream().forEach(pl -> this.savePlayerFile((EntityPlayer) pl));
+        /*
+        for (int i = 0; i < this.players.size(); ++i) {
+            this.savePlayerFile((EntityPlayer) this.players.get(i));
+        }*/
+
+    }
+
+    public void addWhitelist(GameProfile gameprofile) {
+        this.whitelist.add(new WhiteListEntry(gameprofile));
+    }
+
+    public void removeWhitelist(GameProfile gameprofile) {
+        this.whitelist.remove(gameprofile);
+    }
+
+    public WhiteList getWhitelist() {
+        return this.whitelist;
+    }
+
+    public String[] getWhitelisted() {
+        return this.whitelist.getEntries();
+    }
+
+    public OpList getOPs() {
+        return this.operators;
+    }
+
+    public String[] n() {
+        return this.operators.getEntries();
+    }
+
+    public void reloadWhitelist() {}
+
+    public void b(EntityPlayer entityplayer, WorldServer worldserver) {
+        WorldBorder worldborder = entityplayer.world.getWorldBorder(); // CraftBukkit
+
+        entityplayer.playerConnection.sendPacket(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.INITIALIZE));
+        entityplayer.playerConnection.sendPacket(new PacketPlayOutUpdateTime(worldserver.getTime(), worldserver.getDayTime(), worldserver.getGameRules().getBoolean("doDaylightCycle")));
+        if (worldserver.W()) {
+            // CraftBukkit start - handle player weather
+            // entityplayer.playerConnection.sendPacket(new PacketPlayOutGameStateChange(1, 0.0F));
+            // entityplayer.playerConnection.sendPacket(new PacketPlayOutGameStateChange(7, worldserver.j(1.0F)));
+            // entityplayer.playerConnection.sendPacket(new PacketPlayOutGameStateChange(8, worldserver.h(1.0F)));
+            entityplayer.setPlayerWeather(org.bukkit.WeatherType.DOWNFALL, false);
+            entityplayer.updateWeather(-worldserver.o, worldserver.o, -worldserver.q, worldserver.q);
+            // CraftBukkit end
+        }
+
+    }
+
+    public void updateClient(EntityPlayer entityplayer) {
+        entityplayer.updateInventory(entityplayer.defaultContainer);
+        // entityplayer.triggerHealthUpdate();
+        entityplayer.getBukkitEntity().updateScaledHealth(); // CraftBukkit - Update scaled health on respawn and worldchange
+        entityplayer.playerConnection.sendPacket(new PacketPlayOutHeldItemSlot(entityplayer.inventory.itemInHandIndex));
+    }
+
+    public int getPlayerCount() {
+        return this.players.size();
+    }
+
+    public int getMaxPlayers() {
+        return this.maxPlayers;
+    }
+
+    public String[] getSeenPlayers() {
+        return this.server.worlds.get(0).getDataManager().getPlayerFileData().getSeenPlayers(); // CraftBukkit
+    }
+
+    public boolean getHasWhitelist() {
+        return this.hasWhitelist;
+    }
+
+    public void setHasWhitelist(boolean flag) {
+        this.hasWhitelist = flag;
+    }
+
+    public List<EntityPlayer> b(String s) {
+        ArrayList arraylist = Lists.newArrayList();
+        Iterator iterator = this.players.iterator();
+
+        while (iterator.hasNext()) {
+            EntityPlayer entityplayer = (EntityPlayer) iterator.next();
+
+            if (entityplayer.A().equals(s)) {
+                arraylist.add(entityplayer);
+            }
+        }
+
+        return arraylist;
+    }
+
+    public int s() {
+        return this.r;
+    }
+
+    public MinecraftServer getServer() {
+        return this.server;
+    }
+
+    public NBTTagCompound t() {
+        return null;
+    }
+
+    private void a(EntityPlayer entityplayer, EntityPlayer entityplayer1, World world) {
+        if (entityplayer1 != null) {
+            entityplayer.playerInteractManager.setGameMode(entityplayer1.playerInteractManager.getGameMode());
+        } else if (this.s != null) {
+            entityplayer.playerInteractManager.setGameMode(this.s);
+        }
+
+        entityplayer.playerInteractManager.b(world.getWorldData().getGameType());
+    }
+
+    public void u() {
+        // CraftBukkit start - disconnect safely
+        for (EntityPlayer player : this.players) {
+            player.playerConnection.disconnect(this.server.server.getShutdownMessage()); // CraftBukkit - add custom shutdown message
+        }
+        // CraftBukkit end
+
+    }
+
+    // CraftBukkit start
+    public void sendMessage(IChatBaseComponent[] iChatBaseComponents) {
+        for (IChatBaseComponent component : iChatBaseComponents) {
+            sendMessage(component, true);
+        }
+    }
+    // CraftBukkit end
+
+    public void sendMessage(IChatBaseComponent ichatbasecomponent, boolean flag) {
+        this.server.sendMessage(ichatbasecomponent);
+        int i = flag ? 1 : 0;
+
+        // CraftBukkit start - we run this through our processor first so we can get web links etc
+        this.sendAll(new PacketPlayOutChat(CraftChatMessage.fixComponent(ichatbasecomponent), (byte) i));
+        // CraftBukkit end
+    }
+
+    public void sendMessage(IChatBaseComponent ichatbasecomponent) {
+        this.sendMessage(ichatbasecomponent, true);
+    }
+
+    public ServerStatisticManager a(EntityHuman entityhuman) {
+        UUID uuid = entityhuman.getUniqueID();
+        ServerStatisticManager serverstatisticmanager = uuid == null ? null : (ServerStatisticManager) this.o.get(uuid);
+
+        if (serverstatisticmanager == null) {
+            File file = new File(this.server.getWorldServer(0).getDataManager().getDirectory(), "stats");
+            File file1 = new File(file, uuid + ".json");
+
+            if (!file1.exists()) {
+                File file2 = new File(file, entityhuman.getName() + ".json");
+
+                if (file2.exists() && file2.isFile()) {
+                    file2.renameTo(file1);
+                }
+            }
+
+            serverstatisticmanager = new ServerStatisticManager(this.server, file1);
+            serverstatisticmanager.a();
+            this.o.put(uuid, serverstatisticmanager);
+        }
+
+        return serverstatisticmanager;
+    }
+
+    public void a(int i) {
+        this.r = i;
+        if (this.server.worldServer != null) {
+            WorldServer[] aworldserver = this.server.worldServer;
+            int j = aworldserver.length;
+
+            // CraftBukkit start
+            for (int k = 0; k < server.worlds.size(); ++k) {
+                WorldServer worldserver = server.worlds.get(0);
+                // CraftBukkit end
+
+                if (worldserver != null) {
+                    worldserver.getPlayerChunkMap().a(i);
+                    worldserver.getTracker().a(i);
+                }
+            }
+
+        }
+    }
+
+    public List<EntityPlayer> v() {
+        return this.players;
+    }
+
+    public EntityPlayer a(UUID uuid) {
+        return (EntityPlayer) this.j.get(uuid);
+    }
+
+    public boolean f(GameProfile gameprofile) {
+        return false;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/ServerConnection.java src/main/java/net/minecraft/server/ServerConnection.java
--- src_origin/main/java/net/minecraft/server/ServerConnection.java	2016-08-25 22:39:52.412602029 +0800
+++ src/main/java/net/minecraft/server/ServerConnection.java	2016-08-26 03:24:14.871198506 +0800
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
 import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import io.netty.bootstrap.ServerBootstrap;
 import io.netty.channel.Channel;
@@ -23,6 +24,7 @@
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -59,7 +61,8 @@
     private final MinecraftServer f;
     public volatile boolean d;
     private final List<ChannelFuture> g = Collections.synchronizedList(Lists.<ChannelFuture>newArrayList());
-    private final List<NetworkManager> h = Collections.synchronizedList(Lists.<NetworkManager>newArrayList());
+    //private final List<NetworkManager> h = Collections.synchronizedList(Lists.<NetworkManager>newArrayList());
+    private final Queue<NetworkManager> h = Queues.newConcurrentLinkedQueue();
 
     public ServerConnection(MinecraftServer minecraftserver) {
         this.f = minecraftserver;
@@ -119,16 +122,61 @@
     }
 
     public void c() {
-        List list = this.h;
+        //List list = this.h;
 
         synchronized (this.h) {
             // Spigot Start
             // This prevents players from 'gaming' the server, and strategically relogging to increase their position in the tick order
+            /*
             if ( org.spigotmc.SpigotConfig.playerShuffle > 0 && MinecraftServer.currentTick % org.spigotmc.SpigotConfig.playerShuffle == 0 )
             {
                 Collections.shuffle( this.h );
-            }
+            }*/
             // Spigot End
+            this.h.parallelStream().forEach(networkmanager -> {
+                if (!networkmanager.h()) {
+                    if (networkmanager.isConnected()) {
+                        try {
+                            networkmanager.a();
+                        } catch (Exception exception) {
+                            if (networkmanager.isLocal()) {
+                                CrashReport crashreport = CrashReport.a(exception, "Ticking memory connection");
+                                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Ticking connection");
+
+                                crashreportsystemdetails.a("Connection", new CrashReportCallable() {
+                                    public String a() throws Exception {
+                                        return networkmanager.toString();
+                                    }
+
+                                    public Object call() throws Exception {
+                                        return this.a();
+                                    }
+                                });
+                                throw new ReportedException(crashreport);
+                            }
+
+                            ServerConnection.e.warn("Failed to handle packet for {}", new Object[] { networkmanager.getSocketAddress(), exception});
+                            final ChatComponentText chatcomponenttext = new ChatComponentText("Internal server error");
+
+                            networkmanager.sendPacket(new PacketPlayOutKickDisconnect(chatcomponenttext), new GenericFutureListener() {
+                                public void operationComplete(Future future) throws Exception {
+                                    networkmanager.close(chatcomponenttext);
+                                }
+                            }, new GenericFutureListener[0]);
+                            networkmanager.stopReading();
+                        }
+                    } else {
+                        // Spigot Start
+                        // Fix a race condition where a NetworkManager could be unregistered just before connection.
+                        if (networkmanager.preparing) return;
+                        // Spigot End
+                        this.h.remove(networkmanager);
+                        networkmanager.handleDisconnection();
+                    }
+                }
+            });
+            
+            /*
             Iterator iterator = this.h.iterator();
 
             while (iterator.hasNext()) {
@@ -174,7 +222,7 @@
                         networkmanager.handleDisconnection();
                     }
                 }
-            }
+            }*/
 
         }
     }
diff -Naur src_origin/main/java/net/minecraft/server/SpawnerCreature.java src/main/java/net/minecraft/server/SpawnerCreature.java
--- src_origin/main/java/net/minecraft/server/SpawnerCreature.java	2016-08-25 22:39:52.446602032 +0800
+++ src/main/java/net/minecraft/server/SpawnerCreature.java	2016-08-26 03:24:14.908198509 +0800
@@ -1,309 +1,312 @@
-package net.minecraft.server;
-
-import com.google.common.collect.Sets;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Random;
-import java.util.Set;
-
-// CraftBukkit start
-import org.bukkit.craftbukkit.util.LongHash;
-import org.bukkit.craftbukkit.util.LongHashSet;
-import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
-// CraftBukkit end
-
-public final class SpawnerCreature {
-
-    private static final int a = (int) Math.pow(17.0D, 2.0D);
-    private final LongHashSet b = new LongHashSet(); // CraftBukkit
-
-    public SpawnerCreature() {}
-
-    // Spigot start - get entity count only from chunks being processed in b
-    private int getEntityCount(WorldServer server, Class oClass)
-    {
-        int i = 0;
-        Iterator<Long> it = this.b.iterator();
-        while ( it.hasNext() )
-        {
-            Long coord = it.next();
-            int x = LongHash.msw( coord );
-            int z = LongHash.lsw( coord );
-            if ( !((ChunkProviderServer)server.chunkProvider).unloadQueue.contains( coord ) && server.isChunkLoaded( x, z, true ) )
-            {
-                i += server.getChunkAt( x, z ).entityCount.get( oClass );
-            }
-        }
-        return i;
-    }
-    // Spigot end
-
-    public int a(WorldServer worldserver, boolean flag, boolean flag1, boolean flag2) {
-        if (!flag && !flag1) {
-            return 0;
-        } else {
-            this.b.clear();
-            int i = 0;
-            Iterator iterator = worldserver.players.iterator();
-
-            int j;
-            int k;
-
-            while (iterator.hasNext()) {
-                EntityHuman entityhuman = (EntityHuman) iterator.next();
-
-                if (!entityhuman.isSpectator()) {
-                    int l = MathHelper.floor(entityhuman.locX / 16.0D);
-
-                    j = MathHelper.floor(entityhuman.locZ / 16.0D);
-                    boolean flag3 = true;
-                    // Spigot Start
-                    byte b0 = worldserver.spigotConfig.mobSpawnRange;
-                    b0 = ( b0 > worldserver.spigotConfig.viewDistance ) ? (byte) worldserver.spigotConfig.viewDistance : b0;
-                    b0 = ( b0 > 8 ) ? 8 : b0;
-
-                    for (int i1 = -b0; i1 <= b0; ++i1) {
-                        for (k = -b0; k <= b0; ++k) {
-                            boolean flag4 = i1 == -b0 || i1 == b0 || k == -b0 || k == b0;
-                            // Spigot End
-                            // CraftBukkit start - use LongHash and LongHashSet
-                            // ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i1 + l, k + j);
-
-                            long chunkCoords = LongHash.toLong(i1 + l, k + j);
-                            if (!this.b.contains(chunkCoords)) {
-                                ++i;
-                                if (!flag4 && worldserver.getWorldBorder().isInBounds(i1 + l, k + j)) { // CraftBukkit
-                                    PlayerChunk playerchunk = worldserver.getPlayerChunkMap().getChunk(i1 + l, k + j); // CraftBukkit
-
-                                    if (playerchunk != null && playerchunk.e()) {
-                                        this.b.add(chunkCoords);
-                                        // CraftBukkit end
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-
-            int j1 = 0;
-            BlockPosition blockposition = worldserver.getSpawn();
-            EnumCreatureType[] aenumcreaturetype = EnumCreatureType.values();
-
-            j = aenumcreaturetype.length;
-
-            for (int k1 = 0; k1 < j; ++k1) {
-                EnumCreatureType enumcreaturetype = aenumcreaturetype[k1];
-
-               // CraftBukkit start - Use per-world spawn limits
-                int limit = enumcreaturetype.b();
-                switch (enumcreaturetype) {
-                    case MONSTER:
-                        limit = worldserver.getWorld().getMonsterSpawnLimit();
-                        break;
-                    case CREATURE:
-                        limit = worldserver.getWorld().getAnimalSpawnLimit();
-                        break;
-                    case WATER_CREATURE:
-                        limit = worldserver.getWorld().getWaterAnimalSpawnLimit();
-                        break;
-                    case AMBIENT:
-                        limit = worldserver.getWorld().getAmbientSpawnLimit();
-                        break;
-                }
-
-                if (limit == 0) {
-                    continue;
-                }
-				int mobcnt = 0; // Spigot
-                // CraftBukkit end
-
-                if ((!enumcreaturetype.d() || flag1) && (enumcreaturetype.d() || flag) && (!enumcreaturetype.e() || flag2)) {
-                    k = worldserver.a(enumcreaturetype.a());
-                    int l1 = limit * i / a; // CraftBukkit - use per-world limits
-
-                    if ((mobcnt = getEntityCount(worldserver, enumcreaturetype.a())) <= limit * i / 256) {
-                        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
-                        Iterator iterator1 = this.b.iterator();
-
-                        int moblimit = (limit * i / 256) - mobcnt + 1; // Spigot - up to 1 more than limit
-                        label120:
-                        while (iterator1.hasNext() && (moblimit > 0)) { // Spigot - while more allowed
-                            // CraftBukkit start = use LongHash and LongObjectHashMap
-                            long key = ((Long) iterator1.next()).longValue();
-                            BlockPosition blockposition1 = getRandomPosition(worldserver, LongHash.msw(key), LongHash.lsw(key));
-                            // CraftBukkit
-                            int i2 = blockposition1.getX();
-                            int j2 = blockposition1.getY();
-                            int k2 = blockposition1.getZ();
-                            IBlockData iblockdata = worldserver.getType(blockposition1);
-
-                            if (!iblockdata.l()) {
-                                int l2 = 0;
-                                int i3 = 0;
-
-                                while (i3 < 3) {
-                                    int j3 = i2;
-                                    int k3 = j2;
-                                    int l3 = k2;
-                                    boolean flag5 = true;
-                                    BiomeBase.BiomeMeta biomebase_biomemeta = null;
-                                    GroupDataEntity groupdataentity = null;
-                                    int i4 = MathHelper.f(Math.random() * 4.0D);
-                                    int j4 = 0;
-
-                                    while (true) {
-                                        if (j4 < i4) {
-                                            label113: {
-                                                j3 += worldserver.random.nextInt(6) - worldserver.random.nextInt(6);
-                                                k3 += worldserver.random.nextInt(1) - worldserver.random.nextInt(1);
-                                                l3 += worldserver.random.nextInt(6) - worldserver.random.nextInt(6);
-                                                blockposition_mutableblockposition.c(j3, k3, l3);
-                                                float f = (float) j3 + 0.5F;
-                                                float f1 = (float) l3 + 0.5F;
-
-                                                if (!worldserver.isPlayerNearby((double) f, (double) k3, (double) f1, 24.0D) && blockposition.distanceSquared((double) f, (double) k3, (double) f1) >= 576.0D) {
-                                                    if (biomebase_biomemeta == null) {
-                                                        biomebase_biomemeta = worldserver.a(enumcreaturetype, (BlockPosition) blockposition_mutableblockposition);
-                                                        if (biomebase_biomemeta == null) {
-                                                            break label113;
-                                                        }
-                                                    }
-
-                                                    if (worldserver.a(enumcreaturetype, biomebase_biomemeta, (BlockPosition) blockposition_mutableblockposition) && a(EntityPositionTypes.a(biomebase_biomemeta.b), worldserver, blockposition_mutableblockposition)) {
-                                                        EntityInsentient entityinsentient;
-
-                                                        try {
-                                                            entityinsentient = (EntityInsentient) biomebase_biomemeta.b.getConstructor(new Class[] { World.class}).newInstance(new Object[] { worldserver});
-                                                        } catch (Exception exception) {
-                                                            exception.printStackTrace();
-                                                            return j1;
-                                                        }
-
-                                                        entityinsentient.setPositionRotation((double) f, (double) k3, (double) f1, worldserver.random.nextFloat() * 360.0F, 0.0F);
-                                                        if (entityinsentient.cK() && entityinsentient.canSpawn()) {
-                                                            groupdataentity = entityinsentient.prepare(worldserver.D(new BlockPosition(entityinsentient)), groupdataentity);
-                                                            if (entityinsentient.canSpawn()) {
-                                                                ++l2;
-                                                                worldserver.addEntity(entityinsentient, SpawnReason.NATURAL); // CraftBukkit - Added a reason for spawning this creature
-                                                            } else {
-                                                                entityinsentient.die();
-                                                            }
-
-                                                            // Spigot start
-                                                            if ( --moblimit <= 0 ) {
-                                                                // If we're past limit, stop spawn
-                                                                // Spigot end
-                                                                continue label120;
-                                                            }
-                                                        }
-
-                                                        j1 += l2;
-                                                    }
-                                                }
-
-                                                ++j4;
-                                                continue;
-                                            }
-                                        }
-
-                                        ++i3;
-                                        break;
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-
-            return j1;
-        }
-    }
-
-    private static BlockPosition getRandomPosition(World world, int i, int j) {
-        Chunk chunk = world.getChunkAt(i, j);
-        int k = i * 16 + world.random.nextInt(16);
-        int l = j * 16 + world.random.nextInt(16);
-        int i1 = MathHelper.c(chunk.e(new BlockPosition(k, 0, l)) + 1, 16);
-        int j1 = world.random.nextInt(i1 > 0 ? i1 : chunk.g() + 16 - 1);
-
-        return new BlockPosition(k, j1, l);
-    }
-
-    public static boolean a(IBlockData iblockdata) {
-        return iblockdata.k() ? false : (iblockdata.m() ? false : (iblockdata.getMaterial().isLiquid() ? false : !BlockMinecartTrackAbstract.i(iblockdata)));
-    }
-
-    public static boolean a(EntityInsentient.EnumEntityPositionType entityinsentient_enumentitypositiontype, World world, BlockPosition blockposition) {
-        if (!world.getWorldBorder().a(blockposition)) {
-            return false;
-        } else {
-            IBlockData iblockdata = world.getType(blockposition);
-
-            if (entityinsentient_enumentitypositiontype == EntityInsentient.EnumEntityPositionType.IN_WATER) {
-                return iblockdata.getMaterial().isLiquid() && world.getType(blockposition.down()).getMaterial().isLiquid() && !world.getType(blockposition.up()).l();
-            } else {
-                BlockPosition blockposition1 = blockposition.down();
-
-                if (!world.getType(blockposition1).q()) {
-                    return false;
-                } else {
-                    Block block = world.getType(blockposition1).getBlock();
-                    boolean flag = block != Blocks.BEDROCK && block != Blocks.BARRIER;
-
-                    return flag && a(iblockdata) && a(world.getType(blockposition.up()));
-                }
-            }
-        }
-    }
-
-    public static void a(World world, BiomeBase biomebase, int i, int j, int k, int l, Random random) {
-        List list = biomebase.getMobs(EnumCreatureType.CREATURE);
-
-        if (!list.isEmpty()) {
-            while (random.nextFloat() < biomebase.f()) {
-                BiomeBase.BiomeMeta biomebase_biomemeta = (BiomeBase.BiomeMeta) WeightedRandom.a(world.random, list);
-                int i1 = biomebase_biomemeta.c + random.nextInt(1 + biomebase_biomemeta.d - biomebase_biomemeta.c);
-                GroupDataEntity groupdataentity = null;
-                int j1 = i + random.nextInt(k);
-                int k1 = j + random.nextInt(l);
-                int l1 = j1;
-                int i2 = k1;
-
-                for (int j2 = 0; j2 < i1; ++j2) {
-                    boolean flag = false;
-
-                    for (int k2 = 0; !flag && k2 < 4; ++k2) {
-                        BlockPosition blockposition = world.q(new BlockPosition(j1, 0, k1));
-
-                        if (a(EntityInsentient.EnumEntityPositionType.ON_GROUND, world, blockposition)) {
-                            EntityInsentient entityinsentient;
-
-                            try {
-                                entityinsentient = (EntityInsentient) biomebase_biomemeta.b.getConstructor(new Class[] { World.class}).newInstance(new Object[] { world});
-                            } catch (Exception exception) {
-                                exception.printStackTrace();
-                                continue;
-                            }
-
-                            entityinsentient.setPositionRotation((double) ((float) j1 + 0.5F), (double) blockposition.getY(), (double) ((float) k1 + 0.5F), random.nextFloat() * 360.0F, 0.0F);
-                            // CraftBukkit start - Added a reason for spawning this creature, moved entityinsentient.prepare(groupdataentity) up
-                            groupdataentity = entityinsentient.prepare(world.D(new BlockPosition(entityinsentient)), groupdataentity);
-                            world.addEntity(entityinsentient, SpawnReason.CHUNK_GEN);
-                            // CraftBukkit end
-                            flag = true;
-                        }
-
-                        j1 += random.nextInt(5) - random.nextInt(5);
-
-                        for (k1 += random.nextInt(5) - random.nextInt(5); j1 < i || j1 >= i + k || k1 < j || k1 >= j + k; k1 = i2 + random.nextInt(5) - random.nextInt(5)) {
-                            j1 = l1 + random.nextInt(5) - random.nextInt(5);
-                        }
-                    }
-                }
-            }
-
-        }
-    }
-}
+package net.minecraft.server;
+
+import com.google.common.collect.Sets;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Random;
+import java.util.Set;
+
+// CraftBukkit start
+import org.bukkit.craftbukkit.util.LongHash;
+import org.bukkit.craftbukkit.util.LongHashSet;
+import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
+// CraftBukkit end
+
+public final class SpawnerCreature {
+
+    private static final int a = (int) Math.pow(17.0D, 2.0D);
+    //private final LongHashSet b = new LongHashSet(); // CraftBukkit
+    private final Set<Long> b = Sets.newConcurrentHashSet();
+
+    public SpawnerCreature() {}
+
+    // Spigot start - get entity count only from chunks being processed in b
+    private int getEntityCount(WorldServer server, Class oClass)
+    {
+        int i = 0;
+        Iterator<Long> it = this.b.iterator();
+        while ( it.hasNext() )
+        {
+            Long coord = it.next();
+            int x = LongHash.msw( coord );
+            int z = LongHash.lsw( coord );
+            if ( !((ChunkProviderServer)server.chunkProvider).unloadQueue.contains( coord ) && server.isChunkLoaded( x, z, true ) )
+            {
+                i += server.getChunkAt( x, z ).entityCount.get( oClass );
+            }
+        }
+        return i;
+    }
+    // Spigot end
+
+    public int a(WorldServer worldserver, boolean flag, boolean flag1, boolean flag2) {
+        if (!flag && !flag1) {
+            return 0;
+        } else {
+            this.b.clear();
+            int i = 0;
+            Iterator iterator = worldserver.players.iterator();
+
+            int j;
+            int k;
+
+            while (iterator.hasNext()) {
+                EntityHuman entityhuman = (EntityHuman) iterator.next();
+
+                if (!entityhuman.isSpectator()) {
+                    int l = MathHelper.floor(entityhuman.locX / 16.0D);
+
+                    j = MathHelper.floor(entityhuman.locZ / 16.0D);
+                    boolean flag3 = true;
+                    // Spigot Start
+                    byte b0 = worldserver.spigotConfig.mobSpawnRange;
+                    b0 = ( b0 > worldserver.spigotConfig.viewDistance ) ? (byte) worldserver.spigotConfig.viewDistance : b0;
+                    b0 = ( b0 > 8 ) ? 8 : b0;
+
+                    for (int i1 = -b0; i1 <= b0; ++i1) {
+                        for (k = -b0; k <= b0; ++k) {
+                            boolean flag4 = i1 == -b0 || i1 == b0 || k == -b0 || k == b0;
+                            // Spigot End
+                            // CraftBukkit start - use LongHash and LongHashSet
+                            // ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i1 + l, k + j);
+
+                            long chunkCoords = LongHash.toLong(i1 + l, k + j);
+                            if (!this.b.contains(chunkCoords)) {
+                                ++i;
+                                if (!flag4 && worldserver.getWorldBorder().isInBounds(i1 + l, k + j)) { // CraftBukkit
+                                    PlayerChunk playerchunk = worldserver.getPlayerChunkMap().getChunk(i1 + l, k + j); // CraftBukkit
+
+                                    if (playerchunk != null && playerchunk.e()) {
+                                        this.b.add(chunkCoords);
+                                        // CraftBukkit end
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            int j1 = 0;
+            BlockPosition blockposition = worldserver.getSpawn();
+            EnumCreatureType[] aenumcreaturetype = EnumCreatureType.values();
+
+            j = aenumcreaturetype.length;
+
+            for (int k1 = 0; k1 < j; ++k1) {
+                EnumCreatureType enumcreaturetype = aenumcreaturetype[k1];
+
+               // CraftBukkit start - Use per-world spawn limits
+                int limit = enumcreaturetype.b();
+                switch (enumcreaturetype) {
+                    case MONSTER:
+                        limit = worldserver.getWorld().getMonsterSpawnLimit();
+                        break;
+                    case CREATURE:
+                        limit = worldserver.getWorld().getAnimalSpawnLimit();
+                        break;
+                    case WATER_CREATURE:
+                        limit = worldserver.getWorld().getWaterAnimalSpawnLimit();
+                        break;
+                    case AMBIENT:
+                        limit = worldserver.getWorld().getAmbientSpawnLimit();
+                        break;
+                }
+
+                if (limit == 0) {
+                    continue;
+                }
+				int mobcnt = 0; // Spigot
+                // CraftBukkit end
+
+                if ((!enumcreaturetype.d() || flag1) && (enumcreaturetype.d() || flag) && (!enumcreaturetype.e() || flag2)) {
+                    k = worldserver.a(enumcreaturetype.a());
+                    int l1 = limit * i / a; // CraftBukkit - use per-world limits
+
+                    if ((mobcnt = getEntityCount(worldserver, enumcreaturetype.a())) <= limit * i / 256) {
+                        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+                        Iterator iterator1 = this.b.iterator();
+
+                        int moblimit = (limit * i / 256) - mobcnt + 1; // Spigot - up to 1 more than limit
+                        label120:
+                        while (iterator1.hasNext() && (moblimit > 0)) { // Spigot - while more allowed
+                            // CraftBukkit start = use LongHash and LongObjectHashMap
+                            //long key = ((Long) iterator1.next()).longValue();
+                            long key = (long) iterator1.next();
+                            BlockPosition blockposition1 = getRandomPosition(worldserver, LongHash.msw(key), LongHash.lsw(key));
+                            // CraftBukkit
+                            int i2 = blockposition1.getX();
+                            int j2 = blockposition1.getY();
+                            int k2 = blockposition1.getZ();
+                            IBlockData iblockdata = worldserver.getType(blockposition1);
+
+                            if (!iblockdata.l()) {
+                                int l2 = 0;
+                                int i3 = 0;
+
+                                while (i3 < 3) {
+                                    int j3 = i2;
+                                    int k3 = j2;
+                                    int l3 = k2;
+                                    boolean flag5 = true;
+                                    BiomeBase.BiomeMeta biomebase_biomemeta = null;
+                                    GroupDataEntity groupdataentity = null;
+                                    int i4 = MathHelper.f(Math.random() * 4.0D);
+                                    int j4 = 0;
+
+                                    while (true) {
+                                        if (j4 < i4) {
+                                            label113: {
+                                                j3 += worldserver.random.nextInt(6) - worldserver.random.nextInt(6);
+                                                k3 += worldserver.random.nextInt(1) - worldserver.random.nextInt(1);
+                                                l3 += worldserver.random.nextInt(6) - worldserver.random.nextInt(6);
+                                                blockposition_mutableblockposition.c(j3, k3, l3);
+                                                float f = (float) j3 + 0.5F;
+                                                float f1 = (float) l3 + 0.5F;
+
+                                                if (!worldserver.isPlayerNearby((double) f, (double) k3, (double) f1, 24.0D) && blockposition.distanceSquared((double) f, (double) k3, (double) f1) >= 576.0D) {
+                                                    if (biomebase_biomemeta == null) {
+                                                        biomebase_biomemeta = worldserver.a(enumcreaturetype, (BlockPosition) blockposition_mutableblockposition);
+                                                        if (biomebase_biomemeta == null) {
+                                                            break label113;
+                                                        }
+                                                    }
+
+                                                    if (worldserver.a(enumcreaturetype, biomebase_biomemeta, (BlockPosition) blockposition_mutableblockposition) && a(EntityPositionTypes.a(biomebase_biomemeta.b), worldserver, blockposition_mutableblockposition)) {
+                                                        EntityInsentient entityinsentient;
+
+                                                        try {
+                                                            entityinsentient = (EntityInsentient) biomebase_biomemeta.b.getConstructor(new Class[] { World.class}).newInstance(new Object[] { worldserver});
+                                                        } catch (Exception exception) {
+                                                            exception.printStackTrace();
+                                                            return j1;
+                                                        }
+
+                                                        entityinsentient.setPositionRotation((double) f, (double) k3, (double) f1, worldserver.random.nextFloat() * 360.0F, 0.0F);
+                                                        if (entityinsentient.cK() && entityinsentient.canSpawn()) {
+                                                            groupdataentity = entityinsentient.prepare(worldserver.D(new BlockPosition(entityinsentient)), groupdataentity);
+                                                            if (entityinsentient.canSpawn()) {
+                                                                ++l2;
+                                                                worldserver.addEntity(entityinsentient, SpawnReason.NATURAL); // CraftBukkit - Added a reason for spawning this creature
+                                                            } else {
+                                                                entityinsentient.die();
+                                                            }
+
+                                                            // Spigot start
+                                                            if ( --moblimit <= 0 ) {
+                                                                // If we're past limit, stop spawn
+                                                                // Spigot end
+                                                                continue label120;
+                                                            }
+                                                        }
+
+                                                        j1 += l2;
+                                                    }
+                                                }
+
+                                                ++j4;
+                                                continue;
+                                            }
+                                        }
+
+                                        ++i3;
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            return j1;
+        }
+    }
+
+    private static BlockPosition getRandomPosition(World world, int i, int j) {
+        Chunk chunk = world.getChunkAt(i, j);
+        int k = i * 16 + world.random.nextInt(16);
+        int l = j * 16 + world.random.nextInt(16);
+        int i1 = MathHelper.c(chunk.e(new BlockPosition(k, 0, l)) + 1, 16);
+        int j1 = world.random.nextInt(i1 > 0 ? i1 : chunk.g() + 16 - 1);
+
+        return new BlockPosition(k, j1, l);
+    }
+
+    public static boolean a(IBlockData iblockdata) {
+        return iblockdata.k() ? false : (iblockdata.m() ? false : (iblockdata.getMaterial().isLiquid() ? false : !BlockMinecartTrackAbstract.i(iblockdata)));
+    }
+
+    public static boolean a(EntityInsentient.EnumEntityPositionType entityinsentient_enumentitypositiontype, World world, BlockPosition blockposition) {
+        if (!world.getWorldBorder().a(blockposition)) {
+            return false;
+        } else {
+            IBlockData iblockdata = world.getType(blockposition);
+
+            if (entityinsentient_enumentitypositiontype == EntityInsentient.EnumEntityPositionType.IN_WATER) {
+                return iblockdata.getMaterial().isLiquid() && world.getType(blockposition.down()).getMaterial().isLiquid() && !world.getType(blockposition.up()).l();
+            } else {
+                BlockPosition blockposition1 = blockposition.down();
+
+                if (!world.getType(blockposition1).q()) {
+                    return false;
+                } else {
+                    Block block = world.getType(blockposition1).getBlock();
+                    boolean flag = block != Blocks.BEDROCK && block != Blocks.BARRIER;
+
+                    return flag && a(iblockdata) && a(world.getType(blockposition.up()));
+                }
+            }
+        }
+    }
+
+    public static void a(World world, BiomeBase biomebase, int i, int j, int k, int l, Random random) {
+        List list = biomebase.getMobs(EnumCreatureType.CREATURE);
+
+        if (!list.isEmpty()) {
+            while (random.nextFloat() < biomebase.f()) {
+                BiomeBase.BiomeMeta biomebase_biomemeta = (BiomeBase.BiomeMeta) WeightedRandom.a(world.random, list);
+                int i1 = biomebase_biomemeta.c + random.nextInt(1 + biomebase_biomemeta.d - biomebase_biomemeta.c);
+                GroupDataEntity groupdataentity = null;
+                int j1 = i + random.nextInt(k);
+                int k1 = j + random.nextInt(l);
+                int l1 = j1;
+                int i2 = k1;
+
+                for (int j2 = 0; j2 < i1; ++j2) {
+                    boolean flag = false;
+
+                    for (int k2 = 0; !flag && k2 < 4; ++k2) {
+                        BlockPosition blockposition = world.q(new BlockPosition(j1, 0, k1));
+
+                        if (a(EntityInsentient.EnumEntityPositionType.ON_GROUND, world, blockposition)) {
+                            EntityInsentient entityinsentient;
+
+                            try {
+                                entityinsentient = (EntityInsentient) biomebase_biomemeta.b.getConstructor(new Class[] { World.class}).newInstance(new Object[] { world});
+                            } catch (Exception exception) {
+                                exception.printStackTrace();
+                                continue;
+                            }
+
+                            entityinsentient.setPositionRotation((double) ((float) j1 + 0.5F), (double) blockposition.getY(), (double) ((float) k1 + 0.5F), random.nextFloat() * 360.0F, 0.0F);
+                            // CraftBukkit start - Added a reason for spawning this creature, moved entityinsentient.prepare(groupdataentity) up
+                            groupdataentity = entityinsentient.prepare(world.D(new BlockPosition(entityinsentient)), groupdataentity);
+                            world.addEntity(entityinsentient, SpawnReason.CHUNK_GEN);
+                            // CraftBukkit end
+                            flag = true;
+                        }
+
+                        j1 += random.nextInt(5) - random.nextInt(5);
+
+                        for (k1 += random.nextInt(5) - random.nextInt(5); j1 < i || j1 >= i + k || k1 < j || k1 >= j + k; k1 = i2 + random.nextInt(5) - random.nextInt(5)) {
+                            j1 = l1 + random.nextInt(5) - random.nextInt(5);
+                        }
+                    }
+                }
+            }
+
+        }
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/World.java src/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2016-08-25 22:39:52.627602049 +0800
+++ src/main/java/net/minecraft/server/World.java	2016-08-26 03:24:15.094198527 +0800
@@ -1,3126 +1,3295 @@
-	package net.minecraft.server;
-
-import com.google.common.base.Function;
-import com.google.common.base.Objects;
-import com.google.common.base.Predicate;
-import com.google.common.collect.Lists;
-import java.util.ArrayList;
-import java.util.Calendar;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Random;
-import java.util.UUID;
-import javax.annotation.Nullable;
-
-// CraftBukkit start
-import com.google.common.collect.Maps;
-import java.util.Map;
-import org.bukkit.Bukkit;
-import org.bukkit.block.BlockState;
-import org.bukkit.craftbukkit.SpigotTimings; // Spigot
-import org.bukkit.craftbukkit.CraftServer;
-import org.bukkit.craftbukkit.CraftWorld;
-import org.bukkit.craftbukkit.event.CraftEventFactory;
-import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.event.block.BlockCanBuildEvent;
-import org.bukkit.event.block.BlockPhysicsEvent;
-import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
-import org.bukkit.generator.ChunkGenerator;
-// CraftBukkit end
-
-public abstract class World implements IBlockAccess {
-
-    private int a = 63;
-    protected boolean d;
-    // Spigot start - guard entity list from removals
-    public final List<Entity> entityList = new java.util.ArrayList<Entity>()
-    {
-        @Override
-        public Entity remove(int index)
-        {
-            guard();
-            return super.remove( index );
-        }
-
-        @Override
-        public boolean remove(Object o)
-        {
-            guard();
-            return super.remove( o );
-        }
-
-        private void guard()
-        {
-            if ( guardEntityList )
-            {
-                throw new java.util.ConcurrentModificationException();
-            }
-        }
-    };
-    // Spigot end
-    protected final List<Entity> f = Lists.newArrayList();
-    public final List<TileEntity> tileEntityList = Lists.newArrayList();
-    public final List<TileEntity> tileEntityListTick = Lists.newArrayList();
-    private final List<TileEntity> b = Lists.newArrayList();
-    private final List<TileEntity> tileEntityListUnload = Lists.newArrayList();
-    public final List<EntityHuman> players = Lists.newArrayList();
-    public final List<Entity> j = Lists.newArrayList();
-    protected final IntHashMap<Entity> entitiesById = new IntHashMap();
-    private final long I = 16777215L;
-    private int J;
-    protected int l = (new Random()).nextInt();
-    protected final int m = 1013904223;
-    protected float n;
-    protected float o;
-    protected float p;
-    protected float q;
-    private int K;
-    public final Random random = new Random();
-    public WorldProvider worldProvider;
-    protected NavigationListener t = new NavigationListener();
-    protected List<IWorldAccess> u;
-    protected IChunkProvider chunkProvider;
-    protected final IDataManager dataManager;
-    public WorldData worldData;
-    protected boolean isLoading;
-    public PersistentCollection worldMaps;
-    protected PersistentVillage villages;
-    protected LootTableRegistry B;
-    public final MethodProfiler methodProfiler;
-    private final Calendar L;
-    public Scoreboard scoreboard;
-    public final boolean isClientSide;
-    public boolean allowMonsters;
-    public boolean allowAnimals;
-    private boolean M;
-    private final WorldBorder N;
-    int[] H;
-
-    // CraftBukkit start Added the following
-    private final CraftWorld world;
-    public boolean pvpMode;
-    public boolean keepSpawnInMemory = true;
-    public ChunkGenerator generator;
-
-    public boolean captureBlockStates = false;
-    public boolean captureTreeGeneration = false;
-    public ArrayList<BlockState> capturedBlockStates= new ArrayList<BlockState>(){
-        @Override
-        public boolean add( BlockState blockState ) {
-            Iterator<BlockState> blockStateIterator = this.iterator();
-            while( blockStateIterator.hasNext() ) {
-                BlockState blockState1 = blockStateIterator.next();
-                if ( blockState1.getLocation().equals( blockState.getLocation() ) ) {
-                    return false;
-                }
-            }
-
-            return super.add( blockState );
-        }
-    };
-    public long ticksPerAnimalSpawns;
-    public long ticksPerMonsterSpawns;
-    public boolean populating;
-    private int tickPosition;
-    public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
-
-    public final SpigotTimings.WorldTimingsHandler timings; // Spigot
-    private boolean guardEntityList; // Spigot
-    public static boolean haveWeSilencedAPhysicsCrash;
-    public static String blockLocation;
-    private org.spigotmc.TickLimiter entityLimiter;
-    private org.spigotmc.TickLimiter tileLimiter;
-    private int tileTickPosition;
-
-    public CraftWorld getWorld() {
-        return this.world;
-    }
-
-    public CraftServer getServer() {
-        return (CraftServer) Bukkit.getServer();
-    }
-
-    public Chunk getChunkIfLoaded(int x, int z) {
-        return ((ChunkProviderServer) this.chunkProvider).getChunkIfLoaded(x, z);
-    }
-
-    protected World(IDataManager idatamanager, WorldData worlddata, WorldProvider worldprovider, MethodProfiler methodprofiler, boolean flag, ChunkGenerator gen, org.bukkit.World.Environment env) {
-        this.spigotConfig = new org.spigotmc.SpigotWorldConfig( worlddata.getName() ); // Spigot
-        this.generator = gen;
-        this.world = new CraftWorld((WorldServer) this, gen, env);
-        this.ticksPerAnimalSpawns = this.getServer().getTicksPerAnimalSpawns(); // CraftBukkit
-        this.ticksPerMonsterSpawns = this.getServer().getTicksPerMonsterSpawns(); // CraftBukkit
-        // CraftBukkit end
-        this.u = Lists.newArrayList(new IWorldAccess[] { this.t});
-        this.L = Calendar.getInstance();
-        this.scoreboard = new Scoreboard();
-        this.allowMonsters = true;
-        this.allowAnimals = true;
-        this.H = new int['\u8000'];
-        this.dataManager = idatamanager;
-        this.methodProfiler = methodprofiler;
-        this.worldData = worlddata;
-        this.worldProvider = worldprovider;
-        this.isClientSide = flag;
-        this.N = worldprovider.getWorldBorder();
-        // CraftBukkit start
-        getWorldBorder().world = (WorldServer) this;
-        // From PlayerList.setPlayerFileData
-        getWorldBorder().a(new IWorldBorderListener() {
-            public void a(WorldBorder worldborder, double d0) {
-                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_SIZE), worldborder.world);
-            }
-
-            public void a(WorldBorder worldborder, double d0, double d1, long i) {
-                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.LERP_SIZE), worldborder.world);
-            }
-
-            public void a(WorldBorder worldborder, double d0, double d1) {
-                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_CENTER), worldborder.world);
-            }
-
-            public void a(WorldBorder worldborder, int i) {
-                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_WARNING_TIME), worldborder.world);
-            }
-
-            public void b(WorldBorder worldborder, int i) {
-                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_WARNING_BLOCKS), worldborder.world);
-            }
-
-            public void b(WorldBorder worldborder, double d0) {}
-
-            public void c(WorldBorder worldborder, double d0) {}
-        });
-        this.getServer().addWorld(this.world);
-        // CraftBukkit end
-        timings = new SpigotTimings.WorldTimingsHandler(this); // Spigot - code below can generate new world and access timings
-                this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
-        this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
-    }
-
-    public World b() {
-        return this;
-    }
-
-    public BiomeBase getBiome(final BlockPosition blockposition) {
-        if (this.isLoaded(blockposition)) {
-            Chunk chunk = this.getChunkAtWorldCoords(blockposition);
-
-            try {
-                return chunk.getBiome(blockposition, this.worldProvider.k());
-            } catch (Throwable throwable) {
-                CrashReport crashreport = CrashReport.a(throwable, "Getting biome");
-                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Coordinates of biome request");
-
-                crashreportsystemdetails.a("Location", new CrashReportCallable() {
-                    public String a() throws Exception {
-                        return CrashReportSystemDetails.a(blockposition);
-                    }
-
-                    public Object call() throws Exception {
-                        return this.a();
-                    }
-                });
-                throw new ReportedException(crashreport);
-            }
-        } else {
-            return this.worldProvider.k().getBiome(blockposition, Biomes.c);
-        }
-    }
-
-    public WorldChunkManager getWorldChunkManager() {
-        return this.worldProvider.k();
-    }
-
-    protected abstract IChunkProvider n();
-
-    public void a(WorldSettings worldsettings) {
-        this.worldData.d(true);
-    }
-
-    @Nullable
-    public MinecraftServer getMinecraftServer() {
-        return null;
-    }
-
-    public IBlockData c(BlockPosition blockposition) {
-        BlockPosition blockposition1;
-
-        for (blockposition1 = new BlockPosition(blockposition.getX(), this.K(), blockposition.getZ()); !this.isEmpty(blockposition1.up()); blockposition1 = blockposition1.up()) {
-            ;
-        }
-
-        return this.getType(blockposition1);
-    }
-
-    private boolean isValidLocation(BlockPosition blockposition) {
-        return !this.E(blockposition) && blockposition.getX() >= -30000000 && blockposition.getZ() >= -30000000 && blockposition.getX() < 30000000 && blockposition.getZ() < 30000000;
-    }
-
-    private boolean E(BlockPosition blockposition) {
-        return blockposition.getY() < 0 || blockposition.getY() >= 256;
-    }
-
-    public boolean isEmpty(BlockPosition blockposition) {
-        return this.getType(blockposition).getMaterial() == Material.AIR;
-    }
-
-    public boolean isLoaded(BlockPosition blockposition) {
-        return this.a(blockposition, true);
-    }
-
-    public boolean a(BlockPosition blockposition, boolean flag) {
-        return this.isChunkLoaded(blockposition.getX() >> 4, blockposition.getZ() >> 4, flag);
-    }
-
-    public boolean areChunksLoaded(BlockPosition blockposition, int i) {
-        return this.areChunksLoaded(blockposition, i, true);
-    }
-
-    public boolean areChunksLoaded(BlockPosition blockposition, int i, boolean flag) {
-        return this.isAreaLoaded(blockposition.getX() - i, blockposition.getY() - i, blockposition.getZ() - i, blockposition.getX() + i, blockposition.getY() + i, blockposition.getZ() + i, flag);
-    }
-
-    public boolean areChunksLoadedBetween(BlockPosition blockposition, BlockPosition blockposition1) {
-        return this.areChunksLoadedBetween(blockposition, blockposition1, true);
-    }
-
-    public boolean areChunksLoadedBetween(BlockPosition blockposition, BlockPosition blockposition1, boolean flag) {
-        return this.isAreaLoaded(blockposition.getX(), blockposition.getY(), blockposition.getZ(), blockposition1.getX(), blockposition1.getY(), blockposition1.getZ(), flag);
-    }
-
-    public boolean a(StructureBoundingBox structureboundingbox) {
-        return this.b(structureboundingbox, true);
-    }
-
-    public boolean b(StructureBoundingBox structureboundingbox, boolean flag) {
-        return this.isAreaLoaded(structureboundingbox.a, structureboundingbox.b, structureboundingbox.c, structureboundingbox.d, structureboundingbox.e, structureboundingbox.f, flag);
-    }
-
-    private boolean isAreaLoaded(int i, int j, int k, int l, int i1, int j1, boolean flag) {
-        if (i1 >= 0 && j < 256) {
-            i >>= 4;
-            k >>= 4;
-            l >>= 4;
-            j1 >>= 4;
-
-            for (int k1 = i; k1 <= l; ++k1) {
-                for (int l1 = k; l1 <= j1; ++l1) {
-                    if (!this.isChunkLoaded(k1, l1, flag)) {
-                        return false;
-                    }
-                }
-            }
-
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    protected abstract boolean isChunkLoaded(int i, int j, boolean flag);
-
-    public Chunk getChunkAtWorldCoords(BlockPosition blockposition) {
-        return this.getChunkAt(blockposition.getX() >> 4, blockposition.getZ() >> 4);
-    }
-
-    public Chunk getChunkAt(int i, int j) {
-        return this.chunkProvider.getChunkAt(i, j);
-    }
-
-    public boolean setTypeAndData(BlockPosition blockposition, IBlockData iblockdata, int i) {
-        // CraftBukkit start - tree generation
-        if (this.captureTreeGeneration) {
-            BlockState blockstate = null;
-            Iterator<BlockState> it = capturedBlockStates.iterator();
-            while (it.hasNext()) {
-                BlockState previous = it.next();
-                if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
-                    blockstate = previous;
-                    it.remove();
-                    break;
-                }
-            }
-            if (blockstate == null) {
-                blockstate = org.bukkit.craftbukkit.block.CraftBlockState.getBlockState(this, blockposition.getX(), blockposition.getY(), blockposition.getZ(), i);
-            }
-            blockstate.setTypeId(CraftMagicNumbers.getId(iblockdata.getBlock()));
-            blockstate.setRawData((byte) iblockdata.getBlock().toLegacyData(iblockdata));
-            this.capturedBlockStates.add(blockstate);
-            return true;
-        }
-        // CraftBukkit end
-        if (this.E(blockposition)) {
-            return false;
-        } else if (!this.isClientSide && this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
-            return false;
-        } else {
-            Chunk chunk = this.getChunkAtWorldCoords(blockposition);
-            Block block = iblockdata.getBlock();
-
-            // CraftBukkit start - capture blockstates
-            BlockState blockstate = null;
-            if (this.captureBlockStates) {
-                blockstate = org.bukkit.craftbukkit.block.CraftBlockState.getBlockState(this, blockposition.getX(), blockposition.getY(), blockposition.getZ(), i);
-                this.capturedBlockStates.add(blockstate);
-            }
-            // CraftBukkit end
-
-            IBlockData iblockdata1 = chunk.a(blockposition, iblockdata);
-
-            if (iblockdata1 == null) {
-                // CraftBukkit start - remove blockstate if failed
-                if (this.captureBlockStates) {
-                    this.capturedBlockStates.remove(blockstate);
-                }
-                // CraftBukkit end
-                return false;
-            } else {
-                if (iblockdata.c() != iblockdata1.c() || iblockdata.d() != iblockdata1.d()) {
-                    this.methodProfiler.a("checkLight");
-                    this.w(blockposition);
-                    this.methodProfiler.b();
-                }
-
-                /*
-                if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && chunk.isReady()) {
-                    this.notify(blockposition, iblockdata1, iblockdata, i);
-                }
-
-                if (!this.isClientSide && (i & 1) != 0) {
-                    this.update(blockposition, iblockdata1.getBlock());
-                    if (iblockdata.n()) {
-                        this.updateAdjacentComparators(blockposition, block);
-                    }
-                }
-                */
-
-                // CraftBukkit start
-                if (!this.captureBlockStates) { // Don't notify clients or update physics while capturing blockstates
-                    // Modularize client and physic updates
-                    notifyAndUpdatePhysics(blockposition, chunk, iblockdata1, iblockdata, i);
-                }
-                // CraftBukkit end
-
-                return true;
-            }
-        }
-    }
-
-    // CraftBukkit start - Split off from original setTypeAndData(int i, int j, int k, Block block, int l, int i1) method in order to directly send client and physic updates
-    public void notifyAndUpdatePhysics(BlockPosition blockposition, Chunk chunk, IBlockData oldBlock, IBlockData newBlock, int flag) {
-        if ((flag & 2) != 0 && (chunk == null || chunk.isReady())) {  // allow chunk to be null here as chunk.isReady() is false when we send our notification during block placement
-            this.notify(blockposition, oldBlock, newBlock, flag);
-        }
-
-        if (!this.isClientSide && (flag & 1) != 0) {
-            this.update(blockposition, oldBlock.getBlock());
-            if (newBlock.n()) {
-                this.updateAdjacentComparators(blockposition, newBlock.getBlock());
-            }
-        }
-    }
-    // CraftBukkit end
-
-    public boolean setAir(BlockPosition blockposition) {
-        return this.setTypeAndData(blockposition, Blocks.AIR.getBlockData(), 3);
-    }
-
-    public boolean setAir(BlockPosition blockposition, boolean flag) {
-        IBlockData iblockdata = this.getType(blockposition);
-        Block block = iblockdata.getBlock();
-
-        if (iblockdata.getMaterial() == Material.AIR) {
-            return false;
-        } else {
-            this.triggerEffect(2001, blockposition, Block.getCombinedId(iblockdata));
-            if (flag) {
-                block.b(this, blockposition, iblockdata, 0);
-            }
-
-            return this.setTypeAndData(blockposition, Blocks.AIR.getBlockData(), 3);
-        }
-    }
-
-    public boolean setTypeUpdate(BlockPosition blockposition, IBlockData iblockdata) {
-        return this.setTypeAndData(blockposition, iblockdata, 3);
-    }
-
-    public void notify(BlockPosition blockposition, IBlockData iblockdata, IBlockData iblockdata1, int i) {
-        for (int j = 0; j < this.u.size(); ++j) {
-            ((IWorldAccess) this.u.get(j)).a(this, blockposition, iblockdata, iblockdata1, i);
-        }
-
-    }
-
-    public void update(BlockPosition blockposition, Block block) {
-        if (this.worldData.getType() != WorldType.DEBUG_ALL_BLOCK_STATES) {
-            // CraftBukkit start
-            if (populating) {
-                return;
-            }
-            // CraftBukkit end
-            this.applyPhysics(blockposition, block);
-        }
-
-    }
-
-    public void a(int i, int j, int k, int l) {
-        int i1;
-
-        if (k > l) {
-            i1 = l;
-            l = k;
-            k = i1;
-        }
-
-        if (!this.worldProvider.m()) {
-            for (i1 = k; i1 <= l; ++i1) {
-                this.c(EnumSkyBlock.SKY, new BlockPosition(i, i1, j));
-            }
-        }
-
-        this.b(i, k, j, i, l, j);
-    }
-
-    public void b(BlockPosition blockposition, BlockPosition blockposition1) {
-        this.b(blockposition.getX(), blockposition.getY(), blockposition.getZ(), blockposition1.getX(), blockposition1.getY(), blockposition1.getZ());
-    }
-
-    public void b(int i, int j, int k, int l, int i1, int j1) {
-        for (int k1 = 0; k1 < this.u.size(); ++k1) {
-            ((IWorldAccess) this.u.get(k1)).a(i, j, k, l, i1, j1);
-        }
-
-    }
-
-    public void applyPhysics(BlockPosition blockposition, Block block) {
-        this.e(blockposition.west(), block);
-        this.e(blockposition.east(), block);
-        this.e(blockposition.down(), block);
-        this.e(blockposition.up(), block);
-        this.e(blockposition.north(), block);
-        this.e(blockposition.south(), block);
-    }
-
-    public void a(BlockPosition blockposition, Block block, EnumDirection enumdirection) {
-        if (enumdirection != EnumDirection.WEST) {
-            this.e(blockposition.west(), block);
-        }
-
-        if (enumdirection != EnumDirection.EAST) {
-            this.e(blockposition.east(), block);
-        }
-
-        if (enumdirection != EnumDirection.DOWN) {
-            this.e(blockposition.down(), block);
-        }
-
-        if (enumdirection != EnumDirection.UP) {
-            this.e(blockposition.up(), block);
-        }
-
-        if (enumdirection != EnumDirection.NORTH) {
-            this.e(blockposition.north(), block);
-        }
-
-        if (enumdirection != EnumDirection.SOUTH) {
-            this.e(blockposition.south(), block);
-        }
-
-    }
-
-    public void e(BlockPosition blockposition, final Block block) {
-        if (!this.isClientSide) {
-            IBlockData iblockdata = this.getType(blockposition);
-
-            try {
-                // CraftBukkit start
-                CraftWorld world = ((WorldServer) this).getWorld();
-                if (world != null) {
-                    BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), CraftMagicNumbers.getId(block));
-                    this.getServer().getPluginManager().callEvent(event);
-
-                    if (event.isCancelled()) {
-                        return;
-                    }
-                }
-                // CraftBukkit end
-                iblockdata.doPhysics(this, blockposition, block);
-            } catch (StackOverflowError stackoverflowerror) { // Spigot Start
-                haveWeSilencedAPhysicsCrash = true;
-                blockLocation = blockposition.getX() + ", " + blockposition.getY() + ", " + blockposition.getZ(); // Spigot End
-            } catch (Throwable throwable) {
-                CrashReport crashreport = CrashReport.a(throwable, "Exception while updating neighbours");
-                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being updated");
-
-                crashreportsystemdetails.a("Source block type", new CrashReportCallable() {
-                    public String a() throws Exception {
-                        try {
-                            return String.format("ID #%d (%s // %s)", new Object[] { Integer.valueOf(Block.getId(block)), block.a(), block.getClass().getCanonicalName()});
-                        } catch (Throwable throwable) {
-                            return "ID #" + Block.getId(block);
-                        }
-                    }
-
-                    public Object call() throws Exception {
-                        return this.a();
-                    }
-                });
-                CrashReportSystemDetails.a(crashreportsystemdetails, blockposition, iblockdata);
-                throw new ReportedException(crashreport);
-            }
-        }
-    }
-
-    public boolean a(BlockPosition blockposition, Block block) {
-        return false;
-    }
-
-    public boolean h(BlockPosition blockposition) {
-        return this.getChunkAtWorldCoords(blockposition).c(blockposition);
-    }
-
-    public boolean i(BlockPosition blockposition) {
-        if (blockposition.getY() >= this.K()) {
-            return this.h(blockposition);
-        } else {
-            BlockPosition blockposition1 = new BlockPosition(blockposition.getX(), this.K(), blockposition.getZ());
-
-            if (!this.h(blockposition1)) {
-                return false;
-            } else {
-                for (blockposition1 = blockposition1.down(); blockposition1.getY() > blockposition.getY(); blockposition1 = blockposition1.down()) {
-                    IBlockData iblockdata = this.getType(blockposition1);
-
-                    if (iblockdata.c() > 0 && !iblockdata.getMaterial().isLiquid()) {
-                        return false;
-                    }
-                }
-
-                return true;
-            }
-        }
-    }
-
-    public int j(BlockPosition blockposition) {
-        if (blockposition.getY() < 0) {
-            return 0;
-        } else {
-            if (blockposition.getY() >= 256) {
-                blockposition = new BlockPosition(blockposition.getX(), 255, blockposition.getZ());
-            }
-
-            return this.getChunkAtWorldCoords(blockposition).a(blockposition, 0);
-        }
-    }
-
-    public int getLightLevel(BlockPosition blockposition) {
-        return this.c(blockposition, true);
-    }
-
-    public int c(BlockPosition blockposition, boolean flag) {
-        if (blockposition.getX() >= -30000000 && blockposition.getZ() >= -30000000 && blockposition.getX() < 30000000 && blockposition.getZ() < 30000000) {
-            if (flag && this.getType(blockposition).f()) {
-                int i = this.c(blockposition.up(), false);
-                int j = this.c(blockposition.east(), false);
-                int k = this.c(blockposition.west(), false);
-                int l = this.c(blockposition.south(), false);
-                int i1 = this.c(blockposition.north(), false);
-
-                if (j > i) {
-                    i = j;
-                }
-
-                if (k > i) {
-                    i = k;
-                }
-
-                if (l > i) {
-                    i = l;
-                }
-
-                if (i1 > i) {
-                    i = i1;
-                }
-
-                return i;
-            } else if (blockposition.getY() < 0) {
-                return 0;
-            } else {
-                if (blockposition.getY() >= 256) {
-                    blockposition = new BlockPosition(blockposition.getX(), 255, blockposition.getZ());
-                }
-
-                Chunk chunk = this.getChunkAtWorldCoords(blockposition);
-
-                return chunk.a(blockposition, this.J);
-            }
-        } else {
-            return 15;
-        }
-    }
-
-    public BlockPosition getHighestBlockYAt(BlockPosition blockposition) {
-        return new BlockPosition(blockposition.getX(), this.b(blockposition.getX(), blockposition.getZ()), blockposition.getZ());
-    }
-
-    public int b(int i, int j) {
-        int k;
-
-        if (i >= -30000000 && j >= -30000000 && i < 30000000 && j < 30000000) {
-            if (this.isChunkLoaded(i >> 4, j >> 4, true)) {
-                k = this.getChunkAt(i >> 4, j >> 4).b(i & 15, j & 15);
-            } else {
-                k = 0;
-            }
-        } else {
-            k = this.K() + 1;
-        }
-
-        return k;
-    }
-
-    @Deprecated
-    public int c(int i, int j) {
-        if (i >= -30000000 && j >= -30000000 && i < 30000000 && j < 30000000) {
-            if (!this.isChunkLoaded(i >> 4, j >> 4, true)) {
-                return 0;
-            } else {
-                Chunk chunk = this.getChunkAt(i >> 4, j >> 4);
-
-                return chunk.w();
-            }
-        } else {
-            return this.K() + 1;
-        }
-    }
-
-    public int b(EnumSkyBlock enumskyblock, BlockPosition blockposition) {
-        if (blockposition.getY() < 0) {
-            blockposition = new BlockPosition(blockposition.getX(), 0, blockposition.getZ());
-        }
-
-        if (!this.isValidLocation(blockposition)) {
-            return enumskyblock.c;
-        } else if (!this.isLoaded(blockposition)) {
-            return enumskyblock.c;
-        } else {
-            Chunk chunk = this.getChunkAtWorldCoords(blockposition);
-
-            return chunk.getBrightness(enumskyblock, blockposition);
-        }
-    }
-
-    public void a(EnumSkyBlock enumskyblock, BlockPosition blockposition, int i) {
-        if (this.isValidLocation(blockposition)) {
-            if (this.isLoaded(blockposition)) {
-                Chunk chunk = this.getChunkAtWorldCoords(blockposition);
-
-                chunk.a(enumskyblock, blockposition, i);
-                this.m(blockposition);
-            }
-        }
-    }
-
-    public void m(BlockPosition blockposition) {
-        for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).a(blockposition);
-        }
-
-    }
-
-    public float n(BlockPosition blockposition) {
-        return this.worldProvider.n()[this.getLightLevel(blockposition)];
-    }
-
-    public IBlockData getType(BlockPosition blockposition) {
-        // CraftBukkit start - tree generation
-        if (captureTreeGeneration) {
-            Iterator<BlockState> it = capturedBlockStates.iterator();
-            while (it.hasNext()) {
-                BlockState previous = it.next();
-                if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
-                    return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
-                }
-            }
-        }
-        // CraftBukkit end
-        if (this.E(blockposition)) {
-            return Blocks.AIR.getBlockData();
-        } else {
-            Chunk chunk = this.getChunkAtWorldCoords(blockposition);
-
-            return chunk.getBlockData(blockposition);
-        }
-    }
-
-    public boolean B() {
-        return this.J < 4;
-    }
-
-    @Nullable
-    public MovingObjectPosition rayTrace(Vec3D vec3d, Vec3D vec3d1) {
-        return this.rayTrace(vec3d, vec3d1, false, false, false);
-    }
-
-    @Nullable
-    public MovingObjectPosition rayTrace(Vec3D vec3d, Vec3D vec3d1, boolean flag) {
-        return this.rayTrace(vec3d, vec3d1, flag, false, false);
-    }
-
-    @Nullable
-    public MovingObjectPosition rayTrace(Vec3D vec3d, Vec3D vec3d1, boolean flag, boolean flag1, boolean flag2) {
-        if (!Double.isNaN(vec3d.x) && !Double.isNaN(vec3d.y) && !Double.isNaN(vec3d.z)) {
-            if (!Double.isNaN(vec3d1.x) && !Double.isNaN(vec3d1.y) && !Double.isNaN(vec3d1.z)) {
-                int i = MathHelper.floor(vec3d1.x);
-                int j = MathHelper.floor(vec3d1.y);
-                int k = MathHelper.floor(vec3d1.z);
-                int l = MathHelper.floor(vec3d.x);
-                int i1 = MathHelper.floor(vec3d.y);
-                int j1 = MathHelper.floor(vec3d.z);
-                BlockPosition blockposition = new BlockPosition(l, i1, j1);
-                IBlockData iblockdata = this.getType(blockposition);
-                Block block = iblockdata.getBlock();
-
-                if ((!flag1 || iblockdata.d(this, blockposition) != Block.k) && block.a(iblockdata, flag)) {
-                    MovingObjectPosition movingobjectposition = iblockdata.a(this, blockposition, vec3d, vec3d1);
-
-                    if (movingobjectposition != null) {
-                        return movingobjectposition;
-                    }
-                }
-
-                MovingObjectPosition movingobjectposition1 = null;
-                int k1 = 200;
-
-                while (k1-- >= 0) {
-                    if (Double.isNaN(vec3d.x) || Double.isNaN(vec3d.y) || Double.isNaN(vec3d.z)) {
-                        return null;
-                    }
-
-                    if (l == i && i1 == j && j1 == k) {
-                        return flag2 ? movingobjectposition1 : null;
-                    }
-
-                    boolean flag3 = true;
-                    boolean flag4 = true;
-                    boolean flag5 = true;
-                    double d0 = 999.0D;
-                    double d1 = 999.0D;
-                    double d2 = 999.0D;
-
-                    if (i > l) {
-                        d0 = (double) l + 1.0D;
-                    } else if (i < l) {
-                        d0 = (double) l + 0.0D;
-                    } else {
-                        flag3 = false;
-                    }
-
-                    if (j > i1) {
-                        d1 = (double) i1 + 1.0D;
-                    } else if (j < i1) {
-                        d1 = (double) i1 + 0.0D;
-                    } else {
-                        flag4 = false;
-                    }
-
-                    if (k > j1) {
-                        d2 = (double) j1 + 1.0D;
-                    } else if (k < j1) {
-                        d2 = (double) j1 + 0.0D;
-                    } else {
-                        flag5 = false;
-                    }
-
-                    double d3 = 999.0D;
-                    double d4 = 999.0D;
-                    double d5 = 999.0D;
-                    double d6 = vec3d1.x - vec3d.x;
-                    double d7 = vec3d1.y - vec3d.y;
-                    double d8 = vec3d1.z - vec3d.z;
-
-                    if (flag3) {
-                        d3 = (d0 - vec3d.x) / d6;
-                    }
-
-                    if (flag4) {
-                        d4 = (d1 - vec3d.y) / d7;
-                    }
-
-                    if (flag5) {
-                        d5 = (d2 - vec3d.z) / d8;
-                    }
-
-                    if (d3 == -0.0D) {
-                        d3 = -1.0E-4D;
-                    }
-
-                    if (d4 == -0.0D) {
-                        d4 = -1.0E-4D;
-                    }
-
-                    if (d5 == -0.0D) {
-                        d5 = -1.0E-4D;
-                    }
-
-                    EnumDirection enumdirection;
-
-                    if (d3 < d4 && d3 < d5) {
-                        enumdirection = i > l ? EnumDirection.WEST : EnumDirection.EAST;
-                        vec3d = new Vec3D(d0, vec3d.y + d7 * d3, vec3d.z + d8 * d3);
-                    } else if (d4 < d5) {
-                        enumdirection = j > i1 ? EnumDirection.DOWN : EnumDirection.UP;
-                        vec3d = new Vec3D(vec3d.x + d6 * d4, d1, vec3d.z + d8 * d4);
-                    } else {
-                        enumdirection = k > j1 ? EnumDirection.NORTH : EnumDirection.SOUTH;
-                        vec3d = new Vec3D(vec3d.x + d6 * d5, vec3d.y + d7 * d5, d2);
-                    }
-
-                    l = MathHelper.floor(vec3d.x) - (enumdirection == EnumDirection.EAST ? 1 : 0);
-                    i1 = MathHelper.floor(vec3d.y) - (enumdirection == EnumDirection.UP ? 1 : 0);
-                    j1 = MathHelper.floor(vec3d.z) - (enumdirection == EnumDirection.SOUTH ? 1 : 0);
-                    blockposition = new BlockPosition(l, i1, j1);
-                    IBlockData iblockdata1 = this.getType(blockposition);
-                    Block block1 = iblockdata1.getBlock();
-
-                    if (!flag1 || iblockdata1.getMaterial() == Material.PORTAL || iblockdata1.d(this, blockposition) != Block.k) {
-                        if (block1.a(iblockdata1, flag)) {
-                            MovingObjectPosition movingobjectposition2 = iblockdata1.a(this, blockposition, vec3d, vec3d1);
-
-                            if (movingobjectposition2 != null) {
-                                return movingobjectposition2;
-                            }
-                        } else {
-                            movingobjectposition1 = new MovingObjectPosition(MovingObjectPosition.EnumMovingObjectType.MISS, vec3d, enumdirection, blockposition);
-                        }
-                    }
-                }
-
-                return flag2 ? movingobjectposition1 : null;
-            } else {
-                return null;
-            }
-        } else {
-            return null;
-        }
-    }
-
-    public void a(@Nullable EntityHuman entityhuman, BlockPosition blockposition, SoundEffect soundeffect, SoundCategory soundcategory, float f, float f1) {
-        this.a(entityhuman, (double) blockposition.getX() + 0.5D, (double) blockposition.getY() + 0.5D, (double) blockposition.getZ() + 0.5D, soundeffect, soundcategory, f, f1);
-    }
-
-    public void a(@Nullable EntityHuman entityhuman, double d0, double d1, double d2, SoundEffect soundeffect, SoundCategory soundcategory, float f, float f1) {
-        for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).a(entityhuman, soundeffect, soundcategory, d0, d1, d2, f, f1);
-        }
-
-    }
-
-    public void a(double d0, double d1, double d2, SoundEffect soundeffect, SoundCategory soundcategory, float f, float f1, boolean flag) {}
-
-    public void a(BlockPosition blockposition, @Nullable SoundEffect soundeffect) {
-        for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).a(soundeffect, blockposition);
-        }
-
-    }
-
-    public void addParticle(EnumParticle enumparticle, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
-        this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
-    }
-
-    private void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
-        for (int j = 0; j < this.u.size(); ++j) {
-            ((IWorldAccess) this.u.get(j)).a(i, flag, d0, d1, d2, d3, d4, d5, aint);
-        }
-
-    }
-
-    public boolean strikeLightning(Entity entity) {
-        this.j.add(entity);
-        return true;
-    }
-
-    public boolean addEntity(Entity entity) {
-        // CraftBukkit start - Used for entities other than creatures
-        return addEntity(entity, SpawnReason.DEFAULT);
-    }
-
-    public boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
-        org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
-        if (entity == null) return false;
-        // CraftBukkit end
-        int i = MathHelper.floor(entity.locX / 16.0D);
-        int j = MathHelper.floor(entity.locZ / 16.0D);
-        boolean flag = entity.attachedToPlayer;
-
-        if (entity instanceof EntityHuman) {
-            flag = true;
-        }
-
-        // CraftBukkit start
-        org.bukkit.event.Cancellable event = null;
-        if (entity instanceof EntityLiving && !(entity instanceof EntityPlayer)) {
-            boolean isAnimal = entity instanceof EntityAnimal || entity instanceof EntityWaterAnimal || entity instanceof EntityGolem;
-            boolean isMonster = entity instanceof EntityMonster || entity instanceof EntityGhast || entity instanceof EntitySlime;
-
-            if (spawnReason != SpawnReason.CUSTOM) {
-                if (isAnimal && !allowAnimals || isMonster && !allowMonsters) {
-                    entity.dead = true;
-                    return false;
-                }
-            }
-
-            event = CraftEventFactory.callCreatureSpawnEvent((EntityLiving) entity, spawnReason);
-        } else if (entity instanceof EntityItem) {
-            event = CraftEventFactory.callItemSpawnEvent((EntityItem) entity);
-        } else if (entity.getBukkitEntity() instanceof org.bukkit.entity.Projectile) {
-            // Not all projectiles extend EntityProjectile, so check for Bukkit interface instead
-            event = CraftEventFactory.callProjectileLaunchEvent(entity);
-        }
-        // Spigot start
-        else if (entity instanceof EntityExperienceOrb) {
-            EntityExperienceOrb xp = (EntityExperienceOrb) entity;
-            double radius = spigotConfig.expMerge;
-            if (radius > 0) {
-                List<Entity> entities = this.getEntities(entity, entity.getBoundingBox().grow(radius, radius, radius));
-                for (Entity e : entities) {
-                    if (e instanceof EntityExperienceOrb) {
-                        EntityExperienceOrb loopItem = (EntityExperienceOrb) e;
-                        if (!loopItem.dead) {
-                            xp.value += loopItem.value;
-                            loopItem.die();
-                        }
-                    }
-                }
-            }
-        } // Spigot end
-
-        if (event != null && (event.isCancelled() || entity.dead)) {
-            entity.dead = true;
-            return false;
-        }
-        // CraftBukkit end
-
-
-        if (!flag && !this.isChunkLoaded(i, j, false)) {
-            return false;
-        } else {
-            if (entity instanceof EntityHuman) {
-                EntityHuman entityhuman = (EntityHuman) entity;
-
-                this.players.add(entityhuman);
-                this.everyoneSleeping();
-            }
-
-            this.getChunkAt(i, j).a(entity);
-            this.entityList.add(entity);
-            this.b(entity);
-            return true;
-        }
-    }
-
-    protected void b(Entity entity) {
-        for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).a(entity);
-        }
-
-        entity.valid = true; // CraftBukkit
-    }
-
-    protected void c(Entity entity) {
-        for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).b(entity);
-        }
-
-        entity.valid = false; // CraftBukkit
-    }
-
-    public void kill(Entity entity) {
-        if (entity.isVehicle()) {
-            entity.az();
-        }
-
-        if (entity.isPassenger()) {
-            entity.stopRiding();
-        }
-
-        entity.die();
-        if (entity instanceof EntityHuman) {
-            this.players.remove(entity);
-            // Spigot start
-            for ( Object o : worldMaps.c )
-            {
-                if ( o instanceof WorldMap )
-                {
-                    WorldMap map = (WorldMap) o;
-                    map.j.remove( entity );
-                    for ( Iterator<WorldMap.WorldMapHumanTracker> iter = (Iterator<WorldMap.WorldMapHumanTracker>) map.h.iterator(); iter.hasNext(); )
-                    {
-                        if ( iter.next().trackee == entity )
-                        {
-                            iter.remove();
-                        }
-                    }
-                }
-            }
-            // Spigot end
-            this.everyoneSleeping();
-            this.c(entity);
-        }
-
-    }
-
-    public void removeEntity(Entity entity) {
-        org.spigotmc.AsyncCatcher.catchOp( "entity remove"); // Spigot
-        entity.b(false);
-        entity.die();
-        if (entity instanceof EntityHuman) {
-            this.players.remove(entity);
-            this.everyoneSleeping();
-        }
-
-        if (!guardEntityList) { // Spigot - It will get removed after the tick if we are ticking
-        int i = entity.ac;
-        int j = entity.ae;
-
-        if (entity.ab && this.isChunkLoaded(i, j, true)) {
-            this.getChunkAt(i, j).b(entity);
-        }
-
-        // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
-        int index = this.entityList.indexOf(entity);
-        if (index != -1) {
-            if (index <= this.tickPosition) {
-                this.tickPosition--;
-            }
-            this.entityList.remove(index);
-        }
-        // CraftBukkit end
-        } // Spigot
-        this.c(entity);
-    }
-
-    public void addIWorldAccess(IWorldAccess iworldaccess) {
-        this.u.add(iworldaccess);
-    }
-
-    public List<AxisAlignedBB> getCubes(@Nullable Entity entity, AxisAlignedBB axisalignedbb) {
-        ArrayList arraylist = Lists.newArrayList();
-        int i = MathHelper.floor(axisalignedbb.a) - 1;
-        int j = MathHelper.f(axisalignedbb.d) + 1;
-        int k = MathHelper.floor(axisalignedbb.b) - 1;
-        int l = MathHelper.f(axisalignedbb.e) + 1;
-        int i1 = MathHelper.floor(axisalignedbb.c) - 1;
-        int j1 = MathHelper.f(axisalignedbb.f) + 1;
-        WorldBorder worldborder = this.getWorldBorder();
-        boolean flag = entity != null && entity.br();
-        boolean flag1 = entity != null && this.a(worldborder, entity);
-        IBlockData iblockdata = Blocks.STONE.getBlockData();
-        BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
-
-        int k1;
-
-        for (int l1 = i; l1 < j; ++l1) {
-            for (k1 = i1; k1 < j1; ++k1) {
-                int i2 = (l1 != i && l1 != j - 1 ? 0 : 1) + (k1 != i1 && k1 != j1 - 1 ? 0 : 1);
-
-                if (i2 != 2 && this.isLoaded(blockposition_pooledblockposition.f(l1, 64, k1))) {
-                    for (int j2 = k; j2 < l; ++j2) {
-                        if (i2 <= 0 || j2 != k && j2 != l - 1) {
-                            blockposition_pooledblockposition.f(l1, j2, k1);
-                            if (entity != null) {
-                                if (flag && flag1) {
-                                    entity.k(false);
-                                } else if (!flag && !flag1) {
-                                    entity.k(true);
-                                }
-                            }
-
-                            IBlockData iblockdata1 = iblockdata;
-
-                            if (worldborder.a((BlockPosition) blockposition_pooledblockposition) || !flag1) {
-                                iblockdata1 = this.getType(blockposition_pooledblockposition);
-                            }
-
-                            iblockdata1.a(this, blockposition_pooledblockposition, axisalignedbb, arraylist, entity);
-                        }
-                    }
-                }
-            }
-        }
-
-        blockposition_pooledblockposition.t();
-        if (entity != null) {
-            List list = this.getEntities(entity, axisalignedbb.g(0.25D));
-
-            for (k1 = 0; k1 < list.size(); ++k1) {
-                Entity entity1 = (Entity) list.get(k1);
-
-                if (!entity.x(entity1)) {
-                    AxisAlignedBB axisalignedbb1 = entity1.ag();
-
-                    if (axisalignedbb1 != null && axisalignedbb1.b(axisalignedbb)) {
-                        arraylist.add(axisalignedbb1);
-                    }
-
-                    axisalignedbb1 = entity.j(entity1);
-                    if (axisalignedbb1 != null && axisalignedbb1.b(axisalignedbb)) {
-                        arraylist.add(axisalignedbb1);
-                    }
-                }
-            }
-        }
-
-        return arraylist;
-    }
-
-    public boolean a(WorldBorder worldborder, Entity entity) {
-        double d0 = worldborder.b();
-        double d1 = worldborder.c();
-        double d2 = worldborder.d();
-        double d3 = worldborder.e();
-
-        if (entity.br()) {
-            ++d0;
-            ++d1;
-            --d2;
-            --d3;
-        } else {
-            --d0;
-            --d1;
-            ++d2;
-            ++d3;
-        }
-
-        return entity.locX > d0 && entity.locX < d2 && entity.locZ > d1 && entity.locZ < d3;
-    }
-
-    public List<AxisAlignedBB> a(AxisAlignedBB axisalignedbb) {
-        ArrayList arraylist = Lists.newArrayList();
-        int i = MathHelper.floor(axisalignedbb.a) - 1;
-        int j = MathHelper.f(axisalignedbb.d) + 1;
-        int k = MathHelper.floor(axisalignedbb.b) - 1;
-        int l = MathHelper.f(axisalignedbb.e) + 1;
-        int i1 = MathHelper.floor(axisalignedbb.c) - 1;
-        int j1 = MathHelper.f(axisalignedbb.f) + 1;
-        BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
-
-        for (int k1 = i; k1 < j; ++k1) {
-            for (int l1 = i1; l1 < j1; ++l1) {
-                int i2 = (k1 != i && k1 != j - 1 ? 0 : 1) + (l1 != i1 && l1 != j1 - 1 ? 0 : 1);
-
-                if (i2 != 2 && this.isLoaded(blockposition_pooledblockposition.f(k1, 64, l1))) {
-                    for (int j2 = k; j2 < l; ++j2) {
-                        if (i2 <= 0 || j2 != k && j2 != l - 1) {
-                            blockposition_pooledblockposition.f(k1, j2, l1);
-                            IBlockData iblockdata;
-
-                            if (k1 >= -30000000 && k1 < 30000000 && l1 >= -30000000 && l1 < 30000000) {
-                                iblockdata = this.getType(blockposition_pooledblockposition);
-                            } else {
-                                iblockdata = Blocks.BEDROCK.getBlockData();
-                            }
-
-                            iblockdata.a(this, blockposition_pooledblockposition, axisalignedbb, arraylist, (Entity) null);
-                        }
-                    }
-                }
-            }
-        }
-
-        blockposition_pooledblockposition.t();
-        return arraylist;
-    }
-
-    public boolean b(AxisAlignedBB axisalignedbb) {
-        ArrayList arraylist = Lists.newArrayList();
-        int i = MathHelper.floor(axisalignedbb.a) - 1;
-        int j = MathHelper.f(axisalignedbb.d) + 1;
-        int k = MathHelper.floor(axisalignedbb.b) - 1;
-        int l = MathHelper.f(axisalignedbb.e) + 1;
-        int i1 = MathHelper.floor(axisalignedbb.c) - 1;
-        int j1 = MathHelper.f(axisalignedbb.f) + 1;
-        BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
-
-        try {
-            for (int k1 = i; k1 < j; ++k1) {
-                for (int l1 = i1; l1 < j1; ++l1) {
-                    int i2 = (k1 != i && k1 != j - 1 ? 0 : 1) + (l1 != i1 && l1 != j1 - 1 ? 0 : 1);
-
-                    if (i2 != 2 && this.isLoaded(blockposition_pooledblockposition.f(k1, 64, l1))) {
-                        for (int j2 = k; j2 < l; ++j2) {
-                            if (i2 <= 0 || j2 != k && j2 != l - 1) {
-                                blockposition_pooledblockposition.f(k1, j2, l1);
-                                if (k1 < -30000000 || k1 >= 30000000 || l1 < -30000000 || l1 >= 30000000) {
-                                    boolean flag = true;
-
-                                    return flag;
-                                }
-
-                                IBlockData iblockdata = this.getType(blockposition_pooledblockposition);
-
-                                iblockdata.a(this, blockposition_pooledblockposition, axisalignedbb, arraylist, (Entity) null);
-                                if (!arraylist.isEmpty()) {
-                                    boolean flag1 = true;
-
-                                    return flag1;
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-
-            return false;
-        } finally {
-            blockposition_pooledblockposition.t();
-        }
-    }
-
-    public int a(float f) {
-        float f1 = this.c(f);
-        float f2 = 1.0F - (MathHelper.cos(f1 * 6.2831855F) * 2.0F + 0.5F);
-
-        f2 = MathHelper.a(f2, 0.0F, 1.0F);
-        f2 = 1.0F - f2;
-        f2 = (float) ((double) f2 * (1.0D - (double) (this.j(f) * 5.0F) / 16.0D));
-        f2 = (float) ((double) f2 * (1.0D - (double) (this.h(f) * 5.0F) / 16.0D));
-        f2 = 1.0F - f2;
-        return (int) (f2 * 11.0F);
-    }
-
-    public float c(float f) {
-        return this.worldProvider.a(this.worldData.getDayTime(), f);
-    }
-
-    public float E() {
-        return WorldProvider.a[this.worldProvider.a(this.worldData.getDayTime())];
-    }
-
-    public float d(float f) {
-        float f1 = this.c(f);
-
-        return f1 * 6.2831855F;
-    }
-
-    public BlockPosition p(BlockPosition blockposition) {
-        return this.getChunkAtWorldCoords(blockposition).f(blockposition);
-    }
-
-    public BlockPosition q(BlockPosition blockposition) {
-        Chunk chunk = this.getChunkAtWorldCoords(blockposition);
-
-        BlockPosition blockposition1;
-        BlockPosition blockposition2;
-
-        for (blockposition1 = new BlockPosition(blockposition.getX(), chunk.g() + 16, blockposition.getZ()); blockposition1.getY() >= 0; blockposition1 = blockposition2) {
-            blockposition2 = blockposition1.down();
-            Material material = chunk.getBlockData(blockposition2).getMaterial();
-
-            if (material.isSolid() && material != Material.LEAVES) {
-                break;
-            }
-        }
-
-        return blockposition1;
-    }
-
-    public boolean b(BlockPosition blockposition, Block block) {
-        return true;
-    }
-
-    public void a(BlockPosition blockposition, Block block, int i) {}
-
-    public void a(BlockPosition blockposition, Block block, int i, int j) {}
-
-    public void b(BlockPosition blockposition, Block block, int i, int j) {}
-
-    public void tickEntities() {
-        this.methodProfiler.a("entities");
-        this.methodProfiler.a("global");
-
-        int i;
-        Entity entity;
-
-        for (i = 0; i < this.j.size(); ++i) {
-            entity = (Entity) this.j.get(i);
-            // CraftBukkit start - Fixed an NPE
-            if (entity == null) {
-                continue;
-            }
-            // CraftBukkit end
-
-            try {
-                ++entity.ticksLived;
-                entity.m();
-            } catch (Throwable throwable) {
-                CrashReport crashreport = CrashReport.a(throwable, "Ticking entity");
-                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being ticked");
-
-                if (entity == null) {
-                    crashreportsystemdetails.a("Entity", (Object) "~~NULL~~");
-                } else {
-                    entity.appendEntityCrashDetails(crashreportsystemdetails);
-                }
-
-                throw new ReportedException(crashreport);
-            }
-
-            if (entity.dead) {
-                this.j.remove(i--);
-            }
-        }
-
-        this.methodProfiler.c("remove");
-        this.entityList.removeAll(this.f);
-
-        int j;
-
-        for (i = 0; i < this.f.size(); ++i) {
-            entity = (Entity) this.f.get(i);
-            int k = entity.ac;
-
-            j = entity.ae;
-            if (entity.ab && this.isChunkLoaded(k, j, true)) {
-                this.getChunkAt(k, j).b(entity);
-            }
-        }
-
-        for (i = 0; i < this.f.size(); ++i) {
-            this.c((Entity) this.f.get(i));
-        }
-
-        this.f.clear();
-        this.l();
-        this.methodProfiler.c("regular");
-
-        CrashReportSystemDetails crashreportsystemdetails1;
-        CrashReport crashreport1;
-
-        org.spigotmc.ActivationRange.activateEntities(this); // Spigot
-        timings.entityTick.startTiming(); // Spigot
-        guardEntityList = true; // Spigot
-        // CraftBukkit start - Use field for loop variable
-        int entitiesThisCycle = 0;
-        if (tickPosition < 0) tickPosition = 0;
-        for (entityLimiter.initTick();
-                entitiesThisCycle < entityList.size() && (entitiesThisCycle % 10 != 0 || entityLimiter.shouldContinue());
-                tickPosition++, entitiesThisCycle++) {
-            tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
-            entity = (Entity) this.entityList.get(this.tickPosition);
-            // CraftBukkit end
-            Entity entity1 = entity.bB();
-
-            if (entity1 != null) {
-                if (!entity1.dead && entity1.w(entity)) {
-                    continue;
-                }
-
-                entity.stopRiding();
-            }
-
-            this.methodProfiler.a("tick");
-            if (!entity.dead && !(entity instanceof EntityPlayer)) {
-                try {
-                    SpigotTimings.tickEntityTimer.startTiming(); // Spigot
-                    this.g(entity);
-                    SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
-                } catch (Throwable throwable1) {
-                    crashreport1 = CrashReport.a(throwable1, "Ticking entity");
-                    crashreportsystemdetails1 = crashreport1.a("Entity being ticked");
-                    entity.appendEntityCrashDetails(crashreportsystemdetails1);
-                    throw new ReportedException(crashreport1);
-                }
-            }
-
-            this.methodProfiler.b();
-            this.methodProfiler.a("remove");
-            if (entity.dead) {
-                j = entity.ac;
-                int l = entity.ae;
-
-                if (entity.ab && this.isChunkLoaded(j, l, true)) {
-                    this.getChunkAt(j, l).b(entity);
-                }
-
-                guardEntityList = false; // Spigot
-                this.entityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
-                guardEntityList = true; // Spigot
-                this.c(entity);
-            }
-
-            this.methodProfiler.b();
-        }
-        guardEntityList = false; // Spigot
-
-        timings.entityTick.stopTiming(); // Spigot
-        this.methodProfiler.c("blockEntities");
-        this.M = true;
-        timings.tileEntityTick.startTiming(); // Spigot
-        // CraftBukkit start - From below, clean up tile entities before ticking them
-        if (!this.tileEntityListUnload.isEmpty()) {
-            this.tileEntityListTick.removeAll(this.tileEntityListUnload);
-            this.tileEntityList.removeAll(this.tileEntityListUnload);
-            this.tileEntityListUnload.clear();
-        }
-        // CraftBukkit end
-
-        // Spigot start
-        // Iterator iterator = this.tileEntityListTick.iterator();
-        int tilesThisCycle = 0;
-        for (tileLimiter.initTick();
-                tilesThisCycle < tileEntityListTick.size() && (tilesThisCycle % 10 != 0 || tileLimiter.shouldContinue());
-                tileTickPosition++, tilesThisCycle++) {
-            tileTickPosition = (tileTickPosition < tileEntityListTick.size()) ? tileTickPosition : 0;
-            TileEntity tileentity = (TileEntity) this.tileEntityListTick.get(tileTickPosition);
-            // Spigot start
-            if (tileentity == null) {
-                getServer().getLogger().severe("Spigot has detected a null entity and has removed it, preventing a crash");
-                tilesThisCycle--;
-                this.tileEntityListTick.remove(tileTickPosition--);
-                continue;
-            }
-            // Spigot end
-
-            if (!tileentity.x() && tileentity.t()) {
-                BlockPosition blockposition = tileentity.getPosition();
-
-                if (this.isLoaded(blockposition) && this.N.a(blockposition)) {
-                    try {
-                        this.methodProfiler.a(""/*tileentity.getClass().getSimpleName()*/); // CraftBukkit: SPIGOT-1900
-                        tileentity.tickTimer.startTiming(); // Spigot
-                        ((ITickable) tileentity).E_();
-                        this.methodProfiler.b();
-                    } catch (Throwable throwable2) {
-                        crashreport1 = CrashReport.a(throwable2, "Ticking block entity");
-                        crashreportsystemdetails1 = crashreport1.a("Block entity being ticked");
-                        tileentity.a(crashreportsystemdetails1);
-                        throw new ReportedException(crashreport1);
-                    }
-                    // Spigot start
-                    finally {
-                        tileentity.tickTimer.stopTiming();
-                    }
-                    // Spigot end
-                }
-            }
-
-            if (tileentity.x()) {
-                tilesThisCycle--;
-                this.tileEntityListTick.remove(tileTickPosition--);
-                this.tileEntityList.remove(tileentity);
-                if (this.isLoaded(tileentity.getPosition())) {
-                    this.getChunkAtWorldCoords(tileentity.getPosition()).d(tileentity.getPosition());
-                }
-            }
-        }
-
-        timings.tileEntityTick.stopTiming(); // Spigot
-        timings.tileEntityPending.startTiming(); // Spigot
-        this.M = false;
-        /* CraftBukkit start - Moved up
-        if (!this.tileEntityListUnload.isEmpty()) {
-            this.tileEntityListTick.removeAll(this.tileEntityListUnload);
-            this.tileEntityList.removeAll(this.tileEntityListUnload);
-            this.tileEntityListUnload.clear();
-        }
-        // CraftBukkit end */
-
-        this.methodProfiler.c("pendingBlockEntities");
-        if (!this.b.isEmpty()) {
-            for (int i1 = 0; i1 < this.b.size(); ++i1) {
-                TileEntity tileentity1 = (TileEntity) this.b.get(i1);
-
-                if (!tileentity1.x()) {
-                    /* CraftBukkit start - Order matters, moved down
-                    if (!this.tileEntityList.contains(tileentity1)) {
-                        this.a(tileentity1);
-                    }
-                    // CraftBukkit end */
-
-                    if (this.isLoaded(tileentity1.getPosition())) {
-                        Chunk chunk = this.getChunkAtWorldCoords(tileentity1.getPosition());
-                        IBlockData iblockdata = chunk.getBlockData(tileentity1.getPosition());
-
-                        chunk.a(tileentity1.getPosition(), tileentity1);
-                        this.notify(tileentity1.getPosition(), iblockdata, iblockdata, 3);
-                        // CraftBukkit start
-                        // From above, don't screw this up - SPIGOT-1746
-                        if (!this.tileEntityList.contains(tileentity1)) {
-                            this.a(tileentity1);
-                        }
-                        // CraftBukkit end
-                    }
-                }
-            }
-
-            this.b.clear();
-        }
-
-        timings.tileEntityPending.stopTiming(); // Spigot
-        this.methodProfiler.b();
-        this.methodProfiler.b();
-    }
-
-    protected void l() {}
-
-    public boolean a(TileEntity tileentity) {
-        boolean flag = this.tileEntityList.add(tileentity);
-
-        if (flag && tileentity instanceof ITickable) {
-            this.tileEntityListTick.add(tileentity);
-        }
-
-        if (this.isClientSide) {
-            BlockPosition blockposition = tileentity.getPosition();
-            IBlockData iblockdata = this.getType(blockposition);
-
-            this.notify(blockposition, iblockdata, iblockdata, 2);
-        }
-
-        return flag;
-    }
-
-    public void b(Collection<TileEntity> collection) {
-        if (this.M) {
-            this.b.addAll(collection);
-        } else {
-            Iterator iterator = collection.iterator();
-
-            while (iterator.hasNext()) {
-                TileEntity tileentity = (TileEntity) iterator.next();
-
-                this.a(tileentity);
-            }
-        }
-
-    }
-
-    public void g(Entity entity) {
-        this.entityJoinedWorld(entity, true);
-    }
-
-    public void entityJoinedWorld(Entity entity, boolean flag) {
-        int i = MathHelper.floor(entity.locX);
-        int j = MathHelper.floor(entity.locZ);
-        boolean flag1 = true;
-
-        // Spigot start
-        if (flag && !org.spigotmc.ActivationRange.checkIfActive(entity)) {
-            entity.ticksLived++;
-            entity.inactiveTick();
-        } else {
-            entity.tickTimer.startTiming(); // Spigot
-            // CraftBukkit end
-            entity.M = entity.locX;
-            entity.N = entity.locY;
-            entity.O = entity.locZ;
-            entity.lastYaw = entity.yaw;
-            entity.lastPitch = entity.pitch;
-            if (flag && entity.ab) {
-                ++entity.ticksLived;
-                if (entity.isPassenger()) {
-                    entity.aw();
-                } else {
-                    entity.m();
-                }
-            }
-
-            this.methodProfiler.a("chunkCheck");
-            if (Double.isNaN(entity.locX) || Double.isInfinite(entity.locX)) {
-                entity.locX = entity.M;
-            }
-
-            if (Double.isNaN(entity.locY) || Double.isInfinite(entity.locY)) {
-                entity.locY = entity.N;
-            }
-
-            if (Double.isNaN(entity.locZ) || Double.isInfinite(entity.locZ)) {
-                entity.locZ = entity.O;
-            }
-
-            if (Double.isNaN((double) entity.pitch) || Double.isInfinite((double) entity.pitch)) {
-                entity.pitch = entity.lastPitch;
-            }
-
-            if (Double.isNaN((double) entity.yaw) || Double.isInfinite((double) entity.yaw)) {
-                entity.yaw = entity.lastYaw;
-            }
-
-            int k = MathHelper.floor(entity.locX / 16.0D);
-            int l = MathHelper.floor(entity.locY / 16.0D);
-            int i1 = MathHelper.floor(entity.locZ / 16.0D);
-
-            if (!entity.ab || entity.ac != k || entity.ad != l || entity.ae != i1) {
-                if (entity.ab && this.isChunkLoaded(entity.ac, entity.ae, true)) {
-                    this.getChunkAt(entity.ac, entity.ae).a(entity, entity.ad);
-                }
-
-                if (!entity.bv() && !this.isChunkLoaded(k, i1, true)) {
-                    entity.ab = false;
-                } else {
-                    this.getChunkAt(k, i1).a(entity);
-                }
-            }
-
-            this.methodProfiler.b();
-            if (flag && entity.ab) {
-                Iterator iterator = entity.bx().iterator();
-
-                while (iterator.hasNext()) {
-                    Entity entity1 = (Entity) iterator.next();
-
-                    if (!entity1.dead && entity1.bB() == entity) {
-                        this.g(entity1);
-                    } else {
-                        entity1.stopRiding();
-                    }
-                }
-            }
-
-            entity.tickTimer.stopTiming(); // Spigot
-        }
-    }
-
-    public boolean c(AxisAlignedBB axisalignedbb) {
-        return this.a(axisalignedbb, (Entity) null);
-    }
-
-    public boolean a(AxisAlignedBB axisalignedbb, @Nullable Entity entity) {
-        List list = this.getEntities((Entity) null, axisalignedbb);
-
-        for (int i = 0; i < list.size(); ++i) {
-            Entity entity1 = (Entity) list.get(i);
-
-            if (!entity1.dead && entity1.i && entity1 != entity && (entity == null || entity1.x(entity))) {
-                return false;
-            }
-        }
-
-        return true;
-    }
-
-    public boolean d(AxisAlignedBB axisalignedbb) {
-        int i = MathHelper.floor(axisalignedbb.a);
-        int j = MathHelper.f(axisalignedbb.d);
-        int k = MathHelper.floor(axisalignedbb.b);
-        int l = MathHelper.f(axisalignedbb.e);
-        int i1 = MathHelper.floor(axisalignedbb.c);
-        int j1 = MathHelper.f(axisalignedbb.f);
-        BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
-
-        for (int k1 = i; k1 < j; ++k1) {
-            for (int l1 = k; l1 < l; ++l1) {
-                for (int i2 = i1; i2 < j1; ++i2) {
-                    IBlockData iblockdata = this.getType(blockposition_pooledblockposition.f(k1, l1, i2));
-
-                    if (iblockdata.getMaterial() != Material.AIR) {
-                        blockposition_pooledblockposition.t();
-                        return true;
-                    }
-                }
-            }
-        }
-
-        blockposition_pooledblockposition.t();
-        return false;
-    }
-
-    public boolean containsLiquid(AxisAlignedBB axisalignedbb) {
-        int i = MathHelper.floor(axisalignedbb.a);
-        int j = MathHelper.f(axisalignedbb.d);
-        int k = MathHelper.floor(axisalignedbb.b);
-        int l = MathHelper.f(axisalignedbb.e);
-        int i1 = MathHelper.floor(axisalignedbb.c);
-        int j1 = MathHelper.f(axisalignedbb.f);
-        BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
-
-        for (int k1 = i; k1 < j; ++k1) {
-            for (int l1 = k; l1 < l; ++l1) {
-                for (int i2 = i1; i2 < j1; ++i2) {
-                    IBlockData iblockdata = this.getType(blockposition_pooledblockposition.f(k1, l1, i2));
-
-                    if (iblockdata.getMaterial().isLiquid()) {
-                        blockposition_pooledblockposition.t();
-                        return true;
-                    }
-                }
-            }
-        }
-
-        blockposition_pooledblockposition.t();
-        return false;
-    }
-
-    public boolean f(AxisAlignedBB axisalignedbb) {
-        int i = MathHelper.floor(axisalignedbb.a);
-        int j = MathHelper.f(axisalignedbb.d);
-        int k = MathHelper.floor(axisalignedbb.b);
-        int l = MathHelper.f(axisalignedbb.e);
-        int i1 = MathHelper.floor(axisalignedbb.c);
-        int j1 = MathHelper.f(axisalignedbb.f);
-
-        if (this.isAreaLoaded(i, k, i1, j, l, j1, true)) {
-            BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
-            int k1 = i;
-
-            while (true) {
-                if (k1 >= j) {
-                    blockposition_pooledblockposition.t();
-                    break;
-                }
-
-                for (int l1 = k; l1 < l; ++l1) {
-                    for (int i2 = i1; i2 < j1; ++i2) {
-                        Block block = this.getType(blockposition_pooledblockposition.f(k1, l1, i2)).getBlock();
-
-                        if (block == Blocks.FIRE || block == Blocks.FLOWING_LAVA || block == Blocks.LAVA) {
-                            blockposition_pooledblockposition.t();
-                            return true;
-                        }
-                    }
-                }
-
-                ++k1;
-            }
-        }
-
-        return false;
-    }
-
-    public boolean a(AxisAlignedBB axisalignedbb, Material material, Entity entity) {
-        int i = MathHelper.floor(axisalignedbb.a);
-        int j = MathHelper.f(axisalignedbb.d);
-        int k = MathHelper.floor(axisalignedbb.b);
-        int l = MathHelper.f(axisalignedbb.e);
-        int i1 = MathHelper.floor(axisalignedbb.c);
-        int j1 = MathHelper.f(axisalignedbb.f);
-
-        if (!this.isAreaLoaded(i, k, i1, j, l, j1, true)) {
-            return false;
-        } else {
-            boolean flag = false;
-            Vec3D vec3d = Vec3D.a;
-            BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
-
-            for (int k1 = i; k1 < j; ++k1) {
-                for (int l1 = k; l1 < l; ++l1) {
-                    for (int i2 = i1; i2 < j1; ++i2) {
-                        blockposition_pooledblockposition.f(k1, l1, i2);
-                        IBlockData iblockdata = this.getType(blockposition_pooledblockposition);
-                        Block block = iblockdata.getBlock();
-
-                        if (iblockdata.getMaterial() == material) {
-                            double d0 = (double) ((float) (l1 + 1) - BlockFluids.e(((Integer) iblockdata.get(BlockFluids.LEVEL)).intValue()));
-
-                            if ((double) l >= d0) {
-                                flag = true;
-                                vec3d = block.a(this, (BlockPosition) blockposition_pooledblockposition, entity, vec3d);
-                            }
-                        }
-                    }
-                }
-            }
-
-            blockposition_pooledblockposition.t();
-            if (vec3d.b() > 0.0D && entity.bg()) {
-                vec3d = vec3d.a();
-                double d1 = 0.014D;
-
-                entity.motX += vec3d.x * 0.014D;
-                entity.motY += vec3d.y * 0.014D;
-                entity.motZ += vec3d.z * 0.014D;
-            }
-
-            return flag;
-        }
-    }
-
-    public boolean a(AxisAlignedBB axisalignedbb, Material material) {
-        int i = MathHelper.floor(axisalignedbb.a);
-        int j = MathHelper.f(axisalignedbb.d);
-        int k = MathHelper.floor(axisalignedbb.b);
-        int l = MathHelper.f(axisalignedbb.e);
-        int i1 = MathHelper.floor(axisalignedbb.c);
-        int j1 = MathHelper.f(axisalignedbb.f);
-        BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
-
-        for (int k1 = i; k1 < j; ++k1) {
-            for (int l1 = k; l1 < l; ++l1) {
-                for (int i2 = i1; i2 < j1; ++i2) {
-                    if (this.getType(blockposition_pooledblockposition.f(k1, l1, i2)).getMaterial() == material) {
-                        blockposition_pooledblockposition.t();
-                        return true;
-                    }
-                }
-            }
-        }
-
-        blockposition_pooledblockposition.t();
-        return false;
-    }
-
-    public boolean b(AxisAlignedBB axisalignedbb, Material material) {
-        int i = MathHelper.floor(axisalignedbb.a);
-        int j = MathHelper.f(axisalignedbb.d);
-        int k = MathHelper.floor(axisalignedbb.b);
-        int l = MathHelper.f(axisalignedbb.e);
-        int i1 = MathHelper.floor(axisalignedbb.c);
-        int j1 = MathHelper.f(axisalignedbb.f);
-        BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
-
-        for (int k1 = i; k1 < j; ++k1) {
-            for (int l1 = k; l1 < l; ++l1) {
-                for (int i2 = i1; i2 < j1; ++i2) {
-                    IBlockData iblockdata = this.getType(blockposition_pooledblockposition.f(k1, l1, i2));
-
-                    if (iblockdata.getMaterial() == material) {
-                        int j2 = ((Integer) iblockdata.get(BlockFluids.LEVEL)).intValue();
-                        double d0 = (double) (l1 + 1);
-
-                        if (j2 < 8) {
-                            d0 = (double) (l1 + 1) - (double) j2 / 8.0D;
-                        }
-
-                        if (d0 >= axisalignedbb.b) {
-                            blockposition_pooledblockposition.t();
-                            return true;
-                        }
-                    }
-                }
-            }
-        }
-
-        blockposition_pooledblockposition.t();
-        return false;
-    }
-
-    public Explosion explode(@Nullable Entity entity, double d0, double d1, double d2, float f, boolean flag) {
-        return this.createExplosion(entity, d0, d1, d2, f, false, flag);
-    }
-
-    public Explosion createExplosion(@Nullable Entity entity, double d0, double d1, double d2, float f, boolean flag, boolean flag1) {
-        Explosion explosion = new Explosion(this, entity, d0, d1, d2, f, flag, flag1);
-
-        explosion.a();
-        explosion.a(true);
-        return explosion;
-    }
-
-    public float a(Vec3D vec3d, AxisAlignedBB axisalignedbb) {
-        double d0 = 1.0D / ((axisalignedbb.d - axisalignedbb.a) * 2.0D + 1.0D);
-        double d1 = 1.0D / ((axisalignedbb.e - axisalignedbb.b) * 2.0D + 1.0D);
-        double d2 = 1.0D / ((axisalignedbb.f - axisalignedbb.c) * 2.0D + 1.0D);
-        double d3 = (1.0D - Math.floor(1.0D / d0) * d0) / 2.0D;
-        double d4 = (1.0D - Math.floor(1.0D / d2) * d2) / 2.0D;
-
-        if (d0 >= 0.0D && d1 >= 0.0D && d2 >= 0.0D) {
-            int i = 0;
-            int j = 0;
-
-            for (float f = 0.0F; f <= 1.0F; f = (float) ((double) f + d0)) {
-                for (float f1 = 0.0F; f1 <= 1.0F; f1 = (float) ((double) f1 + d1)) {
-                    for (float f2 = 0.0F; f2 <= 1.0F; f2 = (float) ((double) f2 + d2)) {
-                        double d5 = axisalignedbb.a + (axisalignedbb.d - axisalignedbb.a) * (double) f;
-                        double d6 = axisalignedbb.b + (axisalignedbb.e - axisalignedbb.b) * (double) f1;
-                        double d7 = axisalignedbb.c + (axisalignedbb.f - axisalignedbb.c) * (double) f2;
-
-                        if (this.rayTrace(new Vec3D(d5 + d3, d6, d7 + d4), vec3d) == null) {
-                            ++i;
-                        }
-
-                        ++j;
-                    }
-                }
-            }
-
-            return (float) i / (float) j;
-        } else {
-            return 0.0F;
-        }
-    }
-
-    public boolean douseFire(@Nullable EntityHuman entityhuman, BlockPosition blockposition, EnumDirection enumdirection) {
-        blockposition = blockposition.shift(enumdirection);
-        if (this.getType(blockposition).getBlock() == Blocks.FIRE) {
-            this.a(entityhuman, 1009, blockposition, 0);
-            this.setAir(blockposition);
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    public Map<BlockPosition, TileEntity> capturedTileEntities = Maps.newHashMap();
-    @Nullable
-    public TileEntity getTileEntity(BlockPosition blockposition) {
-        if (this.E(blockposition)) {
-            return null;
-        } else {
-            // CraftBukkit start
-            if (capturedTileEntities.containsKey(blockposition)) {
-                return capturedTileEntities.get(blockposition);
-            }
-            // CraftBukkit end
-
-            TileEntity tileentity = null;
-
-            if (this.M) {
-                tileentity = this.F(blockposition);
-            }
-
-            if (tileentity == null) {
-                tileentity = this.getChunkAtWorldCoords(blockposition).a(blockposition, Chunk.EnumTileEntityState.IMMEDIATE);
-            }
-
-            if (tileentity == null) {
-                tileentity = this.F(blockposition);
-            }
-
-            return tileentity;
-        }
-    }
-
-    @Nullable
-    private TileEntity F(BlockPosition blockposition) {
-        for (int i = 0; i < this.b.size(); ++i) {
-            TileEntity tileentity = (TileEntity) this.b.get(i);
-
-            if (!tileentity.x() && tileentity.getPosition().equals(blockposition)) {
-                return tileentity;
-            }
-        }
-
-        return null;
-    }
-
-    public void setTileEntity(BlockPosition blockposition, @Nullable TileEntity tileentity) {
-        if (!this.E(blockposition)) {
-            if (tileentity != null && !tileentity.x()) {
-            // CraftBukkit start
-            if (captureBlockStates) {
-                tileentity.a(this);
-                tileentity.setPosition(blockposition);
-                capturedTileEntities.put(blockposition, tileentity);
-                return;
-            }
-            // CraftBukkit end
-                if (this.M) {
-                    tileentity.setPosition(blockposition);
-                    Iterator iterator = this.b.iterator();
-
-                    while (iterator.hasNext()) {
-                        TileEntity tileentity1 = (TileEntity) iterator.next();
-
-                        if (tileentity1.getPosition().equals(blockposition)) {
-                            tileentity1.y();
-                            iterator.remove();
-                        }
-                    }
-
-                    tileentity.a(this); // Spigot - No null worlds
-                    this.b.add(tileentity);
-                } else {
-                    this.a(tileentity);
-                    this.getChunkAtWorldCoords(blockposition).a(blockposition, tileentity);
-                }
-            }
-
-        }
-    }
-
-    public void s(BlockPosition blockposition) {
-        TileEntity tileentity = this.getTileEntity(blockposition);
-
-        if (tileentity != null && this.M) {
-            tileentity.y();
-            this.b.remove(tileentity);
-        } else {
-            if (tileentity != null) {
-                this.b.remove(tileentity);
-                this.tileEntityList.remove(tileentity);
-                this.tileEntityListTick.remove(tileentity);
-            }
-
-            this.getChunkAtWorldCoords(blockposition).d(blockposition);
-        }
-
-    }
-
-    public void b(TileEntity tileentity) {
-        this.tileEntityListUnload.add(tileentity);
-    }
-
-    public boolean t(BlockPosition blockposition) {
-        AxisAlignedBB axisalignedbb = this.getType(blockposition).d(this, blockposition);
-
-        return axisalignedbb != Block.k && axisalignedbb.a() >= 1.0D;
-    }
-
-    public boolean d(BlockPosition blockposition, boolean flag) {
-        if (this.E(blockposition)) {
-            return false;
-        } else {
-            Chunk chunk = this.chunkProvider.getLoadedChunkAt(blockposition.getX() >> 4, blockposition.getZ() >> 4);
-
-            if (chunk != null && !chunk.isEmpty()) {
-                IBlockData iblockdata = this.getType(blockposition);
-
-                return iblockdata.getMaterial().k() && iblockdata.h();
-            } else {
-                return flag;
-            }
-        }
-    }
-
-    public void H() {
-        int i = this.a(1.0F);
-
-        if (i != this.J) {
-            this.J = i;
-        }
-
-    }
-
-    public void setSpawnFlags(boolean flag, boolean flag1) {
-        this.allowMonsters = flag;
-        this.allowAnimals = flag1;
-    }
-
-    public void doTick() {
-        this.t();
-    }
-
-    protected void I() {
-        if (this.worldData.hasStorm()) {
-            this.o = 1.0F;
-            if (this.worldData.isThundering()) {
-                this.q = 1.0F;
-            }
-        }
-
-    }
-
-    protected void t() {
-        if (!this.worldProvider.m()) {
-            if (!this.isClientSide) {
-                int i = this.worldData.z();
-
-                if (i > 0) {
-                    --i;
-                    this.worldData.i(i);
-                    this.worldData.setThunderDuration(this.worldData.isThundering() ? 1 : 2);
-                    this.worldData.setWeatherDuration(this.worldData.hasStorm() ? 1 : 2);
-                }
-
-                int j = this.worldData.getThunderDuration();
-
-                if (j <= 0) {
-                    if (this.worldData.isThundering()) {
-                        this.worldData.setThunderDuration(this.random.nextInt(12000) + 3600);
-                    } else {
-                        this.worldData.setThunderDuration(this.random.nextInt(168000) + 12000);
-                    }
-                } else {
-                    --j;
-                    this.worldData.setThunderDuration(j);
-                    if (j <= 0) {
-                        this.worldData.setThundering(!this.worldData.isThundering());
-                    }
-                }
-
-                this.p = this.q;
-                if (this.worldData.isThundering()) {
-                    this.q = (float) ((double) this.q + 0.01D);
-                } else {
-                    this.q = (float) ((double) this.q - 0.01D);
-                }
-
-                this.q = MathHelper.a(this.q, 0.0F, 1.0F);
-                int k = this.worldData.getWeatherDuration();
-
-                if (k <= 0) {
-                    if (this.worldData.hasStorm()) {
-                        this.worldData.setWeatherDuration(this.random.nextInt(12000) + 12000);
-                    } else {
-                        this.worldData.setWeatherDuration(this.random.nextInt(168000) + 12000);
-                    }
-                } else {
-                    --k;
-                    this.worldData.setWeatherDuration(k);
-                    if (k <= 0) {
-                        this.worldData.setStorm(!this.worldData.hasStorm());
-                    }
-                }
-
-                this.n = this.o;
-                if (this.worldData.hasStorm()) {
-                    this.o = (float) ((double) this.o + 0.01D);
-                } else {
-                    this.o = (float) ((double) this.o - 0.01D);
-                }
-
-                this.o = MathHelper.a(this.o, 0.0F, 1.0F);
-
-                // CraftBukkit start
-                for (int idx = 0; idx < this.players.size(); ++idx) {
-                    if (((EntityPlayer) this.players.get(idx)).world == this) {
-                        ((EntityPlayer) this.players.get(idx)).tickWeather();
-                    }
-                }
-                // CraftBukkit end
-            }
-        }
-    }
-
-    protected void j() {}
-
-    public void a(BlockPosition blockposition, IBlockData iblockdata, Random random) {
-        this.d = true;
-        iblockdata.getBlock().b(this, blockposition, iblockdata, random);
-        this.d = false;
-    }
-
-    public boolean u(BlockPosition blockposition) {
-        return this.e(blockposition, false);
-    }
-
-    public boolean v(BlockPosition blockposition) {
-        return this.e(blockposition, true);
-    }
-
-    public boolean e(BlockPosition blockposition, boolean flag) {
-        BiomeBase biomebase = this.getBiome(blockposition);
-        float f = biomebase.a(blockposition);
-
-        if (f > 0.15F) {
-            return false;
-        } else {
-            if (blockposition.getY() >= 0 && blockposition.getY() < 256 && this.b(EnumSkyBlock.BLOCK, blockposition) < 10) {
-                IBlockData iblockdata = this.getType(blockposition);
-                Block block = iblockdata.getBlock();
-
-                if ((block == Blocks.WATER || block == Blocks.FLOWING_WATER) && ((Integer) iblockdata.get(BlockFluids.LEVEL)).intValue() == 0) {
-                    if (!flag) {
-                        return true;
-                    }
-
-                    boolean flag1 = this.G(blockposition.west()) && this.G(blockposition.east()) && this.G(blockposition.north()) && this.G(blockposition.south());
-
-                    if (!flag1) {
-                        return true;
-                    }
-                }
-            }
-
-            return false;
-        }
-    }
-
-    private boolean G(BlockPosition blockposition) {
-        return this.getType(blockposition).getMaterial() == Material.WATER;
-    }
-
-    public boolean f(BlockPosition blockposition, boolean flag) {
-        BiomeBase biomebase = this.getBiome(blockposition);
-        float f = biomebase.a(blockposition);
-
-        if (f > 0.15F) {
-            return false;
-        } else if (!flag) {
-            return true;
-        } else {
-            if (blockposition.getY() >= 0 && blockposition.getY() < 256 && this.b(EnumSkyBlock.BLOCK, blockposition) < 10) {
-                IBlockData iblockdata = this.getType(blockposition);
-
-                if (iblockdata.getMaterial() == Material.AIR && Blocks.SNOW_LAYER.canPlace(this, blockposition)) {
-                    return true;
-                }
-            }
-
-            return false;
-        }
-    }
-
-    public boolean w(BlockPosition blockposition) {
-        boolean flag = false;
-
-        if (!this.worldProvider.m()) {
-            flag |= this.c(EnumSkyBlock.SKY, blockposition);
-        }
-
-        flag |= this.c(EnumSkyBlock.BLOCK, blockposition);
-        return flag;
-    }
-
-    private int a(BlockPosition blockposition, EnumSkyBlock enumskyblock) {
-        if (enumskyblock == EnumSkyBlock.SKY && this.h(blockposition)) {
-            return 15;
-        } else {
-            IBlockData iblockdata = this.getType(blockposition);
-            int i = enumskyblock == EnumSkyBlock.SKY ? 0 : iblockdata.d();
-            int j = iblockdata.c();
-
-            if (j >= 15 && iblockdata.d() > 0) {
-                j = 1;
-            }
-
-            if (j < 1) {
-                j = 1;
-            }
-
-            if (j >= 15) {
-                return 0;
-            } else if (i >= 14) {
-                return i;
-            } else {
-                BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
-                EnumDirection[] aenumdirection = EnumDirection.values();
-                int k = aenumdirection.length;
-
-                for (int l = 0; l < k; ++l) {
-                    EnumDirection enumdirection = aenumdirection[l];
-
-                    blockposition_pooledblockposition.j(blockposition).d(enumdirection);
-                    int i1 = this.b(enumskyblock, (BlockPosition) blockposition_pooledblockposition) - j;
-
-                    if (i1 > i) {
-                        i = i1;
-                    }
-
-                    if (i >= 14) {
-                        return i;
-                    }
-                }
-
-                blockposition_pooledblockposition.t();
-                return i;
-            }
-        }
-    }
-
-    public boolean c(EnumSkyBlock enumskyblock, BlockPosition blockposition) {
-        // CraftBukkit start - Use neighbor cache instead of looking up
-        Chunk chunk = this.getChunkIfLoaded(blockposition.getX() >> 4, blockposition.getZ() >> 4);
-        if (chunk == null || !chunk.areNeighborsLoaded(1) /*!this.areChunksLoaded(blockposition, 17, false)*/) {
-            // CraftBukkit end
-            return false;
-        } else {
-            int i = 0;
-            int j = 0;
-
-            this.methodProfiler.a("getBrightness");
-            int k = this.b(enumskyblock, blockposition);
-            int l = this.a(blockposition, enumskyblock);
-            int i1 = blockposition.getX();
-            int j1 = blockposition.getY();
-            int k1 = blockposition.getZ();
-            int l1;
-            int i2;
-            int j2;
-            int k2;
-            int l2;
-            int i3;
-            int j3;
-            int k3;
-
-            if (l > k) {
-                this.H[j++] = 133152;
-            } else if (l < k) {
-                this.H[j++] = 133152 | k << 18;
-
-                while (i < j) {
-                    l1 = this.H[i++];
-                    i2 = (l1 & 63) - 32 + i1;
-                    j2 = (l1 >> 6 & 63) - 32 + j1;
-                    k2 = (l1 >> 12 & 63) - 32 + k1;
-                    int l3 = l1 >> 18 & 15;
-                    BlockPosition blockposition1 = new BlockPosition(i2, j2, k2);
-
-                    l2 = this.b(enumskyblock, blockposition1);
-                    if (l2 == l3) {
-                        this.a(enumskyblock, blockposition1, 0);
-                        if (l3 > 0) {
-                            i3 = MathHelper.a(i2 - i1);
-                            j3 = MathHelper.a(j2 - j1);
-                            k3 = MathHelper.a(k2 - k1);
-                            if (i3 + j3 + k3 < 17) {
-                                BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
-                                EnumDirection[] aenumdirection = EnumDirection.values();
-                                int i4 = aenumdirection.length;
-
-                                for (int j4 = 0; j4 < i4; ++j4) {
-                                    EnumDirection enumdirection = aenumdirection[j4];
-                                    int k4 = i2 + enumdirection.getAdjacentX();
-                                    int l4 = j2 + enumdirection.getAdjacentY();
-                                    int i5 = k2 + enumdirection.getAdjacentZ();
-
-                                    blockposition_pooledblockposition.f(k4, l4, i5);
-                                    int j5 = Math.max(1, this.getType(blockposition_pooledblockposition).c());
-
-                                    l2 = this.b(enumskyblock, (BlockPosition) blockposition_pooledblockposition);
-                                    if (l2 == l3 - j5 && j < this.H.length) {
-                                        this.H[j++] = k4 - i1 + 32 | l4 - j1 + 32 << 6 | i5 - k1 + 32 << 12 | l3 - j5 << 18;
-                                    }
-                                }
-
-                                blockposition_pooledblockposition.t();
-                            }
-                        }
-                    }
-                }
-
-                i = 0;
-            }
-
-            this.methodProfiler.b();
-            this.methodProfiler.a("checkedPosition < toCheckCount");
-
-            while (i < j) {
-                l1 = this.H[i++];
-                i2 = (l1 & 63) - 32 + i1;
-                j2 = (l1 >> 6 & 63) - 32 + j1;
-                k2 = (l1 >> 12 & 63) - 32 + k1;
-                BlockPosition blockposition2 = new BlockPosition(i2, j2, k2);
-                int k5 = this.b(enumskyblock, blockposition2);
-
-                l2 = this.a(blockposition2, enumskyblock);
-                if (l2 != k5) {
-                    this.a(enumskyblock, blockposition2, l2);
-                    if (l2 > k5) {
-                        i3 = Math.abs(i2 - i1);
-                        j3 = Math.abs(j2 - j1);
-                        k3 = Math.abs(k2 - k1);
-                        boolean flag = j < this.H.length - 6;
-
-                        if (i3 + j3 + k3 < 17 && flag) {
-                            if (this.b(enumskyblock, blockposition2.west()) < l2) {
-                                this.H[j++] = i2 - 1 - i1 + 32 + (j2 - j1 + 32 << 6) + (k2 - k1 + 32 << 12);
-                            }
-
-                            if (this.b(enumskyblock, blockposition2.east()) < l2) {
-                                this.H[j++] = i2 + 1 - i1 + 32 + (j2 - j1 + 32 << 6) + (k2 - k1 + 32 << 12);
-                            }
-
-                            if (this.b(enumskyblock, blockposition2.down()) < l2) {
-                                this.H[j++] = i2 - i1 + 32 + (j2 - 1 - j1 + 32 << 6) + (k2 - k1 + 32 << 12);
-                            }
-
-                            if (this.b(enumskyblock, blockposition2.up()) < l2) {
-                                this.H[j++] = i2 - i1 + 32 + (j2 + 1 - j1 + 32 << 6) + (k2 - k1 + 32 << 12);
-                            }
-
-                            if (this.b(enumskyblock, blockposition2.north()) < l2) {
-                                this.H[j++] = i2 - i1 + 32 + (j2 - j1 + 32 << 6) + (k2 - 1 - k1 + 32 << 12);
-                            }
-
-                            if (this.b(enumskyblock, blockposition2.south()) < l2) {
-                                this.H[j++] = i2 - i1 + 32 + (j2 - j1 + 32 << 6) + (k2 + 1 - k1 + 32 << 12);
-                            }
-                        }
-                    }
-                }
-            }
-
-            this.methodProfiler.b();
-            return true;
-        }
-    }
-
-    public boolean a(boolean flag) {
-        return false;
-    }
-
-    @Nullable
-    public List<NextTickListEntry> a(Chunk chunk, boolean flag) {
-        return null;
-    }
-
-    @Nullable
-    public List<NextTickListEntry> a(StructureBoundingBox structureboundingbox, boolean flag) {
-        return null;
-    }
-
-    public List<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb) {
-        return this.getEntities(entity, axisalignedbb, IEntitySelector.e);
-    }
-
-    public List<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super Entity> predicate) {
-        ArrayList arraylist = Lists.newArrayList();
-        int i = MathHelper.floor((axisalignedbb.a - 2.0D) / 16.0D);
-        int j = MathHelper.floor((axisalignedbb.d + 2.0D) / 16.0D);
-        int k = MathHelper.floor((axisalignedbb.c - 2.0D) / 16.0D);
-        int l = MathHelper.floor((axisalignedbb.f + 2.0D) / 16.0D);
-
-        for (int i1 = i; i1 <= j; ++i1) {
-            for (int j1 = k; j1 <= l; ++j1) {
-                if (this.isChunkLoaded(i1, j1, true)) {
-                    this.getChunkAt(i1, j1).a(entity, axisalignedbb, arraylist, predicate);
-                }
-            }
-        }
-
-        return arraylist;
-    }
-
-    public <T extends Entity> List<T> a(Class<? extends T> oclass, Predicate<? super T> predicate) {
-        ArrayList arraylist = Lists.newArrayList();
-        Iterator iterator = this.entityList.iterator();
-
-        while (iterator.hasNext()) {
-            Entity entity = (Entity) iterator.next();
-
-            if (oclass.isAssignableFrom(entity.getClass()) && predicate.apply((T) entity)) {
-                arraylist.add(entity);
-            }
-        }
-
-        return arraylist;
-    }
-
-    public <T extends Entity> List<T> b(Class<? extends T> oclass, Predicate<? super T> predicate) {
-        ArrayList arraylist = Lists.newArrayList();
-        Iterator iterator = this.players.iterator();
-
-        while (iterator.hasNext()) {
-            Entity entity = (Entity) iterator.next();
-
-            if (oclass.isAssignableFrom(entity.getClass()) && predicate.apply((T) entity)) { // CraftBukkit - fix decompile error
-                arraylist.add(entity);
-            }
-        }
-
-        return arraylist;
-    }
-
-    public <T extends Entity> List<T> a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb) {
-        return this.a(oclass, axisalignedbb, IEntitySelector.e);
-    }
-
-    public <T extends Entity> List<T> a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super T> predicate) {
-        int i = MathHelper.floor((axisalignedbb.a - 2.0D) / 16.0D);
-        int j = MathHelper.f((axisalignedbb.d + 2.0D) / 16.0D);
-        int k = MathHelper.floor((axisalignedbb.c - 2.0D) / 16.0D);
-        int l = MathHelper.f((axisalignedbb.f + 2.0D) / 16.0D);
-        ArrayList arraylist = Lists.newArrayList();
-
-        for (int i1 = i; i1 < j; ++i1) {
-            for (int j1 = k; j1 < l; ++j1) {
-                if (this.isChunkLoaded(i1, j1, true)) {
-                    this.getChunkAt(i1, j1).a(oclass, axisalignedbb, arraylist, predicate);
-                }
-            }
-        }
-
-        return arraylist;
-    }
-
-    @Nullable
-    public <T extends Entity> T a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb, T t0) {
-        List list = this.a(oclass, axisalignedbb);
-        Entity entity = null;
-        double d0 = Double.MAX_VALUE;
-
-        for (int i = 0; i < list.size(); ++i) {
-            Entity entity1 = (Entity) list.get(i);
-
-            if (entity1 != t0 && IEntitySelector.e.apply(entity1)) {
-                double d1 = t0.h(entity1);
-
-                if (d1 <= d0) {
-                    entity = entity1;
-                    d0 = d1;
-                }
-            }
-        }
-
-        return (T) entity; // CraftBukkit fix decompile error
-    }
-
-    @Nullable
-    public Entity getEntity(int i) {
-        return (Entity) this.entitiesById.get(i);
-    }
-
-    public void b(BlockPosition blockposition, TileEntity tileentity) {
-        if (this.isLoaded(blockposition)) {
-            this.getChunkAtWorldCoords(blockposition).e();
-        }
-
-    }
-
-    public int a(Class<?> oclass) {
-        int i = 0;
-        Iterator iterator = this.entityList.iterator();
-
-        while (iterator.hasNext()) {
-            Entity entity = (Entity) iterator.next();
-            // CraftBukkit start - Split out persistent check, don't apply it to special persistent mobs
-            if (entity instanceof EntityInsentient) {
-                EntityInsentient entityinsentient = (EntityInsentient) entity;
-                if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
-                    continue;
-                }
-            }
-            
-            if (oclass.isAssignableFrom(entity.getClass())) {
-            // if ((!(entity instanceof EntityInsentient) || !((EntityInsentient) entity).isPersistent()) && oclass.isAssignableFrom(entity.getClass())) {
-                // CraftBukkit end
-                ++i;
-            }
-        }
-
-        return i;
-    }
-
-    public void a(Collection<Entity> collection) {
-        org.spigotmc.AsyncCatcher.catchOp( "entity world add"); // Spigot
-        // CraftBukkit start
-        // this.entityList.addAll(collection);
-        Iterator iterator = collection.iterator();
-
-        while (iterator.hasNext()) {
-            Entity entity = (Entity) iterator.next();
-
-            if (entity == null) {
-                continue;
-            }
-            this.entityList.add(entity);
-            // CraftBukkit end
-            this.b(entity);
-        }
-
-    }
-
-    public void c(Collection<Entity> collection) {
-        this.f.addAll(collection);
-    }
-
-    public boolean a(Block block, BlockPosition blockposition, boolean flag, EnumDirection enumdirection, @Nullable Entity entity, @Nullable ItemStack itemstack) {
-        IBlockData iblockdata = this.getType(blockposition);
-        AxisAlignedBB axisalignedbb = flag ? null : block.getBlockData().d(this, blockposition);
-
-        // CraftBukkit start - store default return
-        boolean defaultReturn = axisalignedbb != Block.k && !this.a(axisalignedbb.a(blockposition), entity) ? false : (iblockdata.getMaterial() == Material.ORIENTABLE && block == Blocks.ANVIL ? true : iblockdata.getMaterial().isReplaceable() && block.canPlace(this, blockposition, enumdirection, itemstack));
-        BlockCanBuildEvent event = new BlockCanBuildEvent(this.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), CraftMagicNumbers.getId(block), defaultReturn);
-        this.getServer().getPluginManager().callEvent(event);
-
-        return event.isBuildable();
-        // CraftBukkit end
-    }
-
-    public int K() {
-        return this.a;
-    }
-
-    public void b(int i) {
-        this.a = i;
-    }
-
-    public int getBlockPower(BlockPosition blockposition, EnumDirection enumdirection) {
-        return this.getType(blockposition).b(this, blockposition, enumdirection);
-    }
-
-    public WorldType L() {
-        return this.worldData.getType();
-    }
-
-    public int getBlockPower(BlockPosition blockposition) {
-        byte b0 = 0;
-        int i = Math.max(b0, this.getBlockPower(blockposition.down(), EnumDirection.DOWN));
-
-        if (i >= 15) {
-            return i;
-        } else {
-            i = Math.max(i, this.getBlockPower(blockposition.up(), EnumDirection.UP));
-            if (i >= 15) {
-                return i;
-            } else {
-                i = Math.max(i, this.getBlockPower(blockposition.north(), EnumDirection.NORTH));
-                if (i >= 15) {
-                    return i;
-                } else {
-                    i = Math.max(i, this.getBlockPower(blockposition.south(), EnumDirection.SOUTH));
-                    if (i >= 15) {
-                        return i;
-                    } else {
-                        i = Math.max(i, this.getBlockPower(blockposition.west(), EnumDirection.WEST));
-                        if (i >= 15) {
-                            return i;
-                        } else {
-                            i = Math.max(i, this.getBlockPower(blockposition.east(), EnumDirection.EAST));
-                            return i >= 15 ? i : i;
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    public boolean isBlockFacePowered(BlockPosition blockposition, EnumDirection enumdirection) {
-        return this.getBlockFacePower(blockposition, enumdirection) > 0;
-    }
-
-    public int getBlockFacePower(BlockPosition blockposition, EnumDirection enumdirection) {
-        IBlockData iblockdata = this.getType(blockposition);
-
-        return iblockdata.l() ? this.getBlockPower(blockposition) : iblockdata.a((IBlockAccess) this, blockposition, enumdirection);
-    }
-
-    public boolean isBlockIndirectlyPowered(BlockPosition blockposition) {
-        return this.getBlockFacePower(blockposition.down(), EnumDirection.DOWN) > 0 ? true : (this.getBlockFacePower(blockposition.up(), EnumDirection.UP) > 0 ? true : (this.getBlockFacePower(blockposition.north(), EnumDirection.NORTH) > 0 ? true : (this.getBlockFacePower(blockposition.south(), EnumDirection.SOUTH) > 0 ? true : (this.getBlockFacePower(blockposition.west(), EnumDirection.WEST) > 0 ? true : this.getBlockFacePower(blockposition.east(), EnumDirection.EAST) > 0))));
-    }
-
-    public int z(BlockPosition blockposition) {
-        int i = 0;
-        EnumDirection[] aenumdirection = EnumDirection.values();
-        int j = aenumdirection.length;
-
-        for (int k = 0; k < j; ++k) {
-            EnumDirection enumdirection = aenumdirection[k];
-            int l = this.getBlockFacePower(blockposition.shift(enumdirection), enumdirection);
-
-            if (l >= 15) {
-                return 15;
-            }
-
-            if (l > i) {
-                i = l;
-            }
-        }
-
-        return i;
-    }
-
-    @Nullable
-    public EntityHuman findNearbyPlayer(Entity entity, double d0) {
-        return this.a(entity.locX, entity.locY, entity.locZ, d0, false);
-    }
-
-    @Nullable
-    public EntityHuman b(Entity entity, double d0) {
-        return this.a(entity.locX, entity.locY, entity.locZ, d0, true);
-    }
-
-    @Nullable
-    public EntityHuman a(double d0, double d1, double d2, double d3, boolean flag) {
-        double d4 = -1.0D;
-        EntityHuman entityhuman = null;
-
-        for (int i = 0; i < this.players.size(); ++i) {
-            EntityHuman entityhuman1 = (EntityHuman) this.players.get(i);
-            // CraftBukkit start - Fixed an NPE
-            if (entityhuman1 == null || entityhuman1.dead) {
-                continue;
-            }
-            // CraftBukkit end
-
-            if ((IEntitySelector.d.apply(entityhuman1) || !flag) && (IEntitySelector.e.apply(entityhuman1) || flag)) {
-                double d5 = entityhuman1.e(d0, d1, d2);
-
-                if ((d3 < 0.0D || d5 < d3 * d3) && (d4 == -1.0D || d5 < d4)) {
-                    d4 = d5;
-                    entityhuman = entityhuman1;
-                }
-            }
-        }
-
-        return entityhuman;
-    }
-
-    public boolean isPlayerNearby(double d0, double d1, double d2, double d3) {
-        for (int i = 0; i < this.players.size(); ++i) {
-            EntityHuman entityhuman = (EntityHuman) this.players.get(i);
-
-            if (IEntitySelector.e.apply(entityhuman)) {
-                double d4 = entityhuman.e(d0, d1, d2);
-
-                if (d3 < 0.0D || d4 < d3 * d3) {
-                    return true;
-                }
-            }
-        }
-
-        return false;
-    }
-
-    @Nullable
-    public EntityHuman a(Entity entity, double d0, double d1) {
-        return this.a(entity.locX, entity.locY, entity.locZ, d0, d1, (Function) null, (Predicate) null);
-    }
-
-    @Nullable
-    public EntityHuman a(BlockPosition blockposition, double d0, double d1) {
-        return this.a((double) ((float) blockposition.getX() + 0.5F), (double) ((float) blockposition.getY() + 0.5F), (double) ((float) blockposition.getZ() + 0.5F), d0, d1, (Function) null, (Predicate) null);
-    }
-
-    @Nullable
-    public EntityHuman a(double d0, double d1, double d2, double d3, double d4, @Nullable Function<EntityHuman, Double> function, @Nullable Predicate<EntityHuman> predicate) {
-        double d5 = -1.0D;
-        EntityHuman entityhuman = null;
-
-        for (int i = 0; i < this.players.size(); ++i) {
-            EntityHuman entityhuman1 = (EntityHuman) this.players.get(i);
-
-            if (!entityhuman1.abilities.isInvulnerable && entityhuman1.isAlive() && !entityhuman1.isSpectator() && (predicate == null || predicate.apply(entityhuman1))) {
-                double d6 = entityhuman1.e(d0, entityhuman1.locY, d2);
-                double d7 = d3;
-
-                if (entityhuman1.isSneaking()) {
-                    d7 = d3 * 0.800000011920929D;
-                }
-
-                if (entityhuman1.isInvisible()) {
-                    float f = entityhuman1.cL();
-
-                    if (f < 0.1F) {
-                        f = 0.1F;
-                    }
-
-                    d7 *= (double) (0.7F * f);
-                }
-
-                if (function != null) {
-                    d7 *= ((Double) Objects.firstNonNull(function.apply(entityhuman1), Double.valueOf(1.0D))).doubleValue();
-                }
-
-                if ((d4 < 0.0D || Math.abs(entityhuman1.locY - d1) < d4 * d4) && (d3 < 0.0D || d6 < d7 * d7) && (d5 == -1.0D || d6 < d5)) {
-                    d5 = d6;
-                    entityhuman = entityhuman1;
-                }
-            }
-        }
-
-        return entityhuman;
-    }
-
-    @Nullable
-    public EntityHuman a(String s) {
-        for (int i = 0; i < this.players.size(); ++i) {
-            EntityHuman entityhuman = (EntityHuman) this.players.get(i);
-
-            if (s.equals(entityhuman.getName())) {
-                return entityhuman;
-            }
-        }
-
-        return null;
-    }
-
-    @Nullable
-    public EntityHuman b(UUID uuid) {
-        for (int i = 0; i < this.players.size(); ++i) {
-            EntityHuman entityhuman = (EntityHuman) this.players.get(i);
-
-            if (uuid.equals(entityhuman.getUniqueID())) {
-                return entityhuman;
-            }
-        }
-
-        return null;
-    }
-
-    public void checkSession() throws ExceptionWorldConflict {
-        this.dataManager.checkSession();
-    }
-
-    public long getSeed() {
-        return this.worldData.getSeed();
-    }
-
-    public long getTime() {
-        return this.worldData.getTime();
-    }
-
-    public long getDayTime() {
-        return this.worldData.getDayTime();
-    }
-
-    public void setDayTime(long i) {
-        this.worldData.setDayTime(i);
-    }
-
-    public BlockPosition getSpawn() {
-        BlockPosition blockposition = new BlockPosition(this.worldData.b(), this.worldData.c(), this.worldData.d());
-
-        if (!this.getWorldBorder().a(blockposition)) {
-            blockposition = this.getHighestBlockYAt(new BlockPosition(this.getWorldBorder().getCenterX(), 0.0D, this.getWorldBorder().getCenterZ()));
-        }
-
-        return blockposition;
-    }
-
-    public void A(BlockPosition blockposition) {
-        this.worldData.setSpawn(blockposition);
-    }
-
-    public boolean a(EntityHuman entityhuman, BlockPosition blockposition) {
-        return true;
-    }
-
-    public void broadcastEntityEffect(Entity entity, byte b0) {}
-
-    public IChunkProvider getChunkProvider() {
-        return this.chunkProvider;
-    }
-
-    public void playBlockAction(BlockPosition blockposition, Block block, int i, int j) {
-        this.getType(blockposition).a(this, blockposition, i, j);
-    }
-
-    public IDataManager getDataManager() {
-        return this.dataManager;
-    }
-
-    public WorldData getWorldData() {
-        return this.worldData;
-    }
-
-    public GameRules getGameRules() {
-        return this.worldData.w();
-    }
-
-    public void everyoneSleeping() {}
-
-    // CraftBukkit start
-    // Calls the method that checks to see if players are sleeping
-    // Called by CraftPlayer.setPermanentSleeping()
-    public void checkSleepStatus() {
-        if (!this.isClientSide) {
-            this.everyoneSleeping();
-        }
-    }
-    // CraftBukkit end
-
-    public float h(float f) {
-        return (this.p + (this.q - this.p) * f) * this.j(f);
-    }
-
-    public float j(float f) {
-        return this.n + (this.o - this.n) * f;
-    }
-
-    public boolean V() {
-        return (double) this.h(1.0F) > 0.9D;
-    }
-
-    public boolean W() {
-        return (double) this.j(1.0F) > 0.2D;
-    }
-
-    public boolean isRainingAt(BlockPosition blockposition) {
-        if (!this.W()) {
-            return false;
-        } else if (!this.h(blockposition)) {
-            return false;
-        } else if (this.p(blockposition).getY() > blockposition.getY()) {
-            return false;
-        } else {
-            BiomeBase biomebase = this.getBiome(blockposition);
-
-            return biomebase.c() ? false : (this.f(blockposition, false) ? false : biomebase.d());
-        }
-    }
-
-    public boolean C(BlockPosition blockposition) {
-        BiomeBase biomebase = this.getBiome(blockposition);
-
-        return biomebase.e();
-    }
-
-    @Nullable
-    public PersistentCollection X() {
-        return this.worldMaps;
-    }
-
-    public void a(String s, PersistentBase persistentbase) {
-        this.worldMaps.a(s, persistentbase);
-    }
-
-    @Nullable
-    public PersistentBase a(Class<? extends PersistentBase> oclass, String s) {
-        return this.worldMaps.get(oclass, s);
-    }
-
-    public int b(String s) {
-        return this.worldMaps.a(s);
-    }
-
-    public void a(int i, BlockPosition blockposition, int j) {
-        for (int k = 0; k < this.u.size(); ++k) {
-            ((IWorldAccess) this.u.get(k)).a(i, blockposition, j);
-        }
-
-    }
-
-    public void triggerEffect(int i, BlockPosition blockposition, int j) {
-        this.a((EntityHuman) null, i, blockposition, j);
-    }
-
-    public void a(@Nullable EntityHuman entityhuman, int i, BlockPosition blockposition, int j) {
-        try {
-            for (int k = 0; k < this.u.size(); ++k) {
-                ((IWorldAccess) this.u.get(k)).a(entityhuman, i, blockposition, j);
-            }
-
-        } catch (Throwable throwable) {
-            CrashReport crashreport = CrashReport.a(throwable, "Playing level event");
-            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Level event being played");
-
-            crashreportsystemdetails.a("Block coordinates", (Object) CrashReportSystemDetails.a(blockposition));
-            crashreportsystemdetails.a("Event source", (Object) entityhuman);
-            crashreportsystemdetails.a("Event type", (Object) Integer.valueOf(i));
-            crashreportsystemdetails.a("Event data", (Object) Integer.valueOf(j));
-            throw new ReportedException(crashreport);
-        }
-    }
-
-    public int getHeight() {
-        return 256;
-    }
-
-    public int Z() {
-        return this.worldProvider.m() ? 128 : 256;
-    }
-
-    public Random a(int i, int j, int k) {
-        long l = (long) i * 341873128712L + (long) j * 132897987541L + this.getWorldData().getSeed() + (long) k;
-
-        this.random.setSeed(l);
-        return this.random;
-    }
-
-    public CrashReportSystemDetails a(CrashReport crashreport) {
-        CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Affected level", 1);
-
-        crashreportsystemdetails.a("Level name", (Object) (this.worldData == null ? "????" : this.worldData.getName()));
-        crashreportsystemdetails.a("All players", new CrashReportCallable() {
-            public String a() {
-                return World.this.players.size() + " total; " + World.this.players;
-            }
-
-            public Object call() throws Exception {
-                return this.a();
-            }
-        });
-        crashreportsystemdetails.a("Chunk stats", new CrashReportCallable() {
-            public String a() {
-                return World.this.chunkProvider.getName();
-            }
-
-            public Object call() throws Exception {
-                return this.a();
-            }
-        });
-
-        try {
-            this.worldData.a(crashreportsystemdetails);
-        } catch (Throwable throwable) {
-            crashreportsystemdetails.a("Level Data Unobtainable", throwable);
-        }
-
-        return crashreportsystemdetails;
-    }
-
-    public void c(int i, BlockPosition blockposition, int j) {
-        for (int k = 0; k < this.u.size(); ++k) {
-            IWorldAccess iworldaccess = (IWorldAccess) this.u.get(k);
-
-            iworldaccess.b(i, blockposition, j);
-        }
-
-    }
-
-    public Calendar ac() {
-        if (this.getTime() % 600L == 0L) {
-            this.L.setTimeInMillis(MinecraftServer.av());
-        }
-
-        return this.L;
-    }
-
-    public Scoreboard getScoreboard() {
-        return this.scoreboard;
-    }
-
-    public void updateAdjacentComparators(BlockPosition blockposition, Block block) {
-        Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
-
-        while (iterator.hasNext()) {
-            EnumDirection enumdirection = (EnumDirection) iterator.next();
-            BlockPosition blockposition1 = blockposition.shift(enumdirection);
-
-            if (this.isLoaded(blockposition1)) {
-                IBlockData iblockdata = this.getType(blockposition1);
-
-                if (Blocks.UNPOWERED_COMPARATOR.C(iblockdata)) {
-                    iblockdata.doPhysics(this, blockposition1, block);
-                } else if (iblockdata.l()) {
-                    blockposition1 = blockposition1.shift(enumdirection);
-                    iblockdata = this.getType(blockposition1);
-                    if (Blocks.UNPOWERED_COMPARATOR.C(iblockdata)) {
-                        iblockdata.doPhysics(this, blockposition1, block);
-                    }
-                }
-            }
-        }
-
-    }
-
-    public DifficultyDamageScaler D(BlockPosition blockposition) {
-        long i = 0L;
-        float f = 0.0F;
-
-        if (this.isLoaded(blockposition)) {
-            f = this.E();
-            i = this.getChunkAtWorldCoords(blockposition).x();
-        }
-
-        return new DifficultyDamageScaler(this.getDifficulty(), this.getDayTime(), i, f);
-    }
-
-    public EnumDifficulty getDifficulty() {
-        return this.getWorldData().getDifficulty();
-    }
-
-    public int af() {
-        return this.J;
-    }
-
-    public void c(int i) {
-        this.J = i;
-    }
-
-    public void d(int i) {
-        this.K = i;
-    }
-
-    public PersistentVillage ai() {
-        return this.villages;
-    }
-
-    public WorldBorder getWorldBorder() {
-        return this.N;
-    }
-
-    public boolean d(int i, int j) {
-        BlockPosition blockposition = this.getSpawn();
-        int k = i * 16 + 8 - blockposition.getX();
-        int l = j * 16 + 8 - blockposition.getZ();
-        boolean flag = true;
-
-        return k >= -128 && k <= 128 && l >= -128 && l <= 128 && this.keepSpawnInMemory; // CraftBukkit - Added 'this.keepSpawnInMemory'
-    }
-
-    public void a(Packet<?> packet) {
-        throw new UnsupportedOperationException("Can\'t send packets to server unless you\'re on the client.");
-    }
-
-    public LootTableRegistry ak() {
-        return this.B;
-    }
-}
+	package net.minecraft.server;
+
+import com.google.common.base.Function;
+import com.google.common.base.Objects;
+import com.google.common.base.Predicate;
+import com.google.common.collect.Lists;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Random;
+import java.util.UUID;
+import javax.annotation.Nullable;
+
+// CraftBukkit start
+import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
+import java.util.LinkedList;
+import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
+import org.bukkit.Bukkit;
+import org.bukkit.block.BlockState;
+import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.event.block.BlockCanBuildEvent;
+import org.bukkit.event.block.BlockPhysicsEvent;
+import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
+import org.bukkit.generator.ChunkGenerator;
+// CraftBukkit end
+
+public abstract class World implements IBlockAccess {
+
+    private int a = 63;
+    protected boolean d;
+    //Queue<Entity> entityremoveList = Queues.newConcurrentLinkedQueue();
+    // Spigot start - guard entity list from removals
+    public final Queue<Entity> entityQueue = Queues.newConcurrentLinkedQueue();
+    //public final List<Entity> entityList = new java.util.ArrayList<Entity>()
+    public List<Entity> entityList = new ArrayList<Entity>()
+    {
+        @Override
+        public Entity remove(int index)
+        {
+            guard();
+            return super.remove( index );
+        }
+
+        @Override
+        public boolean remove(Object o)
+        {
+            guard();
+            return super.remove( o );
+        }
+
+        private void guard()
+        {
+            if ( guardEntityList )
+            {
+                throw new java.util.ConcurrentModificationException();
+            }
+        }
+    };
+    // Spigot end
+    //protected final List<Entity> f = Lists.newArrayList();
+    protected final Queue<Entity> f = Queues.newConcurrentLinkedQueue();
+    public final List<TileEntity> tileEntityList = Lists.newArrayList();
+    public final List<TileEntity> tileEntityListTick = Lists.newArrayList();
+    public final List<TileEntity> b = Lists.newArrayList();
+    //private final List<TileEntity> tileEntityListUnload = Lists.newArrayList();
+    public final Queue<TileEntity> tileEntityListUnload = Queues.newConcurrentLinkedQueue();
+    public final List<EntityHuman> players = Lists.newArrayList();
+    public final List<Entity> j = Lists.newArrayList();
+    //protected final IntHashMap<Entity> entitiesById = new IntHashMap();
+    protected final Map<Integer, Entity> entitiesById = Maps.newConcurrentMap();
+    private final long I = 16777215L;
+    private int J;
+    protected int l = (new Random()).nextInt();
+    protected final int m = 1013904223;
+    protected float n;
+    protected float o;
+    protected float p;
+    protected float q;
+    private int K;
+    public final Random random = new Random();
+    public WorldProvider worldProvider;
+    protected NavigationListener t = new NavigationListener();
+    protected List<IWorldAccess> u;
+    protected IChunkProvider chunkProvider;
+    protected final IDataManager dataManager;
+    public WorldData worldData;
+    protected boolean isLoading;
+    public PersistentCollection worldMaps;
+    protected PersistentVillage villages;
+    protected LootTableRegistry B;
+    public final MethodProfiler methodProfiler;
+    private final Calendar L;
+    public Scoreboard scoreboard;
+    public final boolean isClientSide;
+    public boolean allowMonsters;
+    public boolean allowAnimals;
+    private boolean M;
+    private final WorldBorder N;
+    int[] H;
+
+    // CraftBukkit start Added the following
+    private final CraftWorld world;
+    public boolean pvpMode;
+    public boolean keepSpawnInMemory = true;
+    public ChunkGenerator generator;
+
+    public boolean captureBlockStates = false;
+    public boolean captureTreeGeneration = false;
+    public ArrayList<BlockState> capturedBlockStates= new ArrayList<BlockState>(){
+        @Override
+        public boolean add( BlockState blockState ) {
+            Iterator<BlockState> blockStateIterator = this.iterator();
+            while( blockStateIterator.hasNext() ) {
+                BlockState blockState1 = blockStateIterator.next();
+                if ( blockState1.getLocation().equals( blockState.getLocation() ) ) {
+                    return false;
+                }
+            }
+
+            return super.add( blockState );
+        }
+    };
+    public long ticksPerAnimalSpawns;
+    public long ticksPerMonsterSpawns;
+    public boolean populating;
+    //private int tickPosition;
+    public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
+
+    public final SpigotTimings.WorldTimingsHandler timings; // Spigot
+    private boolean guardEntityList; // Spigot
+    public static boolean haveWeSilencedAPhysicsCrash;
+    public static String blockLocation;
+    private org.spigotmc.TickLimiter entityLimiter;
+    private org.spigotmc.TickLimiter tileLimiter;
+    private int tileTickPosition;
+
+    public CraftWorld getWorld() {
+        return this.world;
+    }
+
+    public CraftServer getServer() {
+        return (CraftServer) Bukkit.getServer();
+    }
+
+    public Chunk getChunkIfLoaded(int x, int z) {
+        return ((ChunkProviderServer) this.chunkProvider).getChunkIfLoaded(x, z);
+    }
+
+    protected World(IDataManager idatamanager, WorldData worlddata, WorldProvider worldprovider, MethodProfiler methodprofiler, boolean flag, ChunkGenerator gen, org.bukkit.World.Environment env) {
+        this.spigotConfig = new org.spigotmc.SpigotWorldConfig( worlddata.getName() ); // Spigot
+        this.generator = gen;
+        this.world = new CraftWorld((WorldServer) this, gen, env);
+        this.ticksPerAnimalSpawns = this.getServer().getTicksPerAnimalSpawns(); // CraftBukkit
+        this.ticksPerMonsterSpawns = this.getServer().getTicksPerMonsterSpawns(); // CraftBukkit
+        // CraftBukkit end
+        this.u = Lists.newArrayList(new IWorldAccess[] { this.t});
+        this.L = Calendar.getInstance();
+        this.scoreboard = new Scoreboard();
+        this.allowMonsters = true;
+        this.allowAnimals = true;
+        this.H = new int['\u8000'];
+        this.dataManager = idatamanager;
+        this.methodProfiler = methodprofiler;
+        this.worldData = worlddata;
+        this.worldProvider = worldprovider;
+        this.isClientSide = flag;
+        this.N = worldprovider.getWorldBorder();
+        // CraftBukkit start
+        getWorldBorder().world = (WorldServer) this;
+        // From PlayerList.setPlayerFileData
+        getWorldBorder().a(new IWorldBorderListener() {
+            public void a(WorldBorder worldborder, double d0) {
+                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_SIZE), worldborder.world);
+            }
+
+            public void a(WorldBorder worldborder, double d0, double d1, long i) {
+                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.LERP_SIZE), worldborder.world);
+            }
+
+            public void a(WorldBorder worldborder, double d0, double d1) {
+                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_CENTER), worldborder.world);
+            }
+
+            public void a(WorldBorder worldborder, int i) {
+                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_WARNING_TIME), worldborder.world);
+            }
+
+            public void b(WorldBorder worldborder, int i) {
+                getServer().getHandle().sendAll(new PacketPlayOutWorldBorder(worldborder, PacketPlayOutWorldBorder.EnumWorldBorderAction.SET_WARNING_BLOCKS), worldborder.world);
+            }
+
+            public void b(WorldBorder worldborder, double d0) {}
+
+            public void c(WorldBorder worldborder, double d0) {}
+        });
+        this.getServer().addWorld(this.world);
+        // CraftBukkit end
+        timings = new SpigotTimings.WorldTimingsHandler(this); // Spigot - code below can generate new world and access timings
+                this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
+        this.tileLimiter = new org.spigotmc.TickLimiter(spigotConfig.tileMaxTickTime);
+    }
+
+    public World b() {
+        return this;
+    }
+
+    public BiomeBase getBiome(final BlockPosition blockposition) {
+        if (this.isLoaded(blockposition)) {
+            Chunk chunk = this.getChunkAtWorldCoords(blockposition);
+
+            try {
+                return chunk.getBiome(blockposition, this.worldProvider.k());
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Getting biome");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Coordinates of biome request");
+
+                crashreportsystemdetails.a("Location", new CrashReportCallable() {
+                    public String a() throws Exception {
+                        return CrashReportSystemDetails.a(blockposition);
+                    }
+
+                    public Object call() throws Exception {
+                        return this.a();
+                    }
+                });
+                throw new ReportedException(crashreport);
+            }
+        } else {
+            return this.worldProvider.k().getBiome(blockposition, Biomes.c);
+        }
+    }
+
+    public WorldChunkManager getWorldChunkManager() {
+        return this.worldProvider.k();
+    }
+
+    protected abstract IChunkProvider n();
+
+    public void a(WorldSettings worldsettings) {
+        this.worldData.d(true);
+    }
+
+    @Nullable
+    public MinecraftServer getMinecraftServer() {
+        return null;
+    }
+
+    public IBlockData c(BlockPosition blockposition) {
+        BlockPosition blockposition1;
+
+        for (blockposition1 = new BlockPosition(blockposition.getX(), this.K(), blockposition.getZ()); !this.isEmpty(blockposition1.up()); blockposition1 = blockposition1.up()) {
+            ;
+        }
+
+        return this.getType(blockposition1);
+    }
+
+    private boolean isValidLocation(BlockPosition blockposition) {
+        return !this.E(blockposition) && blockposition.getX() >= -30000000 && blockposition.getZ() >= -30000000 && blockposition.getX() < 30000000 && blockposition.getZ() < 30000000;
+    }
+
+    private boolean E(BlockPosition blockposition) {
+        return blockposition.getY() < 0 || blockposition.getY() >= 256;
+    }
+
+    public boolean isEmpty(BlockPosition blockposition) {
+        return this.getType(blockposition).getMaterial() == Material.AIR;
+    }
+
+    public boolean isLoaded(BlockPosition blockposition) {
+        return this.a(blockposition, true);
+    }
+
+    public boolean a(BlockPosition blockposition, boolean flag) {
+        return this.isChunkLoaded(blockposition.getX() >> 4, blockposition.getZ() >> 4, flag);
+    }
+
+    public boolean areChunksLoaded(BlockPosition blockposition, int i) {
+        return this.areChunksLoaded(blockposition, i, true);
+    }
+
+    public boolean areChunksLoaded(BlockPosition blockposition, int i, boolean flag) {
+        return this.isAreaLoaded(blockposition.getX() - i, blockposition.getY() - i, blockposition.getZ() - i, blockposition.getX() + i, blockposition.getY() + i, blockposition.getZ() + i, flag);
+    }
+
+    public boolean areChunksLoadedBetween(BlockPosition blockposition, BlockPosition blockposition1) {
+        return this.areChunksLoadedBetween(blockposition, blockposition1, true);
+    }
+
+    public boolean areChunksLoadedBetween(BlockPosition blockposition, BlockPosition blockposition1, boolean flag) {
+        return this.isAreaLoaded(blockposition.getX(), blockposition.getY(), blockposition.getZ(), blockposition1.getX(), blockposition1.getY(), blockposition1.getZ(), flag);
+    }
+
+    public boolean a(StructureBoundingBox structureboundingbox) {
+        return this.b(structureboundingbox, true);
+    }
+
+    public boolean b(StructureBoundingBox structureboundingbox, boolean flag) {
+        return this.isAreaLoaded(structureboundingbox.a, structureboundingbox.b, structureboundingbox.c, structureboundingbox.d, structureboundingbox.e, structureboundingbox.f, flag);
+    }
+
+    private boolean isAreaLoaded(int i, int j, int k, int l, int i1, int j1, boolean flag) {
+        if (i1 >= 0 && j < 256) {
+            i >>= 4;
+            k >>= 4;
+            l >>= 4;
+            j1 >>= 4;
+
+            for (int k1 = i; k1 <= l; ++k1) {
+                for (int l1 = k; l1 <= j1; ++l1) {
+                    if (!this.isChunkLoaded(k1, l1, flag)) {
+                        return false;
+                    }
+                }
+            }
+
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    protected abstract boolean isChunkLoaded(int i, int j, boolean flag);
+
+    public Chunk getChunkAtWorldCoords(BlockPosition blockposition) {
+        return this.getChunkAt(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+    }
+
+    public Chunk getChunkAt(int i, int j) {
+        return this.chunkProvider.getChunkAt(i, j);
+    }
+
+    public boolean setTypeAndData(BlockPosition blockposition, IBlockData iblockdata, int i) {
+        // CraftBukkit start - tree generation
+        if (this.captureTreeGeneration) {
+            BlockState blockstate = null;
+            Iterator<BlockState> it = capturedBlockStates.iterator();
+            while (it.hasNext()) {
+                BlockState previous = it.next();
+                if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
+                    blockstate = previous;
+                    it.remove();
+                    break;
+                }
+            }
+            if (blockstate == null) {
+                blockstate = org.bukkit.craftbukkit.block.CraftBlockState.getBlockState(this, blockposition.getX(), blockposition.getY(), blockposition.getZ(), i);
+            }
+            blockstate.setTypeId(CraftMagicNumbers.getId(iblockdata.getBlock()));
+            blockstate.setRawData((byte) iblockdata.getBlock().toLegacyData(iblockdata));
+            this.capturedBlockStates.add(blockstate);
+            return true;
+        }
+        // CraftBukkit end
+        if (this.E(blockposition)) {
+            return false;
+        } else if (!this.isClientSide && this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
+            return false;
+        } else {
+            Chunk chunk = this.getChunkAtWorldCoords(blockposition);
+            Block block = iblockdata.getBlock();
+
+            // CraftBukkit start - capture blockstates
+            BlockState blockstate = null;
+            if (this.captureBlockStates) {
+                blockstate = org.bukkit.craftbukkit.block.CraftBlockState.getBlockState(this, blockposition.getX(), blockposition.getY(), blockposition.getZ(), i);
+                this.capturedBlockStates.add(blockstate);
+            }
+            // CraftBukkit end
+
+            IBlockData iblockdata1 = chunk.a(blockposition, iblockdata);
+
+            if (iblockdata1 == null) {
+                // CraftBukkit start - remove blockstate if failed
+                if (this.captureBlockStates) {
+                    this.capturedBlockStates.remove(blockstate);
+                }
+                // CraftBukkit end
+                return false;
+            } else {
+                if (iblockdata.c() != iblockdata1.c() || iblockdata.d() != iblockdata1.d()) {
+                    this.methodProfiler.a("checkLight");
+                    this.w(blockposition);
+                    this.methodProfiler.b();
+                }
+
+                /*
+                if ((i & 2) != 0 && (!this.isClientSide || (i & 4) == 0) && chunk.isReady()) {
+                    this.notify(blockposition, iblockdata1, iblockdata, i);
+                }
+
+                if (!this.isClientSide && (i & 1) != 0) {
+                    this.update(blockposition, iblockdata1.getBlock());
+                    if (iblockdata.n()) {
+                        this.updateAdjacentComparators(blockposition, block);
+                    }
+                }
+                */
+
+                // CraftBukkit start
+                if (!this.captureBlockStates) { // Don't notify clients or update physics while capturing blockstates
+                    // Modularize client and physic updates
+                    notifyAndUpdatePhysics(blockposition, chunk, iblockdata1, iblockdata, i);
+                }
+                // CraftBukkit end
+
+                return true;
+            }
+        }
+    }
+
+    // CraftBukkit start - Split off from original setTypeAndData(int i, int j, int k, Block block, int l, int i1) method in order to directly send client and physic updates
+    public void notifyAndUpdatePhysics(BlockPosition blockposition, Chunk chunk, IBlockData oldBlock, IBlockData newBlock, int flag) {
+        if ((flag & 2) != 0 && (chunk == null || chunk.isReady())) {  // allow chunk to be null here as chunk.isReady() is false when we send our notification during block placement
+            this.notify(blockposition, oldBlock, newBlock, flag);
+        }
+
+        if (!this.isClientSide && (flag & 1) != 0) {
+            this.update(blockposition, oldBlock.getBlock());
+            if (newBlock.n()) {
+                this.updateAdjacentComparators(blockposition, newBlock.getBlock());
+            }
+        }
+    }
+    // CraftBukkit end
+
+    public boolean setAir(BlockPosition blockposition) {
+        return this.setTypeAndData(blockposition, Blocks.AIR.getBlockData(), 3);
+    }
+
+    public boolean setAir(BlockPosition blockposition, boolean flag) {
+        IBlockData iblockdata = this.getType(blockposition);
+        Block block = iblockdata.getBlock();
+
+        if (iblockdata.getMaterial() == Material.AIR) {
+            return false;
+        } else {
+            this.triggerEffect(2001, blockposition, Block.getCombinedId(iblockdata));
+            if (flag) {
+                block.b(this, blockposition, iblockdata, 0);
+            }
+
+            return this.setTypeAndData(blockposition, Blocks.AIR.getBlockData(), 3);
+        }
+    }
+
+    public boolean setTypeUpdate(BlockPosition blockposition, IBlockData iblockdata) {
+        return this.setTypeAndData(blockposition, iblockdata, 3);
+    }
+
+    public void notify(BlockPosition blockposition, IBlockData iblockdata, IBlockData iblockdata1, int i) {
+        this.u.parallelStream().forEach(it -> ((IWorldAccess) it).a(this, blockposition, iblockdata, iblockdata1, i));
+        /*
+        for (int j = 0; j < this.u.size(); ++j) {
+            ((IWorldAccess) this.u.get(j)).a(this, blockposition, iblockdata, iblockdata1, i);
+        }*/
+
+    }
+
+    public void update(BlockPosition blockposition, Block block) {
+        if (this.worldData.getType() != WorldType.DEBUG_ALL_BLOCK_STATES) {
+            // CraftBukkit start
+            if (populating) {
+                return;
+            }
+            // CraftBukkit end
+            this.applyPhysics(blockposition, block);
+        }
+
+    }
+
+    public void a(int i, int j, int k, int l) {
+        int i1;
+
+        if (k > l) {
+            i1 = l;
+            l = k;
+            k = i1;
+        }
+
+        if (!this.worldProvider.m()) {
+            for (i1 = k; i1 <= l; ++i1) {
+                this.c(EnumSkyBlock.SKY, new BlockPosition(i, i1, j));
+            }
+        }
+
+        this.b(i, k, j, i, l, j);
+    }
+
+    public void b(BlockPosition blockposition, BlockPosition blockposition1) {
+        this.b(blockposition.getX(), blockposition.getY(), blockposition.getZ(), blockposition1.getX(), blockposition1.getY(), blockposition1.getZ());
+    }
+
+    public void b(int i, int j, int k, int l, int i1, int j1) {
+        for (int k1 = 0; k1 < this.u.size(); ++k1) {
+            ((IWorldAccess) this.u.get(k1)).a(i, j, k, l, i1, j1);
+        }
+
+    }
+
+    public void applyPhysics(BlockPosition blockposition, Block block) {
+        this.e(blockposition.west(), block);
+        this.e(blockposition.east(), block);
+        this.e(blockposition.down(), block);
+        this.e(blockposition.up(), block);
+        this.e(blockposition.north(), block);
+        this.e(blockposition.south(), block);
+    }
+
+    public void a(BlockPosition blockposition, Block block, EnumDirection enumdirection) {
+        if (enumdirection != EnumDirection.WEST) {
+            this.e(blockposition.west(), block);
+        }
+
+        if (enumdirection != EnumDirection.EAST) {
+            this.e(blockposition.east(), block);
+        }
+
+        if (enumdirection != EnumDirection.DOWN) {
+            this.e(blockposition.down(), block);
+        }
+
+        if (enumdirection != EnumDirection.UP) {
+            this.e(blockposition.up(), block);
+        }
+
+        if (enumdirection != EnumDirection.NORTH) {
+            this.e(blockposition.north(), block);
+        }
+
+        if (enumdirection != EnumDirection.SOUTH) {
+            this.e(blockposition.south(), block);
+        }
+
+    }
+
+    public void e(BlockPosition blockposition, final Block block) {
+        if (!this.isClientSide) {
+            IBlockData iblockdata = this.getType(blockposition);
+
+            try {
+                // CraftBukkit start
+                CraftWorld world = ((WorldServer) this).getWorld();
+                if (world != null) {
+                    BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), CraftMagicNumbers.getId(block));
+                    this.getServer().getPluginManager().callEvent(event);
+
+                    if (event.isCancelled()) {
+                        return;
+                    }
+                }
+                // CraftBukkit end
+                iblockdata.doPhysics(this, blockposition, block);
+            } catch (StackOverflowError stackoverflowerror) { // Spigot Start
+                haveWeSilencedAPhysicsCrash = true;
+                blockLocation = blockposition.getX() + ", " + blockposition.getY() + ", " + blockposition.getZ(); // Spigot End
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Exception while updating neighbours");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being updated");
+
+                crashreportsystemdetails.a("Source block type", new CrashReportCallable() {
+                    public String a() throws Exception {
+                        try {
+                            return String.format("ID #%d (%s // %s)", new Object[] { Integer.valueOf(Block.getId(block)), block.a(), block.getClass().getCanonicalName()});
+                        } catch (Throwable throwable) {
+                            return "ID #" + Block.getId(block);
+                        }
+                    }
+
+                    public Object call() throws Exception {
+                        return this.a();
+                    }
+                });
+                CrashReportSystemDetails.a(crashreportsystemdetails, blockposition, iblockdata);
+                throw new ReportedException(crashreport);
+            }
+        }
+    }
+
+    public boolean a(BlockPosition blockposition, Block block) {
+        return false;
+    }
+
+    public boolean h(BlockPosition blockposition) {
+        return this.getChunkAtWorldCoords(blockposition).c(blockposition);
+    }
+
+    public boolean i(BlockPosition blockposition) {
+        if (blockposition.getY() >= this.K()) {
+            return this.h(blockposition);
+        } else {
+            BlockPosition blockposition1 = new BlockPosition(blockposition.getX(), this.K(), blockposition.getZ());
+
+            if (!this.h(blockposition1)) {
+                return false;
+            } else {
+                for (blockposition1 = blockposition1.down(); blockposition1.getY() > blockposition.getY(); blockposition1 = blockposition1.down()) {
+                    IBlockData iblockdata = this.getType(blockposition1);
+
+                    if (iblockdata.c() > 0 && !iblockdata.getMaterial().isLiquid()) {
+                        return false;
+                    }
+                }
+
+                return true;
+            }
+        }
+    }
+
+    public int j(BlockPosition blockposition) {
+        if (blockposition.getY() < 0) {
+            return 0;
+        } else {
+            if (blockposition.getY() >= 256) {
+                blockposition = new BlockPosition(blockposition.getX(), 255, blockposition.getZ());
+            }
+
+            return this.getChunkAtWorldCoords(blockposition).a(blockposition, 0);
+        }
+    }
+
+    public int getLightLevel(BlockPosition blockposition) {
+        return this.c(blockposition, true);
+    }
+
+    public int c(BlockPosition blockposition, boolean flag) {
+        if (blockposition.getX() >= -30000000 && blockposition.getZ() >= -30000000 && blockposition.getX() < 30000000 && blockposition.getZ() < 30000000) {
+            if (flag && this.getType(blockposition).f()) {
+                int i = this.c(blockposition.up(), false);
+                int j = this.c(blockposition.east(), false);
+                int k = this.c(blockposition.west(), false);
+                int l = this.c(blockposition.south(), false);
+                int i1 = this.c(blockposition.north(), false);
+
+                if (j > i) {
+                    i = j;
+                }
+
+                if (k > i) {
+                    i = k;
+                }
+
+                if (l > i) {
+                    i = l;
+                }
+
+                if (i1 > i) {
+                    i = i1;
+                }
+
+                return i;
+            } else if (blockposition.getY() < 0) {
+                return 0;
+            } else {
+                if (blockposition.getY() >= 256) {
+                    blockposition = new BlockPosition(blockposition.getX(), 255, blockposition.getZ());
+                }
+
+                Chunk chunk = this.getChunkAtWorldCoords(blockposition);
+
+                return chunk.a(blockposition, this.J);
+            }
+        } else {
+            return 15;
+        }
+    }
+
+    public BlockPosition getHighestBlockYAt(BlockPosition blockposition) {
+        return new BlockPosition(blockposition.getX(), this.b(blockposition.getX(), blockposition.getZ()), blockposition.getZ());
+    }
+
+    public int b(int i, int j) {
+        int k;
+
+        if (i >= -30000000 && j >= -30000000 && i < 30000000 && j < 30000000) {
+            if (this.isChunkLoaded(i >> 4, j >> 4, true)) {
+                k = this.getChunkAt(i >> 4, j >> 4).b(i & 15, j & 15);
+            } else {
+                k = 0;
+            }
+        } else {
+            k = this.K() + 1;
+        }
+
+        return k;
+    }
+
+    @Deprecated
+    public int c(int i, int j) {
+        if (i >= -30000000 && j >= -30000000 && i < 30000000 && j < 30000000) {
+            if (!this.isChunkLoaded(i >> 4, j >> 4, true)) {
+                return 0;
+            } else {
+                Chunk chunk = this.getChunkAt(i >> 4, j >> 4);
+
+                return chunk.w();
+            }
+        } else {
+            return this.K() + 1;
+        }
+    }
+
+    public int b(EnumSkyBlock enumskyblock, BlockPosition blockposition) {
+        if (blockposition.getY() < 0) {
+            blockposition = new BlockPosition(blockposition.getX(), 0, blockposition.getZ());
+        }
+
+        if (!this.isValidLocation(blockposition)) {
+            return enumskyblock.c;
+        } else if (!this.isLoaded(blockposition)) {
+            return enumskyblock.c;
+        } else {
+            Chunk chunk = this.getChunkAtWorldCoords(blockposition);
+
+            return chunk.getBrightness(enumskyblock, blockposition);
+        }
+    }
+
+    public void a(EnumSkyBlock enumskyblock, BlockPosition blockposition, int i) {
+        if (this.isValidLocation(blockposition)) {
+            if (this.isLoaded(blockposition)) {
+                Chunk chunk = this.getChunkAtWorldCoords(blockposition);
+
+                chunk.a(enumskyblock, blockposition, i);
+                this.m(blockposition);
+            }
+        }
+    }
+
+    public void m(BlockPosition blockposition) {
+        for (int i = 0; i < this.u.size(); ++i) {
+            ((IWorldAccess) this.u.get(i)).a(blockposition);
+        }
+
+    }
+
+    public float n(BlockPosition blockposition) {
+        return this.worldProvider.n()[this.getLightLevel(blockposition)];
+    }
+
+    public IBlockData getType(BlockPosition blockposition) {
+        // CraftBukkit start - tree generation
+        if (captureTreeGeneration) {
+            Iterator<BlockState> it = capturedBlockStates.iterator();
+            while (it.hasNext()) {
+                BlockState previous = it.next();
+                if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
+                    return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
+                }
+            }
+        }
+        // CraftBukkit end
+        if (this.E(blockposition)) {
+            return Blocks.AIR.getBlockData();
+        } else {
+            Chunk chunk = this.getChunkAtWorldCoords(blockposition);
+
+            return chunk.getBlockData(blockposition);
+        }
+    }
+
+    public boolean B() {
+        return this.J < 4;
+    }
+
+    @Nullable
+    public MovingObjectPosition rayTrace(Vec3D vec3d, Vec3D vec3d1) {
+        return this.rayTrace(vec3d, vec3d1, false, false, false);
+    }
+
+    @Nullable
+    public MovingObjectPosition rayTrace(Vec3D vec3d, Vec3D vec3d1, boolean flag) {
+        return this.rayTrace(vec3d, vec3d1, flag, false, false);
+    }
+
+    @Nullable
+    public MovingObjectPosition rayTrace(Vec3D vec3d, Vec3D vec3d1, boolean flag, boolean flag1, boolean flag2) {
+        if (!Double.isNaN(vec3d.x) && !Double.isNaN(vec3d.y) && !Double.isNaN(vec3d.z)) {
+            if (!Double.isNaN(vec3d1.x) && !Double.isNaN(vec3d1.y) && !Double.isNaN(vec3d1.z)) {
+                int i = MathHelper.floor(vec3d1.x);
+                int j = MathHelper.floor(vec3d1.y);
+                int k = MathHelper.floor(vec3d1.z);
+                int l = MathHelper.floor(vec3d.x);
+                int i1 = MathHelper.floor(vec3d.y);
+                int j1 = MathHelper.floor(vec3d.z);
+                BlockPosition blockposition = new BlockPosition(l, i1, j1);
+                IBlockData iblockdata = this.getType(blockposition);
+                Block block = iblockdata.getBlock();
+
+                if ((!flag1 || iblockdata.d(this, blockposition) != Block.k) && block.a(iblockdata, flag)) {
+                    MovingObjectPosition movingobjectposition = iblockdata.a(this, blockposition, vec3d, vec3d1);
+
+                    if (movingobjectposition != null) {
+                        return movingobjectposition;
+                    }
+                }
+
+                MovingObjectPosition movingobjectposition1 = null;
+                int k1 = 200;
+
+                while (k1-- >= 0) {
+                    if (Double.isNaN(vec3d.x) || Double.isNaN(vec3d.y) || Double.isNaN(vec3d.z)) {
+                        return null;
+                    }
+
+                    if (l == i && i1 == j && j1 == k) {
+                        return flag2 ? movingobjectposition1 : null;
+                    }
+
+                    boolean flag3 = true;
+                    boolean flag4 = true;
+                    boolean flag5 = true;
+                    double d0 = 999.0D;
+                    double d1 = 999.0D;
+                    double d2 = 999.0D;
+
+                    if (i > l) {
+                        d0 = (double) l + 1.0D;
+                    } else if (i < l) {
+                        d0 = (double) l + 0.0D;
+                    } else {
+                        flag3 = false;
+                    }
+
+                    if (j > i1) {
+                        d1 = (double) i1 + 1.0D;
+                    } else if (j < i1) {
+                        d1 = (double) i1 + 0.0D;
+                    } else {
+                        flag4 = false;
+                    }
+
+                    if (k > j1) {
+                        d2 = (double) j1 + 1.0D;
+                    } else if (k < j1) {
+                        d2 = (double) j1 + 0.0D;
+                    } else {
+                        flag5 = false;
+                    }
+
+                    double d3 = 999.0D;
+                    double d4 = 999.0D;
+                    double d5 = 999.0D;
+                    double d6 = vec3d1.x - vec3d.x;
+                    double d7 = vec3d1.y - vec3d.y;
+                    double d8 = vec3d1.z - vec3d.z;
+
+                    if (flag3) {
+                        d3 = (d0 - vec3d.x) / d6;
+                    }
+
+                    if (flag4) {
+                        d4 = (d1 - vec3d.y) / d7;
+                    }
+
+                    if (flag5) {
+                        d5 = (d2 - vec3d.z) / d8;
+                    }
+
+                    if (d3 == -0.0D) {
+                        d3 = -1.0E-4D;
+                    }
+
+                    if (d4 == -0.0D) {
+                        d4 = -1.0E-4D;
+                    }
+
+                    if (d5 == -0.0D) {
+                        d5 = -1.0E-4D;
+                    }
+
+                    EnumDirection enumdirection;
+
+                    if (d3 < d4 && d3 < d5) {
+                        enumdirection = i > l ? EnumDirection.WEST : EnumDirection.EAST;
+                        vec3d = new Vec3D(d0, vec3d.y + d7 * d3, vec3d.z + d8 * d3);
+                    } else if (d4 < d5) {
+                        enumdirection = j > i1 ? EnumDirection.DOWN : EnumDirection.UP;
+                        vec3d = new Vec3D(vec3d.x + d6 * d4, d1, vec3d.z + d8 * d4);
+                    } else {
+                        enumdirection = k > j1 ? EnumDirection.NORTH : EnumDirection.SOUTH;
+                        vec3d = new Vec3D(vec3d.x + d6 * d5, vec3d.y + d7 * d5, d2);
+                    }
+
+                    l = MathHelper.floor(vec3d.x) - (enumdirection == EnumDirection.EAST ? 1 : 0);
+                    i1 = MathHelper.floor(vec3d.y) - (enumdirection == EnumDirection.UP ? 1 : 0);
+                    j1 = MathHelper.floor(vec3d.z) - (enumdirection == EnumDirection.SOUTH ? 1 : 0);
+                    blockposition = new BlockPosition(l, i1, j1);
+                    IBlockData iblockdata1 = this.getType(blockposition);
+                    Block block1 = iblockdata1.getBlock();
+
+                    if (!flag1 || iblockdata1.getMaterial() == Material.PORTAL || iblockdata1.d(this, blockposition) != Block.k) {
+                        if (block1.a(iblockdata1, flag)) {
+                            MovingObjectPosition movingobjectposition2 = iblockdata1.a(this, blockposition, vec3d, vec3d1);
+
+                            if (movingobjectposition2 != null) {
+                                return movingobjectposition2;
+                            }
+                        } else {
+                            movingobjectposition1 = new MovingObjectPosition(MovingObjectPosition.EnumMovingObjectType.MISS, vec3d, enumdirection, blockposition);
+                        }
+                    }
+                }
+
+                return flag2 ? movingobjectposition1 : null;
+            } else {
+                return null;
+            }
+        } else {
+            return null;
+        }
+    }
+
+    public void a(@Nullable EntityHuman entityhuman, BlockPosition blockposition, SoundEffect soundeffect, SoundCategory soundcategory, float f, float f1) {
+        this.a(entityhuman, (double) blockposition.getX() + 0.5D, (double) blockposition.getY() + 0.5D, (double) blockposition.getZ() + 0.5D, soundeffect, soundcategory, f, f1);
+    }
+
+    public void a(@Nullable EntityHuman entityhuman, double d0, double d1, double d2, SoundEffect soundeffect, SoundCategory soundcategory, float f, float f1) {
+        for (int i = 0; i < this.u.size(); ++i) {
+            ((IWorldAccess) this.u.get(i)).a(entityhuman, soundeffect, soundcategory, d0, d1, d2, f, f1);
+        }
+
+    }
+
+    public void a(double d0, double d1, double d2, SoundEffect soundeffect, SoundCategory soundcategory, float f, float f1, boolean flag) {}
+
+    public void a(BlockPosition blockposition, @Nullable SoundEffect soundeffect) {
+        for (int i = 0; i < this.u.size(); ++i) {
+            ((IWorldAccess) this.u.get(i)).a(soundeffect, blockposition);
+        }
+
+    }
+
+    public void addParticle(EnumParticle enumparticle, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
+        this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+    }
+
+    private void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
+        for (int j = 0; j < this.u.size(); ++j) {
+            ((IWorldAccess) this.u.get(j)).a(i, flag, d0, d1, d2, d3, d4, d5, aint);
+        }
+
+    }
+
+    public boolean strikeLightning(Entity entity) {
+        this.j.add(entity);
+        return true;
+    }
+
+    public boolean addEntity(Entity entity) {
+        // CraftBukkit start - Used for entities other than creatures
+        return addEntity(entity, SpawnReason.DEFAULT);
+    }
+
+    public boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
+        org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
+        if (entity == null) return false;
+        // CraftBukkit end
+        int i = MathHelper.floor(entity.locX / 16.0D);
+        int j = MathHelper.floor(entity.locZ / 16.0D);
+        boolean flag = entity.attachedToPlayer;
+
+        if (entity instanceof EntityHuman) {
+            flag = true;
+        }
+
+        // CraftBukkit start
+        org.bukkit.event.Cancellable event = null;
+        if (entity instanceof EntityLiving && !(entity instanceof EntityPlayer)) {
+            boolean isAnimal = entity instanceof EntityAnimal || entity instanceof EntityWaterAnimal || entity instanceof EntityGolem;
+            boolean isMonster = entity instanceof EntityMonster || entity instanceof EntityGhast || entity instanceof EntitySlime;
+
+            if (spawnReason != SpawnReason.CUSTOM) {
+                if (isAnimal && !allowAnimals || isMonster && !allowMonsters) {
+                    entity.dead = true;
+                    return false;
+                }
+            }
+
+            event = CraftEventFactory.callCreatureSpawnEvent((EntityLiving) entity, spawnReason);
+        } else if (entity instanceof EntityItem) {
+            event = CraftEventFactory.callItemSpawnEvent((EntityItem) entity);
+        } else if (entity.getBukkitEntity() instanceof org.bukkit.entity.Projectile) {
+            // Not all projectiles extend EntityProjectile, so check for Bukkit interface instead
+            event = CraftEventFactory.callProjectileLaunchEvent(entity);
+        }
+        // Spigot start
+        else if (entity instanceof EntityExperienceOrb) {
+            EntityExperienceOrb xp = (EntityExperienceOrb) entity;
+            double radius = spigotConfig.expMerge;
+            if (radius > 0) {
+                List<Entity> entities = this.getEntities(entity, entity.getBoundingBox().grow(radius, radius, radius));
+                for (Entity e : entities) {
+                    if (e instanceof EntityExperienceOrb) {
+                        EntityExperienceOrb loopItem = (EntityExperienceOrb) e;
+                        if (!loopItem.dead) {
+                            xp.value += loopItem.value;
+                            loopItem.die();
+                        }
+                    }
+                }
+            }
+        } // Spigot end
+
+        if (event != null && (event.isCancelled() || entity.dead)) {
+            entity.dead = true;
+            return false;
+        }
+        // CraftBukkit end
+
+
+        if (!flag && !this.isChunkLoaded(i, j, false)) {
+            return false;
+        } else {
+            if (entity instanceof EntityHuman) {
+                EntityHuman entityhuman = (EntityHuman) entity;
+
+                this.players.add(entityhuman);
+                this.everyoneSleeping();
+            }
+
+            this.getChunkAt(i, j).a(entity);
+            //this.entityList.add(entity);
+            this.entityQueue.add(entity);
+            this.b(entity);
+            return true;
+        }
+    }
+
+    protected void b(Entity entity) {
+        for (int i = 0; i < this.u.size(); ++i) {
+            ((IWorldAccess) this.u.get(i)).a(entity);
+        }
+
+        entity.valid = true; // CraftBukkit
+    }
+
+    protected void c(Entity entity) {
+        for (int i = 0; i < this.u.size(); ++i) {
+            ((IWorldAccess) this.u.get(i)).b(entity);
+        }
+
+        entity.valid = false; // CraftBukkit
+    }
+
+    public void kill(Entity entity) {
+        if (entity.isVehicle()) {
+            entity.az();
+        }
+
+        if (entity.isPassenger()) {
+            entity.stopRiding();
+        }
+
+        entity.die();
+        if (entity instanceof EntityHuman) {
+            this.players.remove(entity);
+            // Spigot start
+            for ( Object o : worldMaps.c )
+            {
+                if ( o instanceof WorldMap )
+                {
+                    WorldMap map = (WorldMap) o;
+                    map.j.remove( entity );
+                    for ( Iterator<WorldMap.WorldMapHumanTracker> iter = (Iterator<WorldMap.WorldMapHumanTracker>) map.h.iterator(); iter.hasNext(); )
+                    {
+                        if ( iter.next().trackee == entity )
+                        {
+                            iter.remove();
+                        }
+                    }
+                }
+            }
+            // Spigot end
+            this.everyoneSleeping();
+            this.c(entity);
+        }
+
+    }
+
+    public void removeEntity(Entity entity) {
+        org.spigotmc.AsyncCatcher.catchOp( "entity remove"); // Spigot
+        entity.b(false);
+        entity.die();
+        if (entity instanceof EntityHuman) {
+            this.players.remove(entity);
+            this.everyoneSleeping();
+        }
+
+        if (!guardEntityList) { // Spigot - It will get removed after the tick if we are ticking
+        int i = entity.ac;
+        int j = entity.ae;
+
+        if (entity.ab && this.isChunkLoaded(i, j, true)) {
+            this.getChunkAt(i, j).b(entity);
+        }
+
+        // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
+        //this.entityremoveList.add(entity);
+        this.entityQueue.remove(entity);
+        /*
+        int index = this.entityList.indexOf(entity);
+        if (index != -1) {
+            if (index <= this.tickPosition) {
+                this.tickPosition--;
+            }
+            this.entityList.remove(index);
+        }*/
+        // CraftBukkit end
+        } // Spigot
+        this.c(entity);
+    }
+
+    public void addIWorldAccess(IWorldAccess iworldaccess) {
+        this.u.add(iworldaccess);
+    }
+
+    public List<AxisAlignedBB> getCubes(@Nullable Entity entity, AxisAlignedBB axisalignedbb) {
+        ArrayList arraylist = Lists.newArrayList();
+        int i = MathHelper.floor(axisalignedbb.a) - 1;
+        int j = MathHelper.f(axisalignedbb.d) + 1;
+        int k = MathHelper.floor(axisalignedbb.b) - 1;
+        int l = MathHelper.f(axisalignedbb.e) + 1;
+        int i1 = MathHelper.floor(axisalignedbb.c) - 1;
+        int j1 = MathHelper.f(axisalignedbb.f) + 1;
+        WorldBorder worldborder = this.getWorldBorder();
+        boolean flag = entity != null && entity.br();
+        boolean flag1 = entity != null && this.a(worldborder, entity);
+        IBlockData iblockdata = Blocks.STONE.getBlockData();
+        BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
+
+        int k1;
+
+        for (int l1 = i; l1 < j; ++l1) {
+            for (k1 = i1; k1 < j1; ++k1) {
+                int i2 = (l1 != i && l1 != j - 1 ? 0 : 1) + (k1 != i1 && k1 != j1 - 1 ? 0 : 1);
+
+                if (i2 != 2 && this.isLoaded(blockposition_pooledblockposition.f(l1, 64, k1))) {
+                    for (int j2 = k; j2 < l; ++j2) {
+                        if (i2 <= 0 || j2 != k && j2 != l - 1) {
+                            blockposition_pooledblockposition.f(l1, j2, k1);
+                            if (entity != null) {
+                                if (flag && flag1) {
+                                    entity.k(false);
+                                } else if (!flag && !flag1) {
+                                    entity.k(true);
+                                }
+                            }
+
+                            IBlockData iblockdata1 = iblockdata;
+
+                            if (worldborder.a((BlockPosition) blockposition_pooledblockposition) || !flag1) {
+                                iblockdata1 = this.getType(blockposition_pooledblockposition);
+                            }
+
+                            iblockdata1.a(this, blockposition_pooledblockposition, axisalignedbb, arraylist, entity);
+                        }
+                    }
+                }
+            }
+        }
+
+        blockposition_pooledblockposition.t();
+        if (entity != null) {
+            List list = this.getEntities(entity, axisalignedbb.g(0.25D));
+
+            for (k1 = 0; k1 < list.size(); ++k1) {
+                Entity entity1 = (Entity) list.get(k1);
+
+                if (!entity.x(entity1)) {
+                    AxisAlignedBB axisalignedbb1 = entity1.ag();
+
+                    if (axisalignedbb1 != null && axisalignedbb1.b(axisalignedbb)) {
+                        arraylist.add(axisalignedbb1);
+                    }
+
+                    axisalignedbb1 = entity.j(entity1);
+                    if (axisalignedbb1 != null && axisalignedbb1.b(axisalignedbb)) {
+                        arraylist.add(axisalignedbb1);
+                    }
+                }
+            }
+        }
+
+        return arraylist;
+    }
+
+    public boolean a(WorldBorder worldborder, Entity entity) {
+        double d0 = worldborder.b();
+        double d1 = worldborder.c();
+        double d2 = worldborder.d();
+        double d3 = worldborder.e();
+
+        if (entity.br()) {
+            ++d0;
+            ++d1;
+            --d2;
+            --d3;
+        } else {
+            --d0;
+            --d1;
+            ++d2;
+            ++d3;
+        }
+
+        return entity.locX > d0 && entity.locX < d2 && entity.locZ > d1 && entity.locZ < d3;
+    }
+
+    public List<AxisAlignedBB> a(AxisAlignedBB axisalignedbb) {
+        ArrayList arraylist = Lists.newArrayList();
+        int i = MathHelper.floor(axisalignedbb.a) - 1;
+        int j = MathHelper.f(axisalignedbb.d) + 1;
+        int k = MathHelper.floor(axisalignedbb.b) - 1;
+        int l = MathHelper.f(axisalignedbb.e) + 1;
+        int i1 = MathHelper.floor(axisalignedbb.c) - 1;
+        int j1 = MathHelper.f(axisalignedbb.f) + 1;
+        BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
+
+        for (int k1 = i; k1 < j; ++k1) {
+            for (int l1 = i1; l1 < j1; ++l1) {
+                int i2 = (k1 != i && k1 != j - 1 ? 0 : 1) + (l1 != i1 && l1 != j1 - 1 ? 0 : 1);
+
+                if (i2 != 2 && this.isLoaded(blockposition_pooledblockposition.f(k1, 64, l1))) {
+                    for (int j2 = k; j2 < l; ++j2) {
+                        if (i2 <= 0 || j2 != k && j2 != l - 1) {
+                            blockposition_pooledblockposition.f(k1, j2, l1);
+                            IBlockData iblockdata;
+
+                            if (k1 >= -30000000 && k1 < 30000000 && l1 >= -30000000 && l1 < 30000000) {
+                                iblockdata = this.getType(blockposition_pooledblockposition);
+                            } else {
+                                iblockdata = Blocks.BEDROCK.getBlockData();
+                            }
+
+                            iblockdata.a(this, blockposition_pooledblockposition, axisalignedbb, arraylist, (Entity) null);
+                        }
+                    }
+                }
+            }
+        }
+
+        blockposition_pooledblockposition.t();
+        return arraylist;
+    }
+
+    public boolean b(AxisAlignedBB axisalignedbb) {
+        ArrayList arraylist = Lists.newArrayList();
+        int i = MathHelper.floor(axisalignedbb.a) - 1;
+        int j = MathHelper.f(axisalignedbb.d) + 1;
+        int k = MathHelper.floor(axisalignedbb.b) - 1;
+        int l = MathHelper.f(axisalignedbb.e) + 1;
+        int i1 = MathHelper.floor(axisalignedbb.c) - 1;
+        int j1 = MathHelper.f(axisalignedbb.f) + 1;
+        BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
+
+        try {
+            for (int k1 = i; k1 < j; ++k1) {
+                for (int l1 = i1; l1 < j1; ++l1) {
+                    int i2 = (k1 != i && k1 != j - 1 ? 0 : 1) + (l1 != i1 && l1 != j1 - 1 ? 0 : 1);
+
+                    if (i2 != 2 && this.isLoaded(blockposition_pooledblockposition.f(k1, 64, l1))) {
+                        for (int j2 = k; j2 < l; ++j2) {
+                            if (i2 <= 0 || j2 != k && j2 != l - 1) {
+                                blockposition_pooledblockposition.f(k1, j2, l1);
+                                if (k1 < -30000000 || k1 >= 30000000 || l1 < -30000000 || l1 >= 30000000) {
+                                    boolean flag = true;
+
+                                    return flag;
+                                }
+
+                                IBlockData iblockdata = this.getType(blockposition_pooledblockposition);
+
+                                iblockdata.a(this, blockposition_pooledblockposition, axisalignedbb, arraylist, (Entity) null);
+                                if (!arraylist.isEmpty()) {
+                                    boolean flag1 = true;
+
+                                    return flag1;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+
+            return false;
+        } finally {
+            blockposition_pooledblockposition.t();
+        }
+    }
+
+    public int a(float f) {
+        float f1 = this.c(f);
+        float f2 = 1.0F - (MathHelper.cos(f1 * 6.2831855F) * 2.0F + 0.5F);
+
+        f2 = MathHelper.a(f2, 0.0F, 1.0F);
+        f2 = 1.0F - f2;
+        f2 = (float) ((double) f2 * (1.0D - (double) (this.j(f) * 5.0F) / 16.0D));
+        f2 = (float) ((double) f2 * (1.0D - (double) (this.h(f) * 5.0F) / 16.0D));
+        f2 = 1.0F - f2;
+        return (int) (f2 * 11.0F);
+    }
+
+    public float c(float f) {
+        return this.worldProvider.a(this.worldData.getDayTime(), f);
+    }
+
+    public float E() {
+        return WorldProvider.a[this.worldProvider.a(this.worldData.getDayTime())];
+    }
+
+    public float d(float f) {
+        float f1 = this.c(f);
+
+        return f1 * 6.2831855F;
+    }
+
+    public BlockPosition p(BlockPosition blockposition) {
+        return this.getChunkAtWorldCoords(blockposition).f(blockposition);
+    }
+
+    public BlockPosition q(BlockPosition blockposition) {
+        Chunk chunk = this.getChunkAtWorldCoords(blockposition);
+
+        BlockPosition blockposition1;
+        BlockPosition blockposition2;
+
+        for (blockposition1 = new BlockPosition(blockposition.getX(), chunk.g() + 16, blockposition.getZ()); blockposition1.getY() >= 0; blockposition1 = blockposition2) {
+            blockposition2 = blockposition1.down();
+            Material material = chunk.getBlockData(blockposition2).getMaterial();
+
+            if (material.isSolid() && material != Material.LEAVES) {
+                break;
+            }
+        }
+
+        return blockposition1;
+    }
+
+    public boolean b(BlockPosition blockposition, Block block) {
+        return true;
+    }
+
+    public void a(BlockPosition blockposition, Block block, int i) {}
+
+    public void a(BlockPosition blockposition, Block block, int i, int j) {}
+
+    public void b(BlockPosition blockposition, Block block, int i, int j) {}
+
+    CrashReportSystemDetails crashreportsystemdetails1;
+    CrashReport crashreport1;
+    public void tickEntities() {
+        this.methodProfiler.a("entities");
+        this.methodProfiler.a("global");
+
+        int i;
+        //Entity entity;
+        
+        this.j.parallelStream().forEachOrdered(entity -> {
+            if (entity == null) {
+                return;
+            }
+            // CraftBukkit end
+
+            try {
+                ++entity.ticksLived;
+                entity.m();
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Ticking entity");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being ticked");
+
+                if (entity == null) {
+                    crashreportsystemdetails.a("Entity", (Object) "~~NULL~~");
+                } else {
+                    entity.appendEntityCrashDetails(crashreportsystemdetails);
+                }
+
+                throw new ReportedException(crashreport);
+            }
+
+            if (entity.dead) {
+                this.j.remove(entity);
+            }
+        });
+        /*
+        for (i = 0; i < this.j.size(); ++i) {
+            entity = (Entity) this.j.get(i);
+            // CraftBukkit start - Fixed an NPE
+            if (entity == null) {
+                continue;
+            }
+            // CraftBukkit end
+
+            try {
+                ++entity.ticksLived;
+                entity.m();
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Ticking entity");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being ticked");
+
+                if (entity == null) {
+                    crashreportsystemdetails.a("Entity", (Object) "~~NULL~~");
+                } else {
+                    entity.appendEntityCrashDetails(crashreportsystemdetails);
+                }
+
+                throw new ReportedException(crashreport);
+            }
+
+            if (entity.dead) {
+                this.j.remove(i--);
+            }
+        }*/
+
+        this.methodProfiler.c("remove");
+        //this.entityList.removeAll(this.f);
+        this.entityQueue.removeAll(this.f);
+
+        //int j;
+        this.f.parallelStream().filter(ent -> ent.ab && this.isChunkLoaded(ent.ac, ent.ae, true)).forEach(ent -> {
+            this.getChunkAt(ent.ac, ent.ae).b(ent);
+        });
+        
+        /*
+        for (i = 0; i < this.f.size(); ++i) {
+            entity = (Entity) this.f.get(i);
+            int k = entity.ac;
+
+            int j = entity.ae;
+            if (entity.ab && this.isChunkLoaded(k, j, true)) {
+                this.getChunkAt(k, j).b(entity);
+            }
+        }*/
+        while (!this.f.isEmpty()) {
+            this.c((Entity) this.f.poll());
+        }
+        /*
+        for (i = 0; i < this.f.size(); ++i) {
+            this.c((Entity) this.f.get(i));
+        }*/
+
+        this.f.clear();
+        this.l();
+        this.methodProfiler.c("regular");
+        /*
+        CrashReportSystemDetails crashreportsystemdetails1;
+        CrashReport crashreport1;*/
+
+        org.spigotmc.ActivationRange.activateEntities(this); // Spigot
+        timings.entityTick.startTiming(); // Spigot
+        //this.entityQueue = new ConcurrentLinkedQueue(this.entityList);
+        guardEntityList = true; // Spigot
+        // CraftBukkit start - Use field for loop variable
+        //int entitiesThisCycle = 0;
+        //if (tickPosition < 0) tickPosition = 0;
+        this.entityQueue.parallelStream().forEach(ent -> {
+            Entity entity1 = ent.bB();
+            
+            if (entity1 != null) {
+                if (!entity1.dead && entity1.w(ent)) {
+                    return;
+                }
+
+                ent.stopRiding();
+            }
+            
+            this.methodProfiler.a("tick");
+            if (!ent.dead && !(ent instanceof EntityPlayer)) {
+                try {
+                    SpigotTimings.tickEntityTimer.startTiming(); // Spigot
+                    this.g(ent);
+                    SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
+                } catch (Throwable throwable1) {
+                    crashreport1 = CrashReport.a(throwable1, "Ticking entity");
+                    crashreportsystemdetails1 = crashreport1.a("Entity being ticked");
+                    ent.appendEntityCrashDetails(crashreportsystemdetails1);
+                    throw new ReportedException(crashreport1);
+                }
+            }
+
+            this.methodProfiler.b();
+            this.methodProfiler.a("remove");
+            if (ent.dead) {
+                int j = ent.ac;
+                int l = ent.ae;
+
+                if (ent.ab && this.isChunkLoaded(j, l, true)) {
+                    this.getChunkAt(j, l).b(ent);
+                }
+                //this.entityremoveList.add(ent);
+                this.entityQueue.remove(ent);
+                this.c(ent);
+            }
+
+            this.methodProfiler.b();
+        });
+        /*
+        for (entityLimiter.initTick();
+                entitiesThisCycle < entityList.size() && (entitiesThisCycle % 10 != 0 || entityLimiter.shouldContinue());
+                tickPosition++, entitiesThisCycle++) {
+            tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
+            entity = (Entity) this.entityList.get(this.tickPosition);
+            // CraftBukkit end
+            Entity entity1 = entity.bB();
+
+            if (entity1 != null) {
+                if (!entity1.dead && entity1.w(entity)) {
+                    continue;
+                }
+
+                entity.stopRiding();
+            }
+
+            this.methodProfiler.a("tick");
+            if (!entity.dead && !(entity instanceof EntityPlayer)) {
+                try {
+                    SpigotTimings.tickEntityTimer.startTiming(); // Spigot
+                    this.g(entity);
+                    SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
+                } catch (Throwable throwable1) {
+                    crashreport1 = CrashReport.a(throwable1, "Ticking entity");
+                    crashreportsystemdetails1 = crashreport1.a("Entity being ticked");
+                    entity.appendEntityCrashDetails(crashreportsystemdetails1);
+                    throw new ReportedException(crashreport1);
+                }
+            }
+
+            this.methodProfiler.b();
+            this.methodProfiler.a("remove");
+            if (entity.dead) {
+                j = entity.ac;
+                int l = entity.ae;
+
+                if (entity.ab && this.isChunkLoaded(j, l, true)) {
+                    this.getChunkAt(j, l).b(entity);
+                }
+
+                guardEntityList = false; // Spigot
+                this.entityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
+                guardEntityList = true; // Spigot
+                this.c(entity);
+            }
+
+            this.methodProfiler.b();
+        }*/
+        guardEntityList = false; // Spigot
+        /*
+        guardEntityList = true;
+        if (!this.entityremoveList.isEmpty()) {
+            this.entityList.removeAll(this.entityremoveList);
+            this.entityremoveList.clear();
+        }
+        guardEntityList = false;*/
+
+        timings.entityTick.stopTiming(); // Spigot
+        this.methodProfiler.c("blockEntities");
+        this.M = true;
+        timings.tileEntityTick.startTiming(); // Spigot
+        // CraftBukkit start - From below, clean up tile entities before ticking them
+        if (!this.tileEntityListUnload.isEmpty()) {
+            this.tileEntityListTick.removeAll(this.tileEntityListUnload);
+            this.tileEntityList.removeAll(this.tileEntityListUnload);
+            this.tileEntityListUnload.clear();
+        }
+        // CraftBukkit end
+
+        // Spigot start
+        // Iterator iterator = this.tileEntityListTick.iterator();
+        this.tileEntityListTick.parallelStream().forEachOrdered(tileentity -> {
+            if (tileentity == null) {
+                getServer().getLogger().severe("Spigot has detected a null entity and has removed it, preventing a crash");
+                //this.tileEntityListTick.remove(tileTickPosition--);
+                this.tileEntityListUnload.add(tileentity);
+                return;
+            }
+            // Spigot end
+           
+            if (!tileentity.x() && tileentity.t()) {
+                BlockPosition blockposition = tileentity.getPosition();
+
+                if (this.isLoaded(blockposition) && this.N.a(blockposition)) {
+                    try {
+                        this.methodProfiler.a(""); // CraftBukkit: SPIGOT-1900
+                        tileentity.tickTimer.startTiming(); // Spigot
+                        ((ITickable) tileentity).E_();
+                        this.methodProfiler.b();
+                    } catch (Throwable throwable2) {
+                        crashreport1 = CrashReport.a(throwable2, "Ticking block entity");
+                        crashreportsystemdetails1 = crashreport1.a("Block entity being ticked");
+                        tileentity.a(crashreportsystemdetails1);
+                        throw new ReportedException(crashreport1);
+                    }
+                    // Spigot start
+                    finally {
+                        tileentity.tickTimer.stopTiming();
+                    }
+                    // Spigot end
+                }
+            }
+
+            if (tileentity.x()) {
+                this.tileEntityListUnload.add(tileentity);
+                /*
+                this.tileEntityListTick.remove(tileentity);
+                this.tileEntityList.remove(tileentity);*/
+                if (this.isLoaded(tileentity.getPosition())) {
+                    this.getChunkAtWorldCoords(tileentity.getPosition()).d(tileentity.getPosition());
+                }
+            }
+        });
+        if (!this.tileEntityListUnload.isEmpty()) {
+            this.tileEntityListTick.removeAll(this.tileEntityListUnload);
+            this.tileEntityList.removeAll(this.tileEntityListUnload);
+            this.tileEntityListUnload.clear();
+        }
+        /*
+        int tilesThisCycle = 0;
+        
+        for (tileLimiter.initTick();
+                tilesThisCycle < tileEntityListTick.size() && (tilesThisCycle % 10 != 0 || tileLimiter.shouldContinue());
+                tileTickPosition++, tilesThisCycle++) {
+            tileTickPosition = (tileTickPosition < tileEntityListTick.size()) ? tileTickPosition : 0;
+            TileEntity tileentity = (TileEntity) this.tileEntityListTick.get(tileTickPosition);
+            // Spigot start
+            if (tileentity == null) {
+                getServer().getLogger().severe("Spigot has detected a null entity and has removed it, preventing a crash");
+                tilesThisCycle--;
+                this.tileEntityListTick.remove(tileTickPosition--);
+                continue;
+            }
+            // Spigot end
+           
+            if (!tileentity.x() && tileentity.t()) {
+                BlockPosition blockposition = tileentity.getPosition();
+
+                if (this.isLoaded(blockposition) && this.N.a(blockposition)) {
+                    try {
+                        this.methodProfiler.a(""); // CraftBukkit: SPIGOT-1900
+                        tileentity.tickTimer.startTiming(); // Spigot
+                        ((ITickable) tileentity).E_();
+                        this.methodProfiler.b();
+                    } catch (Throwable throwable2) {
+                        crashreport1 = CrashReport.a(throwable2, "Ticking block entity");
+                        crashreportsystemdetails1 = crashreport1.a("Block entity being ticked");
+                        tileentity.a(crashreportsystemdetails1);
+                        throw new ReportedException(crashreport1);
+                    }
+                    // Spigot start
+                    finally {
+                        tileentity.tickTimer.stopTiming();
+                    }
+                    // Spigot end
+                }
+            }
+
+            if (tileentity.x()) {
+                tilesThisCycle--;
+                this.tileEntityListTick.remove(tileTickPosition--);
+                this.tileEntityList.remove(tileentity);
+                if (this.isLoaded(tileentity.getPosition())) {
+                    this.getChunkAtWorldCoords(tileentity.getPosition()).d(tileentity.getPosition());
+                }
+            }
+        }*/
+
+        timings.tileEntityTick.stopTiming(); // Spigot
+        timings.tileEntityPending.startTiming(); // Spigot
+        this.M = false;
+        /* CraftBukkit start - Moved up
+        if (!this.tileEntityListUnload.isEmpty()) {
+            this.tileEntityListTick.removeAll(this.tileEntityListUnload);
+            this.tileEntityList.removeAll(this.tileEntityListUnload);
+            this.tileEntityListUnload.clear();
+        }
+        // CraftBukkit end */
+
+        this.methodProfiler.c("pendingBlockEntities");
+        if (!this.b.isEmpty()) {
+            this.b.parallelStream().filter(tileentity1 -> !tileentity1.x()).forEachOrdered(tileentity1 -> {
+                if (this.isLoaded(tileentity1.getPosition())) {
+                    Chunk chunk = this.getChunkAtWorldCoords(tileentity1.getPosition());
+                    IBlockData iblockdata = chunk.getBlockData(tileentity1.getPosition());
+
+                    chunk.a(tileentity1.getPosition(), tileentity1);
+                    this.notify(tileentity1.getPosition(), iblockdata, iblockdata, 3);
+                    // CraftBukkit start
+                    // From above, don't screw this up - SPIGOT-1746
+                    if (!this.tileEntityList.contains(tileentity1)) {
+                        this.a(tileentity1);
+                    }
+                    // CraftBukkit end
+                }
+            });
+            /*
+            for (int i1 = 0; i1 < this.b.size(); ++i1) {
+                TileEntity tileentity1 = (TileEntity) this.b.get(i1);
+
+                if (!tileentity1.x()) {
+
+                    if (this.isLoaded(tileentity1.getPosition())) {
+                        Chunk chunk = this.getChunkAtWorldCoords(tileentity1.getPosition());
+                        IBlockData iblockdata = chunk.getBlockData(tileentity1.getPosition());
+
+                        chunk.a(tileentity1.getPosition(), tileentity1);
+                        this.notify(tileentity1.getPosition(), iblockdata, iblockdata, 3);
+                        // CraftBukkit start
+                        // From above, don't screw this up - SPIGOT-1746
+                        if (!this.tileEntityList.contains(tileentity1)) {
+                            this.a(tileentity1);
+                        }
+                        // CraftBukkit end
+                    }
+                }
+            }*/
+
+            this.b.clear();
+        }
+
+        timings.tileEntityPending.stopTiming(); // Spigot
+        this.methodProfiler.b();
+        this.methodProfiler.b();
+    }
+
+    protected void l() {}
+
+    public boolean a(TileEntity tileentity) {
+        boolean flag = this.tileEntityList.add(tileentity);
+
+        if (flag && tileentity instanceof ITickable) {
+            this.tileEntityListTick.add(tileentity);
+        }
+
+        if (this.isClientSide) {
+            BlockPosition blockposition = tileentity.getPosition();
+            IBlockData iblockdata = this.getType(blockposition);
+
+            this.notify(blockposition, iblockdata, iblockdata, 2);
+        }
+
+        return flag;
+    }
+
+    public void b(Collection<TileEntity> collection) {
+        if (this.M) {
+            this.b.addAll(collection);
+        } else {
+            Iterator iterator = collection.iterator();
+
+            while (iterator.hasNext()) {
+                TileEntity tileentity = (TileEntity) iterator.next();
+
+                this.a(tileentity);
+            }
+        }
+
+    }
+
+    public void g(Entity entity) {
+        this.entityJoinedWorld(entity, true);
+    }
+
+    public void entityJoinedWorld(Entity entity, boolean flag) {
+        int i = MathHelper.floor(entity.locX);
+        int j = MathHelper.floor(entity.locZ);
+        boolean flag1 = true;
+
+        // Spigot start
+        if (flag && !org.spigotmc.ActivationRange.checkIfActive(entity)) {
+            entity.ticksLived++;
+            entity.inactiveTick();
+        } else {
+            entity.tickTimer.startTiming(); // Spigot
+            // CraftBukkit end
+            entity.M = entity.locX;
+            entity.N = entity.locY;
+            entity.O = entity.locZ;
+            entity.lastYaw = entity.yaw;
+            entity.lastPitch = entity.pitch;
+            if (flag && entity.ab) {//where to poll a ConcurrentModificationException
+                ++entity.ticksLived;
+                if (entity.isPassenger()) {
+                    entity.aw();
+                } else {
+                    entity.m();
+                }
+            }
+
+            this.methodProfiler.a("chunkCheck");
+            if (Double.isNaN(entity.locX) || Double.isInfinite(entity.locX)) {
+                entity.locX = entity.M;
+            }
+
+            if (Double.isNaN(entity.locY) || Double.isInfinite(entity.locY)) {
+                entity.locY = entity.N;
+            }
+
+            if (Double.isNaN(entity.locZ) || Double.isInfinite(entity.locZ)) {
+                entity.locZ = entity.O;
+            }
+
+            if (Double.isNaN((double) entity.pitch) || Double.isInfinite((double) entity.pitch)) {
+                entity.pitch = entity.lastPitch;
+            }
+
+            if (Double.isNaN((double) entity.yaw) || Double.isInfinite((double) entity.yaw)) {
+                entity.yaw = entity.lastYaw;
+            }
+
+            int k = MathHelper.floor(entity.locX / 16.0D);
+            int l = MathHelper.floor(entity.locY / 16.0D);
+            int i1 = MathHelper.floor(entity.locZ / 16.0D);
+
+            if (!entity.ab || entity.ac != k || entity.ad != l || entity.ae != i1) {
+                if (entity.ab && this.isChunkLoaded(entity.ac, entity.ae, true)) {
+                    this.getChunkAt(entity.ac, entity.ae).a(entity, entity.ad);
+                }
+
+                if (!entity.bv() && !this.isChunkLoaded(k, i1, true)) {
+                    entity.ab = false;
+                } else {
+                    this.getChunkAt(k, i1).a(entity);
+                }
+            }
+
+            this.methodProfiler.b();
+            if (flag && entity.ab) {
+                Iterator iterator = entity.bx().iterator();
+
+                while (iterator.hasNext()) {
+                    Entity entity1 = (Entity) iterator.next();
+
+                    if (!entity1.dead && entity1.bB() == entity) {
+                        this.g(entity1);
+                    } else {
+                        entity1.stopRiding();
+                    }
+                }
+            }
+
+            entity.tickTimer.stopTiming(); // Spigot
+        }
+    }
+
+    public boolean c(AxisAlignedBB axisalignedbb) {
+        return this.a(axisalignedbb, (Entity) null);
+    }
+
+    public boolean a(AxisAlignedBB axisalignedbb, @Nullable Entity entity) {
+        List list = this.getEntities((Entity) null, axisalignedbb);
+
+        for (int i = 0; i < list.size(); ++i) {
+            Entity entity1 = (Entity) list.get(i);
+
+            if (!entity1.dead && entity1.i && entity1 != entity && (entity == null || entity1.x(entity))) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public boolean d(AxisAlignedBB axisalignedbb) {
+        int i = MathHelper.floor(axisalignedbb.a);
+        int j = MathHelper.f(axisalignedbb.d);
+        int k = MathHelper.floor(axisalignedbb.b);
+        int l = MathHelper.f(axisalignedbb.e);
+        int i1 = MathHelper.floor(axisalignedbb.c);
+        int j1 = MathHelper.f(axisalignedbb.f);
+        BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
+
+        for (int k1 = i; k1 < j; ++k1) {
+            for (int l1 = k; l1 < l; ++l1) {
+                for (int i2 = i1; i2 < j1; ++i2) {
+                    IBlockData iblockdata = this.getType(blockposition_pooledblockposition.f(k1, l1, i2));
+
+                    if (iblockdata.getMaterial() != Material.AIR) {
+                        blockposition_pooledblockposition.t();
+                        return true;
+                    }
+                }
+            }
+        }
+
+        blockposition_pooledblockposition.t();
+        return false;
+    }
+
+    public boolean containsLiquid(AxisAlignedBB axisalignedbb) {
+        int i = MathHelper.floor(axisalignedbb.a);
+        int j = MathHelper.f(axisalignedbb.d);
+        int k = MathHelper.floor(axisalignedbb.b);
+        int l = MathHelper.f(axisalignedbb.e);
+        int i1 = MathHelper.floor(axisalignedbb.c);
+        int j1 = MathHelper.f(axisalignedbb.f);
+        BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
+
+        for (int k1 = i; k1 < j; ++k1) {
+            for (int l1 = k; l1 < l; ++l1) {
+                for (int i2 = i1; i2 < j1; ++i2) {
+                    IBlockData iblockdata = this.getType(blockposition_pooledblockposition.f(k1, l1, i2));
+
+                    if (iblockdata.getMaterial().isLiquid()) {
+                        blockposition_pooledblockposition.t();
+                        return true;
+                    }
+                }
+            }
+        }
+
+        blockposition_pooledblockposition.t();
+        return false;
+    }
+
+    public boolean f(AxisAlignedBB axisalignedbb) {
+        int i = MathHelper.floor(axisalignedbb.a);
+        int j = MathHelper.f(axisalignedbb.d);
+        int k = MathHelper.floor(axisalignedbb.b);
+        int l = MathHelper.f(axisalignedbb.e);
+        int i1 = MathHelper.floor(axisalignedbb.c);
+        int j1 = MathHelper.f(axisalignedbb.f);
+
+        if (this.isAreaLoaded(i, k, i1, j, l, j1, true)) {
+            BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
+            int k1 = i;
+
+            while (true) {
+                if (k1 >= j) {
+                    blockposition_pooledblockposition.t();
+                    break;
+                }
+
+                for (int l1 = k; l1 < l; ++l1) {
+                    for (int i2 = i1; i2 < j1; ++i2) {
+                        Block block = this.getType(blockposition_pooledblockposition.f(k1, l1, i2)).getBlock();
+
+                        if (block == Blocks.FIRE || block == Blocks.FLOWING_LAVA || block == Blocks.LAVA) {
+                            blockposition_pooledblockposition.t();
+                            return true;
+                        }
+                    }
+                }
+
+                ++k1;
+            }
+        }
+
+        return false;
+    }
+
+    public boolean a(AxisAlignedBB axisalignedbb, Material material, Entity entity) {
+        int i = MathHelper.floor(axisalignedbb.a);
+        int j = MathHelper.f(axisalignedbb.d);
+        int k = MathHelper.floor(axisalignedbb.b);
+        int l = MathHelper.f(axisalignedbb.e);
+        int i1 = MathHelper.floor(axisalignedbb.c);
+        int j1 = MathHelper.f(axisalignedbb.f);
+
+        if (!this.isAreaLoaded(i, k, i1, j, l, j1, true)) {
+            return false;
+        } else {
+            boolean flag = false;
+            Vec3D vec3d = Vec3D.a;
+            BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
+
+            for (int k1 = i; k1 < j; ++k1) {
+                for (int l1 = k; l1 < l; ++l1) {
+                    for (int i2 = i1; i2 < j1; ++i2) {
+                        blockposition_pooledblockposition.f(k1, l1, i2);
+                        IBlockData iblockdata = this.getType(blockposition_pooledblockposition);
+                        Block block = iblockdata.getBlock();
+
+                        if (iblockdata.getMaterial() == material) {
+                            double d0 = (double) ((float) (l1 + 1) - BlockFluids.e(((Integer) iblockdata.get(BlockFluids.LEVEL)).intValue()));
+
+                            if ((double) l >= d0) {
+                                flag = true;
+                                vec3d = block.a(this, (BlockPosition) blockposition_pooledblockposition, entity, vec3d);
+                            }
+                        }
+                    }
+                }
+            }
+
+            blockposition_pooledblockposition.t();
+            if (vec3d.b() > 0.0D && entity.bg()) {
+                vec3d = vec3d.a();
+                double d1 = 0.014D;
+
+                entity.motX += vec3d.x * 0.014D;
+                entity.motY += vec3d.y * 0.014D;
+                entity.motZ += vec3d.z * 0.014D;
+            }
+
+            return flag;
+        }
+    }
+
+    public boolean a(AxisAlignedBB axisalignedbb, Material material) {
+        int i = MathHelper.floor(axisalignedbb.a);
+        int j = MathHelper.f(axisalignedbb.d);
+        int k = MathHelper.floor(axisalignedbb.b);
+        int l = MathHelper.f(axisalignedbb.e);
+        int i1 = MathHelper.floor(axisalignedbb.c);
+        int j1 = MathHelper.f(axisalignedbb.f);
+        BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
+
+        for (int k1 = i; k1 < j; ++k1) {
+            for (int l1 = k; l1 < l; ++l1) {
+                for (int i2 = i1; i2 < j1; ++i2) {
+                    if (this.getType(blockposition_pooledblockposition.f(k1, l1, i2)).getMaterial() == material) {
+                        blockposition_pooledblockposition.t();
+                        return true;
+                    }
+                }
+            }
+        }
+
+        blockposition_pooledblockposition.t();
+        return false;
+    }
+
+    public boolean b(AxisAlignedBB axisalignedbb, Material material) {
+        int i = MathHelper.floor(axisalignedbb.a);
+        int j = MathHelper.f(axisalignedbb.d);
+        int k = MathHelper.floor(axisalignedbb.b);
+        int l = MathHelper.f(axisalignedbb.e);
+        int i1 = MathHelper.floor(axisalignedbb.c);
+        int j1 = MathHelper.f(axisalignedbb.f);
+        BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
+
+        for (int k1 = i; k1 < j; ++k1) {
+            for (int l1 = k; l1 < l; ++l1) {
+                for (int i2 = i1; i2 < j1; ++i2) {
+                    IBlockData iblockdata = this.getType(blockposition_pooledblockposition.f(k1, l1, i2));
+
+                    if (iblockdata.getMaterial() == material) {
+                        int j2 = ((Integer) iblockdata.get(BlockFluids.LEVEL)).intValue();
+                        double d0 = (double) (l1 + 1);
+
+                        if (j2 < 8) {
+                            d0 = (double) (l1 + 1) - (double) j2 / 8.0D;
+                        }
+
+                        if (d0 >= axisalignedbb.b) {
+                            blockposition_pooledblockposition.t();
+                            return true;
+                        }
+                    }
+                }
+            }
+        }
+
+        blockposition_pooledblockposition.t();
+        return false;
+    }
+
+    public Explosion explode(@Nullable Entity entity, double d0, double d1, double d2, float f, boolean flag) {
+        return this.createExplosion(entity, d0, d1, d2, f, false, flag);
+    }
+
+    public Explosion createExplosion(@Nullable Entity entity, double d0, double d1, double d2, float f, boolean flag, boolean flag1) {
+        Explosion explosion = new Explosion(this, entity, d0, d1, d2, f, flag, flag1);
+
+        explosion.a();
+        explosion.a(true);
+        return explosion;
+    }
+
+    public float a(Vec3D vec3d, AxisAlignedBB axisalignedbb) {
+        double d0 = 1.0D / ((axisalignedbb.d - axisalignedbb.a) * 2.0D + 1.0D);
+        double d1 = 1.0D / ((axisalignedbb.e - axisalignedbb.b) * 2.0D + 1.0D);
+        double d2 = 1.0D / ((axisalignedbb.f - axisalignedbb.c) * 2.0D + 1.0D);
+        double d3 = (1.0D - Math.floor(1.0D / d0) * d0) / 2.0D;
+        double d4 = (1.0D - Math.floor(1.0D / d2) * d2) / 2.0D;
+
+        if (d0 >= 0.0D && d1 >= 0.0D && d2 >= 0.0D) {
+            int i = 0;
+            int j = 0;
+
+            for (float f = 0.0F; f <= 1.0F; f = (float) ((double) f + d0)) {
+                for (float f1 = 0.0F; f1 <= 1.0F; f1 = (float) ((double) f1 + d1)) {
+                    for (float f2 = 0.0F; f2 <= 1.0F; f2 = (float) ((double) f2 + d2)) {
+                        double d5 = axisalignedbb.a + (axisalignedbb.d - axisalignedbb.a) * (double) f;
+                        double d6 = axisalignedbb.b + (axisalignedbb.e - axisalignedbb.b) * (double) f1;
+                        double d7 = axisalignedbb.c + (axisalignedbb.f - axisalignedbb.c) * (double) f2;
+
+                        if (this.rayTrace(new Vec3D(d5 + d3, d6, d7 + d4), vec3d) == null) {
+                            ++i;
+                        }
+
+                        ++j;
+                    }
+                }
+            }
+
+            return (float) i / (float) j;
+        } else {
+            return 0.0F;
+        }
+    }
+
+    public boolean douseFire(@Nullable EntityHuman entityhuman, BlockPosition blockposition, EnumDirection enumdirection) {
+        blockposition = blockposition.shift(enumdirection);
+        if (this.getType(blockposition).getBlock() == Blocks.FIRE) {
+            this.a(entityhuman, 1009, blockposition, 0);
+            this.setAir(blockposition);
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public Map<BlockPosition, TileEntity> capturedTileEntities = Maps.newHashMap();
+    @Nullable
+    public TileEntity getTileEntity(BlockPosition blockposition) {
+        if (this.E(blockposition)) {
+            return null;
+        } else {
+            // CraftBukkit start
+            if (capturedTileEntities.containsKey(blockposition)) {
+                return capturedTileEntities.get(blockposition);
+            }
+            // CraftBukkit end
+
+            TileEntity tileentity = null;
+
+            if (this.M) {
+                tileentity = this.F(blockposition);
+            }
+
+            if (tileentity == null) {
+                tileentity = this.getChunkAtWorldCoords(blockposition).a(blockposition, Chunk.EnumTileEntityState.IMMEDIATE);
+            }
+
+            if (tileentity == null) {
+                tileentity = this.F(blockposition);
+            }
+
+            return tileentity;
+        }
+    }
+
+    @Nullable
+    private TileEntity F(BlockPosition blockposition) {
+        for (int i = 0; i < this.b.size(); ++i) {
+            TileEntity tileentity = (TileEntity) this.b.get(i);
+
+            if (!tileentity.x() && tileentity.getPosition().equals(blockposition)) {
+                return tileentity;
+            }
+        }
+
+        return null;
+    }
+
+    public void setTileEntity(BlockPosition blockposition, @Nullable TileEntity tileentity) {
+        if (!this.E(blockposition)) {
+            if (tileentity != null && !tileentity.x()) {
+            // CraftBukkit start
+            if (captureBlockStates) {
+                tileentity.a(this);
+                tileentity.setPosition(blockposition);
+                capturedTileEntities.put(blockposition, tileentity);
+                return;
+            }
+            // CraftBukkit end
+                if (this.M) {
+                    tileentity.setPosition(blockposition);
+                    Iterator iterator = this.b.iterator();
+
+                    while (iterator.hasNext()) {
+                        TileEntity tileentity1 = (TileEntity) iterator.next();
+
+                        if (tileentity1.getPosition().equals(blockposition)) {
+                            tileentity1.y();
+                            iterator.remove();
+                        }
+                    }
+
+                    tileentity.a(this); // Spigot - No null worlds
+                    this.b.add(tileentity);
+                } else {
+                    this.a(tileentity);
+                    this.getChunkAtWorldCoords(blockposition).a(blockposition, tileentity);
+                }
+            }
+
+        }
+    }
+
+    public void s(BlockPosition blockposition) {
+        TileEntity tileentity = this.getTileEntity(blockposition);
+
+        if (tileentity != null && this.M) {
+            tileentity.y();
+            this.b.remove(tileentity);
+        } else {
+            if (tileentity != null) {
+                this.tileEntityListUnload.add(tileentity);
+                /*
+                this.b.remove(tileentity);
+                this.tileEntityList.remove(tileentity);
+                this.tileEntityListTick.remove(tileentity);*/
+            }
+
+            this.getChunkAtWorldCoords(blockposition).d(blockposition);
+        }
+
+    }
+
+    public void b(TileEntity tileentity) {
+        this.tileEntityListUnload.add(tileentity);
+    }
+
+    public boolean t(BlockPosition blockposition) {
+        AxisAlignedBB axisalignedbb = this.getType(blockposition).d(this, blockposition);
+
+        return axisalignedbb != Block.k && axisalignedbb.a() >= 1.0D;
+    }
+
+    public boolean d(BlockPosition blockposition, boolean flag) {
+        if (this.E(blockposition)) {
+            return false;
+        } else {
+            Chunk chunk = this.chunkProvider.getLoadedChunkAt(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+
+            if (chunk != null && !chunk.isEmpty()) {
+                IBlockData iblockdata = this.getType(blockposition);
+
+                return iblockdata.getMaterial().k() && iblockdata.h();
+            } else {
+                return flag;
+            }
+        }
+    }
+
+    public void H() {
+        int i = this.a(1.0F);
+
+        if (i != this.J) {
+            this.J = i;
+        }
+
+    }
+
+    public void setSpawnFlags(boolean flag, boolean flag1) {
+        this.allowMonsters = flag;
+        this.allowAnimals = flag1;
+    }
+
+    public void doTick() {
+        this.t();
+    }
+
+    protected void I() {
+        if (this.worldData.hasStorm()) {
+            this.o = 1.0F;
+            if (this.worldData.isThundering()) {
+                this.q = 1.0F;
+            }
+        }
+
+    }
+
+    protected void t() {
+        if (!this.worldProvider.m()) {
+            if (!this.isClientSide) {
+                int i = this.worldData.z();
+
+                if (i > 0) {
+                    --i;
+                    this.worldData.i(i);
+                    this.worldData.setThunderDuration(this.worldData.isThundering() ? 1 : 2);
+                    this.worldData.setWeatherDuration(this.worldData.hasStorm() ? 1 : 2);
+                }
+
+                int j = this.worldData.getThunderDuration();
+
+                if (j <= 0) {
+                    if (this.worldData.isThundering()) {
+                        this.worldData.setThunderDuration(this.random.nextInt(12000) + 3600);
+                    } else {
+                        this.worldData.setThunderDuration(this.random.nextInt(168000) + 12000);
+                    }
+                } else {
+                    --j;
+                    this.worldData.setThunderDuration(j);
+                    if (j <= 0) {
+                        this.worldData.setThundering(!this.worldData.isThundering());
+                    }
+                }
+
+                this.p = this.q;
+                if (this.worldData.isThundering()) {
+                    this.q = (float) ((double) this.q + 0.01D);
+                } else {
+                    this.q = (float) ((double) this.q - 0.01D);
+                }
+
+                this.q = MathHelper.a(this.q, 0.0F, 1.0F);
+                int k = this.worldData.getWeatherDuration();
+
+                if (k <= 0) {
+                    if (this.worldData.hasStorm()) {
+                        this.worldData.setWeatherDuration(this.random.nextInt(12000) + 12000);
+                    } else {
+                        this.worldData.setWeatherDuration(this.random.nextInt(168000) + 12000);
+                    }
+                } else {
+                    --k;
+                    this.worldData.setWeatherDuration(k);
+                    if (k <= 0) {
+                        this.worldData.setStorm(!this.worldData.hasStorm());
+                    }
+                }
+
+                this.n = this.o;
+                if (this.worldData.hasStorm()) {
+                    this.o = (float) ((double) this.o + 0.01D);
+                } else {
+                    this.o = (float) ((double) this.o - 0.01D);
+                }
+
+                this.o = MathHelper.a(this.o, 0.0F, 1.0F);
+
+                // CraftBukkit start
+                for (int idx = 0; idx < this.players.size(); ++idx) {
+                    if (((EntityPlayer) this.players.get(idx)).world == this) {
+                        ((EntityPlayer) this.players.get(idx)).tickWeather();
+                    }
+                }
+                // CraftBukkit end
+            }
+        }
+    }
+
+    protected void j() {}
+
+    public void a(BlockPosition blockposition, IBlockData iblockdata, Random random) {
+        this.d = true;
+        iblockdata.getBlock().b(this, blockposition, iblockdata, random);
+        this.d = false;
+    }
+
+    public boolean u(BlockPosition blockposition) {
+        return this.e(blockposition, false);
+    }
+
+    public boolean v(BlockPosition blockposition) {
+        return this.e(blockposition, true);
+    }
+
+    public boolean e(BlockPosition blockposition, boolean flag) {
+        BiomeBase biomebase = this.getBiome(blockposition);
+        float f = biomebase.a(blockposition);
+
+        if (f > 0.15F) {
+            return false;
+        } else {
+            if (blockposition.getY() >= 0 && blockposition.getY() < 256 && this.b(EnumSkyBlock.BLOCK, blockposition) < 10) {
+                IBlockData iblockdata = this.getType(blockposition);
+                Block block = iblockdata.getBlock();
+
+                if ((block == Blocks.WATER || block == Blocks.FLOWING_WATER) && ((Integer) iblockdata.get(BlockFluids.LEVEL)).intValue() == 0) {
+                    if (!flag) {
+                        return true;
+                    }
+
+                    boolean flag1 = this.G(blockposition.west()) && this.G(blockposition.east()) && this.G(blockposition.north()) && this.G(blockposition.south());
+
+                    if (!flag1) {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+    }
+
+    private boolean G(BlockPosition blockposition) {
+        return this.getType(blockposition).getMaterial() == Material.WATER;
+    }
+
+    public boolean f(BlockPosition blockposition, boolean flag) {
+        BiomeBase biomebase = this.getBiome(blockposition);
+        float f = biomebase.a(blockposition);
+
+        if (f > 0.15F) {
+            return false;
+        } else if (!flag) {
+            return true;
+        } else {
+            if (blockposition.getY() >= 0 && blockposition.getY() < 256 && this.b(EnumSkyBlock.BLOCK, blockposition) < 10) {
+                IBlockData iblockdata = this.getType(blockposition);
+
+                if (iblockdata.getMaterial() == Material.AIR && Blocks.SNOW_LAYER.canPlace(this, blockposition)) {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+    }
+
+    public boolean w(BlockPosition blockposition) {
+        boolean flag = false;
+
+        if (!this.worldProvider.m()) {
+            flag |= this.c(EnumSkyBlock.SKY, blockposition);
+        }
+
+        flag |= this.c(EnumSkyBlock.BLOCK, blockposition);
+        return flag;
+    }
+
+    private int a(BlockPosition blockposition, EnumSkyBlock enumskyblock) {
+        if (enumskyblock == EnumSkyBlock.SKY && this.h(blockposition)) {
+            return 15;
+        } else {
+            IBlockData iblockdata = this.getType(blockposition);
+            int i = enumskyblock == EnumSkyBlock.SKY ? 0 : iblockdata.d();
+            int j = iblockdata.c();
+
+            if (j >= 15 && iblockdata.d() > 0) {
+                j = 1;
+            }
+
+            if (j < 1) {
+                j = 1;
+            }
+
+            if (j >= 15) {
+                return 0;
+            } else if (i >= 14) {
+                return i;
+            } else {
+                BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
+                EnumDirection[] aenumdirection = EnumDirection.values();
+                int k = aenumdirection.length;
+
+                for (int l = 0; l < k; ++l) {
+                    EnumDirection enumdirection = aenumdirection[l];
+
+                    blockposition_pooledblockposition.j(blockposition).d(enumdirection);
+                    int i1 = this.b(enumskyblock, (BlockPosition) blockposition_pooledblockposition) - j;
+
+                    if (i1 > i) {
+                        i = i1;
+                    }
+
+                    if (i >= 14) {
+                        return i;
+                    }
+                }
+
+                blockposition_pooledblockposition.t();
+                return i;
+            }
+        }
+    }
+
+    public boolean c(EnumSkyBlock enumskyblock, BlockPosition blockposition) {
+        // CraftBukkit start - Use neighbor cache instead of looking up
+        Chunk chunk = this.getChunkIfLoaded(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+        if (chunk == null || !chunk.areNeighborsLoaded(1) /*!this.areChunksLoaded(blockposition, 17, false)*/) {
+            // CraftBukkit end
+            return false;
+        } else {
+            int i = 0;
+            int j = 0;
+
+            this.methodProfiler.a("getBrightness");
+            int k = this.b(enumskyblock, blockposition);
+            int l = this.a(blockposition, enumskyblock);
+            int i1 = blockposition.getX();
+            int j1 = blockposition.getY();
+            int k1 = blockposition.getZ();
+            int l1;
+            int i2;
+            int j2;
+            int k2;
+            int l2;
+            int i3;
+            int j3;
+            int k3;
+
+            if (l > k) {
+                this.H[j++] = 133152;
+            } else if (l < k) {
+                this.H[j++] = 133152 | k << 18;
+
+                while (i < j) {
+                    l1 = this.H[i++];
+                    i2 = (l1 & 63) - 32 + i1;
+                    j2 = (l1 >> 6 & 63) - 32 + j1;
+                    k2 = (l1 >> 12 & 63) - 32 + k1;
+                    int l3 = l1 >> 18 & 15;
+                    BlockPosition blockposition1 = new BlockPosition(i2, j2, k2);
+
+                    l2 = this.b(enumskyblock, blockposition1);
+                    if (l2 == l3) {
+                        this.a(enumskyblock, blockposition1, 0);
+                        if (l3 > 0) {
+                            i3 = MathHelper.a(i2 - i1);
+                            j3 = MathHelper.a(j2 - j1);
+                            k3 = MathHelper.a(k2 - k1);
+                            if (i3 + j3 + k3 < 17) {
+                                BlockPosition.PooledBlockPosition blockposition_pooledblockposition = BlockPosition.PooledBlockPosition.s();
+                                EnumDirection[] aenumdirection = EnumDirection.values();
+                                int i4 = aenumdirection.length;
+
+                                for (int j4 = 0; j4 < i4; ++j4) {
+                                    EnumDirection enumdirection = aenumdirection[j4];
+                                    int k4 = i2 + enumdirection.getAdjacentX();
+                                    int l4 = j2 + enumdirection.getAdjacentY();
+                                    int i5 = k2 + enumdirection.getAdjacentZ();
+
+                                    blockposition_pooledblockposition.f(k4, l4, i5);
+                                    int j5 = Math.max(1, this.getType(blockposition_pooledblockposition).c());
+
+                                    l2 = this.b(enumskyblock, (BlockPosition) blockposition_pooledblockposition);
+                                    if (l2 == l3 - j5 && j < this.H.length) {
+                                        this.H[j++] = k4 - i1 + 32 | l4 - j1 + 32 << 6 | i5 - k1 + 32 << 12 | l3 - j5 << 18;
+                                    }
+                                }
+
+                                blockposition_pooledblockposition.t();
+                            }
+                        }
+                    }
+                }
+
+                i = 0;
+            }
+
+            this.methodProfiler.b();
+            this.methodProfiler.a("checkedPosition < toCheckCount");
+
+            while (i < j) {
+                l1 = this.H[i++];
+                i2 = (l1 & 63) - 32 + i1;
+                j2 = (l1 >> 6 & 63) - 32 + j1;
+                k2 = (l1 >> 12 & 63) - 32 + k1;
+                BlockPosition blockposition2 = new BlockPosition(i2, j2, k2);
+                int k5 = this.b(enumskyblock, blockposition2);
+
+                l2 = this.a(blockposition2, enumskyblock);
+                if (l2 != k5) {
+                    this.a(enumskyblock, blockposition2, l2);
+                    if (l2 > k5) {
+                        i3 = Math.abs(i2 - i1);
+                        j3 = Math.abs(j2 - j1);
+                        k3 = Math.abs(k2 - k1);
+                        boolean flag = j < this.H.length - 6;
+
+                        if (i3 + j3 + k3 < 17 && flag) {
+                            if (this.b(enumskyblock, blockposition2.west()) < l2) {
+                                this.H[j++] = i2 - 1 - i1 + 32 + (j2 - j1 + 32 << 6) + (k2 - k1 + 32 << 12);
+                            }
+
+                            if (this.b(enumskyblock, blockposition2.east()) < l2) {
+                                this.H[j++] = i2 + 1 - i1 + 32 + (j2 - j1 + 32 << 6) + (k2 - k1 + 32 << 12);
+                            }
+
+                            if (this.b(enumskyblock, blockposition2.down()) < l2) {
+                                this.H[j++] = i2 - i1 + 32 + (j2 - 1 - j1 + 32 << 6) + (k2 - k1 + 32 << 12);
+                            }
+
+                            if (this.b(enumskyblock, blockposition2.up()) < l2) {
+                                this.H[j++] = i2 - i1 + 32 + (j2 + 1 - j1 + 32 << 6) + (k2 - k1 + 32 << 12);
+                            }
+
+                            if (this.b(enumskyblock, blockposition2.north()) < l2) {
+                                this.H[j++] = i2 - i1 + 32 + (j2 - j1 + 32 << 6) + (k2 - 1 - k1 + 32 << 12);
+                            }
+
+                            if (this.b(enumskyblock, blockposition2.south()) < l2) {
+                                this.H[j++] = i2 - i1 + 32 + (j2 - j1 + 32 << 6) + (k2 + 1 - k1 + 32 << 12);
+                            }
+                        }
+                    }
+                }
+            }
+
+            this.methodProfiler.b();
+            return true;
+        }
+    }
+
+    public boolean a(boolean flag) {
+        return false;
+    }
+
+    @Nullable
+    public List<NextTickListEntry> a(Chunk chunk, boolean flag) {
+        return null;
+    }
+
+    @Nullable
+    public List<NextTickListEntry> a(StructureBoundingBox structureboundingbox, boolean flag) {
+        return null;
+    }
+
+    public List<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb) {
+        return this.getEntities(entity, axisalignedbb, IEntitySelector.e);
+    }
+
+    public List<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super Entity> predicate) {
+        ArrayList arraylist = Lists.newArrayList();
+        int i = MathHelper.floor((axisalignedbb.a - 2.0D) / 16.0D);
+        int j = MathHelper.floor((axisalignedbb.d + 2.0D) / 16.0D);
+        int k = MathHelper.floor((axisalignedbb.c - 2.0D) / 16.0D);
+        int l = MathHelper.floor((axisalignedbb.f + 2.0D) / 16.0D);
+
+        for (int i1 = i; i1 <= j; ++i1) {
+            for (int j1 = k; j1 <= l; ++j1) {
+                if (this.isChunkLoaded(i1, j1, true)) {
+                    this.getChunkAt(i1, j1).a(entity, axisalignedbb, arraylist, predicate);
+                }
+            }
+        }
+
+        return arraylist;
+    }
+
+    public <T extends Entity> List<T> a(Class<? extends T> oclass, Predicate<? super T> predicate) {
+        ArrayList arraylist = Lists.newArrayList();
+        this.entityList = new ArrayList(this.entityQueue);
+        Iterator iterator = this.entityList.iterator();
+
+        while (iterator.hasNext()) {
+            Entity entity = (Entity) iterator.next();
+
+            if (oclass.isAssignableFrom(entity.getClass()) && predicate.apply((T) entity)) {
+                arraylist.add(entity);
+            }
+        }
+
+        return arraylist;
+    }
+
+    public <T extends Entity> List<T> b(Class<? extends T> oclass, Predicate<? super T> predicate) {
+        ArrayList arraylist = Lists.newArrayList();
+        Iterator iterator = this.players.iterator();
+
+        while (iterator.hasNext()) {
+            Entity entity = (Entity) iterator.next();
+
+            if (oclass.isAssignableFrom(entity.getClass()) && predicate.apply((T) entity)) { // CraftBukkit - fix decompile error
+                arraylist.add(entity);
+            }
+        }
+
+        return arraylist;
+    }
+
+    public <T extends Entity> List<T> a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb) {
+        return this.a(oclass, axisalignedbb, IEntitySelector.e);
+    }
+
+    public <T extends Entity> List<T> a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super T> predicate) {
+        int i = MathHelper.floor((axisalignedbb.a - 2.0D) / 16.0D);
+        int j = MathHelper.f((axisalignedbb.d + 2.0D) / 16.0D);
+        int k = MathHelper.floor((axisalignedbb.c - 2.0D) / 16.0D);
+        int l = MathHelper.f((axisalignedbb.f + 2.0D) / 16.0D);
+        ArrayList arraylist = Lists.newArrayList();
+
+        for (int i1 = i; i1 < j; ++i1) {
+            for (int j1 = k; j1 < l; ++j1) {
+                if (this.isChunkLoaded(i1, j1, true)) {
+                    this.getChunkAt(i1, j1).a(oclass, axisalignedbb, arraylist, predicate);
+                }
+            }
+        }
+
+        return arraylist;
+    }
+
+    @Nullable
+    public <T extends Entity> T a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb, T t0) {
+        List list = this.a(oclass, axisalignedbb);
+        Entity entity = null;
+        double d0 = Double.MAX_VALUE;
+
+        for (int i = 0; i < list.size(); ++i) {
+            Entity entity1 = (Entity) list.get(i);
+
+            if (entity1 != t0 && IEntitySelector.e.apply(entity1)) {
+                double d1 = t0.h(entity1);
+
+                if (d1 <= d0) {
+                    entity = entity1;
+                    d0 = d1;
+                }
+            }
+        }
+
+        return (T) entity; // CraftBukkit fix decompile error
+    }
+
+    @Nullable
+    public Entity getEntity(int i) {
+        return (Entity) this.entitiesById.get(i);
+    }
+
+    public void b(BlockPosition blockposition, TileEntity tileentity) {
+        if (this.isLoaded(blockposition)) {
+            this.getChunkAtWorldCoords(blockposition).e();
+        }
+
+    }
+
+    public int a(Class<?> oclass) {
+        int i = 0;
+        this.entityList = new ArrayList(this.entityQueue);
+        Iterator iterator = this.entityList.iterator();
+
+        while (iterator.hasNext()) {
+            Entity entity = (Entity) iterator.next();
+            // CraftBukkit start - Split out persistent check, don't apply it to special persistent mobs
+            if (entity instanceof EntityInsentient) {
+                EntityInsentient entityinsentient = (EntityInsentient) entity;
+                if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
+                    continue;
+                }
+            }
+            
+            if (oclass.isAssignableFrom(entity.getClass())) {
+            // if ((!(entity instanceof EntityInsentient) || !((EntityInsentient) entity).isPersistent()) && oclass.isAssignableFrom(entity.getClass())) {
+                // CraftBukkit end
+                ++i;
+            }
+        }
+
+        return i;
+    }
+
+    public void a(Collection<Entity> collection) {
+        org.spigotmc.AsyncCatcher.catchOp( "entity world add"); // Spigot
+        // CraftBukkit start
+        // this.entityList.addAll(collection);
+        Iterator iterator = collection.iterator();
+
+        while (iterator.hasNext()) {
+            Entity entity = (Entity) iterator.next();
+
+            if (entity == null) {
+                continue;
+            }
+            //this.entityList.add(entity);
+            this.entityQueue.add(entity);
+            // CraftBukkit end
+            this.b(entity);
+        }
+
+    }
+
+    public void c(Collection<Entity> collection) {
+        this.f.addAll(collection);
+    }
+
+    public boolean a(Block block, BlockPosition blockposition, boolean flag, EnumDirection enumdirection, @Nullable Entity entity, @Nullable ItemStack itemstack) {
+        IBlockData iblockdata = this.getType(blockposition);
+        AxisAlignedBB axisalignedbb = flag ? null : block.getBlockData().d(this, blockposition);
+
+        // CraftBukkit start - store default return
+        boolean defaultReturn = axisalignedbb != Block.k && !this.a(axisalignedbb.a(blockposition), entity) ? false : (iblockdata.getMaterial() == Material.ORIENTABLE && block == Blocks.ANVIL ? true : iblockdata.getMaterial().isReplaceable() && block.canPlace(this, blockposition, enumdirection, itemstack));
+        BlockCanBuildEvent event = new BlockCanBuildEvent(this.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), CraftMagicNumbers.getId(block), defaultReturn);
+        this.getServer().getPluginManager().callEvent(event);
+
+        return event.isBuildable();
+        // CraftBukkit end
+    }
+
+    public int K() {
+        return this.a;
+    }
+
+    public void b(int i) {
+        this.a = i;
+    }
+
+    public int getBlockPower(BlockPosition blockposition, EnumDirection enumdirection) {
+        return this.getType(blockposition).b(this, blockposition, enumdirection);
+    }
+
+    public WorldType L() {
+        return this.worldData.getType();
+    }
+
+    public int getBlockPower(BlockPosition blockposition) {
+        byte b0 = 0;
+        int i = Math.max(b0, this.getBlockPower(blockposition.down(), EnumDirection.DOWN));
+
+        if (i >= 15) {
+            return i;
+        } else {
+            i = Math.max(i, this.getBlockPower(blockposition.up(), EnumDirection.UP));
+            if (i >= 15) {
+                return i;
+            } else {
+                i = Math.max(i, this.getBlockPower(blockposition.north(), EnumDirection.NORTH));
+                if (i >= 15) {
+                    return i;
+                } else {
+                    i = Math.max(i, this.getBlockPower(blockposition.south(), EnumDirection.SOUTH));
+                    if (i >= 15) {
+                        return i;
+                    } else {
+                        i = Math.max(i, this.getBlockPower(blockposition.west(), EnumDirection.WEST));
+                        if (i >= 15) {
+                            return i;
+                        } else {
+                            i = Math.max(i, this.getBlockPower(blockposition.east(), EnumDirection.EAST));
+                            return i >= 15 ? i : i;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    public boolean isBlockFacePowered(BlockPosition blockposition, EnumDirection enumdirection) {
+        return this.getBlockFacePower(blockposition, enumdirection) > 0;
+    }
+
+    public int getBlockFacePower(BlockPosition blockposition, EnumDirection enumdirection) {
+        IBlockData iblockdata = this.getType(blockposition);
+
+        return iblockdata.l() ? this.getBlockPower(blockposition) : iblockdata.a((IBlockAccess) this, blockposition, enumdirection);
+    }
+
+    public boolean isBlockIndirectlyPowered(BlockPosition blockposition) {
+        return this.getBlockFacePower(blockposition.down(), EnumDirection.DOWN) > 0 ? true : (this.getBlockFacePower(blockposition.up(), EnumDirection.UP) > 0 ? true : (this.getBlockFacePower(blockposition.north(), EnumDirection.NORTH) > 0 ? true : (this.getBlockFacePower(blockposition.south(), EnumDirection.SOUTH) > 0 ? true : (this.getBlockFacePower(blockposition.west(), EnumDirection.WEST) > 0 ? true : this.getBlockFacePower(blockposition.east(), EnumDirection.EAST) > 0))));
+    }
+
+    public int z(BlockPosition blockposition) {
+        int i = 0;
+        EnumDirection[] aenumdirection = EnumDirection.values();
+        int j = aenumdirection.length;
+
+        for (int k = 0; k < j; ++k) {
+            EnumDirection enumdirection = aenumdirection[k];
+            int l = this.getBlockFacePower(blockposition.shift(enumdirection), enumdirection);
+
+            if (l >= 15) {
+                return 15;
+            }
+
+            if (l > i) {
+                i = l;
+            }
+        }
+
+        return i;
+    }
+
+    @Nullable
+    public EntityHuman findNearbyPlayer(Entity entity, double d0) {
+        return this.a(entity.locX, entity.locY, entity.locZ, d0, false);
+    }
+
+    @Nullable
+    public EntityHuman b(Entity entity, double d0) {
+        return this.a(entity.locX, entity.locY, entity.locZ, d0, true);
+    }
+
+    @Nullable
+    public EntityHuman a(double d0, double d1, double d2, double d3, boolean flag) {
+        double d4 = -1.0D;
+        EntityHuman entityhuman = null;
+
+        for (int i = 0; i < this.players.size(); ++i) {
+            EntityHuman entityhuman1 = (EntityHuman) this.players.get(i);
+            // CraftBukkit start - Fixed an NPE
+            if (entityhuman1 == null || entityhuman1.dead) {
+                continue;
+            }
+            // CraftBukkit end
+
+            if ((IEntitySelector.d.apply(entityhuman1) || !flag) && (IEntitySelector.e.apply(entityhuman1) || flag)) {
+                double d5 = entityhuman1.e(d0, d1, d2);
+
+                if ((d3 < 0.0D || d5 < d3 * d3) && (d4 == -1.0D || d5 < d4)) {
+                    d4 = d5;
+                    entityhuman = entityhuman1;
+                }
+            }
+        }
+
+        return entityhuman;
+    }
+
+    public boolean isPlayerNearby(double d0, double d1, double d2, double d3) {
+        for (int i = 0; i < this.players.size(); ++i) {
+            EntityHuman entityhuman = (EntityHuman) this.players.get(i);
+
+            if (IEntitySelector.e.apply(entityhuman)) {
+                double d4 = entityhuman.e(d0, d1, d2);
+
+                if (d3 < 0.0D || d4 < d3 * d3) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    @Nullable
+    public EntityHuman a(Entity entity, double d0, double d1) {
+        return this.a(entity.locX, entity.locY, entity.locZ, d0, d1, (Function) null, (Predicate) null);
+    }
+
+    @Nullable
+    public EntityHuman a(BlockPosition blockposition, double d0, double d1) {
+        return this.a((double) ((float) blockposition.getX() + 0.5F), (double) ((float) blockposition.getY() + 0.5F), (double) ((float) blockposition.getZ() + 0.5F), d0, d1, (Function) null, (Predicate) null);
+    }
+
+    @Nullable
+    public EntityHuman a(double d0, double d1, double d2, double d3, double d4, @Nullable Function<EntityHuman, Double> function, @Nullable Predicate<EntityHuman> predicate) {
+        double d5 = -1.0D;
+        EntityHuman entityhuman = null;
+
+        for (int i = 0; i < this.players.size(); ++i) {
+            EntityHuman entityhuman1 = (EntityHuman) this.players.get(i);
+
+            if (!entityhuman1.abilities.isInvulnerable && entityhuman1.isAlive() && !entityhuman1.isSpectator() && (predicate == null || predicate.apply(entityhuman1))) {
+                double d6 = entityhuman1.e(d0, entityhuman1.locY, d2);
+                double d7 = d3;
+
+                if (entityhuman1.isSneaking()) {
+                    d7 = d3 * 0.800000011920929D;
+                }
+
+                if (entityhuman1.isInvisible()) {
+                    float f = entityhuman1.cL();
+
+                    if (f < 0.1F) {
+                        f = 0.1F;
+                    }
+
+                    d7 *= (double) (0.7F * f);
+                }
+
+                if (function != null) {
+                    d7 *= ((Double) Objects.firstNonNull(function.apply(entityhuman1), Double.valueOf(1.0D))).doubleValue();
+                }
+
+                if ((d4 < 0.0D || Math.abs(entityhuman1.locY - d1) < d4 * d4) && (d3 < 0.0D || d6 < d7 * d7) && (d5 == -1.0D || d6 < d5)) {
+                    d5 = d6;
+                    entityhuman = entityhuman1;
+                }
+            }
+        }
+
+        return entityhuman;
+    }
+
+    @Nullable
+    public EntityHuman a(String s) {
+        for (int i = 0; i < this.players.size(); ++i) {
+            EntityHuman entityhuman = (EntityHuman) this.players.get(i);
+
+            if (s.equals(entityhuman.getName())) {
+                return entityhuman;
+            }
+        }
+
+        return null;
+    }
+
+    @Nullable
+    public EntityHuman b(UUID uuid) {
+        for (int i = 0; i < this.players.size(); ++i) {
+            EntityHuman entityhuman = (EntityHuman) this.players.get(i);
+
+            if (uuid.equals(entityhuman.getUniqueID())) {
+                return entityhuman;
+            }
+        }
+
+        return null;
+    }
+
+    public void checkSession() throws ExceptionWorldConflict {
+        this.dataManager.checkSession();
+    }
+
+    public long getSeed() {
+        return this.worldData.getSeed();
+    }
+
+    public long getTime() {
+        return this.worldData.getTime();
+    }
+
+    public long getDayTime() {
+        return this.worldData.getDayTime();
+    }
+
+    public void setDayTime(long i) {
+        this.worldData.setDayTime(i);
+    }
+
+    public BlockPosition getSpawn() {
+        BlockPosition blockposition = new BlockPosition(this.worldData.b(), this.worldData.c(), this.worldData.d());
+
+        if (!this.getWorldBorder().a(blockposition)) {
+            blockposition = this.getHighestBlockYAt(new BlockPosition(this.getWorldBorder().getCenterX(), 0.0D, this.getWorldBorder().getCenterZ()));
+        }
+
+        return blockposition;
+    }
+
+    public void A(BlockPosition blockposition) {
+        this.worldData.setSpawn(blockposition);
+    }
+
+    public boolean a(EntityHuman entityhuman, BlockPosition blockposition) {
+        return true;
+    }
+
+    public void broadcastEntityEffect(Entity entity, byte b0) {}
+
+    public IChunkProvider getChunkProvider() {
+        return this.chunkProvider;
+    }
+
+    public void playBlockAction(BlockPosition blockposition, Block block, int i, int j) {
+        this.getType(blockposition).a(this, blockposition, i, j);
+    }
+
+    public IDataManager getDataManager() {
+        return this.dataManager;
+    }
+
+    public WorldData getWorldData() {
+        return this.worldData;
+    }
+
+    public GameRules getGameRules() {
+        return this.worldData.w();
+    }
+
+    public void everyoneSleeping() {}
+
+    // CraftBukkit start
+    // Calls the method that checks to see if players are sleeping
+    // Called by CraftPlayer.setPermanentSleeping()
+    public void checkSleepStatus() {
+        if (!this.isClientSide) {
+            this.everyoneSleeping();
+        }
+    }
+    // CraftBukkit end
+
+    public float h(float f) {
+        return (this.p + (this.q - this.p) * f) * this.j(f);
+    }
+
+    public float j(float f) {
+        return this.n + (this.o - this.n) * f;
+    }
+
+    public boolean V() {
+        return (double) this.h(1.0F) > 0.9D;
+    }
+
+    public boolean W() {
+        return (double) this.j(1.0F) > 0.2D;
+    }
+
+    public boolean isRainingAt(BlockPosition blockposition) {
+        if (!this.W()) {
+            return false;
+        } else if (!this.h(blockposition)) {
+            return false;
+        } else if (this.p(blockposition).getY() > blockposition.getY()) {
+            return false;
+        } else {
+            BiomeBase biomebase = this.getBiome(blockposition);
+
+            return biomebase.c() ? false : (this.f(blockposition, false) ? false : biomebase.d());
+        }
+    }
+
+    public boolean C(BlockPosition blockposition) {
+        BiomeBase biomebase = this.getBiome(blockposition);
+
+        return biomebase.e();
+    }
+
+    @Nullable
+    public PersistentCollection X() {
+        return this.worldMaps;
+    }
+
+    public void a(String s, PersistentBase persistentbase) {
+        this.worldMaps.a(s, persistentbase);
+    }
+
+    @Nullable
+    public PersistentBase a(Class<? extends PersistentBase> oclass, String s) {
+        return this.worldMaps.get(oclass, s);
+    }
+
+    public int b(String s) {
+        return this.worldMaps.a(s);
+    }
+
+    public void a(int i, BlockPosition blockposition, int j) {
+        for (int k = 0; k < this.u.size(); ++k) {
+            ((IWorldAccess) this.u.get(k)).a(i, blockposition, j);
+        }
+
+    }
+
+    public void triggerEffect(int i, BlockPosition blockposition, int j) {
+        this.a((EntityHuman) null, i, blockposition, j);
+    }
+
+    public void a(@Nullable EntityHuman entityhuman, int i, BlockPosition blockposition, int j) {
+        try {
+            for (int k = 0; k < this.u.size(); ++k) {
+                ((IWorldAccess) this.u.get(k)).a(entityhuman, i, blockposition, j);
+            }
+
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.a(throwable, "Playing level event");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Level event being played");
+
+            crashreportsystemdetails.a("Block coordinates", (Object) CrashReportSystemDetails.a(blockposition));
+            crashreportsystemdetails.a("Event source", (Object) entityhuman);
+            crashreportsystemdetails.a("Event type", (Object) Integer.valueOf(i));
+            crashreportsystemdetails.a("Event data", (Object) Integer.valueOf(j));
+            throw new ReportedException(crashreport);
+        }
+    }
+
+    public int getHeight() {
+        return 256;
+    }
+
+    public int Z() {
+        return this.worldProvider.m() ? 128 : 256;
+    }
+
+    public Random a(int i, int j, int k) {
+        long l = (long) i * 341873128712L + (long) j * 132897987541L + this.getWorldData().getSeed() + (long) k;
+
+        this.random.setSeed(l);
+        return this.random;
+    }
+
+    public CrashReportSystemDetails a(CrashReport crashreport) {
+        CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Affected level", 1);
+
+        crashreportsystemdetails.a("Level name", (Object) (this.worldData == null ? "????" : this.worldData.getName()));
+        crashreportsystemdetails.a("All players", new CrashReportCallable() {
+            public String a() {
+                return World.this.players.size() + " total; " + World.this.players;
+            }
+
+            public Object call() throws Exception {
+                return this.a();
+            }
+        });
+        crashreportsystemdetails.a("Chunk stats", new CrashReportCallable() {
+            public String a() {
+                return World.this.chunkProvider.getName();
+            }
+
+            public Object call() throws Exception {
+                return this.a();
+            }
+        });
+
+        try {
+            this.worldData.a(crashreportsystemdetails);
+        } catch (Throwable throwable) {
+            crashreportsystemdetails.a("Level Data Unobtainable", throwable);
+        }
+
+        return crashreportsystemdetails;
+    }
+
+    public void c(int i, BlockPosition blockposition, int j) {
+        for (int k = 0; k < this.u.size(); ++k) {
+            IWorldAccess iworldaccess = (IWorldAccess) this.u.get(k);
+
+            iworldaccess.b(i, blockposition, j);
+        }
+
+    }
+
+    public Calendar ac() {
+        if (this.getTime() % 600L == 0L) {
+            this.L.setTimeInMillis(MinecraftServer.av());
+        }
+
+        return this.L;
+    }
+
+    public Scoreboard getScoreboard() {
+        return this.scoreboard;
+    }
+
+    public void updateAdjacentComparators(BlockPosition blockposition, Block block) {
+        Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+        while (iterator.hasNext()) {
+            EnumDirection enumdirection = (EnumDirection) iterator.next();
+            BlockPosition blockposition1 = blockposition.shift(enumdirection);
+
+            if (this.isLoaded(blockposition1)) {
+                IBlockData iblockdata = this.getType(blockposition1);
+
+                if (Blocks.UNPOWERED_COMPARATOR.C(iblockdata)) {
+                    iblockdata.doPhysics(this, blockposition1, block);
+                } else if (iblockdata.l()) {
+                    blockposition1 = blockposition1.shift(enumdirection);
+                    iblockdata = this.getType(blockposition1);
+                    if (Blocks.UNPOWERED_COMPARATOR.C(iblockdata)) {
+                        iblockdata.doPhysics(this, blockposition1, block);
+                    }
+                }
+            }
+        }
+
+    }
+
+    public DifficultyDamageScaler D(BlockPosition blockposition) {
+        long i = 0L;
+        float f = 0.0F;
+
+        if (this.isLoaded(blockposition)) {
+            f = this.E();
+            i = this.getChunkAtWorldCoords(blockposition).x();
+        }
+
+        return new DifficultyDamageScaler(this.getDifficulty(), this.getDayTime(), i, f);
+    }
+
+    public EnumDifficulty getDifficulty() {
+        return this.getWorldData().getDifficulty();
+    }
+
+    public int af() {
+        return this.J;
+    }
+
+    public void c(int i) {
+        this.J = i;
+    }
+
+    public void d(int i) {
+        this.K = i;
+    }
+
+    public PersistentVillage ai() {
+        return this.villages;
+    }
+
+    public WorldBorder getWorldBorder() {
+        return this.N;
+    }
+
+    public boolean d(int i, int j) {
+        BlockPosition blockposition = this.getSpawn();
+        int k = i * 16 + 8 - blockposition.getX();
+        int l = j * 16 + 8 - blockposition.getZ();
+        boolean flag = true;
+
+        return k >= -128 && k <= 128 && l >= -128 && l <= 128 && this.keepSpawnInMemory; // CraftBukkit - Added 'this.keepSpawnInMemory'
+    }
+
+    public void a(Packet<?> packet) {
+        throw new UnsupportedOperationException("Can\'t send packets to server unless you\'re on the client.");
+    }
+
+    public LootTableRegistry ak() {
+        return this.B;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/WorldServer.java src/main/java/net/minecraft/server/WorldServer.java
--- src_origin/main/java/net/minecraft/server/WorldServer.java	2016-08-25 22:39:52.722602058 +0800
+++ src/main/java/net/minecraft/server/WorldServer.java	2016-08-26 03:24:15.194198536 +0800
@@ -1,1392 +1,1622 @@
-package net.minecraft.server;
-
-import com.google.common.base.Predicate;
-import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
-import com.google.common.util.concurrent.ListenableFuture;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Random;
-import java.util.Set;
-import java.util.TreeSet;
-import java.util.UUID;
-import javax.annotation.Nullable;
-import org.apache.logging.log4j.LogManager;
-import org.apache.logging.log4j.Logger;
-
-// CraftBukkit start
-import java.util.logging.Level;
-
-import org.bukkit.WeatherType;
-import org.bukkit.block.BlockState;
-import org.bukkit.craftbukkit.util.HashTreeSet;
-
-import org.bukkit.event.block.BlockFormEvent;
-import org.bukkit.event.weather.LightningStrikeEvent;
-// CraftBukkit end
-
-public class WorldServer extends World implements IAsyncTaskHandler {
-
-    private static final Logger a = LogManager.getLogger();
-    private final MinecraftServer server;
-    public EntityTracker tracker;
-    private final PlayerChunkMap manager;
-    // private final Set<NextTickListEntry> nextTickListHash = Sets.newHashSet();
-    private final HashTreeSet<NextTickListEntry> nextTickList = new HashTreeSet<NextTickListEntry>(); // CraftBukkit - HashTreeSet
-    private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
-    public boolean savingDisabled;
-    private boolean O;
-    private int emptyTime;
-    private final PortalTravelAgent portalTravelAgent;
-    private final SpawnerCreature spawnerCreature = new SpawnerCreature();
-    protected final VillageSiege siegeManager = new VillageSiege(this);
-    private final WorldServer.BlockActionDataList[] S = new WorldServer.BlockActionDataList[] { new WorldServer.BlockActionDataList(null), new WorldServer.BlockActionDataList(null)};
-    private int T;
-    private final List<NextTickListEntry> U = Lists.newArrayList();
-
-    // CraftBukkit start
-    public final int dimension;
-
-    // Add env and gen to constructor
-    public WorldServer(MinecraftServer minecraftserver, IDataManager idatamanager, WorldData worlddata, int i, MethodProfiler methodprofiler, org.bukkit.World.Environment env, org.bukkit.generator.ChunkGenerator gen) {
-        super(idatamanager, worlddata, DimensionManager.a(env.getId()).d(), methodprofiler, false, gen, env);
-        this.dimension = i;
-        this.pvpMode = minecraftserver.getPVP();
-        worlddata.world = this;
-        // CraftBukkit end
-        this.server = minecraftserver;
-        this.tracker = new EntityTracker(this);
-        this.manager = new PlayerChunkMap(this, spigotConfig.viewDistance); // Spigot
-        this.worldProvider.a((World) this);
-        this.chunkProvider = this.n();
-        this.portalTravelAgent = new org.bukkit.craftbukkit.CraftTravelAgent(this); // CraftBukkit
-        this.H();
-        this.I();
-        this.getWorldBorder().a(minecraftserver.aD());
-    }
-
-    public World b() {
-        this.worldMaps = new PersistentCollection(this.dataManager);
-        String s = PersistentVillage.a(this.worldProvider);
-        PersistentVillage persistentvillage = (PersistentVillage) this.worldMaps.get(PersistentVillage.class, s);
-
-        if (persistentvillage == null) {
-            this.villages = new PersistentVillage(this);
-            this.worldMaps.a(s, this.villages);
-        } else {
-            this.villages = persistentvillage;
-            this.villages.a((World) this);
-        }
-
-        if (getServer().getScoreboardManager() == null) { // CraftBukkit
-        this.scoreboard = new ScoreboardServer(this.server);
-        PersistentScoreboard persistentscoreboard = (PersistentScoreboard) this.worldMaps.get(PersistentScoreboard.class, "scoreboard");
-
-        if (persistentscoreboard == null) {
-            persistentscoreboard = new PersistentScoreboard();
-            this.worldMaps.a("scoreboard", persistentscoreboard);
-        }
-
-        persistentscoreboard.a(this.scoreboard);
-        ((ScoreboardServer) this.scoreboard).a((Runnable) (new RunnableSaveScoreboard(persistentscoreboard)));
-        // CraftBukkit start
-        } else {
-            this.scoreboard = getServer().getScoreboardManager().getMainScoreboard().getHandle();
-        }
-        // CraftBukkit end
-        this.B = new LootTableRegistry(new File(new File(this.dataManager.getDirectory(), "data"), "loot_tables"));
-        this.getWorldBorder().setCenter(this.worldData.B(), this.worldData.C());
-        this.getWorldBorder().setDamageAmount(this.worldData.H());
-        this.getWorldBorder().setDamageBuffer(this.worldData.G());
-        this.getWorldBorder().setWarningDistance(this.worldData.I());
-        this.getWorldBorder().setWarningTime(this.worldData.J());
-        if (this.worldData.E() > 0L) {
-            this.getWorldBorder().transitionSizeBetween(this.worldData.D(), this.worldData.F(), this.worldData.E());
-        } else {
-            this.getWorldBorder().setSize(this.worldData.D());
-        }
-
-        // CraftBukkit start
-        if (generator != null) {
-            getWorld().getPopulators().addAll(generator.getDefaultPopulators(getWorld()));
-        }
-        // CraftBukkit end
-
-        return this;
-    }
-
-    // CraftBukkit start
-    @Override
-    public TileEntity getTileEntity(BlockPosition pos) {
-        TileEntity result = super.getTileEntity(pos);
-        Block type = getType(pos).getBlock();
-
-        if (type == Blocks.CHEST || type == Blocks.TRAPPED_CHEST) { // Spigot
-            if (!(result instanceof TileEntityChest)) {
-                result = fixTileEntity(pos, type, result);
-            }
-        } else if (type == Blocks.FURNACE) {
-            if (!(result instanceof TileEntityFurnace)) {
-                result = fixTileEntity(pos, type, result);
-            }
-        } else if (type == Blocks.DROPPER) {
-            if (!(result instanceof TileEntityDropper)) {
-                result = fixTileEntity(pos, type, result);
-            }
-        } else if (type == Blocks.DISPENSER) {
-            if (!(result instanceof TileEntityDispenser)) {
-                result = fixTileEntity(pos, type, result);
-            }
-        } else if (type == Blocks.JUKEBOX) {
-            if (!(result instanceof BlockJukeBox.TileEntityRecordPlayer)) {
-                result = fixTileEntity(pos, type, result);
-            }
-        } else if (type == Blocks.NOTEBLOCK) {
-            if (!(result instanceof TileEntityNote)) {
-                result = fixTileEntity(pos, type, result);
-            }
-        } else if (type == Blocks.MOB_SPAWNER) {
-            if (!(result instanceof TileEntityMobSpawner)) {
-                result = fixTileEntity(pos, type, result);
-            }
-        } else if ((type == Blocks.STANDING_SIGN) || (type == Blocks.WALL_SIGN)) {
-            if (!(result instanceof TileEntitySign)) {
-                result = fixTileEntity(pos, type, result);
-            }
-        } else if (type == Blocks.ENDER_CHEST) {
-            if (!(result instanceof TileEntityEnderChest)) {
-                result = fixTileEntity(pos, type, result);
-            }
-        } else if (type == Blocks.BREWING_STAND) {
-            if (!(result instanceof TileEntityBrewingStand)) {
-                result = fixTileEntity(pos, type, result);
-            }
-        } else if (type == Blocks.BEACON) {
-            if (!(result instanceof TileEntityBeacon)) {
-                result = fixTileEntity(pos, type, result);
-            }
-        } else if (type == Blocks.HOPPER) {
-            if (!(result instanceof TileEntityHopper)) {
-                result = fixTileEntity(pos, type, result);
-            }
-        }
-
-        return result;
-    }
-
-    private TileEntity fixTileEntity(BlockPosition pos, Block type, TileEntity found) {
-        this.getServer().getLogger().log(Level.SEVERE, "Block at {0},{1},{2} is {3} but has {4}" + ". "
-                + "Bukkit will attempt to fix this, but there may be additional damage that we cannot recover.", new Object[]{pos.getX(), pos.getY(), pos.getZ(), org.bukkit.Material.getMaterial(Block.getId(type)).toString(), found});
-
-        if (type instanceof ITileEntity) {
-            TileEntity replacement = ((ITileEntity) type).a(this, type.toLegacyData(this.getType(pos)));
-            replacement.world = this;
-            this.setTileEntity(pos, replacement);
-            return replacement;
-        } else {
-            this.getServer().getLogger().severe("Don't know how to fix for this type... Can't do anything! :(");
-            return found;
-        }
-    }
-
-    private boolean canSpawn(int x, int z) {
-        if (this.generator != null) {
-            return this.generator.canSpawn(this.getWorld(), x, z);
-        } else {
-            return this.worldProvider.canSpawn(x, z);
-        }
-    }
-    // CraftBukkit end
-
-    public void doTick() {
-        super.doTick();
-        if (this.getWorldData().isHardcore() && this.getDifficulty() != EnumDifficulty.HARD) {
-            this.getWorldData().setDifficulty(EnumDifficulty.HARD);
-        }
-
-        this.worldProvider.k().b();
-        if (this.everyoneDeeplySleeping()) {
-            if (this.getGameRules().getBoolean("doDaylightCycle")) {
-                long i = this.worldData.getDayTime() + 24000L;
-
-                this.worldData.setDayTime(i - i % 24000L);
-            }
-
-            this.f();
-        }
-
-        // CraftBukkit start - Only call spawner if we have players online and the world allows for mobs or animals
-        long time = this.worldData.getTime();
-        if (this.getGameRules().getBoolean("doMobSpawning") && this.worldData.getType() != WorldType.DEBUG_ALL_BLOCK_STATES && (this.allowMonsters || this.allowAnimals) && (this instanceof WorldServer && this.players.size() > 0)) {
-            timings.mobSpawn.startTiming(); // Spigot
-            this.spawnerCreature.a(this, this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldData.getTime() % 400L == 0L);
-            timings.mobSpawn.stopTiming(); // Spigot
-            // CraftBukkit end
-        }
-
-        timings.doChunkUnload.startTiming(); // Spigot
-        this.methodProfiler.c("chunkSource");
-        this.chunkProvider.unloadChunks();
-        int j = this.a(1.0F);
-
-        if (j != this.af()) {
-            this.c(j);
-        }
-
-        this.worldData.setTime(this.worldData.getTime() + 1L);
-        if (this.getGameRules().getBoolean("doDaylightCycle")) {
-            this.worldData.setDayTime(this.worldData.getDayTime() + 1L);
-        }
-
-        timings.doChunkUnload.stopTiming(); // Spigot
-        this.methodProfiler.c("tickPending");
-        timings.doTickPending.startTiming(); // Spigot
-        this.a(false);
-        timings.doTickPending.stopTiming(); // Spigot
-        this.methodProfiler.c("tickBlocks");
-        timings.doTickTiles.startTiming(); // Spigot
-        this.j();
-        timings.doTickTiles.stopTiming(); // Spigot
-        this.methodProfiler.c("chunkMap");
-        timings.doChunkMap.startTiming(); // Spigot
-        this.manager.flush();
-        timings.doChunkMap.stopTiming(); // Spigot
-        this.methodProfiler.c("village");
-        timings.doVillages.startTiming(); // Spigot
-        this.villages.tick();
-        this.siegeManager.a();
-        timings.doVillages.stopTiming(); // Spigot
-        this.methodProfiler.c("portalForcer");
-        timings.doPortalForcer.startTiming(); // Spigot
-        this.portalTravelAgent.a(this.getTime());
-        timings.doPortalForcer.stopTiming(); // Spigot
-        this.methodProfiler.b();
-        timings.doSounds.startTiming(); // Spigot
-        this.ao();
-        timings.doSounds.stopTiming(); // Spigot
-
-        timings.doChunkGC.startTiming();// Spigot
-        this.getWorld().processChunkGC(); // CraftBukkit
-        timings.doChunkGC.stopTiming(); // Spigot
-    }
-
-    @Nullable
-    public BiomeBase.BiomeMeta a(EnumCreatureType enumcreaturetype, BlockPosition blockposition) {
-        List list = this.getChunkProviderServer().a(enumcreaturetype, blockposition);
-
-        return list != null && !list.isEmpty() ? (BiomeBase.BiomeMeta) WeightedRandom.a(this.random, list) : null;
-    }
-
-    public boolean a(EnumCreatureType enumcreaturetype, BiomeBase.BiomeMeta biomebase_biomemeta, BlockPosition blockposition) {
-        List list = this.getChunkProviderServer().a(enumcreaturetype, blockposition);
-
-        return list != null && !list.isEmpty() ? list.contains(biomebase_biomemeta) : false;
-    }
-
-    public void everyoneSleeping() {
-        this.O = false;
-        if (!this.players.isEmpty()) {
-            int i = 0;
-            int j = 0;
-            Iterator iterator = this.players.iterator();
-
-            while (iterator.hasNext()) {
-                EntityHuman entityhuman = (EntityHuman) iterator.next();
-
-                if (entityhuman.isSpectator()) {
-                    ++i;
-                } else if (entityhuman.isSleeping() || entityhuman.fauxSleeping) {
-                    ++j;
-                }
-            }
-
-            this.O = j > 0 && j >= this.players.size() - i;
-        }
-
-    }
-
-    protected void f() {
-        this.O = false;
-        Iterator iterator = this.players.iterator();
-
-        while (iterator.hasNext()) {
-            EntityHuman entityhuman = (EntityHuman) iterator.next();
-
-            if (entityhuman.isSleeping()) {
-                entityhuman.a(false, false, true);
-            }
-        }
-
-        this.c();
-    }
-
-    private void c() {
-        this.worldData.setStorm(false);
-        // CraftBukkit start
-        // If we stop due to everyone sleeping we should reset the weather duration to some other random value.
-        // Not that everyone ever manages to get the whole server to sleep at the same time....
-        if (!this.worldData.hasStorm()) {
-            this.worldData.setWeatherDuration(0);
-        }
-        // CraftBukkit end
-        this.worldData.setThundering(false);
-        // CraftBukkit start
-        // If we stop due to everyone sleeping we should reset the weather duration to some other random value.
-        // Not that everyone ever manages to get the whole server to sleep at the same time....
-        if (!this.worldData.isThundering()) {
-            this.worldData.setThunderDuration(0);
-        }
-        // CraftBukkit end
-    }
-
-    public boolean everyoneDeeplySleeping() {
-        if (this.O && !this.isClientSide) {
-            Iterator iterator = this.players.iterator();
-
-            // CraftBukkit - This allows us to assume that some people are in bed but not really, allowing time to pass in spite of AFKers
-            boolean foundActualSleepers = false;
-
-            EntityHuman entityhuman;
-
-            do {
-                if (!iterator.hasNext()) {
-                    return foundActualSleepers;
-                }
-
-                entityhuman = (EntityHuman) iterator.next();
-
-                // CraftBukkit start
-                if (entityhuman.isDeeplySleeping()) {
-                    foundActualSleepers = true;
-                }
-            } while (!entityhuman.isSpectator() || entityhuman.isDeeplySleeping() || entityhuman.fauxSleeping);
-            // CraftBukkit end
-
-            return false;
-        } else {
-            return false;
-        }
-    }
-
-    protected boolean isChunkLoaded(int i, int j, boolean flag) {
-        return this.getChunkProviderServer().isLoaded(i, j);
-    }
-
-    protected void i() {
-        this.methodProfiler.a("playerCheckLight");
-        if (spigotConfig.randomLightUpdates && !this.players.isEmpty()) { // Spigot
-            int i = this.random.nextInt(this.players.size());
-            EntityHuman entityhuman = (EntityHuman) this.players.get(i);
-            int j = MathHelper.floor(entityhuman.locX) + this.random.nextInt(11) - 5;
-            int k = MathHelper.floor(entityhuman.locY) + this.random.nextInt(11) - 5;
-            int l = MathHelper.floor(entityhuman.locZ) + this.random.nextInt(11) - 5;
-
-            this.w(new BlockPosition(j, k, l));
-        }
-
-        this.methodProfiler.b();
-    }
-
-    protected void j() {
-        this.i();
-        if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
-            Iterator iterator = this.manager.b();
-
-            while (iterator.hasNext()) {
-                ((Chunk) iterator.next()).b(false);
-            }
-
-        } else {
-            int i = this.getGameRules().c("randomTickSpeed");
-            boolean flag = this.W();
-            boolean flag1 = this.V();
-
-            this.methodProfiler.a("pollingChunks");
-
-            for (Iterator iterator1 = this.manager.b(); iterator1.hasNext(); this.methodProfiler.b()) {
-                this.methodProfiler.a("getChunk");
-                Chunk chunk = (Chunk) iterator1.next();
-                int j = chunk.locX * 16;
-                int k = chunk.locZ * 16;
-
-                this.methodProfiler.c("checkNextLight");
-                chunk.n();
-                this.methodProfiler.c("tickChunk");
-                chunk.b(false);
-                if ( !chunk.areNeighborsLoaded( 1 ) ) continue; // Spigot
-                this.methodProfiler.c("thunder");
-                int l;
-                BlockPosition blockposition;
-
-                if (flag && flag1 && this.random.nextInt(100000) == 0) {
-                    this.l = this.l * 3 + 1013904223;
-                    l = this.l >> 2;
-                    blockposition = this.a(new BlockPosition(j + (l & 15), 0, k + (l >> 8 & 15)));
-                    if (this.isRainingAt(blockposition)) {
-                        DifficultyDamageScaler difficultydamagescaler = this.D(blockposition);
-
-                        if (this.random.nextDouble() < (double) difficultydamagescaler.b() * 0.05D) {
-                            EntityHorse entityhorse = new EntityHorse(this);
-
-                            entityhorse.setType(EnumHorseType.SKELETON);
-                            entityhorse.y(true);
-                            entityhorse.setAgeRaw(0);
-                            entityhorse.setPosition((double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ());
-                            this.addEntity(entityhorse, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.LIGHTNING); // CraftBukkit
-                            this.strikeLightning(new EntityLightning(this, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), true));
-                        } else {
-                            this.strikeLightning(new EntityLightning(this, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), false));
-                        }
-                    }
-                }
-
-                this.methodProfiler.c("iceandsnow");
-                if (this.random.nextInt(16) == 0) {
-                    this.l = this.l * 3 + 1013904223;
-                    l = this.l >> 2;
-                    blockposition = this.p(new BlockPosition(j + (l & 15), 0, k + (l >> 8 & 15)));
-                    BlockPosition blockposition1 = blockposition.down();
-
-                    if (this.v(blockposition1)) {
-                        // CraftBukkit start
-                        BlockState blockState = this.getWorld().getBlockAt(blockposition1.getX(), blockposition1.getY(), blockposition1.getZ()).getState();
-                        blockState.setTypeId(Block.getId(Blocks.ICE));
-
-                        BlockFormEvent iceBlockForm = new BlockFormEvent(blockState.getBlock(), blockState);
-                        this.getServer().getPluginManager().callEvent(iceBlockForm);
-                        if (!iceBlockForm.isCancelled()) {
-                            blockState.update(true);
-                        }
-                        // CraftBukkit end
-                    }
-
-                    if (flag && this.f(blockposition, true)) {
-                        // CraftBukkit start
-                        BlockState blockState = this.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()).getState();
-                        blockState.setTypeId(Block.getId(Blocks.SNOW_LAYER));
-
-                        BlockFormEvent snow = new BlockFormEvent(blockState.getBlock(), blockState);
-                        this.getServer().getPluginManager().callEvent(snow);
-                        if (!snow.isCancelled()) {
-                            blockState.update(true);
-                        }
-                        // CraftBukkit end
-                    }
-
-                    if (flag && this.getBiome(blockposition1).d()) {
-                        this.getType(blockposition1).getBlock().h(this, blockposition1);
-                    }
-                }
-
-                this.methodProfiler.c("tickBlocks");
-                if (i > 0) {
-                    ChunkSection[] achunksection = chunk.getSections();
-                    int i1 = achunksection.length;
-
-                    for (int j1 = 0; j1 < i1; ++j1) {
-                        ChunkSection chunksection = achunksection[j1];
-
-                        if (chunksection != Chunk.a && chunksection.shouldTick()) {
-                            for (int k1 = 0; k1 < i; ++k1) {
-                                this.l = this.l * 3 + 1013904223;
-                                int l1 = this.l >> 2;
-                                int i2 = l1 & 15;
-                                int j2 = l1 >> 8 & 15;
-                                int k2 = l1 >> 16 & 15;
-                                IBlockData iblockdata = chunksection.getType(i2, k2, j2);
-                                Block block = iblockdata.getBlock();
-
-                                this.methodProfiler.a("randomTick");
-                                if (block.isTicking()) {
-                                    block.a((World) this, new BlockPosition(i2 + j, k2 + chunksection.getYPosition(), j2 + k), iblockdata, this.random);
-                                }
-
-                                this.methodProfiler.b();
-                            }
-                        }
-                    }
-                }
-            }
-
-            this.methodProfiler.b();
-        }
-    }
-
-    protected BlockPosition a(BlockPosition blockposition) {
-        BlockPosition blockposition1 = this.p(blockposition);
-        AxisAlignedBB axisalignedbb = (new AxisAlignedBB(blockposition1, new BlockPosition(blockposition1.getX(), this.getHeight(), blockposition1.getZ()))).g(3.0D);
-        List list = this.a(EntityLiving.class, axisalignedbb, new Predicate() {
-            public boolean a(@Nullable EntityLiving entityliving) {
-                return entityliving != null && entityliving.isAlive() && WorldServer.this.h(entityliving.getChunkCoordinates());
-            }
-
-            public boolean apply(Object object) {
-                return this.a((EntityLiving) object);
-            }
-        });
-
-        if (!list.isEmpty()) {
-            return ((EntityLiving) list.get(this.random.nextInt(list.size()))).getChunkCoordinates();
-        } else {
-            if (blockposition1.getY() == -1) {
-                blockposition1 = blockposition1.up(2);
-            }
-
-            return blockposition1;
-        }
-    }
-
-    public boolean a(BlockPosition blockposition, Block block) {
-        NextTickListEntry nextticklistentry = new NextTickListEntry(blockposition, block);
-
-        return this.U.contains(nextticklistentry);
-    }
-
-    public boolean b(BlockPosition blockposition, Block block) {
-        NextTickListEntry nextticklistentry = new NextTickListEntry(blockposition, block);
-
-        return this.nextTickList.contains(nextticklistentry); // CraftBukkit
-    }
-
-    public void a(BlockPosition blockposition, Block block, int i) {
-        this.a(blockposition, block, i, 0);
-    }
-
-    public void a(BlockPosition blockposition, Block block, int i, int j) {
-        if (blockposition instanceof BlockPosition.MutableBlockPosition || blockposition instanceof BlockPosition.PooledBlockPosition) {
-            blockposition = new BlockPosition(blockposition);
-            LogManager.getLogger().warn("Tried to assign a mutable BlockPos to tick data...", new Error(blockposition.getClass().toString()));
-        }
-
-        Material material = block.getBlockData().getMaterial();
-
-        if (this.d && material != Material.AIR) {
-            if (block.s()) {
-                if (this.areChunksLoadedBetween(blockposition.a(-8, -8, -8), blockposition.a(8, 8, 8))) {
-                    IBlockData iblockdata = this.getType(blockposition);
-
-                    if (iblockdata.getMaterial() != Material.AIR && iblockdata.getBlock() == block) {
-                        iblockdata.getBlock().b((World) this, blockposition, iblockdata, this.random);
-                    }
-                }
-
-                return;
-            }
-
-            i = 1;
-        }
-
-        NextTickListEntry nextticklistentry = new NextTickListEntry(blockposition, block);
-
-        if (this.isLoaded(blockposition)) {
-            if (material != Material.AIR) {
-                nextticklistentry.a((long) i + this.worldData.getTime());
-                nextticklistentry.a(j);
-            }
-
-            // CraftBukkit - use nextTickList
-            if (!this.nextTickList.contains(nextticklistentry)) {
-                this.nextTickList.add(nextticklistentry);
-            }
-        }
-
-    }
-
-    public void b(BlockPosition blockposition, Block block, int i, int j) {
-        if (blockposition instanceof BlockPosition.MutableBlockPosition || blockposition instanceof BlockPosition.PooledBlockPosition) {
-            blockposition = new BlockPosition(blockposition);
-            LogManager.getLogger().warn("Tried to assign a mutable BlockPos to tick data...", new Error(blockposition.getClass().toString()));
-        }
-
-        NextTickListEntry nextticklistentry = new NextTickListEntry(blockposition, block);
-
-        nextticklistentry.a(j);
-        Material material = block.getBlockData().getMaterial();
-
-        if (material != Material.AIR) {
-            nextticklistentry.a((long) i + this.worldData.getTime());
-        }
-
-        // CraftBukkit - use nextTickList
-        if (!this.nextTickList.contains(nextticklistentry)) {
-            this.nextTickList.add(nextticklistentry);
-        }
-
-    }
-
-    public void tickEntities() {
-        if (false && this.players.isEmpty()) { // CraftBukkit - this prevents entity cleanup, other issues on servers with no players
-            if (this.emptyTime++ >= 300) {
-                return;
-            }
-        } else {
-            this.m();
-        }
-
-        this.worldProvider.r();
-        super.tickEntities();
-        spigotConfig.currentPrimedTnt = 0; // Spigot
-    }
-
-    protected void l() {
-        super.l();
-        this.methodProfiler.c("players");
-
-        for (int i = 0; i < this.players.size(); ++i) {
-            Entity entity = (Entity) this.players.get(i);
-            Entity entity1 = entity.bB();
-
-            if (entity1 != null) {
-                if (!entity1.dead && entity1.w(entity)) {
-                    continue;
-                }
-
-                entity.stopRiding();
-            }
-
-            this.methodProfiler.a("tick");
-            if (!entity.dead) {
-                try {
-                    this.g(entity);
-                } catch (Throwable throwable) {
-                    CrashReport crashreport = CrashReport.a(throwable, "Ticking player");
-                    CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Player being ticked");
-
-                    entity.appendEntityCrashDetails(crashreportsystemdetails);
-                    throw new ReportedException(crashreport);
-                }
-            }
-
-            this.methodProfiler.b();
-            this.methodProfiler.a("remove");
-            if (entity.dead) {
-                int j = entity.ac;
-                int k = entity.ae;
-
-                if (entity.ab && this.isChunkLoaded(j, k, true)) {
-                    this.getChunkAt(j, k).b(entity);
-                }
-
-                this.entityList.remove(entity);
-                this.c(entity);
-            }
-
-            this.methodProfiler.b();
-        }
-
-    }
-
-    public void m() {
-        this.emptyTime = 0;
-    }
-
-    public boolean a(boolean flag) {
-        if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
-            return false;
-        } else {
-            int i = this.nextTickList.size();
-
-            if (false) { // CraftBukkit
-                throw new IllegalStateException("TickNextTick list out of synch");
-            } else {
-                if (i > 65536) {
-                    // CraftBukkit start - If the server has too much to process over time, try to alleviate that
-                    if (i > 20 * 65536) {
-                        i = i / 20;
-                    } else {
-                        i = 65536;
-                    }
-                    // CraftBukkit end
-                }
-
-                this.methodProfiler.a("cleaning");
-
-                NextTickListEntry nextticklistentry;
-
-                for (int j = 0; j < i; ++j) {
-                    nextticklistentry = (NextTickListEntry) this.nextTickList.first();
-                    if (!flag && nextticklistentry.b > this.worldData.getTime()) {
-                        break;
-                    }
-
-                    // CraftBukkit - use nextTickList
-                    this.nextTickList.remove(nextticklistentry);
-                    // this.nextTickListHash.remove(nextticklistentry);
-                    this.U.add(nextticklistentry);
-                }
-
-                this.methodProfiler.b();
-                this.methodProfiler.a("ticking");
-                Iterator iterator = this.U.iterator();
-
-                while (iterator.hasNext()) {
-                    nextticklistentry = (NextTickListEntry) iterator.next();
-                    iterator.remove();
-                    boolean flag1 = false;
-
-                    if (this.areChunksLoadedBetween(nextticklistentry.a.a(0, 0, 0), nextticklistentry.a.a(0, 0, 0))) {
-                        IBlockData iblockdata = this.getType(nextticklistentry.a);
-
-                        if (iblockdata.getMaterial() != Material.AIR && Block.a(iblockdata.getBlock(), nextticklistentry.a())) {
-                            try {
-                                iblockdata.getBlock().b((World) this, nextticklistentry.a, iblockdata, this.random);
-                            } catch (Throwable throwable) {
-                                CrashReport crashreport = CrashReport.a(throwable, "Exception while ticking a block");
-                                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being ticked");
-
-                                CrashReportSystemDetails.a(crashreportsystemdetails, nextticklistentry.a, iblockdata);
-                                throw new ReportedException(crashreport);
-                            }
-                        }
-                    } else {
-                        this.a(nextticklistentry.a, nextticklistentry.a(), 0);
-                    }
-                }
-
-                this.methodProfiler.b();
-                this.U.clear();
-                return !this.nextTickList.isEmpty();
-            }
-        }
-    }
-
-    @Nullable
-    public List<NextTickListEntry> a(Chunk chunk, boolean flag) {
-        ChunkCoordIntPair chunkcoordintpair = chunk.k();
-        int i = (chunkcoordintpair.x << 4) - 2;
-        int j = i + 16 + 2;
-        int k = (chunkcoordintpair.z << 4) - 2;
-        int l = k + 16 + 2;
-
-        return this.a(new StructureBoundingBox(i, 0, k, j, 256, l), flag);
-    }
-
-    @Nullable
-    public List<NextTickListEntry> a(StructureBoundingBox structureboundingbox, boolean flag) {
-        ArrayList arraylist = null;
-
-        for (int i = 0; i < 2; ++i) {
-            Iterator iterator;
-
-            if (i == 0) {
-                iterator = this.nextTickList.iterator();
-            } else {
-                iterator = this.U.iterator();
-            }
-
-            while (iterator.hasNext()) {
-                NextTickListEntry nextticklistentry = (NextTickListEntry) iterator.next();
-                BlockPosition blockposition = nextticklistentry.a;
-
-                if (blockposition.getX() >= structureboundingbox.a && blockposition.getX() < structureboundingbox.d && blockposition.getZ() >= structureboundingbox.c && blockposition.getZ() < structureboundingbox.f) {
-                    if (flag) {
-                        if (i == 0) {
-                            // this.nextTickListHash.remove(nextticklistentry); // CraftBukkit - removed
-                        }
-
-                        iterator.remove();
-                    }
-
-                    if (arraylist == null) {
-                        arraylist = Lists.newArrayList();
-                    }
-
-                    arraylist.add(nextticklistentry);
-                }
-            }
-        }
-
-        return arraylist;
-    }
-
-    /* CraftBukkit start - We prevent spawning in general, so this butchering is not needed
-    public void entityJoinedWorld(Entity entity, boolean flag) {
-        if (!this.getSpawnAnimals() && (entity instanceof EntityAnimal || entity instanceof EntityWaterAnimal)) {
-            entity.die();
-        }
-
-        if (!this.getSpawnNPCs() && entity instanceof NPC) {
-            entity.die();
-        }
-
-        super.entityJoinedWorld(entity, flag);
-    }
-    // CraftBukkit end */
-
-    private boolean getSpawnNPCs() {
-        return this.server.getSpawnNPCs();
-    }
-
-    private boolean getSpawnAnimals() {
-        return this.server.getSpawnAnimals();
-    }
-
-    protected IChunkProvider n() {
-        IChunkLoader ichunkloader = this.dataManager.createChunkLoader(this.worldProvider);
-
-        // CraftBukkit start
-        org.bukkit.craftbukkit.generator.InternalChunkGenerator gen;
-
-        if (this.generator != null) {
-            gen = new org.bukkit.craftbukkit.generator.CustomChunkGenerator(this, this.getSeed(), this.generator);
-        } else if (this.worldProvider instanceof WorldProviderHell) {
-            gen = new org.bukkit.craftbukkit.generator.NetherChunkGenerator(this, this.getSeed());
-        } else if (this.worldProvider instanceof WorldProviderTheEnd) {
-            gen = new org.bukkit.craftbukkit.generator.SkyLandsChunkGenerator(this, this.getSeed());
-        } else {
-            gen = new org.bukkit.craftbukkit.generator.NormalChunkGenerator(this, this.getSeed());
-        }
-
-        return new ChunkProviderServer(this, ichunkloader, gen);
-        // CraftBukkit end
-    }
-
-    public List<TileEntity> getTileEntities(int i, int j, int k, int l, int i1, int j1) {
-        ArrayList arraylist = Lists.newArrayList();
-
-        // CraftBukkit start - Get tile entities from chunks instead of world
-        for (int chunkX = (i >> 4); chunkX <= ((l - 1) >> 4); chunkX++) {
-            for (int chunkZ = (k >> 4); chunkZ <= ((j1 - 1) >> 4); chunkZ++) {
-                Chunk chunk = getChunkAt(chunkX, chunkZ);
-                if (chunk == null) {
-                    continue;
-                }
-                for (Object te : chunk.tileEntities.values()) {
-                    TileEntity tileentity = (TileEntity) te;
-                    if ((tileentity.position.getX() >= i) && (tileentity.position.getY() >= j) && (tileentity.position.getZ() >= k) && (tileentity.position.getX() < l) && (tileentity.position.getY() < i1) && (tileentity.position.getZ() < j1)) {
-                        arraylist.add(tileentity);
-                    }
-                }
-            }
-        }
-        /*
-        for (int k1 = 0; k1 < this.tileEntityList.size(); ++k1) {
-            TileEntity tileentity = (TileEntity) this.tileEntityList.get(k1);
-            BlockPosition blockposition = tileentity.getPosition();
-
-            if (blockposition.getX() >= i && blockposition.getY() >= j && blockposition.getZ() >= k && blockposition.getX() < l && blockposition.getY() < i1 && blockposition.getZ() < j1) {
-                arraylist.add(tileentity);
-            }
-        }
-        */
-        // CraftBukkit end
-
-        return arraylist;
-    }
-
-    public boolean a(EntityHuman entityhuman, BlockPosition blockposition) {
-        return !this.server.a(this, blockposition, entityhuman) && this.getWorldBorder().a(blockposition);
-    }
-
-    public void a(WorldSettings worldsettings) {
-        if (!this.worldData.v()) {
-            try {
-                this.b(worldsettings);
-                if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
-                    this.an();
-                }
-
-                super.a(worldsettings);
-            } catch (Throwable throwable) {
-                CrashReport crashreport = CrashReport.a(throwable, "Exception initializing level");
-
-                try {
-                    this.a(crashreport);
-                } catch (Throwable throwable1) {
-                    ;
-                }
-
-                throw new ReportedException(crashreport);
-            }
-
-            this.worldData.d(true);
-        }
-
-    }
-
-    private void an() {
-        this.worldData.f(false);
-        this.worldData.c(true);
-        this.worldData.setStorm(false);
-        this.worldData.setThundering(false);
-        this.worldData.i(1000000000);
-        this.worldData.setDayTime(6000L);
-        this.worldData.setGameType(EnumGamemode.SPECTATOR);
-        this.worldData.g(false);
-        this.worldData.setDifficulty(EnumDifficulty.PEACEFUL);
-        this.worldData.e(true);
-        this.getGameRules().set("doDaylightCycle", "false");
-    }
-
-    private void b(WorldSettings worldsettings) {
-        if (!this.worldProvider.e()) {
-            this.worldData.setSpawn(BlockPosition.ZERO.up(this.worldProvider.getSeaLevel()));
-        } else if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
-            this.worldData.setSpawn(BlockPosition.ZERO.up());
-        } else {
-            this.isLoading = true;
-            WorldChunkManager worldchunkmanager = this.worldProvider.k();
-            List list = worldchunkmanager.a();
-            Random random = new Random(this.getSeed());
-            BlockPosition blockposition = worldchunkmanager.a(0, 0, 256, list, random);
-            int i = 8;
-            int j = this.worldProvider.getSeaLevel();
-            int k = 8;
-
-            // CraftBukkit start
-            if (this.generator != null) {
-                Random rand = new Random(this.getSeed());
-                org.bukkit.Location spawn = this.generator.getFixedSpawnLocation(((WorldServer) this).getWorld(), rand);
-
-                if (spawn != null) {
-                    if (spawn.getWorld() != ((WorldServer) this).getWorld()) {
-                        throw new IllegalStateException("Cannot set spawn point for " + this.worldData.getName() + " to be in another world (" + spawn.getWorld().getName() + ")");
-                    } else {
-                        this.worldData.setSpawn(new BlockPosition(spawn.getBlockX(), spawn.getBlockY(), spawn.getBlockZ()));
-                        this.isLoading = false;
-                        return;
-                    }
-                }
-            }
-            // CraftBukkit end
-
-            if (blockposition != null) {
-                i = blockposition.getX();
-                k = blockposition.getZ();
-            } else {
-                WorldServer.a.warn("Unable to find spawn biome");
-            }
-
-            int l = 0;
-
-            while (!this.canSpawn(i, k)) { // CraftBukkit - use our own canSpawn
-                i += random.nextInt(64) - random.nextInt(64);
-                k += random.nextInt(64) - random.nextInt(64);
-                ++l;
-                if (l == 1000) {
-                    break;
-                }
-            }
-
-            this.worldData.setSpawn(new BlockPosition(i, j, k));
-            this.isLoading = false;
-            if (worldsettings.c()) {
-                this.o();
-            }
-
-        }
-    }
-
-    protected void o() {
-        WorldGenBonusChest worldgenbonuschest = new WorldGenBonusChest();
-
-        for (int i = 0; i < 10; ++i) {
-            int j = this.worldData.b() + this.random.nextInt(6) - this.random.nextInt(6);
-            int k = this.worldData.d() + this.random.nextInt(6) - this.random.nextInt(6);
-            BlockPosition blockposition = this.q(new BlockPosition(j, 0, k)).up();
-
-            if (worldgenbonuschest.generate(this, this.random, blockposition)) {
-                break;
-            }
-        }
-
-    }
-
-    public BlockPosition getDimensionSpawn() {
-        return this.worldProvider.h();
-    }
-
-    public void save(boolean flag, @Nullable IProgressUpdate iprogressupdate) throws ExceptionWorldConflict {
-        ChunkProviderServer chunkproviderserver = this.getChunkProviderServer();
-
-        if (chunkproviderserver.e()) {
-            org.bukkit.Bukkit.getPluginManager().callEvent(new org.bukkit.event.world.WorldSaveEvent(getWorld())); // CraftBukkit
-            if (iprogressupdate != null) {
-                iprogressupdate.a("Saving level");
-            }
-
-            this.a();
-            if (iprogressupdate != null) {
-                iprogressupdate.c("Saving chunks");
-            }
-
-            chunkproviderserver.a(flag);
-            // CraftBukkit - ArrayList -> Collection
-            Collection arraylist = chunkproviderserver.a();
-            Iterator iterator = arraylist.iterator();
-
-            while (iterator.hasNext()) {
-                Chunk chunk = (Chunk) iterator.next();
-
-                if (chunk != null && !this.manager.a(chunk.locX, chunk.locZ)) {
-                    chunkproviderserver.unload(chunk);
-                }
-            }
-
-        }
-    }
-
-    public void flushSave() {
-        ChunkProviderServer chunkproviderserver = this.getChunkProviderServer();
-
-        if (chunkproviderserver.e()) {
-            chunkproviderserver.c();
-        }
-    }
-
-    protected void a() throws ExceptionWorldConflict {
-        this.checkSession();
-        WorldServer[] aworldserver = this.server.worldServer;
-        int i = aworldserver.length;
-
-        for (int j = 0; j < i; ++j) {
-            WorldServer worldserver = aworldserver[j];
-
-            if (worldserver instanceof SecondaryWorldServer) {
-                ((SecondaryWorldServer) worldserver).c();
-            }
-        }
-
-        // CraftBukkit start - Save secondary data for nether/end
-        if (this instanceof SecondaryWorldServer) {
-            ((SecondaryWorldServer) this).c();
-        }
-        // CraftBukkit end
-
-        this.worldData.a(this.getWorldBorder().getSize());
-        this.worldData.d(this.getWorldBorder().getCenterX());
-        this.worldData.c(this.getWorldBorder().getCenterZ());
-        this.worldData.e(this.getWorldBorder().getDamageBuffer());
-        this.worldData.f(this.getWorldBorder().getDamageAmount());
-        this.worldData.j(this.getWorldBorder().getWarningDistance());
-        this.worldData.k(this.getWorldBorder().getWarningTime());
-        this.worldData.b(this.getWorldBorder().j());
-        this.worldData.e(this.getWorldBorder().i());
-        this.dataManager.saveWorldData(this.worldData, this.server.getPlayerList().t());
-        this.worldMaps.a();
-    }
-
-    public boolean addEntity(Entity entity) {
-        return this.i(entity) ? super.addEntity(entity) : false;
-    }
-
-    public void a(Collection<Entity> collection) {
-        ArrayList arraylist = Lists.newArrayList(collection);
-        Iterator iterator = arraylist.iterator();
-
-        while (iterator.hasNext()) {
-            Entity entity = (Entity) iterator.next();
-
-            if (this.i(entity)) {
-                this.entityList.add(entity);
-                this.b(entity);
-            }
-        }
-
-    }
-
-    private boolean i(Entity entity) {
-        if (entity.dead) {
-            // WorldServer.a.warn("Tried to add entity {} but it was marked as removed already", new Object[] { EntityTypes.b(entity)}); // CraftBukkit
-            return false;
-        } else {
-            UUID uuid = entity.getUniqueID();
-
-            if (this.entitiesByUUID.containsKey(uuid)) {
-                Entity entity1 = (Entity) this.entitiesByUUID.get(uuid);
-
-                if (this.f.contains(entity1)) {
-                    this.f.remove(entity1);
-                } else {
-                    if (!(entity instanceof EntityHuman)) {
-                        // WorldServer.a.warn("Keeping entity {} that already exists with UUID {}", new Object[] { EntityTypes.b(entity1), uuid.toString()}); // CraftBukkit
-                        return false;
-                    }
-
-                    WorldServer.a.warn("Force-added player with duplicate UUID {}", new Object[] { uuid.toString()});
-                }
-
-                this.removeEntity(entity1);
-            }
-
-            return true;
-        }
-    }
-
-    protected void b(Entity entity) {
-        super.b(entity);
-        this.entitiesById.a(entity.getId(), entity);
-        this.entitiesByUUID.put(entity.getUniqueID(), entity);
-        Entity[] aentity = entity.aT();
-
-        if (aentity != null) {
-            Entity[] aentity1 = aentity;
-            int i = aentity.length;
-
-            for (int j = 0; j < i; ++j) {
-                Entity entity1 = aentity1[j];
-
-                this.entitiesById.a(entity1.getId(), entity1);
-            }
-        }
-
-    }
-
-    protected void c(Entity entity) {
-        super.c(entity);
-        this.entitiesById.d(entity.getId());
-        this.entitiesByUUID.remove(entity.getUniqueID());
-        Entity[] aentity = entity.aT();
-
-        if (aentity != null) {
-            Entity[] aentity1 = aentity;
-            int i = aentity.length;
-
-            for (int j = 0; j < i; ++j) {
-                Entity entity1 = aentity1[j];
-
-                this.entitiesById.d(entity1.getId());
-            }
-        }
-
-    }
-
-    public boolean strikeLightning(Entity entity) {
-        // CraftBukkit start
-        LightningStrikeEvent lightning = new LightningStrikeEvent(this.getWorld(), (org.bukkit.entity.LightningStrike) entity.getBukkitEntity());
-        this.getServer().getPluginManager().callEvent(lightning);
-
-        if (lightning.isCancelled()) {
-            return false;
-        }
-        // CraftBukkit end
-        if (super.strikeLightning(entity)) {
-            this.server.getPlayerList().sendPacketNearby((EntityHuman) null, entity.locX, entity.locY, entity.locZ, 512.0D, dimension, new PacketPlayOutSpawnEntityWeather(entity)); // CraftBukkit - Use dimension
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    public void broadcastEntityEffect(Entity entity, byte b0) {
-        this.getTracker().sendPacketToEntity(entity, new PacketPlayOutEntityStatus(entity, b0));
-    }
-
-    public ChunkProviderServer getChunkProviderServer() {
-        return (ChunkProviderServer) super.getChunkProvider();
-    }
-
-    public Explosion createExplosion(@Nullable Entity entity, double d0, double d1, double d2, float f, boolean flag, boolean flag1) {
-        // CraftBukkit start
-        Explosion explosion = super.createExplosion(entity, d0, d1, d2, f, flag, flag1);
-
-        if (explosion.wasCanceled) {
-            return explosion;
-        }
-
-        /* Remove
-        Explosion explosion = new Explosion(this, entity, d0, d1, d2, f, flag, flag1);
-
-        explosion.a();
-        explosion.a(false);
-        */
-        // CraftBukkit end - TODO: Check if explosions are still properly implemented
-        if (!flag1) {
-            explosion.clearBlocks();
-        }
-
-        Iterator iterator = this.players.iterator();
-
-        while (iterator.hasNext()) {
-            EntityHuman entityhuman = (EntityHuman) iterator.next();
-
-            if (entityhuman.e(d0, d1, d2) < 4096.0D) {
-                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutExplosion(d0, d1, d2, f, explosion.getBlocks(), (Vec3D) explosion.b().get(entityhuman)));
-            }
-        }
-
-        return explosion;
-    }
-
-    public void playBlockAction(BlockPosition blockposition, Block block, int i, int j) {
-        BlockActionData blockactiondata = new BlockActionData(blockposition, block, i, j);
-        Iterator iterator = this.S[this.T].iterator();
-
-        BlockActionData blockactiondata1;
-
-        do {
-            if (!iterator.hasNext()) {
-                this.S[this.T].add(blockactiondata);
-                return;
-            }
-
-            blockactiondata1 = (BlockActionData) iterator.next();
-        } while (!blockactiondata1.equals(blockactiondata));
-
-    }
-
-    private void ao() {
-        while (!this.S[this.T].isEmpty()) {
-            int i = this.T;
-
-            this.T ^= 1;
-            Iterator iterator = this.S[i].iterator();
-
-            while (iterator.hasNext()) {
-                BlockActionData blockactiondata = (BlockActionData) iterator.next();
-
-                if (this.a(blockactiondata)) {
-                    // CraftBukkit - this.worldProvider.dimension -> this.dimension
-                    this.server.getPlayerList().sendPacketNearby((EntityHuman) null, (double) blockactiondata.a().getX(), (double) blockactiondata.a().getY(), (double) blockactiondata.a().getZ(), 64.0D, dimension, new PacketPlayOutBlockAction(blockactiondata.a(), blockactiondata.d(), blockactiondata.b(), blockactiondata.c()));
-                }
-            }
-
-            this.S[i].clear();
-        }
-
-    }
-
-    private boolean a(BlockActionData blockactiondata) {
-        IBlockData iblockdata = this.getType(blockactiondata.a());
-
-        return iblockdata.getBlock() == blockactiondata.d() ? iblockdata.a(this, blockactiondata.a(), blockactiondata.b(), blockactiondata.c()) : false;
-    }
-
-    public void saveLevel() {
-        this.dataManager.a();
-    }
-
-    protected void t() {
-        boolean flag = this.W();
-
-        super.t();
-        /* CraftBukkit start
-        if (this.n != this.o) {
-            this.server.getPlayerList().a((Packet) (new PacketPlayOutGameStateChange(7, this.o)), this.worldProvider.getDimensionManager().getDimensionID());
-        }
-
-        if (this.p != this.q) {
-            this.server.getPlayerList().a((Packet) (new PacketPlayOutGameStateChange(8, this.q)), this.worldProvider.getDimensionManager().getDimensionID());
-        }
-
-        if (flag != this.W()) {
-            if (flag) {
-                this.server.getPlayerList().sendAll(new PacketPlayOutGameStateChange(2, 0.0F));
-            } else {
-                this.server.getPlayerList().sendAll(new PacketPlayOutGameStateChange(1, 0.0F));
-            }
-
-            this.server.getPlayerList().sendAll(new PacketPlayOutGameStateChange(7, this.o));
-            this.server.getPlayerList().sendAll(new PacketPlayOutGameStateChange(8, this.q));
-        }
-        // */
-        if (flag != this.W()) {
-            // Only send weather packets to those affected
-            for (int i = 0; i < this.players.size(); ++i) {
-                if (((EntityPlayer) this.players.get(i)).world == this) {
-                    ((EntityPlayer) this.players.get(i)).setPlayerWeather((!flag ? WeatherType.DOWNFALL : WeatherType.CLEAR), false);
-                }
-            }
-        }
-        for (int i = 0; i < this.players.size(); ++i) {
-            if (((EntityPlayer) this.players.get(i)).world == this) {
-                ((EntityPlayer) this.players.get(i)).updateWeather(this.n, this.o, this.p, this.q);
-            }
-        }
-        // CraftBukkit end
-
-    }
-
-    @Nullable
-    public MinecraftServer getMinecraftServer() {
-        return this.server;
-    }
-
-    public EntityTracker getTracker() {
-        return this.tracker;
-    }
-
-    public PlayerChunkMap getPlayerChunkMap() {
-        return this.manager;
-    }
-
-    public PortalTravelAgent getTravelAgent() {
-        return this.portalTravelAgent;
-    }
-
-    public DefinedStructureManager y() {
-        return this.dataManager.h();
-    }
-
-    public void a(EnumParticle enumparticle, double d0, double d1, double d2, int i, double d3, double d4, double d5, double d6, int... aint) {
-        this.a(enumparticle, false, d0, d1, d2, i, d3, d4, d5, d6, aint);
-    }
-
-    public void a(EnumParticle enumparticle, boolean flag, double d0, double d1, double d2, int i, double d3, double d4, double d5, double d6, int... aint) {
-        // CraftBukkit - visibility api support
-        sendParticles(null, enumparticle, flag, d0, d1, d2, i, d3, d4, d5, d6, aint);
-    }
-
-    public void sendParticles(EntityPlayer sender, EnumParticle enumparticle, boolean flag, double d0, double d1, double d2, int i, double d3, double d4, double d5, double d6, int... aint) {
-        // CraftBukkit end
-        PacketPlayOutWorldParticles packetplayoutworldparticles = new PacketPlayOutWorldParticles(enumparticle, flag, (float) d0, (float) d1, (float) d2, (float) d3, (float) d4, (float) d5, (float) d6, i, aint);
-
-        for (int j = 0; j < this.players.size(); ++j) {
-            EntityPlayer entityplayer = (EntityPlayer) this.players.get(j);
-            if (sender != null && !entityplayer.getBukkitEntity().canSee(sender.getBukkitEntity())) continue; // CraftBukkit
-            BlockPosition blockposition = entityplayer.getChunkCoordinates();
-            double d7 = blockposition.distanceSquared(d0, d1, d2);
-
-
-            this.a(entityplayer, flag, d0, d1, d2, packetplayoutworldparticles);
-        }
-
-    }
-
-    public void a(EntityPlayer entityplayer, EnumParticle enumparticle, boolean flag, double d0, double d1, double d2, int i, double d3, double d4, double d5, double d6, int... aint) {
-        PacketPlayOutWorldParticles packetplayoutworldparticles = new PacketPlayOutWorldParticles(enumparticle, flag, (float) d0, (float) d1, (float) d2, (float) d3, (float) d4, (float) d5, (float) d6, i, aint);
-
-        this.a(entityplayer, flag, d0, d1, d2, packetplayoutworldparticles);
-    }
-
-    private void a(EntityPlayer entityplayer, boolean flag, double d0, double d1, double d2, Packet<?> packet) {
-        BlockPosition blockposition = entityplayer.getChunkCoordinates();
-        double d3 = blockposition.distanceSquared(d0, d1, d2);
-
-        if (d3 <= 1024.0D || flag && d3 <= 262144.0D) {
-            entityplayer.playerConnection.sendPacket(packet);
-        }
-
-    }
-
-    @Nullable
-    public Entity getEntity(UUID uuid) {
-        return (Entity) this.entitiesByUUID.get(uuid);
-    }
-
-    public ListenableFuture<Object> postToMainThread(Runnable runnable) {
-        return this.server.postToMainThread(runnable);
-    }
-
-    public boolean isMainThread() {
-        return this.server.isMainThread();
-    }
-
-    public IChunkProvider getChunkProvider() {
-        return this.getChunkProviderServer();
-    }
-
-    static class BlockActionDataList extends ArrayList<BlockActionData> {
-
-        private BlockActionDataList() {}
-
-        BlockActionDataList(Object object) {
-            this();
-        }
-    }
-}
+package net.minecraft.server;
+
+import com.google.common.base.Predicate;
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
+import com.google.common.collect.Sets;
+import com.google.common.util.concurrent.ListenableFuture;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Queue;
+import java.util.Random;
+import java.util.Set;
+import java.util.TreeSet;
+import java.util.UUID;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ForkJoinTask;
+import java.util.concurrent.RecursiveAction;
+import java.util.concurrent.RecursiveTask;
+import javax.annotation.Nullable;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+// CraftBukkit start
+import java.util.logging.Level;
+import java.util.stream.IntStream;
+
+import org.bukkit.WeatherType;
+import org.bukkit.block.BlockState;
+import org.bukkit.craftbukkit.util.HashTreeSet;
+
+import org.bukkit.event.block.BlockFormEvent;
+import org.bukkit.event.weather.LightningStrikeEvent;
+import org.spigotmc.SpigotWorldConfig;
+// CraftBukkit end
+
+public class WorldServer extends World implements IAsyncTaskHandler {
+
+    private static final Logger a = LogManager.getLogger();
+    private final MinecraftServer server;
+    public EntityTracker tracker;
+    private final PlayerChunkMap manager;
+    // private final Set<NextTickListEntry> nextTickListHash = Sets.newHashSet();
+    private final HashTreeSet<NextTickListEntry> nextTickList = new HashTreeSet<NextTickListEntry>(); // CraftBukkit - HashTreeSet
+    private final Set<NextTickListEntry> nextTickQueue = Sets.newConcurrentHashSet();
+    private final Set<NextTickListEntry> nextTickList_remove = Sets.newConcurrentHashSet();
+    private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
+    public boolean savingDisabled;
+    private boolean O;
+    private int emptyTime;
+    private final PortalTravelAgent portalTravelAgent;
+    private final SpawnerCreature spawnerCreature = new SpawnerCreature();
+    protected final VillageSiege siegeManager = new VillageSiege(this);
+    private final WorldServer.BlockActionDataList[] S = new WorldServer.BlockActionDataList[] { new WorldServer.BlockActionDataList(null), new WorldServer.BlockActionDataList(null)};
+    private int T;
+    //private final List<NextTickListEntry> U = Lists.newArrayList();
+    private final Queue<NextTickListEntry> U = Queues.newConcurrentLinkedQueue();
+
+    // CraftBukkit start
+    public final int dimension;
+
+    // Add env and gen to constructor
+    public WorldServer(MinecraftServer minecraftserver, IDataManager idatamanager, WorldData worlddata, int i, MethodProfiler methodprofiler, org.bukkit.World.Environment env, org.bukkit.generator.ChunkGenerator gen) {
+        super(idatamanager, worlddata, DimensionManager.a(env.getId()).d(), methodprofiler, false, gen, env);
+        this.dimension = i;
+        this.pvpMode = minecraftserver.getPVP();
+        worlddata.world = this;
+        // CraftBukkit end
+        this.server = minecraftserver;
+        this.tracker = new EntityTracker(this);
+        this.manager = new PlayerChunkMap(this, spigotConfig.viewDistance); // Spigot
+        this.worldProvider.a((World) this);
+        this.chunkProvider = this.n();
+        this.portalTravelAgent = new org.bukkit.craftbukkit.CraftTravelAgent(this); // CraftBukkit
+        this.H();
+        this.I();
+        this.getWorldBorder().a(minecraftserver.aD());
+    }
+
+    public World b() {
+        this.worldMaps = new PersistentCollection(this.dataManager);
+        String s = PersistentVillage.a(this.worldProvider);
+        PersistentVillage persistentvillage = (PersistentVillage) this.worldMaps.get(PersistentVillage.class, s);
+
+        if (persistentvillage == null) {
+            this.villages = new PersistentVillage(this);
+            this.worldMaps.a(s, this.villages);
+        } else {
+            this.villages = persistentvillage;
+            this.villages.a((World) this);
+        }
+
+        if (getServer().getScoreboardManager() == null) { // CraftBukkit
+        this.scoreboard = new ScoreboardServer(this.server);
+        PersistentScoreboard persistentscoreboard = (PersistentScoreboard) this.worldMaps.get(PersistentScoreboard.class, "scoreboard");
+
+        if (persistentscoreboard == null) {
+            persistentscoreboard = new PersistentScoreboard();
+            this.worldMaps.a("scoreboard", persistentscoreboard);
+        }
+
+        persistentscoreboard.a(this.scoreboard);
+        ((ScoreboardServer) this.scoreboard).a((Runnable) (new RunnableSaveScoreboard(persistentscoreboard)));
+        // CraftBukkit start
+        } else {
+            this.scoreboard = getServer().getScoreboardManager().getMainScoreboard().getHandle();
+        }
+        // CraftBukkit end
+        this.B = new LootTableRegistry(new File(new File(this.dataManager.getDirectory(), "data"), "loot_tables"));
+        this.getWorldBorder().setCenter(this.worldData.B(), this.worldData.C());
+        this.getWorldBorder().setDamageAmount(this.worldData.H());
+        this.getWorldBorder().setDamageBuffer(this.worldData.G());
+        this.getWorldBorder().setWarningDistance(this.worldData.I());
+        this.getWorldBorder().setWarningTime(this.worldData.J());
+        if (this.worldData.E() > 0L) {
+            this.getWorldBorder().transitionSizeBetween(this.worldData.D(), this.worldData.F(), this.worldData.E());
+        } else {
+            this.getWorldBorder().setSize(this.worldData.D());
+        }
+
+        // CraftBukkit start
+        if (generator != null) {
+            getWorld().getPopulators().addAll(generator.getDefaultPopulators(getWorld()));
+        }
+        // CraftBukkit end
+
+        return this;
+    }
+
+    // CraftBukkit start
+    @Override
+    public TileEntity getTileEntity(BlockPosition pos) {
+        TileEntity result = super.getTileEntity(pos);
+        Block type = getType(pos).getBlock();
+
+        if (type == Blocks.CHEST || type == Blocks.TRAPPED_CHEST) { // Spigot
+            if (!(result instanceof TileEntityChest)) {
+                result = fixTileEntity(pos, type, result);
+            }
+        } else if (type == Blocks.FURNACE) {
+            if (!(result instanceof TileEntityFurnace)) {
+                result = fixTileEntity(pos, type, result);
+            }
+        } else if (type == Blocks.DROPPER) {
+            if (!(result instanceof TileEntityDropper)) {
+                result = fixTileEntity(pos, type, result);
+            }
+        } else if (type == Blocks.DISPENSER) {
+            if (!(result instanceof TileEntityDispenser)) {
+                result = fixTileEntity(pos, type, result);
+            }
+        } else if (type == Blocks.JUKEBOX) {
+            if (!(result instanceof BlockJukeBox.TileEntityRecordPlayer)) {
+                result = fixTileEntity(pos, type, result);
+            }
+        } else if (type == Blocks.NOTEBLOCK) {
+            if (!(result instanceof TileEntityNote)) {
+                result = fixTileEntity(pos, type, result);
+            }
+        } else if (type == Blocks.MOB_SPAWNER) {
+            if (!(result instanceof TileEntityMobSpawner)) {
+                result = fixTileEntity(pos, type, result);
+            }
+        } else if ((type == Blocks.STANDING_SIGN) || (type == Blocks.WALL_SIGN)) {
+            if (!(result instanceof TileEntitySign)) {
+                result = fixTileEntity(pos, type, result);
+            }
+        } else if (type == Blocks.ENDER_CHEST) {
+            if (!(result instanceof TileEntityEnderChest)) {
+                result = fixTileEntity(pos, type, result);
+            }
+        } else if (type == Blocks.BREWING_STAND) {
+            if (!(result instanceof TileEntityBrewingStand)) {
+                result = fixTileEntity(pos, type, result);
+            }
+        } else if (type == Blocks.BEACON) {
+            if (!(result instanceof TileEntityBeacon)) {
+                result = fixTileEntity(pos, type, result);
+            }
+        } else if (type == Blocks.HOPPER) {
+            if (!(result instanceof TileEntityHopper)) {
+                result = fixTileEntity(pos, type, result);
+            }
+        }
+
+        return result;
+    }
+
+    private TileEntity fixTileEntity(BlockPosition pos, Block type, TileEntity found) {
+        this.getServer().getLogger().log(Level.SEVERE, "Block at {0},{1},{2} is {3} but has {4}" + ". "
+                + "Bukkit will attempt to fix this, but there may be additional damage that we cannot recover.", new Object[]{pos.getX(), pos.getY(), pos.getZ(), org.bukkit.Material.getMaterial(Block.getId(type)).toString(), found});
+
+        if (type instanceof ITileEntity) {
+            TileEntity replacement = ((ITileEntity) type).a(this, type.toLegacyData(this.getType(pos)));
+            replacement.world = this;
+            this.setTileEntity(pos, replacement);
+            return replacement;
+        } else {
+            this.getServer().getLogger().severe("Don't know how to fix for this type... Can't do anything! :(");
+            return found;
+        }
+    }
+
+    private boolean canSpawn(int x, int z) {
+        if (this.generator != null) {
+            return this.generator.canSpawn(this.getWorld(), x, z);
+        } else {
+            return this.worldProvider.canSpawn(x, z);
+        }
+    }
+    // CraftBukkit end
+
+    public void doTick() {
+        super.doTick();
+        if (this.getWorldData().isHardcore() && this.getDifficulty() != EnumDifficulty.HARD) {
+            this.getWorldData().setDifficulty(EnumDifficulty.HARD);
+        }
+
+        this.worldProvider.k().b();
+        if (this.everyoneDeeplySleeping()) {
+            if (this.getGameRules().getBoolean("doDaylightCycle")) {
+                long i = this.worldData.getDayTime() + 24000L;
+
+                this.worldData.setDayTime(i - i % 24000L);
+            }
+
+            this.f();
+        }
+
+        // CraftBukkit start - Only call spawner if we have players online and the world allows for mobs or animals
+        long time = this.worldData.getTime();
+        if (this.getGameRules().getBoolean("doMobSpawning") && this.worldData.getType() != WorldType.DEBUG_ALL_BLOCK_STATES && (this.allowMonsters || this.allowAnimals) && (this instanceof WorldServer && this.players.size() > 0)) {
+            timings.mobSpawn.startTiming(); // Spigot
+            //this.spawnerCreature.a(this, this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldData.getTime() % 400L == 0L);
+            SpigotWorldConfig.TickTask = ForkJoinTask.adapt(new mobspawn(this, this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldData.getTime() % 400L == 0L));
+            SpigotWorldConfig.TickPool.submit(SpigotWorldConfig.TickTask);
+            timings.mobSpawn.stopTiming(); // Spigot
+            // CraftBukkit end
+        }
+
+        timings.doChunkUnload.startTiming(); // Spigot
+        this.methodProfiler.c("chunkSource");
+        this.chunkProvider.unloadChunks();
+        int j = this.a(1.0F);
+
+        if (j != this.af()) {
+            this.c(j);
+        }
+
+        this.worldData.setTime(this.worldData.getTime() + 1L);
+        if (this.getGameRules().getBoolean("doDaylightCycle")) {
+            this.worldData.setDayTime(this.worldData.getDayTime() + 1L);
+        }
+
+        timings.doChunkUnload.stopTiming(); // Spigot
+        this.methodProfiler.c("tickPending");
+        timings.doTickPending.startTiming(); // Spigot
+        this.a(false);
+        timings.doTickPending.stopTiming(); // Spigot
+        this.methodProfiler.c("tickBlocks");
+        timings.doTickTiles.startTiming(); // Spigot
+        this.j();
+        timings.doTickTiles.stopTiming(); // Spigot
+        this.methodProfiler.c("chunkMap");
+        timings.doChunkMap.startTiming(); // Spigot
+        this.manager.flush();
+        timings.doChunkMap.stopTiming(); // Spigot
+        this.methodProfiler.c("village");
+        timings.doVillages.startTiming(); // Spigot
+        this.villages.tick();
+        this.siegeManager.a();
+        timings.doVillages.stopTiming(); // Spigot
+        this.methodProfiler.c("portalForcer");
+        timings.doPortalForcer.startTiming(); // Spigot
+        this.portalTravelAgent.a(this.getTime());
+        timings.doPortalForcer.stopTiming(); // Spigot
+        this.methodProfiler.b();
+        timings.doSounds.startTiming(); // Spigot
+        this.ao();
+        timings.doSounds.stopTiming(); // Spigot
+
+        timings.doChunkGC.startTiming();// Spigot
+        this.getWorld().processChunkGC(); // CraftBukkit
+        timings.doChunkGC.stopTiming(); // Spigot
+        if (!this.nextTickQueue.isEmpty()) {
+            this.nextTickList.addAll(this.nextTickQueue);
+            this.nextTickQueue.clear();
+        }
+    }
+
+    @Nullable
+    public BiomeBase.BiomeMeta a(EnumCreatureType enumcreaturetype, BlockPosition blockposition) {
+        List list = this.getChunkProviderServer().a(enumcreaturetype, blockposition);
+
+        return list != null && !list.isEmpty() ? (BiomeBase.BiomeMeta) WeightedRandom.a(this.random, list) : null;
+    }
+
+    //forkjoin
+    public boolean a(EnumCreatureType enumcreaturetype, BiomeBase.BiomeMeta biomebase_biomemeta, BlockPosition blockposition) {
+        //List list = this.getChunkProviderServer().a(enumcreaturetype, blockposition);
+        SpigotWorldConfig.TickTask = ForkJoinTask.adapt(new biometa(this, enumcreaturetype, blockposition));
+        SpigotWorldConfig.TickPool.submit(SpigotWorldConfig.TickTask);
+        List list = null;
+        try {
+            list = (List) SpigotWorldConfig.TickTask.get();
+        } catch (InterruptedException ex) {
+            java.util.logging.Logger.getLogger(WorldServer.class.getName()).log(Level.SEVERE, null, ex);
+        } catch (ExecutionException ex) {
+            java.util.logging.Logger.getLogger(WorldServer.class.getName()).log(Level.SEVERE, null, ex);
+        }
+
+        return list != null && !list.isEmpty() ? list.contains(biomebase_biomemeta) : false;
+    }
+
+    public void everyoneSleeping() {
+        this.O = false;
+        if (!this.players.isEmpty()) {
+            int i = 0;
+            int j = 0;
+            Iterator iterator = this.players.iterator();
+
+            while (iterator.hasNext()) {
+                EntityHuman entityhuman = (EntityHuman) iterator.next();
+
+                if (entityhuman.isSpectator()) {
+                    ++i;
+                } else if (entityhuman.isSleeping() || entityhuman.fauxSleeping) {
+                    ++j;
+                }
+            }
+
+            this.O = j > 0 && j >= this.players.size() - i;
+        }
+
+    }
+
+    protected void f() {
+        this.O = false;
+        Iterator iterator = this.players.iterator();
+
+        while (iterator.hasNext()) {
+            EntityHuman entityhuman = (EntityHuman) iterator.next();
+
+            if (entityhuman.isSleeping()) {
+                entityhuman.a(false, false, true);
+            }
+        }
+
+        this.c();
+    }
+
+    private void c() {
+        this.worldData.setStorm(false);
+        // CraftBukkit start
+        // If we stop due to everyone sleeping we should reset the weather duration to some other random value.
+        // Not that everyone ever manages to get the whole server to sleep at the same time....
+        if (!this.worldData.hasStorm()) {
+            this.worldData.setWeatherDuration(0);
+        }
+        // CraftBukkit end
+        this.worldData.setThundering(false);
+        // CraftBukkit start
+        // If we stop due to everyone sleeping we should reset the weather duration to some other random value.
+        // Not that everyone ever manages to get the whole server to sleep at the same time....
+        if (!this.worldData.isThundering()) {
+            this.worldData.setThunderDuration(0);
+        }
+        // CraftBukkit end
+    }
+
+    public boolean everyoneDeeplySleeping() {
+        if (this.O && !this.isClientSide) {
+            Iterator iterator = this.players.iterator();
+
+            // CraftBukkit - This allows us to assume that some people are in bed but not really, allowing time to pass in spite of AFKers
+            boolean foundActualSleepers = false;
+
+            EntityHuman entityhuman;
+
+            do {
+                if (!iterator.hasNext()) {
+                    return foundActualSleepers;
+                }
+
+                entityhuman = (EntityHuman) iterator.next();
+
+                // CraftBukkit start
+                if (entityhuman.isDeeplySleeping()) {
+                    foundActualSleepers = true;
+                }
+            } while (!entityhuman.isSpectator() || entityhuman.isDeeplySleeping() || entityhuman.fauxSleeping);
+            // CraftBukkit end
+
+            return false;
+        } else {
+            return false;
+        }
+    }
+
+    protected boolean isChunkLoaded(int i, int j, boolean flag) {
+        return this.getChunkProviderServer().isLoaded(i, j);
+    }
+
+    protected void i() {
+        this.methodProfiler.a("playerCheckLight");
+        if (spigotConfig.randomLightUpdates && !this.players.isEmpty()) { // Spigot
+            int i = this.random.nextInt(this.players.size());
+            EntityHuman entityhuman = (EntityHuman) this.players.get(i);
+            int j = MathHelper.floor(entityhuman.locX) + this.random.nextInt(11) - 5;
+            int k = MathHelper.floor(entityhuman.locY) + this.random.nextInt(11) - 5;
+            int l = MathHelper.floor(entityhuman.locZ) + this.random.nextInt(11) - 5;
+
+            this.w(new BlockPosition(j, k, l));
+        }
+
+        this.methodProfiler.b();
+    }
+
+    protected void j() {
+        this.i();
+        if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
+            Iterator iterator = this.manager.b();
+
+            while (iterator.hasNext()) {
+                ((Chunk) iterator.next()).b(false);
+            }
+
+        } else {
+            int i = this.getGameRules().c("randomTickSpeed");
+            boolean flag = this.W();
+            boolean flag1 = this.V();
+
+            this.methodProfiler.a("pollingChunks");
+
+            for (Iterator iterator1 = this.manager.b(); iterator1.hasNext(); this.methodProfiler.b()) {
+                this.methodProfiler.a("getChunk");
+                Chunk chunk = (Chunk) iterator1.next();
+                int j = chunk.locX * 16;
+                int k = chunk.locZ * 16;
+
+                this.methodProfiler.c("checkNextLight");
+                chunk.n();
+                this.methodProfiler.c("tickChunk");
+                chunk.b(false);
+                if ( !chunk.areNeighborsLoaded( 1 ) ) continue; // Spigot
+                this.methodProfiler.c("thunder");
+                int l;
+                BlockPosition blockposition;
+
+                if (flag && flag1 && this.random.nextInt(100000) == 0) {
+                    this.l = this.l * 3 + 1013904223;
+                    l = this.l >> 2;
+                    blockposition = this.a(new BlockPosition(j + (l & 15), 0, k + (l >> 8 & 15)));
+                    if (this.isRainingAt(blockposition)) {
+                        DifficultyDamageScaler difficultydamagescaler = this.D(blockposition);
+
+                        if (this.random.nextDouble() < (double) difficultydamagescaler.b() * 0.05D) {
+                            EntityHorse entityhorse = new EntityHorse(this);
+
+                            entityhorse.setType(EnumHorseType.SKELETON);
+                            entityhorse.y(true);
+                            entityhorse.setAgeRaw(0);
+                            entityhorse.setPosition((double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ());
+                            this.addEntity(entityhorse, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.LIGHTNING); // CraftBukkit
+                            this.strikeLightning(new EntityLightning(this, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), true));
+                        } else {
+                            this.strikeLightning(new EntityLightning(this, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), false));
+                        }
+                    }
+                }
+
+                this.methodProfiler.c("iceandsnow");
+                if (this.random.nextInt(16) == 0) {
+                    this.l = this.l * 3 + 1013904223;
+                    l = this.l >> 2;
+                    blockposition = this.p(new BlockPosition(j + (l & 15), 0, k + (l >> 8 & 15)));
+                    BlockPosition blockposition1 = blockposition.down();
+
+                    if (this.v(blockposition1)) {
+                        // CraftBukkit start
+                        BlockState blockState = this.getWorld().getBlockAt(blockposition1.getX(), blockposition1.getY(), blockposition1.getZ()).getState();
+                        blockState.setTypeId(Block.getId(Blocks.ICE));
+
+                        BlockFormEvent iceBlockForm = new BlockFormEvent(blockState.getBlock(), blockState);
+                        this.getServer().getPluginManager().callEvent(iceBlockForm);
+                        if (!iceBlockForm.isCancelled()) {
+                            blockState.update(true);
+                        }
+                        // CraftBukkit end
+                    }
+
+                    if (flag && this.f(blockposition, true)) {
+                        // CraftBukkit start
+                        BlockState blockState = this.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()).getState();
+                        blockState.setTypeId(Block.getId(Blocks.SNOW_LAYER));
+
+                        BlockFormEvent snow = new BlockFormEvent(blockState.getBlock(), blockState);
+                        this.getServer().getPluginManager().callEvent(snow);
+                        if (!snow.isCancelled()) {
+                            blockState.update(true);
+                        }
+                        // CraftBukkit end
+                    }
+
+                    if (flag && this.getBiome(blockposition1).d()) {
+                        this.getType(blockposition1).getBlock().h(this, blockposition1);
+                    }
+                }
+
+                this.methodProfiler.c("tickBlocks");
+                if (i > 0) {
+                    ChunkSection[] achunksection = chunk.getSections();
+                    int i1 = achunksection.length;
+
+                    for (int j1 = 0; j1 < i1; ++j1) {
+                        ChunkSection chunksection = achunksection[j1];
+
+                        if (chunksection != Chunk.a && chunksection.shouldTick()) {
+                            for (int k1 = 0; k1 < i; ++k1) {
+                                this.l = this.l * 3 + 1013904223;
+                                int l1 = this.l >> 2;
+                                int i2 = l1 & 15;
+                                int j2 = l1 >> 8 & 15;
+                                int k2 = l1 >> 16 & 15;
+                                IBlockData iblockdata = chunksection.getType(i2, k2, j2);
+                                Block block = iblockdata.getBlock();
+
+                                this.methodProfiler.a("randomTick");
+                                if (block.isTicking()) {
+                                    block.a((World) this, new BlockPosition(i2 + j, k2 + chunksection.getYPosition(), j2 + k), iblockdata, this.random);
+                                }
+
+                                this.methodProfiler.b();
+                            }
+                        }
+                    }
+                }
+            }
+
+            this.methodProfiler.b();
+        }
+    }
+
+    protected BlockPosition a(BlockPosition blockposition) {
+        BlockPosition blockposition1 = this.p(blockposition);
+        AxisAlignedBB axisalignedbb = (new AxisAlignedBB(blockposition1, new BlockPosition(blockposition1.getX(), this.getHeight(), blockposition1.getZ()))).g(3.0D);
+        List list = this.a(EntityLiving.class, axisalignedbb, new Predicate() {
+            public boolean a(@Nullable EntityLiving entityliving) {
+                return entityliving != null && entityliving.isAlive() && WorldServer.this.h(entityliving.getChunkCoordinates());
+            }
+
+            public boolean apply(Object object) {
+                return this.a((EntityLiving) object);
+            }
+        });
+
+        if (!list.isEmpty()) {
+            return ((EntityLiving) list.get(this.random.nextInt(list.size()))).getChunkCoordinates();
+        } else {
+            if (blockposition1.getY() == -1) {
+                blockposition1 = blockposition1.up(2);
+            }
+
+            return blockposition1;
+        }
+    }
+
+    public boolean a(BlockPosition blockposition, Block block) {
+        NextTickListEntry nextticklistentry = new NextTickListEntry(blockposition, block);
+
+        return this.U.contains(nextticklistentry);
+    }
+
+    public boolean b(BlockPosition blockposition, Block block) {
+        NextTickListEntry nextticklistentry = new NextTickListEntry(blockposition, block);
+
+        return this.nextTickList.contains(nextticklistentry); // CraftBukkit
+    }
+
+    public void a(BlockPosition blockposition, Block block, int i) {
+        this.a(blockposition, block, i, 0);
+    }
+
+    //world.a
+    public void a(BlockPosition blockposition, Block block, int i, int j) {
+        if (blockposition instanceof BlockPosition.MutableBlockPosition || blockposition instanceof BlockPosition.PooledBlockPosition) {
+            blockposition = new BlockPosition(blockposition);
+            LogManager.getLogger().warn("Tried to assign a mutable BlockPos to tick data...", new Error(blockposition.getClass().toString()));
+        }
+
+        Material material = block.getBlockData().getMaterial();
+
+        if (this.d && material != Material.AIR) {
+            if (block.s()) {
+                if (this.areChunksLoadedBetween(blockposition.a(-8, -8, -8), blockposition.a(8, 8, 8))) {
+                    IBlockData iblockdata = this.getType(blockposition);
+
+                    if (iblockdata.getMaterial() != Material.AIR && iblockdata.getBlock() == block) {
+                        iblockdata.getBlock().b((World) this, blockposition, iblockdata, this.random);
+                    }
+                }
+
+                return;
+            }
+
+            i = 1;
+        }
+
+        NextTickListEntry nextticklistentry = new NextTickListEntry(blockposition, block);
+
+        if (this.isLoaded(blockposition)) {
+            if (material != Material.AIR) {
+                nextticklistentry.a((long) i + this.worldData.getTime());
+                nextticklistentry.a(j);
+            }
+
+            // CraftBukkit - use nextTickList
+            if (!this.nextTickList.contains(nextticklistentry)) {
+                //this.nextTickList.add(nextticklistentry);
+                this.nextTickQueue.add(nextticklistentry);
+            }
+        }
+
+    }
+    
+    //world.b
+    public void b(BlockPosition blockposition, Block block, int i, int j) {
+        if (blockposition instanceof BlockPosition.MutableBlockPosition || blockposition instanceof BlockPosition.PooledBlockPosition) {
+            blockposition = new BlockPosition(blockposition);
+            LogManager.getLogger().warn("Tried to assign a mutable BlockPos to tick data...", new Error(blockposition.getClass().toString()));
+        }
+
+        NextTickListEntry nextticklistentry = new NextTickListEntry(blockposition, block);
+
+        nextticklistentry.a(j);
+        Material material = block.getBlockData().getMaterial();
+
+        if (material != Material.AIR) {
+            nextticklistentry.a((long) i + this.worldData.getTime());
+        }
+
+        // CraftBukkit - use nextTickList
+        if (!this.nextTickList.contains(nextticklistentry)) {
+            //this.nextTickList.add(nextticklistentry);
+            this.nextTickQueue.add(nextticklistentry);
+        }
+
+    }
+    
+    r rt;
+    public void tickEntities() {
+        if (false && this.players.isEmpty()) { // CraftBukkit - this prevents entity cleanup, other issues on servers with no players
+            if (this.emptyTime++ >= 300) {
+                return;
+            }
+        } else {
+            this.m();
+        }
+
+        //this.worldProvider.r();
+        rt = new r();
+        rt.fork();
+        super.tickEntities();
+        spigotConfig.currentPrimedTnt = 0; // Spigot
+    }
+
+    protected void l() {
+        super.l();
+        this.methodProfiler.c("players");
+        
+        this.players.parallelStream().forEach(entity -> {
+            Entity entity1 = entity.bB();
+
+            if (entity1 != null) {
+                if (!entity1.dead && entity1.w(entity)) {
+                    return;
+                }
+
+                entity.stopRiding();
+            }
+
+            this.methodProfiler.a("tick");
+            if (!entity.dead) {
+                try {
+                    this.g(entity);
+                } catch (Throwable throwable) {
+                    CrashReport crashreport = CrashReport.a(throwable, "Ticking player");
+                    CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Player being ticked");
+
+                    entity.appendEntityCrashDetails(crashreportsystemdetails);
+                    throw new ReportedException(crashreport);
+                }
+            }
+
+            this.methodProfiler.b();
+            this.methodProfiler.a("remove");
+            if (entity.dead) {
+                int j = entity.ac;
+                int k = entity.ae;
+
+                if (entity.ab && this.isChunkLoaded(j, k, true)) {
+                    this.getChunkAt(j, k).b(entity);
+                }
+
+                //this.entityList.remove(entity);
+                this.entityQueue.remove(entity);
+                this.c(entity);
+            }
+
+            this.methodProfiler.b();
+        });
+        /*
+        for (int i = 0; i < this.players.size(); ++i) {
+            Entity entity = (Entity) this.players.get(i);
+            Entity entity1 = entity.bB();
+
+            if (entity1 != null) {
+                if (!entity1.dead && entity1.w(entity)) {
+                    continue;
+                }
+
+                entity.stopRiding();
+            }
+
+            this.methodProfiler.a("tick");
+            if (!entity.dead) {
+                try {
+                    this.g(entity);
+                } catch (Throwable throwable) {
+                    CrashReport crashreport = CrashReport.a(throwable, "Ticking player");
+                    CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Player being ticked");
+
+                    entity.appendEntityCrashDetails(crashreportsystemdetails);
+                    throw new ReportedException(crashreport);
+                }
+            }
+
+            this.methodProfiler.b();
+            this.methodProfiler.a("remove");
+            if (entity.dead) {
+                int j = entity.ac;
+                int k = entity.ae;
+
+                if (entity.ab && this.isChunkLoaded(j, k, true)) {
+                    this.getChunkAt(j, k).b(entity);
+                }
+
+                //this.entityList.remove(entity);
+                this.entityQueue.remove(entity);
+                this.c(entity);
+            }
+
+            this.methodProfiler.b();
+        }*/
+
+    }
+
+    public void m() {
+        this.emptyTime = 0;
+    }
+
+    public boolean a(boolean flag) {
+        if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
+            return false;
+        } else {
+            int i = this.nextTickList.size();
+
+            if (false) { // CraftBukkit
+                throw new IllegalStateException("TickNextTick list out of synch");
+            } else {
+                if (i > 65536) {
+                    // CraftBukkit start - If the server has too much to process over time, try to alleviate that
+                    if (i > 20 * 65536) {
+                        i = i / 20;
+                    } else {
+                        i = 65536;
+                    }
+                    // CraftBukkit end
+                }
+
+                this.methodProfiler.a("cleaning");
+
+                //NextTickListEntry nextticklistentry;
+                
+                this.nextTickList.parallelStream().forEach(ntle -> {
+                    if (!flag && ntle.b > this.worldData.getTime()) {
+                        return;
+                    }
+
+                    // CraftBukkit - use nextTickList
+                    this.nextTickList.remove(ntle);
+                    // this.nextTickListHash.remove(nextticklistentry);
+                    this.U.add(ntle);
+                });
+                /*
+                for (int j = 0; j < i; ++j) {
+                    nextticklistentry = (NextTickListEntry) this.nextTickList.first();
+                    if (!flag && nextticklistentry.b > this.worldData.getTime()) {
+                        break;
+                    }
+
+                    // CraftBukkit - use nextTickList
+                    this.nextTickList.remove(nextticklistentry);
+                    // this.nextTickListHash.remove(nextticklistentry);
+                    this.U.add(nextticklistentry);
+                }*/
+                
+                this.methodProfiler.b();
+                this.methodProfiler.a("ticking");
+                
+                this.U.parallelStream().forEachOrdered(ntle -> {
+                    boolean flag1 = false;
+
+                    if (this.areChunksLoadedBetween(ntle.a.a(0, 0, 0), ntle.a.a(0, 0, 0))) {
+                        IBlockData iblockdata = this.getType(ntle.a);
+
+                        if (iblockdata.getMaterial() != Material.AIR && Block.a(iblockdata.getBlock(), ntle.a())) {
+                            try {
+                                iblockdata.getBlock().b((World) this, ntle.a, iblockdata, this.random);
+                            } catch (Throwable throwable) {
+                                CrashReport crashreport = CrashReport.a(throwable, "Exception while ticking a block");
+                                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being ticked");
+
+                                CrashReportSystemDetails.a(crashreportsystemdetails, ntle.a, iblockdata);
+                                throw new ReportedException(crashreport);
+                            }
+                        }
+                    } else {
+                        this.a(ntle.a, ntle.a(), 0);
+                    }
+                });
+                
+                /*
+                Iterator iterator = this.U.iterator();
+
+                while (iterator.hasNext()) {
+                    nextticklistentry = (NextTickListEntry) iterator.next();
+                    iterator.remove();
+                    boolean flag1 = false;
+
+                    if (this.areChunksLoadedBetween(nextticklistentry.a.a(0, 0, 0), nextticklistentry.a.a(0, 0, 0))) {
+                        IBlockData iblockdata = this.getType(nextticklistentry.a);
+
+                        if (iblockdata.getMaterial() != Material.AIR && Block.a(iblockdata.getBlock(), nextticklistentry.a())) {
+                            try {
+                                iblockdata.getBlock().b((World) this, nextticklistentry.a, iblockdata, this.random);
+                            } catch (Throwable throwable) {
+                                CrashReport crashreport = CrashReport.a(throwable, "Exception while ticking a block");
+                                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being ticked");
+
+                                CrashReportSystemDetails.a(crashreportsystemdetails, nextticklistentry.a, iblockdata);
+                                throw new ReportedException(crashreport);
+                            }
+                        }
+                    } else {
+                        this.a(nextticklistentry.a, nextticklistentry.a(), 0);
+                    }
+                }*/
+
+                this.methodProfiler.b();
+                this.U.clear();
+                return !this.nextTickList.isEmpty();
+            }
+        }
+    }
+
+    @Nullable
+    public List<NextTickListEntry> a(Chunk chunk, boolean flag) {
+        ChunkCoordIntPair chunkcoordintpair = chunk.k();
+        int i = (chunkcoordintpair.x << 4) - 2;
+        int j = i + 16 + 2;
+        int k = (chunkcoordintpair.z << 4) - 2;
+        int l = k + 16 + 2;
+
+        return this.a(new StructureBoundingBox(i, 0, k, j, 256, l), flag);
+    }
+
+    @Nullable
+    public List<NextTickListEntry> a(StructureBoundingBox structureboundingbox, boolean flag) {
+        ArrayList arraylist = null;
+
+        for (int i = 0; i < 2; ++i) {
+            Iterator iterator;
+
+            if (i == 0) {
+                iterator = this.nextTickList.iterator();
+                while (iterator.hasNext()) {
+                    NextTickListEntry nextticklistentry = (NextTickListEntry) iterator.next();
+                    BlockPosition blockposition = nextticklistentry.a;
+
+                    if (blockposition.getX() >= structureboundingbox.a && blockposition.getX() < structureboundingbox.d && blockposition.getZ() >= structureboundingbox.c && blockposition.getZ() < structureboundingbox.f) {
+                        if (flag) {
+                            if (i == 0) {
+                                // this.nextTickListHash.remove(nextticklistentry); // CraftBukkit - removed
+                            }
+
+                            //iterator.remove();
+                            this.nextTickList_remove.add(nextticklistentry);
+                        }
+
+                        if (arraylist == null) {
+                            arraylist = Lists.newArrayList();
+                        }
+
+                        arraylist.add(nextticklistentry);
+                    }
+                }
+                if (!this.nextTickList_remove.isEmpty()){
+                    this.nextTickList.removeAll(this.nextTickList_remove);
+                    this.nextTickList_remove.clear();
+                }
+            } else {
+                iterator = this.U.iterator();
+                while (iterator.hasNext()) {
+                    NextTickListEntry nextticklistentry = (NextTickListEntry) iterator.next();
+                    BlockPosition blockposition = nextticklistentry.a;
+
+                    if (blockposition.getX() >= structureboundingbox.a && blockposition.getX() < structureboundingbox.d && blockposition.getZ() >= structureboundingbox.c && blockposition.getZ() < structureboundingbox.f) {
+                        if (flag) {
+                            if (i == 0) {
+                                // this.nextTickListHash.remove(nextticklistentry); // CraftBukkit - removed
+                            }
+
+                            //iterator.remove();
+                            this.nextTickList_remove.add(nextticklistentry);
+                        }
+
+                        if (arraylist == null) {
+                            arraylist = Lists.newArrayList();
+                        }
+
+                        arraylist.add(nextticklistentry);
+                    }
+                }
+                if (!this.nextTickList_remove.isEmpty()){
+                    this.nextTickList.removeAll(this.nextTickList_remove);
+                    this.nextTickList_remove.clear();
+                }
+            }
+            
+            /*
+            while (iterator.hasNext()) {
+                NextTickListEntry nextticklistentry = (NextTickListEntry) iterator.next();
+                BlockPosition blockposition = nextticklistentry.a;
+
+                if (blockposition.getX() >= structureboundingbox.a && blockposition.getX() < structureboundingbox.d && blockposition.getZ() >= structureboundingbox.c && blockposition.getZ() < structureboundingbox.f) {
+                    if (flag) {
+                        if (i == 0) {
+                            // this.nextTickListHash.remove(nextticklistentry); // CraftBukkit - removed
+                        }
+
+                        iterator.remove();
+                    }
+
+                    if (arraylist == null) {
+                        arraylist = Lists.newArrayList();
+                    }
+
+                    arraylist.add(nextticklistentry);
+                }
+            }*/
+        }
+
+        return arraylist;
+    }
+
+    /* CraftBukkit start - We prevent spawning in general, so this butchering is not needed
+    public void entityJoinedWorld(Entity entity, boolean flag) {
+        if (!this.getSpawnAnimals() && (entity instanceof EntityAnimal || entity instanceof EntityWaterAnimal)) {
+            entity.die();
+        }
+
+        if (!this.getSpawnNPCs() && entity instanceof NPC) {
+            entity.die();
+        }
+
+        super.entityJoinedWorld(entity, flag);
+    }
+    // CraftBukkit end */
+
+    private boolean getSpawnNPCs() {
+        return this.server.getSpawnNPCs();
+    }
+
+    private boolean getSpawnAnimals() {
+        return this.server.getSpawnAnimals();
+    }
+
+    protected IChunkProvider n() {
+        IChunkLoader ichunkloader = this.dataManager.createChunkLoader(this.worldProvider);
+
+        // CraftBukkit start
+        org.bukkit.craftbukkit.generator.InternalChunkGenerator gen;
+
+        if (this.generator != null) {
+            gen = new org.bukkit.craftbukkit.generator.CustomChunkGenerator(this, this.getSeed(), this.generator);
+        } else if (this.worldProvider instanceof WorldProviderHell) {
+            gen = new org.bukkit.craftbukkit.generator.NetherChunkGenerator(this, this.getSeed());
+        } else if (this.worldProvider instanceof WorldProviderTheEnd) {
+            gen = new org.bukkit.craftbukkit.generator.SkyLandsChunkGenerator(this, this.getSeed());
+        } else {
+            gen = new org.bukkit.craftbukkit.generator.NormalChunkGenerator(this, this.getSeed());
+        }
+
+        return new ChunkProviderServer(this, ichunkloader, gen);
+        // CraftBukkit end
+    }
+
+    public List<TileEntity> getTileEntities(int i, int j, int k, int l, int i1, int j1) {
+        ArrayList arraylist = Lists.newArrayList();
+
+        // CraftBukkit start - Get tile entities from chunks instead of world
+        for (int chunkX = (i >> 4); chunkX <= ((l - 1) >> 4); chunkX++) {
+            for (int chunkZ = (k >> 4); chunkZ <= ((j1 - 1) >> 4); chunkZ++) {
+                Chunk chunk = getChunkAt(chunkX, chunkZ);
+                if (chunk == null) {
+                    continue;
+                }
+                chunk.tileEntities.values().parallelStream().filter(tileentity -> (tileentity.position.getX() >= i) && (tileentity.position.getY() >= j) &&
+                    (tileentity.position.getZ() >= k) && (tileentity.position.getX() < l) && (tileentity.position.getY() < i1) && (tileentity.position.getZ() < j1)).forEach(tileentity -> arraylist.add(tileentity));
+                /*
+                for (Object te : chunk.tileEntities.values()) {
+                    TileEntity tileentity = (TileEntity) te;
+                    if ((tileentity.position.getX() >= i) && (tileentity.position.getY() >= j) && (tileentity.position.getZ() >= k) && (tileentity.position.getX() < l) && (tileentity.position.getY() < i1) && (tileentity.position.getZ() < j1)) {
+                        arraylist.add(tileentity);
+                    }
+                }*/
+            }
+        }
+        /*
+        for (int k1 = 0; k1 < this.tileEntityList.size(); ++k1) {
+            TileEntity tileentity = (TileEntity) this.tileEntityList.get(k1);
+            BlockPosition blockposition = tileentity.getPosition();
+
+            if (blockposition.getX() >= i && blockposition.getY() >= j && blockposition.getZ() >= k && blockposition.getX() < l && blockposition.getY() < i1 && blockposition.getZ() < j1) {
+                arraylist.add(tileentity);
+            }
+        }
+        */
+        // CraftBukkit end
+
+        return arraylist;
+    }
+
+    public boolean a(EntityHuman entityhuman, BlockPosition blockposition) {
+        return !this.server.a(this, blockposition, entityhuman) && this.getWorldBorder().a(blockposition);
+    }
+
+    public void a(WorldSettings worldsettings) {
+        if (!this.worldData.v()) {
+            try {
+                this.b(worldsettings);
+                if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
+                    this.an();
+                }
+
+                super.a(worldsettings);
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Exception initializing level");
+
+                try {
+                    this.a(crashreport);
+                } catch (Throwable throwable1) {
+                    ;
+                }
+
+                throw new ReportedException(crashreport);
+            }
+
+            this.worldData.d(true);
+        }
+
+    }
+
+    private void an() {
+        this.worldData.f(false);
+        this.worldData.c(true);
+        this.worldData.setStorm(false);
+        this.worldData.setThundering(false);
+        this.worldData.i(1000000000);
+        this.worldData.setDayTime(6000L);
+        this.worldData.setGameType(EnumGamemode.SPECTATOR);
+        this.worldData.g(false);
+        this.worldData.setDifficulty(EnumDifficulty.PEACEFUL);
+        this.worldData.e(true);
+        this.getGameRules().set("doDaylightCycle", "false");
+    }
+
+    private void b(WorldSettings worldsettings) {
+        if (!this.worldProvider.e()) {
+            this.worldData.setSpawn(BlockPosition.ZERO.up(this.worldProvider.getSeaLevel()));
+        } else if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
+            this.worldData.setSpawn(BlockPosition.ZERO.up());
+        } else {
+            this.isLoading = true;
+            WorldChunkManager worldchunkmanager = this.worldProvider.k();
+            List list = worldchunkmanager.a();
+            Random random = new Random(this.getSeed());
+            BlockPosition blockposition = worldchunkmanager.a(0, 0, 256, list, random);
+            int i = 8;
+            int j = this.worldProvider.getSeaLevel();
+            int k = 8;
+
+            // CraftBukkit start
+            if (this.generator != null) {
+                Random rand = new Random(this.getSeed());
+                org.bukkit.Location spawn = this.generator.getFixedSpawnLocation(((WorldServer) this).getWorld(), rand);
+
+                if (spawn != null) {
+                    if (spawn.getWorld() != ((WorldServer) this).getWorld()) {
+                        throw new IllegalStateException("Cannot set spawn point for " + this.worldData.getName() + " to be in another world (" + spawn.getWorld().getName() + ")");
+                    } else {
+                        this.worldData.setSpawn(new BlockPosition(spawn.getBlockX(), spawn.getBlockY(), spawn.getBlockZ()));
+                        this.isLoading = false;
+                        return;
+                    }
+                }
+            }
+            // CraftBukkit end
+
+            if (blockposition != null) {
+                i = blockposition.getX();
+                k = blockposition.getZ();
+            } else {
+                WorldServer.a.warn("Unable to find spawn biome");
+            }
+
+            int l = 0;
+
+            while (!this.canSpawn(i, k)) { // CraftBukkit - use our own canSpawn
+                i += random.nextInt(64) - random.nextInt(64);
+                k += random.nextInt(64) - random.nextInt(64);
+                ++l;
+                if (l == 1000) {
+                    break;
+                }
+            }
+
+            this.worldData.setSpawn(new BlockPosition(i, j, k));
+            this.isLoading = false;
+            if (worldsettings.c()) {
+                this.o();
+            }
+
+        }
+    }
+
+    protected void o() {
+        WorldGenBonusChest worldgenbonuschest = new WorldGenBonusChest();
+
+        for (int i = 0; i < 10; ++i) {
+            int j = this.worldData.b() + this.random.nextInt(6) - this.random.nextInt(6);
+            int k = this.worldData.d() + this.random.nextInt(6) - this.random.nextInt(6);
+            BlockPosition blockposition = this.q(new BlockPosition(j, 0, k)).up();
+
+            if (worldgenbonuschest.generate(this, this.random, blockposition)) {
+                break;
+            }
+        }
+
+    }
+
+    public BlockPosition getDimensionSpawn() {
+        return this.worldProvider.h();
+    }
+
+    public void save(boolean flag, @Nullable IProgressUpdate iprogressupdate) throws ExceptionWorldConflict {
+        ChunkProviderServer chunkproviderserver = this.getChunkProviderServer();
+
+        if (chunkproviderserver.e()) {
+            org.bukkit.Bukkit.getPluginManager().callEvent(new org.bukkit.event.world.WorldSaveEvent(getWorld())); // CraftBukkit
+            if (iprogressupdate != null) {
+                iprogressupdate.a("Saving level");
+            }
+
+            this.a();
+            if (iprogressupdate != null) {
+                iprogressupdate.c("Saving chunks");
+            }
+
+            chunkproviderserver.a(flag);
+            // CraftBukkit - ArrayList -> Collection
+            Collection arraylist = chunkproviderserver.a();
+            Iterator iterator = arraylist.iterator();
+
+            while (iterator.hasNext()) {
+                Chunk chunk = (Chunk) iterator.next();
+
+                if (chunk != null && !this.manager.a(chunk.locX, chunk.locZ)) {
+                    chunkproviderserver.unload(chunk);
+                }
+            }
+
+        }
+    }
+
+    public void flushSave() {
+        ChunkProviderServer chunkproviderserver = this.getChunkProviderServer();
+
+        if (chunkproviderserver.e()) {
+            chunkproviderserver.c();
+        }
+    }
+
+    protected void a() throws ExceptionWorldConflict {
+        this.checkSession();
+        WorldServer[] aworldserver = this.server.worldServer;
+        int i = aworldserver.length;
+
+        for (int j = 0; j < i; ++j) {
+            WorldServer worldserver = aworldserver[j];
+
+            if (worldserver instanceof SecondaryWorldServer) {
+                ((SecondaryWorldServer) worldserver).c();
+            }
+        }
+
+        // CraftBukkit start - Save secondary data for nether/end
+        if (this instanceof SecondaryWorldServer) {
+            ((SecondaryWorldServer) this).c();
+        }
+        // CraftBukkit end
+
+        this.worldData.a(this.getWorldBorder().getSize());
+        this.worldData.d(this.getWorldBorder().getCenterX());
+        this.worldData.c(this.getWorldBorder().getCenterZ());
+        this.worldData.e(this.getWorldBorder().getDamageBuffer());
+        this.worldData.f(this.getWorldBorder().getDamageAmount());
+        this.worldData.j(this.getWorldBorder().getWarningDistance());
+        this.worldData.k(this.getWorldBorder().getWarningTime());
+        this.worldData.b(this.getWorldBorder().j());
+        this.worldData.e(this.getWorldBorder().i());
+        this.dataManager.saveWorldData(this.worldData, this.server.getPlayerList().t());
+        this.worldMaps.a();
+    }
+
+    public boolean addEntity(Entity entity) {
+        return this.i(entity) ? super.addEntity(entity) : false;
+    }
+
+    public void a(Collection<Entity> collection) {
+        ArrayList arraylist = Lists.newArrayList(collection);
+        
+        arraylist.parallelStream().filter(entity -> this.i((Entity)entity)).forEach(entity -> {
+            this.entityQueue.add((Entity)entity);
+            this.b((Entity)entity);
+        });
+        /*
+        Iterator iterator = arraylist.iterator();
+
+        while (iterator.hasNext()) {
+            Entity entity = (Entity) iterator.next();
+
+            if (this.i(entity)) {
+                //this.entityList.add(entity);
+                this.entityQueue.add(entity);
+                this.b(entity);
+            }
+        }*/
+
+    }
+
+    private boolean i(Entity entity) {
+        if (entity.dead) {
+            // WorldServer.a.warn("Tried to add entity {} but it was marked as removed already", new Object[] { EntityTypes.b(entity)}); // CraftBukkit
+            return false;
+        } else {
+            UUID uuid = entity.getUniqueID();
+
+            if (this.entitiesByUUID.containsKey(uuid)) {
+                Entity entity1 = (Entity) this.entitiesByUUID.get(uuid);
+
+                if (this.f.contains(entity1)) {
+                    this.f.remove(entity1);
+                } else {
+                    if (!(entity instanceof EntityHuman)) {
+                        // WorldServer.a.warn("Keeping entity {} that already exists with UUID {}", new Object[] { EntityTypes.b(entity1), uuid.toString()}); // CraftBukkit
+                        return false;
+                    }
+
+                    WorldServer.a.warn("Force-added player with duplicate UUID {}", new Object[] { uuid.toString()});
+                }
+
+                this.removeEntity(entity1);
+            }
+
+            return true;
+        }
+    }
+
+    protected void b(Entity entity) {
+        super.b(entity);
+        //this.entitiesById.a(entity.getId(), entity);
+        this.entitiesById.put(entity.getId(), entity);
+        this.entitiesByUUID.put(entity.getUniqueID(), entity);
+        Entity[] aentity = entity.aT();
+
+        if (aentity != null) {
+            Entity[] aentity1 = aentity;
+            int i = aentity.length;
+
+            for (int j = 0; j < i; ++j) {
+                Entity entity1 = aentity1[j];
+
+                //this.entitiesById.a(entity1.getId(), entity1);
+                this.entitiesById.put(entity1.getId(), entity1);
+            }
+        }
+
+    }
+
+    protected void c(Entity entity) {
+        super.c(entity);
+        //this.entitiesById.d(entity.getId());
+        this.entitiesById.remove(entity.getId());
+        this.entitiesByUUID.remove(entity.getUniqueID());
+        Entity[] aentity = entity.aT();
+
+        if (aentity != null) {
+            Entity[] aentity1 = aentity;
+            int i = aentity.length;
+
+            for (int j = 0; j < i; ++j) {
+                Entity entity1 = aentity1[j];
+
+                //this.entitiesById.d(entity1.getId());
+                this.entitiesById.remove(entity1.getId());
+            }
+        }
+
+    }
+
+    public boolean strikeLightning(Entity entity) {
+        // CraftBukkit start
+        LightningStrikeEvent lightning = new LightningStrikeEvent(this.getWorld(), (org.bukkit.entity.LightningStrike) entity.getBukkitEntity());
+        this.getServer().getPluginManager().callEvent(lightning);
+
+        if (lightning.isCancelled()) {
+            return false;
+        }
+        // CraftBukkit end
+        if (super.strikeLightning(entity)) {
+            this.server.getPlayerList().sendPacketNearby((EntityHuman) null, entity.locX, entity.locY, entity.locZ, 512.0D, dimension, new PacketPlayOutSpawnEntityWeather(entity)); // CraftBukkit - Use dimension
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public void broadcastEntityEffect(Entity entity, byte b0) {
+        this.getTracker().sendPacketToEntity(entity, new PacketPlayOutEntityStatus(entity, b0));
+    }
+
+    public ChunkProviderServer getChunkProviderServer() {
+        return (ChunkProviderServer) super.getChunkProvider();
+    }
+
+    public Explosion createExplosion(@Nullable Entity entity, double d0, double d1, double d2, float f, boolean flag, boolean flag1) {
+        // CraftBukkit start
+        Explosion explosion = super.createExplosion(entity, d0, d1, d2, f, flag, flag1);
+
+        if (explosion.wasCanceled) {
+            return explosion;
+        }
+
+        /* Remove
+        Explosion explosion = new Explosion(this, entity, d0, d1, d2, f, flag, flag1);
+
+        explosion.a();
+        explosion.a(false);
+        */
+        // CraftBukkit end - TODO: Check if explosions are still properly implemented
+        if (!flag1) {
+            explosion.clearBlocks();
+        }
+
+        Iterator iterator = this.players.iterator();
+
+        while (iterator.hasNext()) {
+            EntityHuman entityhuman = (EntityHuman) iterator.next();
+
+            if (entityhuman.e(d0, d1, d2) < 4096.0D) {
+                ((EntityPlayer) entityhuman).playerConnection.sendPacket(new PacketPlayOutExplosion(d0, d1, d2, f, explosion.getBlocks(), (Vec3D) explosion.b().get(entityhuman)));
+            }
+        }
+
+        return explosion;
+    }
+
+    public void playBlockAction(BlockPosition blockposition, Block block, int i, int j) {
+        BlockActionData blockactiondata = new BlockActionData(blockposition, block, i, j);
+        Iterator iterator = this.S[this.T].iterator();
+
+        BlockActionData blockactiondata1;
+
+        do {
+            if (!iterator.hasNext()) {
+                this.S[this.T].add(blockactiondata);
+                return;
+            }
+
+            blockactiondata1 = (BlockActionData) iterator.next();
+        } while (!blockactiondata1.equals(blockactiondata));
+
+    }
+
+    private void ao() {
+        while (!this.S[this.T].isEmpty()) {
+            int i = this.T;
+
+            this.T ^= 1;
+            Iterator iterator = this.S[i].iterator();
+
+            while (iterator.hasNext()) {
+                BlockActionData blockactiondata = (BlockActionData) iterator.next();
+
+                if (this.a(blockactiondata)) {
+                    // CraftBukkit - this.worldProvider.dimension -> this.dimension
+                    this.server.getPlayerList().sendPacketNearby((EntityHuman) null, (double) blockactiondata.a().getX(), (double) blockactiondata.a().getY(), (double) blockactiondata.a().getZ(), 64.0D, dimension, new PacketPlayOutBlockAction(blockactiondata.a(), blockactiondata.d(), blockactiondata.b(), blockactiondata.c()));
+                }
+            }
+            //remove none-used tile
+            if (!this.tileEntityListUnload.isEmpty()) {
+                this.b.removeAll(this.tileEntityListUnload);
+                this.tileEntityListTick.removeAll(this.tileEntityListUnload);
+                this.tileEntityList.removeAll(this.tileEntityListUnload);
+                this.tileEntityListUnload.clear();
+            }
+
+            this.S[i].clear();
+        }
+
+    }
+
+    private boolean a(BlockActionData blockactiondata) {
+        IBlockData iblockdata = this.getType(blockactiondata.a());
+
+        return iblockdata.getBlock() == blockactiondata.d() ? iblockdata.a(this, blockactiondata.a(), blockactiondata.b(), blockactiondata.c()) : false;
+    }
+
+    public void saveLevel() {
+        this.dataManager.a();
+    }
+
+    protected void t() {
+        boolean flag = this.W();
+
+        super.t();
+        /* CraftBukkit start
+        if (this.n != this.o) {
+            this.server.getPlayerList().a((Packet) (new PacketPlayOutGameStateChange(7, this.o)), this.worldProvider.getDimensionManager().getDimensionID());
+        }
+
+        if (this.p != this.q) {
+            this.server.getPlayerList().a((Packet) (new PacketPlayOutGameStateChange(8, this.q)), this.worldProvider.getDimensionManager().getDimensionID());
+        }
+
+        if (flag != this.W()) {
+            if (flag) {
+                this.server.getPlayerList().sendAll(new PacketPlayOutGameStateChange(2, 0.0F));
+            } else {
+                this.server.getPlayerList().sendAll(new PacketPlayOutGameStateChange(1, 0.0F));
+            }
+
+            this.server.getPlayerList().sendAll(new PacketPlayOutGameStateChange(7, this.o));
+            this.server.getPlayerList().sendAll(new PacketPlayOutGameStateChange(8, this.q));
+        }
+        // */
+        if (flag != this.W()) {
+            // Only send weather packets to those affected
+            for (int i = 0; i < this.players.size(); ++i) {
+                if (((EntityPlayer) this.players.get(i)).world == this) {
+                    ((EntityPlayer) this.players.get(i)).setPlayerWeather((!flag ? WeatherType.DOWNFALL : WeatherType.CLEAR), false);
+                }
+            }
+        }
+        for (int i = 0; i < this.players.size(); ++i) {
+            if (((EntityPlayer) this.players.get(i)).world == this) {
+                ((EntityPlayer) this.players.get(i)).updateWeather(this.n, this.o, this.p, this.q);
+            }
+        }
+        // CraftBukkit end
+
+    }
+
+    @Nullable
+    public MinecraftServer getMinecraftServer() {
+        return this.server;
+    }
+
+    public EntityTracker getTracker() {
+        return this.tracker;
+    }
+
+    public PlayerChunkMap getPlayerChunkMap() {
+        return this.manager;
+    }
+
+    public PortalTravelAgent getTravelAgent() {
+        return this.portalTravelAgent;
+    }
+
+    public DefinedStructureManager y() {
+        return this.dataManager.h();
+    }
+
+    public void a(EnumParticle enumparticle, double d0, double d1, double d2, int i, double d3, double d4, double d5, double d6, int... aint) {
+        this.a(enumparticle, false, d0, d1, d2, i, d3, d4, d5, d6, aint);
+    }
+
+    public void a(EnumParticle enumparticle, boolean flag, double d0, double d1, double d2, int i, double d3, double d4, double d5, double d6, int... aint) {
+        // CraftBukkit - visibility api support
+        sendParticles(null, enumparticle, flag, d0, d1, d2, i, d3, d4, d5, d6, aint);
+    }
+
+    public void sendParticles(EntityPlayer sender, EnumParticle enumparticle, boolean flag, double d0, double d1, double d2, int i, double d3, double d4, double d5, double d6, int... aint) {
+        // CraftBukkit end
+        PacketPlayOutWorldParticles packetplayoutworldparticles = new PacketPlayOutWorldParticles(enumparticle, flag, (float) d0, (float) d1, (float) d2, (float) d3, (float) d4, (float) d5, (float) d6, i, aint);
+
+        for (int j = 0; j < this.players.size(); ++j) {
+            EntityPlayer entityplayer = (EntityPlayer) this.players.get(j);
+            if (sender != null && !entityplayer.getBukkitEntity().canSee(sender.getBukkitEntity())) continue; // CraftBukkit
+            BlockPosition blockposition = entityplayer.getChunkCoordinates();
+            double d7 = blockposition.distanceSquared(d0, d1, d2);
+
+
+            this.a(entityplayer, flag, d0, d1, d2, packetplayoutworldparticles);
+        }
+
+    }
+
+    public void a(EntityPlayer entityplayer, EnumParticle enumparticle, boolean flag, double d0, double d1, double d2, int i, double d3, double d4, double d5, double d6, int... aint) {
+        PacketPlayOutWorldParticles packetplayoutworldparticles = new PacketPlayOutWorldParticles(enumparticle, flag, (float) d0, (float) d1, (float) d2, (float) d3, (float) d4, (float) d5, (float) d6, i, aint);
+
+        this.a(entityplayer, flag, d0, d1, d2, packetplayoutworldparticles);
+    }
+
+    private void a(EntityPlayer entityplayer, boolean flag, double d0, double d1, double d2, Packet<?> packet) {
+        BlockPosition blockposition = entityplayer.getChunkCoordinates();
+        double d3 = blockposition.distanceSquared(d0, d1, d2);
+
+        if (d3 <= 1024.0D || flag && d3 <= 262144.0D) {
+            entityplayer.playerConnection.sendPacket(packet);
+        }
+
+    }
+
+    @Nullable
+    public Entity getEntity(UUID uuid) {
+        return (Entity) this.entitiesByUUID.get(uuid);
+    }
+
+    public ListenableFuture<Object> postToMainThread(Runnable runnable) {
+        return this.server.postToMainThread(runnable);
+    }
+
+    public boolean isMainThread() {
+        return this.server.isMainThread();
+    }
+
+    public IChunkProvider getChunkProvider() {
+        return this.getChunkProviderServer();
+    }
+
+    static class BlockActionDataList extends ArrayList<BlockActionData> {
+
+        private BlockActionDataList() {}
+
+        BlockActionDataList(Object object) {
+            this();
+        }
+    }
+    
+    class biometa implements Callable<List> {
+        WorldServer ws;
+        EnumCreatureType enumcreaturetype;
+        BlockPosition blockposition;
+        
+        biometa(WorldServer ws, EnumCreatureType enumcreaturetype, BlockPosition blockposition){
+            this.ws = ws;
+            this.enumcreaturetype = enumcreaturetype;
+            this.blockposition = blockposition;
+        }
+        
+        @Override
+        public List call() throws Exception {
+            return ws.getChunkProviderServer().a(enumcreaturetype, blockposition);
+        }
+    }
+    
+    class r extends RecursiveAction {
+        
+        @Override
+        protected void compute() {
+            worldProvider.r();
+        }
+    }
+    
+    class mobspawn implements Callable<Integer> {
+        WorldServer ws;
+        boolean flag, flag1, flag2;
+        
+        mobspawn(WorldServer ws, boolean flag, boolean flag1, boolean flag2){
+            this.ws = ws;
+            this.flag = flag;
+            this.flag1 = flag1;
+            this.flag2 = flag2;
+        }
+        
+        @Override
+        public Integer call() throws Exception {
+            return spawnerCreature.a(ws, flag, flag1, flag2);
+        }
+    }
+    
+}
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java src/main/java/org/bukkit/craftbukkit/CraftWorld.java
--- src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-08-25 22:39:53.043602088 +0800
+++ src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-08-26 03:24:15.514198566 +0800
@@ -1,1565 +1,1565 @@
-package org.bukkit.craftbukkit;
-
-import com.google.common.base.Preconditions;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Iterator;
-import java.util.Random;
-import java.util.Set;
-import java.util.UUID;
-
-import net.minecraft.server.*;
-
-import org.apache.commons.lang.Validate;
-import org.bukkit.BlockChangeDelegate;
-import org.bukkit.Bukkit;
-import org.bukkit.Chunk;
-import org.bukkit.ChunkSnapshot;
-import org.bukkit.Difficulty;
-import org.bukkit.Effect;
-import org.bukkit.Location;
-import org.bukkit.Particle;
-import org.bukkit.Sound;
-import org.bukkit.TreeType;
-import org.bukkit.World;
-import org.bukkit.WorldBorder;
-import org.bukkit.block.Biome;
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockFace;
-import org.bukkit.block.BlockState;
-import org.bukkit.craftbukkit.block.CraftBlock;
-import org.bukkit.craftbukkit.block.CraftBlockState;
-import org.bukkit.craftbukkit.entity.*;
-import org.bukkit.craftbukkit.inventory.CraftItemStack;
-import org.bukkit.craftbukkit.metadata.BlockMetadataStore;
-import org.bukkit.craftbukkit.potion.CraftPotionUtil;
-import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.craftbukkit.util.LongHash;
-import org.bukkit.entity.*;
-import org.bukkit.entity.Entity;
-import org.bukkit.entity.minecart.CommandMinecart;
-import org.bukkit.entity.minecart.ExplosiveMinecart;
-import org.bukkit.entity.minecart.HopperMinecart;
-import org.bukkit.entity.minecart.PoweredMinecart;
-import org.bukkit.entity.minecart.SpawnerMinecart;
-import org.bukkit.entity.minecart.StorageMinecart;
-import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
-import org.bukkit.event.world.SpawnChangeEvent;
-import org.bukkit.generator.BlockPopulator;
-import org.bukkit.generator.ChunkGenerator;
-import org.bukkit.inventory.ItemStack;
-import org.bukkit.metadata.MetadataValue;
-import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.messaging.StandardMessenger;
-import org.bukkit.potion.PotionData;
-import org.bukkit.potion.PotionType;
-import org.bukkit.util.Vector;
-
-public class CraftWorld implements World {
-    public static final int CUSTOM_DIMENSION_OFFSET = 10;
-
-    private final WorldServer world;
-    private WorldBorder worldBorder;
-    private Environment environment;
-    private final CraftServer server = (CraftServer) Bukkit.getServer();
-    private final ChunkGenerator generator;
-    private final List<BlockPopulator> populators = new ArrayList<BlockPopulator>();
-    private final BlockMetadataStore blockMetadata = new BlockMetadataStore(this);
-    private int monsterSpawn = -1;
-    private int animalSpawn = -1;
-    private int waterAnimalSpawn = -1;
-    private int ambientSpawn = -1;
-    private int chunkLoadCount = 0;
-    private int chunkGCTickCount;
-
-    private static final Random rand = new Random();
-
-    public CraftWorld(WorldServer world, ChunkGenerator gen, Environment env) {
-        this.world = world;
-        this.generator = gen;
-
-        environment = env;
-
-        if (server.chunkGCPeriod > 0) {
-            chunkGCTickCount = rand.nextInt(server.chunkGCPeriod);
-        }
-    }
-
-    public Block getBlockAt(int x, int y, int z) {
-        return getChunkAt(x >> 4, z >> 4).getBlock(x & 0xF, y, z & 0xF);
-    }
-
-    public int getBlockTypeIdAt(int x, int y, int z) {
-        return CraftMagicNumbers.getId(world.getType(new BlockPosition(x, y, z)).getBlock());
-    }
-
-    public int getHighestBlockYAt(int x, int z) {
-        if (!isChunkLoaded(x >> 4, z >> 4)) {
-            loadChunk(x >> 4, z >> 4);
-        }
-
-        return world.getHighestBlockYAt(new BlockPosition(x, 0, z)).getY();
-    }
-
-    public Location getSpawnLocation() {
-        BlockPosition spawn = world.getSpawn();
-        return new Location(this, spawn.getX(), spawn.getY(), spawn.getZ());
-    }
-
-    public boolean setSpawnLocation(int x, int y, int z) {
-        try {
-            Location previousLocation = getSpawnLocation();
-            world.worldData.setSpawn(new BlockPosition(x, y, z));
-
-            // Notify anyone who's listening.
-            SpawnChangeEvent event = new SpawnChangeEvent(this, previousLocation);
-            server.getPluginManager().callEvent(event);
-
-            return true;
-        } catch (Exception e) {
-            return false;
-        }
-    }
-
-    public Chunk getChunkAt(int x, int z) {
-        return this.world.getChunkProviderServer().getChunkAt(x, z).bukkitChunk;
-    }
-
-    public Chunk getChunkAt(Block block) {
-        return getChunkAt(block.getX() >> 4, block.getZ() >> 4);
-    }
-
-    public boolean isChunkLoaded(int x, int z) {
-        return world.getChunkProviderServer().isLoaded(x, z);
-    }
-
-    public Chunk[] getLoadedChunks() {
-        Object[] chunks = world.getChunkProviderServer().chunks.values().toArray();
-        org.bukkit.Chunk[] craftChunks = new CraftChunk[chunks.length];
-
-        for (int i = 0; i < chunks.length; i++) {
-            net.minecraft.server.Chunk chunk = (net.minecraft.server.Chunk) chunks[i];
-            craftChunks[i] = chunk.bukkitChunk;
-        }
-
-        return craftChunks;
-    }
-
-    public void loadChunk(int x, int z) {
-        loadChunk(x, z, true);
-    }
-
-    public boolean unloadChunk(Chunk chunk) {
-        return unloadChunk(chunk.getX(), chunk.getZ());
-    }
-
-    public boolean unloadChunk(int x, int z) {
-        return unloadChunk(x, z, true);
-    }
-
-    public boolean unloadChunk(int x, int z, boolean save) {
-        return unloadChunk(x, z, save, false);
-    }
-
-    public boolean unloadChunkRequest(int x, int z) {
-        return unloadChunkRequest(x, z, true);
-    }
-
-    public boolean unloadChunkRequest(int x, int z, boolean safe) {
-        org.spigotmc.AsyncCatcher.catchOp( "chunk unload"); // Spigot
-        if (safe && isChunkInUse(x, z)) {
-            return false;
-        }
-
-        net.minecraft.server.Chunk chunk = world.getChunkProviderServer().getLoadedChunkAt(x, z);
-        if (chunk != null) {
-            world.getChunkProviderServer().unload(chunk);
-        }
-
-        return true;
-    }
-
-    public boolean unloadChunk(int x, int z, boolean save, boolean safe) {
-        org.spigotmc.AsyncCatcher.catchOp( "chunk unload"); // Spigot
-        if (isChunkInUse(x, z)) {
-            return false;
-        }
-
-        return unloadChunk0(x, z, save);
-    }
-
-    private boolean unloadChunk0(int x, int z, boolean save) {
-        net.minecraft.server.Chunk chunk = world.getChunkProviderServer().getChunkIfLoaded(x, z);
-        if (chunk == null) {
-            return true;
-        }
-
-        // If chunk had previously been queued to save, must do save to avoid loss of that data
-        return world.getChunkProviderServer().unloadChunk(chunk, chunk.mustSave || save);
-    }
-
-    public boolean regenerateChunk(int x, int z) {
-        if (!unloadChunk0(x, z, false)) {
-            return false;
-        }
-
-        final long chunkKey = ChunkCoordIntPair.a(x, z);
-        world.getChunkProviderServer().unloadQueue.remove(chunkKey);
-
-        net.minecraft.server.Chunk chunk = null;
-
-        chunk = world.getChunkProviderServer().chunkGenerator.getOrCreateChunk(x, z);
-        PlayerChunk playerChunk = world.getPlayerChunkMap().getChunk(x, z);
-        if (playerChunk != null) {
-            playerChunk.chunk = chunk;
-        }
-
-        if (chunk != null) {
-            world.getChunkProviderServer().chunks.put(chunkKey, chunk);
-
-            chunk.addEntities();
-            chunk.loadNearby(world.getChunkProviderServer(), world.getChunkProviderServer().chunkGenerator, true);
-
-            refreshChunk(x, z);
-        }
-
-        return chunk != null;
-    }
-
-    public boolean refreshChunk(int x, int z) {
-        if (!isChunkLoaded(x, z)) {
-            return false;
-        }
-
-        int px = x << 4;
-        int pz = z << 4;
-
-        // If there are more than 64 updates to a chunk at once, it will update all 'touched' sections within the chunk
-        // And will include biome data if all sections have been 'touched'
-        // This flags 65 blocks distributed across all the sections of the chunk, so that everything is sent, including biomes
-        int height = getMaxHeight() / 16;
-        for (int idx = 0; idx < 64; idx++) {
-            world.notify(new BlockPosition(px + (idx / height), ((idx % height) * 16), pz), Blocks.AIR.getBlockData(), Blocks.STONE.getBlockData(), 3);
-        }
-        world.notify(new BlockPosition(px + 15, (height * 16) - 1, pz + 15), Blocks.AIR.getBlockData(), Blocks.STONE.getBlockData(), 3);
-
-        return true;
-    }
-
-    public boolean isChunkInUse(int x, int z) {
-        return world.getPlayerChunkMap().isChunkInUse(x, z);
-    }
-
-    public boolean loadChunk(int x, int z, boolean generate) {
-        org.spigotmc.AsyncCatcher.catchOp( "chunk load"); // Spigot
-        chunkLoadCount++;
-        if (generate) {
-            // Use the default variant of loadChunk when generate == true.
-            return world.getChunkProviderServer().getChunkAt(x, z) != null;
-        }
-
-        return world.getChunkProviderServer().getOrLoadChunkAt(x, z) != null;
-    }
-
-    public boolean isChunkLoaded(Chunk chunk) {
-        return isChunkLoaded(chunk.getX(), chunk.getZ());
-    }
-
-    public void loadChunk(Chunk chunk) {
-        loadChunk(chunk.getX(), chunk.getZ());
-        ((CraftChunk) getChunkAt(chunk.getX(), chunk.getZ())).getHandle().bukkitChunk = chunk;
-    }
-
-    public WorldServer getHandle() {
-        return world;
-    }
-
-    public org.bukkit.entity.Item dropItem(Location loc, ItemStack item) {
-        Validate.notNull(item, "Cannot drop a Null item.");
-        Validate.isTrue(item.getTypeId() != 0, "Cannot drop AIR.");
-        EntityItem entity = new EntityItem(world, loc.getX(), loc.getY(), loc.getZ(), CraftItemStack.asNMSCopy(item));
-        entity.pickupDelay = 10;
-        world.addEntity(entity, SpawnReason.CUSTOM);
-        // TODO this is inconsistent with how Entity.getBukkitEntity() works.
-        // However, this entity is not at the moment backed by a server entity class so it may be left.
-        return new CraftItem(world.getServer(), entity);
-    }
-
-    private static void randomLocationWithinBlock(Location loc, double xs, double ys, double zs) {
-        double prevX = loc.getX();
-        double prevY = loc.getY();
-        double prevZ = loc.getZ();
-        loc.add(xs, ys, zs);
-        if (loc.getX() < Math.floor(prevX)) {
-            loc.setX(Math.floor(prevX));
-        }
-        if (loc.getX() >= Math.ceil(prevX)) {
-            loc.setX(Math.ceil(prevX - 0.01));
-        }
-        if (loc.getY() < Math.floor(prevY)) {
-            loc.setY(Math.floor(prevY));
-        }
-        if (loc.getY() >= Math.ceil(prevY)) {
-            loc.setY(Math.ceil(prevY - 0.01));
-        }
-        if (loc.getZ() < Math.floor(prevZ)) {
-            loc.setZ(Math.floor(prevZ));
-        }
-        if (loc.getZ() >= Math.ceil(prevZ)) {
-            loc.setZ(Math.ceil(prevZ - 0.01));
-        }
-    }
-
-    public org.bukkit.entity.Item dropItemNaturally(Location loc, ItemStack item) {
-        double xs = world.random.nextFloat() * 0.7F - 0.35D;
-        double ys = world.random.nextFloat() * 0.7F - 0.35D;
-        double zs = world.random.nextFloat() * 0.7F - 0.35D;
-        loc = loc.clone();
-        // Makes sure the new item is created within the block the location points to.
-        // This prevents item spill in 1-block wide farms.
-        randomLocationWithinBlock(loc, xs, ys, zs);
-        return dropItem(loc, item);
-    }
-
-    public Arrow spawnArrow(Location loc, Vector velocity, float speed, float spread) {
-        return spawnArrow(loc, velocity, speed, spread, Arrow.class);
-    }
-
-    public <T extends Arrow> T spawnArrow(Location loc, Vector velocity, float speed, float spread, Class<T> clazz) {
-        Validate.notNull(loc, "Can not spawn arrow with a null location");
-        Validate.notNull(velocity, "Can not spawn arrow with a null velocity");
-        Validate.notNull(clazz, "Can not spawn an arrow with no class");
-
-        EntityArrow arrow;
-        if (TippedArrow.class.isAssignableFrom(clazz)) {
-            arrow = new EntityTippedArrow(world);
-            ((EntityTippedArrow) arrow).setType(CraftPotionUtil.fromBukkit(new PotionData(PotionType.WATER, false, false)));
-        } else if (SpectralArrow.class.isAssignableFrom(clazz)) {
-            arrow = new EntitySpectralArrow(world);
-        } else {
-            arrow = new EntityTippedArrow(world);
-        }
-
-        arrow.setPositionRotation(loc.getX(), loc.getY(), loc.getZ(), loc.getYaw(), loc.getPitch());
-        arrow.shoot(velocity.getX(), velocity.getY(), velocity.getZ(), speed, spread);
-        world.addEntity(arrow);
-        return (T) arrow.getBukkitEntity();
-    }
-
-    public Entity spawnEntity(Location loc, EntityType entityType) {
-        return spawn(loc, entityType.getEntityClass());
-    }
-
-    public LightningStrike strikeLightning(Location loc) {
-        EntityLightning lightning = new EntityLightning(world, loc.getX(), loc.getY(), loc.getZ(), false);
-        world.strikeLightning(lightning);
-        return new CraftLightningStrike(server, lightning);
-    }
-
-    public LightningStrike strikeLightningEffect(Location loc) {
-        EntityLightning lightning = new EntityLightning(world, loc.getX(), loc.getY(), loc.getZ(), true);
-        world.strikeLightning(lightning);
-        return new CraftLightningStrike(server, lightning);
-    }
-
-    public boolean generateTree(Location loc, TreeType type) {
-        BlockPosition pos = new BlockPosition(loc.getBlockX(), loc.getBlockY(), loc.getBlockZ());
-
-        net.minecraft.server.WorldGenerator gen;
-        switch (type) {
-        case BIG_TREE:
-            gen = new WorldGenBigTree(true);
-            break;
-        case BIRCH:
-            gen = new WorldGenForest(true, false);
-            break;
-        case REDWOOD:
-            gen = new WorldGenTaiga2(true);
-            break;
-        case TALL_REDWOOD:
-            gen = new WorldGenTaiga1();
-            break;
-        case JUNGLE:
-            IBlockData iblockdata1 = Blocks.LOG.getBlockData().set(BlockLog1.VARIANT, BlockWood.EnumLogVariant.JUNGLE);
-            IBlockData iblockdata2 = Blocks.LEAVES.getBlockData().set(BlockLeaves1.VARIANT, BlockWood.EnumLogVariant.JUNGLE).set(BlockLeaves.CHECK_DECAY, Boolean.valueOf(false));
-            gen = new WorldGenJungleTree(true, 10, 20, iblockdata1, iblockdata2); // Magic values as in BlockSapling
-            break;
-        case SMALL_JUNGLE:
-            iblockdata1 = Blocks.LOG.getBlockData().set(BlockLog1.VARIANT, BlockWood.EnumLogVariant.JUNGLE);
-            iblockdata2 = Blocks.LEAVES.getBlockData().set(BlockLeaves1.VARIANT, BlockWood.EnumLogVariant.JUNGLE).set(BlockLeaves.CHECK_DECAY, Boolean.valueOf(false));
-            gen = new WorldGenTrees(true, 4 + rand.nextInt(7), iblockdata1, iblockdata2, false);
-            break;
-        case COCOA_TREE:
-            iblockdata1 = Blocks.LOG.getBlockData().set(BlockLog1.VARIANT, BlockWood.EnumLogVariant.JUNGLE);
-            iblockdata2 = Blocks.LEAVES.getBlockData().set(BlockLeaves1.VARIANT, BlockWood.EnumLogVariant.JUNGLE).set(BlockLeaves.CHECK_DECAY, Boolean.valueOf(false));
-            gen = new WorldGenTrees(true, 4 + rand.nextInt(7), iblockdata1, iblockdata2, true);
-            break;
-        case JUNGLE_BUSH:
-            iblockdata1 = Blocks.LOG.getBlockData().set(BlockLog1.VARIANT, BlockWood.EnumLogVariant.JUNGLE);
-            iblockdata2 = Blocks.LEAVES.getBlockData().set(BlockLeaves1.VARIANT, BlockWood.EnumLogVariant.OAK).set(BlockLeaves.CHECK_DECAY, Boolean.valueOf(false));
-            gen = new WorldGenGroundBush(iblockdata1, iblockdata2);
-            break;
-        case RED_MUSHROOM:
-            gen = new WorldGenHugeMushroom(Blocks.RED_MUSHROOM_BLOCK);
-            break;
-        case BROWN_MUSHROOM:
-            gen = new WorldGenHugeMushroom(Blocks.BROWN_MUSHROOM_BLOCK);
-            break;
-        case SWAMP:
-            gen = new WorldGenSwampTree();
-            break;
-        case ACACIA:
-            gen = new WorldGenAcaciaTree(true);
-            break;
-        case DARK_OAK:
-            gen = new WorldGenForestTree(true);
-            break;
-        case MEGA_REDWOOD:
-            gen = new WorldGenMegaTree(false, rand.nextBoolean());
-            break;
-        case TALL_BIRCH:
-            gen = new WorldGenForest(true, true);
-            break;
-        case CHORUS_PLANT:
-            BlockChorusFlower.a(world, pos, rand, 8);
-            return true;
-        case TREE:
-        default:
-            gen = new WorldGenTrees(true);
-            break;
-        }
-
-        return gen.generate(world, rand, pos);
-    }
-
-    public boolean generateTree(Location loc, TreeType type, BlockChangeDelegate delegate) {
-        world.captureTreeGeneration = true;
-        world.captureBlockStates = true;
-        boolean grownTree = generateTree(loc, type);
-        world.captureBlockStates = false;
-        world.captureTreeGeneration = false;
-        if (grownTree) { // Copy block data to delegate
-            for (BlockState blockstate : world.capturedBlockStates) {
-                int x = blockstate.getX();
-                int y = blockstate.getY();
-                int z = blockstate.getZ();
-                BlockPosition position = new BlockPosition(x, y, z);
-                net.minecraft.server.IBlockData oldBlock = world.getType(position);
-                int typeId = blockstate.getTypeId();
-                int data = blockstate.getRawData();
-                int flag = ((CraftBlockState)blockstate).getFlag();
-                delegate.setTypeIdAndData(x, y, z, typeId, data);
-                net.minecraft.server.IBlockData newBlock = world.getType(position);
-                world.notifyAndUpdatePhysics(position, null, oldBlock, newBlock, flag);
-            }
-            world.capturedBlockStates.clear();
-            return true;
-        } else {
-            world.capturedBlockStates.clear();
-            return false;
-        }
-    }
-
-    public TileEntity getTileEntityAt(final int x, final int y, final int z) {
-        return world.getTileEntity(new BlockPosition(x, y, z));
-    }
-
-    public String getName() {
-        return world.worldData.getName();
-    }
-
-    @Deprecated
-    public long getId() {
-        return world.worldData.getSeed();
-    }
-
-    public UUID getUID() {
-        return world.getDataManager().getUUID();
-    }
-
-    @Override
-    public String toString() {
-        return "CraftWorld{name=" + getName() + '}';
-    }
-
-    public long getTime() {
-        long time = getFullTime() % 24000;
-        if (time < 0) time += 24000;
-        return time;
-    }
-
-    public void setTime(long time) {
-        long margin = (time - getFullTime()) % 24000;
-        if (margin < 0) margin += 24000;
-        setFullTime(getFullTime() + margin);
-    }
-
-    public long getFullTime() {
-        return world.getDayTime();
-    }
-
-    public void setFullTime(long time) {
-        world.setDayTime(time);
-
-        // Forces the client to update to the new time immediately
-        for (Player p : getPlayers()) {
-            CraftPlayer cp = (CraftPlayer) p;
-            if (cp.getHandle().playerConnection == null) continue;
-
-            cp.getHandle().playerConnection.sendPacket(new PacketPlayOutUpdateTime(cp.getHandle().world.getTime(), cp.getHandle().getPlayerTime(), cp.getHandle().world.getGameRules().getBoolean("doDaylightCycle")));
-        }
-    }
-
-    public boolean createExplosion(double x, double y, double z, float power) {
-        return createExplosion(x, y, z, power, false, true);
-    }
-
-    public boolean createExplosion(double x, double y, double z, float power, boolean setFire) {
-        return createExplosion(x, y, z, power, setFire, true);
-    }
-
-    public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks) {
-        return !world.createExplosion(null, x, y, z, power, setFire, breakBlocks).wasCanceled;
-    }
-
-    public boolean createExplosion(Location loc, float power) {
-        return createExplosion(loc, power, false);
-    }
-
-    public boolean createExplosion(Location loc, float power, boolean setFire) {
-        return createExplosion(loc.getX(), loc.getY(), loc.getZ(), power, setFire);
-    }
-
-    public Environment getEnvironment() {
-        return environment;
-    }
-
-    public void setEnvironment(Environment env) {
-        if (environment != env) {
-            environment = env;
-            switch (env) {
-                case NORMAL:
-                    world.worldProvider = new WorldProviderNormal();
-                    break;
-                case NETHER:
-                    world.worldProvider = new WorldProviderHell();
-                    break;
-                case THE_END:
-                    world.worldProvider = new WorldProviderTheEnd();
-                    break;
-            }
-        }
-    }
-
-    public Block getBlockAt(Location location) {
-        return getBlockAt(location.getBlockX(), location.getBlockY(), location.getBlockZ());
-    }
-
-    public int getBlockTypeIdAt(Location location) {
-        return getBlockTypeIdAt(location.getBlockX(), location.getBlockY(), location.getBlockZ());
-    }
-
-    public int getHighestBlockYAt(Location location) {
-        return getHighestBlockYAt(location.getBlockX(), location.getBlockZ());
-    }
-
-    public Chunk getChunkAt(Location location) {
-        return getChunkAt(location.getBlockX() >> 4, location.getBlockZ() >> 4);
-    }
-
-    public ChunkGenerator getGenerator() {
-        return generator;
-    }
-
-    public List<BlockPopulator> getPopulators() {
-        return populators;
-    }
-
-    public Block getHighestBlockAt(int x, int z) {
-        return getBlockAt(x, getHighestBlockYAt(x, z), z);
-    }
-
-    public Block getHighestBlockAt(Location location) {
-        return getHighestBlockAt(location.getBlockX(), location.getBlockZ());
-    }
-
-    public Biome getBiome(int x, int z) {
-        return CraftBlock.biomeBaseToBiome(this.world.getBiome(new BlockPosition(x, 0, z)));
-    }
-
-    public void setBiome(int x, int z, Biome bio) {
-        BiomeBase bb = CraftBlock.biomeToBiomeBase(bio);
-        if (this.world.isLoaded(new BlockPosition(x, 0, z))) {
-            net.minecraft.server.Chunk chunk = this.world.getChunkAtWorldCoords(new BlockPosition(x, 0, z));
-
-            if (chunk != null) {
-                byte[] biomevals = chunk.getBiomeIndex();
-                biomevals[((z & 0xF) << 4) | (x & 0xF)] = (byte) BiomeBase.REGISTRY_ID.a(bb);
-            }
-        }
-    }
-
-    public double getTemperature(int x, int z) {
-        return this.world.getBiome(new BlockPosition(x, 0, z)).getTemperature();
-    }
-
-    public double getHumidity(int x, int z) {
-        return this.world.getBiome(new BlockPosition(x, 0, z)).getHumidity();
-    }
-
-    public List<Entity> getEntities() {
-        List<Entity> list = new ArrayList<Entity>();
-
-        for (Object o : world.entityList) {
-            if (o instanceof net.minecraft.server.Entity) {
-                net.minecraft.server.Entity mcEnt = (net.minecraft.server.Entity) o;
-                Entity bukkitEntity = mcEnt.getBukkitEntity();
-
-                // Assuming that bukkitEntity isn't null
-                if (bukkitEntity != null) {
-                    list.add(bukkitEntity);
-                }
-            }
-        }
-
-        return list;
-    }
-
-    public List<LivingEntity> getLivingEntities() {
-        List<LivingEntity> list = new ArrayList<LivingEntity>();
-
-        for (Object o : world.entityList) {
-            if (o instanceof net.minecraft.server.Entity) {
-                net.minecraft.server.Entity mcEnt = (net.minecraft.server.Entity) o;
-                Entity bukkitEntity = mcEnt.getBukkitEntity();
-
-                // Assuming that bukkitEntity isn't null
-                if (bukkitEntity != null && bukkitEntity instanceof LivingEntity) {
-                    list.add((LivingEntity) bukkitEntity);
-                }
-            }
-        }
-
-        return list;
-    }
-
-    @SuppressWarnings("unchecked")
-    @Deprecated
-    public <T extends Entity> Collection<T> getEntitiesByClass(Class<T>... classes) {
-        return (Collection<T>)getEntitiesByClasses(classes);
-    }
-
-    @SuppressWarnings("unchecked")
-    public <T extends Entity> Collection<T> getEntitiesByClass(Class<T> clazz) {
-        Collection<T> list = new ArrayList<T>();
-
-        for (Object entity: world.entityList) {
-            if (entity instanceof net.minecraft.server.Entity) {
-                Entity bukkitEntity = ((net.minecraft.server.Entity) entity).getBukkitEntity();
-
-                if (bukkitEntity == null) {
-                    continue;
-                }
-
-                Class<?> bukkitClass = bukkitEntity.getClass();
-
-                if (clazz.isAssignableFrom(bukkitClass)) {
-                    list.add((T) bukkitEntity);
-                }
-            }
-        }
-
-        return list;
-    }
-
-    public Collection<Entity> getEntitiesByClasses(Class<?>... classes) {
-        Collection<Entity> list = new ArrayList<Entity>();
-
-        for (Object entity: world.entityList) {
-            if (entity instanceof net.minecraft.server.Entity) {
-                Entity bukkitEntity = ((net.minecraft.server.Entity) entity).getBukkitEntity();
-
-                if (bukkitEntity == null) {
-                    continue;
-                }
-
-                Class<?> bukkitClass = bukkitEntity.getClass();
-
-                for (Class<?> clazz : classes) {
-                    if (clazz.isAssignableFrom(bukkitClass)) {
-                        list.add(bukkitEntity);
-                        break;
-                    }
-                }
-            }
-        }
-
-        return list;
-    }
-
-    @Override
-    public Collection<Entity> getNearbyEntities(Location location, double x, double y, double z) {
-        if (location == null || !location.getWorld().equals(this)) {
-            return Collections.emptyList();
-        }
-
-        AxisAlignedBB bb = new AxisAlignedBB(location.getX() - x, location.getY() - y, location.getZ() - z, location.getX() + x, location.getY() + y, location.getZ() + z);
-        List<net.minecraft.server.Entity> entityList = getHandle().getEntities((net.minecraft.server.Entity) null, bb, null);
-        List<Entity> bukkitEntityList = new ArrayList<org.bukkit.entity.Entity>(entityList.size());
-        for (Object entity : entityList) {
-            bukkitEntityList.add(((net.minecraft.server.Entity) entity).getBukkitEntity());
-        }
-        return bukkitEntityList;
-    }
-
-    public List<Player> getPlayers() {
-        List<Player> list = new ArrayList<Player>(world.players.size());
-
-        for (EntityHuman human : world.players) {
-            HumanEntity bukkitEntity = human.getBukkitEntity();
-
-            if ((bukkitEntity != null) && (bukkitEntity instanceof Player)) {
-                list.add((Player) bukkitEntity);
-            }
-        }
-
-        return list;
-    }
-
-    public void save() {
-    // Spigot start
-        save(true);
-    }
-    public void save(boolean forceSave) {
-    // Spigot end
-        this.server.checkSaveState();
-        try {
-            boolean oldSave = world.savingDisabled;
-
-            world.savingDisabled = false;
-            world.save(forceSave, null); // Spigot
-
-            world.savingDisabled = oldSave;
-        } catch (ExceptionWorldConflict ex) {
-            ex.printStackTrace();
-        }
-    }
-
-    public boolean isAutoSave() {
-        return !world.savingDisabled;
-    }
-
-    public void setAutoSave(boolean value) {
-        world.savingDisabled = !value;
-    }
-
-    public void setDifficulty(Difficulty difficulty) {
-        this.getHandle().worldData.setDifficulty(EnumDifficulty.getById(difficulty.getValue()));
-    }
-
-    public Difficulty getDifficulty() {
-        return Difficulty.getByValue(this.getHandle().getDifficulty().ordinal());
-    }
-
-    public BlockMetadataStore getBlockMetadata() {
-        return blockMetadata;
-    }
-
-    public boolean hasStorm() {
-        return world.worldData.hasStorm();
-    }
-
-    public void setStorm(boolean hasStorm) {
-        world.worldData.setStorm(hasStorm);
-    }
-
-    public int getWeatherDuration() {
-        return world.worldData.getWeatherDuration();
-    }
-
-    public void setWeatherDuration(int duration) {
-        world.worldData.setWeatherDuration(duration);
-    }
-
-    public boolean isThundering() {
-        return world.worldData.isThundering();
-    }
-
-    public void setThundering(boolean thundering) {
-        world.worldData.setThundering(thundering);
-    }
-
-    public int getThunderDuration() {
-        return world.worldData.getThunderDuration();
-    }
-
-    public void setThunderDuration(int duration) {
-        world.worldData.setThunderDuration(duration);
-    }
-
-    public long getSeed() {
-        return world.worldData.getSeed();
-    }
-
-    public boolean getPVP() {
-        return world.pvpMode;
-    }
-
-    public void setPVP(boolean pvp) {
-        world.pvpMode = pvp;
-    }
-
-    public void playEffect(Player player, Effect effect, int data) {
-        playEffect(player.getLocation(), effect, data, 0);
-    }
-
-    public void playEffect(Location location, Effect effect, int data) {
-        playEffect(location, effect, data, 64);
-    }
-
-    public <T> void playEffect(Location loc, Effect effect, T data) {
-        playEffect(loc, effect, data, 64);
-    }
-
-    public <T> void playEffect(Location loc, Effect effect, T data, int radius) {
-        if (data != null) {
-            Validate.isTrue(effect.getData() != null && effect.getData().isAssignableFrom(data.getClass()), "Wrong kind of data for this effect!");
-        } else {
-            Validate.isTrue(effect.getData() == null, "Wrong kind of data for this effect!");
-        }
-
-        if (data != null && data.getClass().equals( org.bukkit.material.MaterialData.class )) {
-            org.bukkit.material.MaterialData materialData = (org.bukkit.material.MaterialData) data;
-            Validate.isTrue( materialData.getItemType().isBlock(), "Material must be block" );
-            spigot().playEffect( loc, effect, materialData.getItemType().getId(), materialData.getData(), 0, 0, 0, 1, 1, radius );
-        } else {
-            int dataValue = data == null ? 0 : CraftEffect.getDataValue( effect, data );
-            playEffect( loc, effect, dataValue, radius );
-        }
-    }
-
-    public void playEffect(Location location, Effect effect, int data, int radius) {
-        spigot().playEffect( location, effect, data, 0, 0, 0, 0, 1, 1, radius );
-    }
-
-    public <T extends Entity> T spawn(Location location, Class<T> clazz) throws IllegalArgumentException {
-        return spawn(location, clazz, SpawnReason.CUSTOM);
-    }
-
-    public FallingBlock spawnFallingBlock(Location location, org.bukkit.Material material, byte data) throws IllegalArgumentException {
-        Validate.notNull(location, "Location cannot be null");
-        Validate.notNull(material, "Material cannot be null");
-        Validate.isTrue(material.isBlock(), "Material must be a block");
-
-        EntityFallingBlock entity = new EntityFallingBlock(world, location.getX(), location.getY(), location.getZ(), CraftMagicNumbers.getBlock(material).fromLegacyData(data));
-        entity.ticksLived = 1;
-
-        world.addEntity(entity, SpawnReason.CUSTOM);
-        return (FallingBlock) entity.getBukkitEntity();
-    }
-
-    public FallingBlock spawnFallingBlock(Location location, int blockId, byte blockData) throws IllegalArgumentException {
-        return spawnFallingBlock(location, org.bukkit.Material.getMaterial(blockId), blockData);
-    }
-
-    @SuppressWarnings("unchecked")
-    public net.minecraft.server.Entity createEntity(Location location, Class<? extends Entity> clazz) throws IllegalArgumentException {
-        if (location == null || clazz == null) {
-            throw new IllegalArgumentException("Location or entity class cannot be null");
-        }
-
-        net.minecraft.server.Entity entity = null;
-
-        double x = location.getX();
-        double y = location.getY();
-        double z = location.getZ();
-        float pitch = location.getPitch();
-        float yaw = location.getYaw();
-
-        // order is important for some of these
-        if (Boat.class.isAssignableFrom(clazz)) {
-            entity = new EntityBoat(world, x, y, z);
-        } else if (FallingBlock.class.isAssignableFrom(clazz)) {
-            entity = new EntityFallingBlock(world, x, y, z, world.getType(new BlockPosition(x, y, z)));
-        } else if (Projectile.class.isAssignableFrom(clazz)) {
-            if (Snowball.class.isAssignableFrom(clazz)) {
-                entity = new EntitySnowball(world, x, y, z);
-            } else if (Egg.class.isAssignableFrom(clazz)) {
-                entity = new EntityEgg(world, x, y, z);
-            } else if (Arrow.class.isAssignableFrom(clazz)) {
-                if (TippedArrow.class.isAssignableFrom(clazz)) {
-                    entity = new EntityTippedArrow(world);
-                    ((EntityTippedArrow) entity).setType(CraftPotionUtil.fromBukkit(new PotionData(PotionType.WATER, false, false)));
-                } else if (SpectralArrow.class.isAssignableFrom(clazz)) {
-                    entity = new EntitySpectralArrow(world);
-                } else {
-                    entity = new EntityTippedArrow(world);
-                }
-                entity.setPositionRotation(x, y, z, 0, 0);
-            } else if (ThrownExpBottle.class.isAssignableFrom(clazz)) {
-                entity = new EntityThrownExpBottle(world);
-                entity.setPositionRotation(x, y, z, 0, 0);
-            } else if (EnderPearl.class.isAssignableFrom(clazz)) {
-                entity = new EntityEnderPearl(world);
-                entity.setPositionRotation(x, y, z, 0, 0);
-            } else if (ThrownPotion.class.isAssignableFrom(clazz)) {
-                if (LingeringPotion.class.isAssignableFrom(clazz)) {
-                    entity = new EntityPotion(world, x, y, z, CraftItemStack.asNMSCopy(new ItemStack(org.bukkit.Material.LINGERING_POTION, 1)));
-                } else {
-                    entity = new EntityPotion(world, x, y, z, CraftItemStack.asNMSCopy(new ItemStack(org.bukkit.Material.SPLASH_POTION, 1)));
-                }
-            } else if (Fireball.class.isAssignableFrom(clazz)) {
-                if (SmallFireball.class.isAssignableFrom(clazz)) {
-                    entity = new EntitySmallFireball(world);
-                } else if (WitherSkull.class.isAssignableFrom(clazz)) {
-                    entity = new EntityWitherSkull(world);
-                } else if (DragonFireball.class.isAssignableFrom(clazz)) {
-                    entity = new EntityDragonFireball(world);
-                } else {
-                    entity = new EntityLargeFireball(world);
-                }
-                entity.setPositionRotation(x, y, z, yaw, pitch);
-                Vector direction = location.getDirection().multiply(10);
-                ((EntityFireball) entity).setDirection(direction.getX(), direction.getY(), direction.getZ());
-            } else if (ShulkerBullet.class.isAssignableFrom(clazz)) {
-                entity = new EntityShulkerBullet(world);
-                entity.setPositionRotation(x, y, z, yaw, pitch);
-            }
-        } else if (Minecart.class.isAssignableFrom(clazz)) {
-            if (PoweredMinecart.class.isAssignableFrom(clazz)) {
-                entity = new EntityMinecartFurnace(world, x, y, z);
-            } else if (StorageMinecart.class.isAssignableFrom(clazz)) {
-                entity = new EntityMinecartChest(world, x, y, z);
-            } else if (ExplosiveMinecart.class.isAssignableFrom(clazz)) {
-                entity = new EntityMinecartTNT(world, x, y, z);
-            } else if (HopperMinecart.class.isAssignableFrom(clazz)) {
-                entity = new EntityMinecartHopper(world, x, y, z);
-            } else if (SpawnerMinecart.class.isAssignableFrom(clazz)) {
-                entity = new EntityMinecartMobSpawner(world, x, y, z);
-            } else if (CommandMinecart.class.isAssignableFrom(clazz)) {
-                entity = new EntityMinecartCommandBlock(world, x, y, z);
-            } else { // Default to rideable minecart for pre-rideable compatibility
-                entity = new EntityMinecartRideable(world, x, y, z);
-            }
-        } else if (EnderSignal.class.isAssignableFrom(clazz)) {
-            entity = new EntityEnderSignal(world, x, y, z);
-        } else if (EnderCrystal.class.isAssignableFrom(clazz)) {
-            entity = new EntityEnderCrystal(world);
-            entity.setPositionRotation(x, y, z, 0, 0);
-        } else if (LivingEntity.class.isAssignableFrom(clazz)) {
-            if (Chicken.class.isAssignableFrom(clazz)) {
-                entity = new EntityChicken(world);
-            } else if (Cow.class.isAssignableFrom(clazz)) {
-                if (MushroomCow.class.isAssignableFrom(clazz)) {
-                    entity = new EntityMushroomCow(world);
-                } else {
-                    entity = new EntityCow(world);
-                }
-            } else if (Golem.class.isAssignableFrom(clazz)) {
-                if (Snowman.class.isAssignableFrom(clazz)) {
-                    entity = new EntitySnowman(world);
-                } else if (IronGolem.class.isAssignableFrom(clazz)) {
-                    entity = new EntityIronGolem(world);
-                } else if (Shulker.class.isAssignableFrom(clazz)) {
-                    entity = new EntityShulker(world);
-                }
-            } else if (Creeper.class.isAssignableFrom(clazz)) {
-                entity = new EntityCreeper(world);
-            } else if (Ghast.class.isAssignableFrom(clazz)) {
-                entity = new EntityGhast(world);
-            } else if (Pig.class.isAssignableFrom(clazz)) {
-                entity = new EntityPig(world);
-            } else if (Player.class.isAssignableFrom(clazz)) {
-                // need a net server handler for this one
-            } else if (Sheep.class.isAssignableFrom(clazz)) {
-                entity = new EntitySheep(world);
-            } else if (Horse.class.isAssignableFrom(clazz)) {
-                entity = new EntityHorse(world);
-            } else if (Skeleton.class.isAssignableFrom(clazz)) {
-                entity = new EntitySkeleton(world);
-            } else if (Slime.class.isAssignableFrom(clazz)) {
-                if (MagmaCube.class.isAssignableFrom(clazz)) {
-                    entity = new EntityMagmaCube(world);
-                } else {
-                    entity = new EntitySlime(world);
-                }
-            } else if (Spider.class.isAssignableFrom(clazz)) {
-                if (CaveSpider.class.isAssignableFrom(clazz)) {
-                    entity = new EntityCaveSpider(world);
-                } else {
-                    entity = new EntitySpider(world);
-                }
-            } else if (Squid.class.isAssignableFrom(clazz)) {
-                entity = new EntitySquid(world);
-            } else if (Tameable.class.isAssignableFrom(clazz)) {
-                if (Wolf.class.isAssignableFrom(clazz)) {
-                    entity = new EntityWolf(world);
-                } else if (Ocelot.class.isAssignableFrom(clazz)) {
-                    entity = new EntityOcelot(world);
-                }
-            } else if (PigZombie.class.isAssignableFrom(clazz)) {
-                entity = new EntityPigZombie(world);
-            } else if (Zombie.class.isAssignableFrom(clazz)) {
-                entity = new EntityZombie(world);
-            } else if (Giant.class.isAssignableFrom(clazz)) {
-                entity = new EntityGiantZombie(world);
-            } else if (Silverfish.class.isAssignableFrom(clazz)) {
-                entity = new EntitySilverfish(world);
-            } else if (Enderman.class.isAssignableFrom(clazz)) {
-                entity = new EntityEnderman(world);
-            } else if (Blaze.class.isAssignableFrom(clazz)) {
-                entity = new EntityBlaze(world);
-            } else if (Villager.class.isAssignableFrom(clazz)) {
-                entity = new EntityVillager(world);
-            } else if (Witch.class.isAssignableFrom(clazz)) {
-                entity = new EntityWitch(world);
-            } else if (Wither.class.isAssignableFrom(clazz)) {
-                entity = new EntityWither(world);
-            } else if (ComplexLivingEntity.class.isAssignableFrom(clazz)) {
-                if (EnderDragon.class.isAssignableFrom(clazz)) {
-                    entity = new EntityEnderDragon(world);
-                }
-            } else if (Ambient.class.isAssignableFrom(clazz)) {
-                if (Bat.class.isAssignableFrom(clazz)) {
-                    entity = new EntityBat(world);
-                }
-            } else if (Rabbit.class.isAssignableFrom(clazz)) {
-                entity = new EntityRabbit(world);
-            } else if (Endermite.class.isAssignableFrom(clazz)) {
-                entity = new EntityEndermite(world);
-            } else if (Guardian.class.isAssignableFrom(clazz)) {
-                entity = new EntityGuardian(world);
-            } else if (ArmorStand.class.isAssignableFrom(clazz)) {
-                entity = new EntityArmorStand(world, x, y, z);
-            } else if (PolarBear.class.isAssignableFrom(clazz)) {
-                entity = new EntityPolarBear(world);
-            }
-
-            if (entity != null) {
-                entity.setLocation(x, y, z, yaw, pitch);
-            }
-        } else if (Hanging.class.isAssignableFrom(clazz)) {
-            Block block = getBlockAt(location);
-            BlockFace face = BlockFace.SELF;
-
-            int width = 16; // 1 full block, also painting smallest size.
-            int height = 16; // 1 full block, also painting smallest size.
-
-            if (ItemFrame.class.isAssignableFrom(clazz)) {
-                width = 12;
-                height = 12;
-            } else if (LeashHitch.class.isAssignableFrom(clazz)) {
-                width = 9;
-                height = 9;
-            }
-
-            BlockFace[] faces = new BlockFace[]{BlockFace.EAST, BlockFace.NORTH, BlockFace.WEST, BlockFace.SOUTH};
-            final BlockPosition pos = new BlockPosition((int) x, (int) y, (int) z);
-            for (BlockFace dir : faces) {
-                net.minecraft.server.Block nmsBlock = CraftMagicNumbers.getBlock(block.getRelative(dir));
-                if (nmsBlock.getBlockData().getMaterial().isBuildable() || BlockDiodeAbstract.isDiode(nmsBlock.getBlockData())) {
-                    boolean taken = false;
-                    AxisAlignedBB bb = EntityHanging.calculateBoundingBox(null, pos, CraftBlock.blockFaceToNotch(dir).opposite(), width, height);
-                    List<net.minecraft.server.Entity> list = (List<net.minecraft.server.Entity>) world.getEntities(null, bb);
-                    for (Iterator<net.minecraft.server.Entity> it = list.iterator(); !taken && it.hasNext();) {
-                        net.minecraft.server.Entity e = it.next();
-                        if (e instanceof EntityHanging) {
-                            taken = true; // Hanging entities do not like hanging entities which intersect them.
-                        }
-                    }
-
-                    if (!taken) {
-                        face = dir;
-                        break;
-                    }
-                }
-            }
-
-            if (LeashHitch.class.isAssignableFrom(clazz)) {
-                entity = new EntityLeash(world, new BlockPosition((int) x, (int) y, (int) z));
-                entity.attachedToPlayer = true;
-            } else {
-                EnumDirection dir = CraftBlock.blockFaceToNotch(face).opposite();
-                if (Painting.class.isAssignableFrom(clazz)) {
-                    entity = new EntityPainting(world, new BlockPosition((int) x, (int) y, (int) z), dir);
-                } else if (ItemFrame.class.isAssignableFrom(clazz)) {
-                    entity = new EntityItemFrame(world, new BlockPosition((int) x, (int) y, (int) z), dir);
-                }
-            }
-
-            if (entity != null && !((EntityHanging) entity).survives()) {
-                throw new IllegalArgumentException("Cannot spawn hanging entity for " + clazz.getName() + " at " + location);
-            }
-        } else if (TNTPrimed.class.isAssignableFrom(clazz)) {
-            entity = new EntityTNTPrimed(world, x, y, z, null);
-        } else if (ExperienceOrb.class.isAssignableFrom(clazz)) {
-            entity = new EntityExperienceOrb(world, x, y, z, 0);
-        } else if (Weather.class.isAssignableFrom(clazz)) {
-            // not sure what this can do
-            if (LightningStrike.class.isAssignableFrom(clazz)) {
-                entity = new EntityLightning(world, x, y, z, false);
-                // what is this, I don't even
-            }
-        } else if (Firework.class.isAssignableFrom(clazz)) {
-            entity = new EntityFireworks(world, x, y, z, null);
-        } else if (AreaEffectCloud.class.isAssignableFrom(clazz)) {
-            entity = new EntityAreaEffectCloud(world, x, y, z);
-        }
-
-        if (entity != null) {
-            // Spigot start
-            if (entity instanceof EntityOcelot)
-            {
-                ( (EntityOcelot) entity ).spawnBonus = false;
-            }
-            // Spigot end
-            return entity;
-        }
-
-        throw new IllegalArgumentException("Cannot spawn an entity for " + clazz.getName());
-    }
-
-    @SuppressWarnings("unchecked")
-    public <T extends Entity> T addEntity(net.minecraft.server.Entity entity, SpawnReason reason) throws IllegalArgumentException {
-        Preconditions.checkArgument(entity != null, "Cannot spawn null entity");
-
-        if (entity instanceof EntityInsentient) {
-            ((EntityInsentient) entity).prepare(getHandle().D(new BlockPosition(entity)), (GroupDataEntity) null);
-        }
-
-        world.addEntity(entity, reason);
-        return (T) entity.getBukkitEntity();
-    }
-
-    public <T extends Entity> T spawn(Location location, Class<T> clazz, SpawnReason reason) throws IllegalArgumentException {
-        net.minecraft.server.Entity entity = createEntity(location, clazz);
-
-        return addEntity(entity, reason);
-    }
-
-    public ChunkSnapshot getEmptyChunkSnapshot(int x, int z, boolean includeBiome, boolean includeBiomeTempRain) {
-        return CraftChunk.getEmptyChunkSnapshot(x, z, this, includeBiome, includeBiomeTempRain);
-    }
-
-    public void setSpawnFlags(boolean allowMonsters, boolean allowAnimals) {
-        world.setSpawnFlags(allowMonsters, allowAnimals);
-    }
-
-    public boolean getAllowAnimals() {
-        return world.allowAnimals;
-    }
-
-    public boolean getAllowMonsters() {
-        return world.allowMonsters;
-    }
-
-    public int getMaxHeight() {
-        return world.getHeight();
-    }
-
-    public int getSeaLevel() {
-        return 64;
-    }
-
-    public boolean getKeepSpawnInMemory() {
-        return world.keepSpawnInMemory;
-    }
-
-    public void setKeepSpawnInMemory(boolean keepLoaded) {
-        world.keepSpawnInMemory = keepLoaded;
-        // Grab the worlds spawn chunk
-        BlockPosition chunkcoordinates = this.world.getSpawn();
-        int chunkCoordX = chunkcoordinates.getX() >> 4;
-        int chunkCoordZ = chunkcoordinates.getZ() >> 4;
-        // Cycle through the 25x25 Chunks around it to load/unload the chunks.
-        for (int x = -12; x <= 12; x++) {
-            for (int z = -12; z <= 12; z++) {
-                if (keepLoaded) {
-                    loadChunk(chunkCoordX + x, chunkCoordZ + z);
-                } else {
-                    if (isChunkLoaded(chunkCoordX + x, chunkCoordZ + z)) {
-                        unloadChunk(chunkCoordX + x, chunkCoordZ + z);
-                    }
-                }
-            }
-        }
-    }
-
-    @Override
-    public int hashCode() {
-        return getUID().hashCode();
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (obj == null) {
-            return false;
-        }
-        if (getClass() != obj.getClass()) {
-            return false;
-        }
-
-        final CraftWorld other = (CraftWorld) obj;
-
-        return this.getUID() == other.getUID();
-    }
-
-    public File getWorldFolder() {
-        return ((WorldNBTStorage) world.getDataManager()).getDirectory();
-    }
-
-    public void sendPluginMessage(Plugin source, String channel, byte[] message) {
-        StandardMessenger.validatePluginMessage(server.getMessenger(), source, channel, message);
-
-        for (Player player : getPlayers()) {
-            player.sendPluginMessage(source, channel, message);
-        }
-    }
-
-    public Set<String> getListeningPluginChannels() {
-        Set<String> result = new HashSet<String>();
-
-        for (Player player : getPlayers()) {
-            result.addAll(player.getListeningPluginChannels());
-        }
-
-        return result;
-    }
-
-    public org.bukkit.WorldType getWorldType() {
-        return org.bukkit.WorldType.getByName(world.getWorldData().getType().name());
-    }
-
-    public boolean canGenerateStructures() {
-        return world.getWorldData().shouldGenerateMapFeatures();
-    }
-
-    public long getTicksPerAnimalSpawns() {
-        return world.ticksPerAnimalSpawns;
-    }
-
-    public void setTicksPerAnimalSpawns(int ticksPerAnimalSpawns) {
-        world.ticksPerAnimalSpawns = ticksPerAnimalSpawns;
-    }
-
-    public long getTicksPerMonsterSpawns() {
-        return world.ticksPerMonsterSpawns;
-    }
-
-    public void setTicksPerMonsterSpawns(int ticksPerMonsterSpawns) {
-        world.ticksPerMonsterSpawns = ticksPerMonsterSpawns;
-    }
-
-    public void setMetadata(String metadataKey, MetadataValue newMetadataValue) {
-        server.getWorldMetadata().setMetadata(this, metadataKey, newMetadataValue);
-    }
-
-    public List<MetadataValue> getMetadata(String metadataKey) {
-        return server.getWorldMetadata().getMetadata(this, metadataKey);
-    }
-
-    public boolean hasMetadata(String metadataKey) {
-        return server.getWorldMetadata().hasMetadata(this, metadataKey);
-    }
-
-    public void removeMetadata(String metadataKey, Plugin owningPlugin) {
-        server.getWorldMetadata().removeMetadata(this, metadataKey, owningPlugin);
-    }
-
-    public int getMonsterSpawnLimit() {
-        if (monsterSpawn < 0) {
-            return server.getMonsterSpawnLimit();
-        }
-
-        return monsterSpawn;
-    }
-
-    public void setMonsterSpawnLimit(int limit) {
-        monsterSpawn = limit;
-    }
-
-    public int getAnimalSpawnLimit() {
-        if (animalSpawn < 0) {
-            return server.getAnimalSpawnLimit();
-        }
-
-        return animalSpawn;
-    }
-
-    public void setAnimalSpawnLimit(int limit) {
-        animalSpawn = limit;
-    }
-
-    public int getWaterAnimalSpawnLimit() {
-        if (waterAnimalSpawn < 0) {
-            return server.getWaterAnimalSpawnLimit();
-        }
-
-        return waterAnimalSpawn;
-    }
-
-    public void setWaterAnimalSpawnLimit(int limit) {
-        waterAnimalSpawn = limit;
-    }
-
-    public int getAmbientSpawnLimit() {
-        if (ambientSpawn < 0) {
-            return server.getAmbientSpawnLimit();
-        }
-
-        return ambientSpawn;
-    }
-
-    public void setAmbientSpawnLimit(int limit) {
-        ambientSpawn = limit;
-    }
-
-
-    public void playSound(Location loc, Sound sound, float volume, float pitch) {
-        if (loc == null || sound == null) return;
-
-        double x = loc.getX();
-        double y = loc.getY();
-        double z = loc.getZ();
-
-        getHandle().a(null, x, y, z, CraftSound.getSoundEffect(CraftSound.getSound(sound)), SoundCategory.MASTER, volume, pitch); // PAIL: rename
-    }
-
-    public void playSound(Location loc, String sound, float volume, float pitch) {
-        if (loc == null || sound == null) return;
-
-        double x = loc.getX();
-        double y = loc.getY();
-        double z = loc.getZ();
-
-        PacketPlayOutCustomSoundEffect packet = new PacketPlayOutCustomSoundEffect(sound, SoundCategory.MASTER, x, y, z, volume, pitch);
-        world.getMinecraftServer().getPlayerList().sendPacketNearby(null, x, y, z, volume > 1.0F ? 16.0F * volume : 16.0D, this.world.dimension, packet);
-    }
-
-    public String getGameRuleValue(String rule) {
-        return getHandle().getGameRules().get(rule);
-    }
-
-    public boolean setGameRuleValue(String rule, String value) {
-        // No null values allowed
-        if (rule == null || value == null) return false;
-
-        if (!isGameRule(rule)) return false;
-
-        getHandle().getGameRules().set(rule, value);
-        return true;
-    }
-
-    public String[] getGameRules() {
-        return getHandle().getGameRules().getGameRules();
-    }
-
-    public boolean isGameRule(String rule) {
-        return getHandle().getGameRules().contains(rule);
-    }
-
-    @Override
-    public WorldBorder getWorldBorder() {
-        if (this.worldBorder == null) {
-            this.worldBorder = new CraftWorldBorder(this);
-        }
-
-        return this.worldBorder;
-    }
-
-    @Override
-    public void spawnParticle(Particle particle, Location location, int count) {
-        spawnParticle(particle, location.getX(), location.getY(), location.getZ(), count);
-    }
-
-    @Override
-    public void spawnParticle(Particle particle, double x, double y, double z, int count) {
-        spawnParticle(particle, x, y, z, count, null);
-    }
-
-    @Override
-    public <T> void spawnParticle(Particle particle, Location location, int count, T data) {
-        spawnParticle(particle, location.getX(), location.getY(), location.getZ(), count, data);
-    }
-
-    @Override
-    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, T data) {
-        spawnParticle(particle, x, y, z, count, 0, 0, 0, data);
-    }
-
-    @Override
-    public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ) {
-        spawnParticle(particle, location.getX(), location.getY(), location.getZ(), count, offsetX, offsetY, offsetZ);
-    }
-
-    @Override
-    public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ) {
-        spawnParticle(particle, x, y, z, count, offsetX, offsetY, offsetZ, null);
-    }
-
-    @Override
-    public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, T data) {
-        spawnParticle(particle, location.getX(), location.getY(), location.getZ(), count, offsetX, offsetY, offsetZ, data);
-    }
-
-    @Override
-    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, T data) {
-        spawnParticle(particle, x, y, z, count, offsetX, offsetY, offsetZ, 1, data);
-    }
-
-    @Override
-    public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra) {
-        spawnParticle(particle, location.getX(), location.getY(), location.getZ(), count, offsetX, offsetY, offsetZ, extra);
-    }
-
-    @Override
-    public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra) {
-        spawnParticle(particle, x, y, z, count, offsetX, offsetY, offsetZ, extra, null);
-    }
-
-    @Override
-    public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data) {
-        spawnParticle(particle, location.getX(), location.getY(), location.getZ(), count, offsetX, offsetY, offsetZ, extra, data);
-    }
-
-    @Override
-    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data) {
-        if (data != null && !particle.getDataType().isInstance(data)) {
-            throw new IllegalArgumentException("data should be " + particle.getDataType() + " got " + data.getClass());
-        }
-        getHandle().sendParticles(
-                null, // Sender
-                CraftParticle.toNMS(particle), // Particle
-                true, // Extended range
-                x, y, z, // Position
-                count,  // Count
-                offsetX, offsetY, offsetZ, // Random offset
-                extra, // Speed?
-                CraftParticle.toData(particle, data)
-
-        );
-
-    }
-
-    public void processChunkGC() {
-        chunkGCTickCount++;
-
-        if (chunkLoadCount >= server.chunkGCLoadThresh && server.chunkGCLoadThresh > 0) {
-            chunkLoadCount = 0;
-        } else if (chunkGCTickCount >= server.chunkGCPeriod && server.chunkGCPeriod > 0) {
-            chunkGCTickCount = 0;
-        } else {
-            return;
-        }
-
-        ChunkProviderServer cps = world.getChunkProviderServer();
-        for (net.minecraft.server.Chunk chunk : cps.chunks.values()) {
-            // If in use, skip it
-            if (isChunkInUse(chunk.locX, chunk.locZ)) {
-                continue;
-            }
-
-            // Already unloading?
-            if (cps.unloadQueue.contains(ChunkCoordIntPair.a(chunk.locX, chunk.locZ))) {
-                continue;
-            }
-
-            // Add unload request
-            cps.unload(chunk);
-        }
-    }
-    // Spigot start
-    private final Spigot spigot = new Spigot()
-    {
-        @Override
-        public void playEffect( Location location, Effect effect, int id, int data, float offsetX, float offsetY, float offsetZ, float speed, int particleCount, int radius )
-        {
-            Validate.notNull( location, "Location cannot be null" );
-            Validate.notNull( effect, "Effect cannot be null" );
-            Validate.notNull( location.getWorld(), "World cannot be null" );
-            Packet packet;
-            if ( effect.getType() != Effect.Type.PARTICLE )
-            {
-                int packetData = effect.getId();
-                packet = new PacketPlayOutWorldEvent( packetData, new BlockPosition(location.getBlockX(), location.getBlockY(), location.getBlockZ() ), id, false );
-            } else
-            {
-                net.minecraft.server.EnumParticle particle = null;
-                int[] extra = null;
-                for ( net.minecraft.server.EnumParticle p : net.minecraft.server.EnumParticle.values() )
-                {
-                    if ( effect.getName().startsWith( p.b().replace("_", "") ) )
-                    {
-                        particle = p;
-                        if ( effect.getData() != null ) 
-                        {
-                            if ( effect.getData().equals( org.bukkit.Material.class ) )
-                            {
-                                extra = new int[]{ id };
-                            } else 
-                            {
-                                extra = new int[]{ (data << 12) | (id & 0xFFF) };
-                            }
-                        }
-                        break;
-                    }
-                }
-                if ( extra == null )
-                {
-                    extra = new int[0];
-                }
-                packet = new PacketPlayOutWorldParticles( particle, true, (float) location.getX(), (float) location.getY(), (float) location.getZ(), offsetX, offsetY, offsetZ, speed, particleCount, extra );
-            }
-            int distance;
-            radius *= radius;
-            for ( Player player : getPlayers() )
-            {
-                if ( ( (CraftPlayer) player ).getHandle().playerConnection == null )
-                {
-                    continue;
-                }
-                if ( !location.getWorld().equals( player.getWorld() ) )
-                {
-                    continue;
-                }
-                distance = (int) player.getLocation().distanceSquared( location );
-                if ( distance <= radius )
-                {
-                    ( (CraftPlayer) player ).getHandle().playerConnection.sendPacket( packet );
-                }
-            }
-        }
-
-        @Override
-        public void playEffect( Location location, Effect effect )
-        {
-            CraftWorld.this.playEffect( location, effect, 0 );
-        }
-
-        @Override
-        public LightningStrike strikeLightning(Location loc, boolean isSilent)
-        {
-            EntityLightning lightning = new EntityLightning( world, loc.getX(), loc.getY(), loc.getZ(), false, isSilent );
-            world.strikeLightning( lightning );
-            return new CraftLightningStrike( server, lightning );
-        }
-
-        @Override
-        public LightningStrike strikeLightningEffect(Location loc, boolean isSilent)
-        {
-            EntityLightning lightning = new EntityLightning( world, loc.getX(), loc.getY(), loc.getZ(), true, isSilent );
-            world.strikeLightning( lightning );
-            return new CraftLightningStrike( server, lightning );
-        }
-    };
-
-    public Spigot spigot()
-    {
-        return spigot;
-    }
-    // Spigot end
-}
+package org.bukkit.craftbukkit;
+
+import com.google.common.base.Preconditions;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Iterator;
+import java.util.Random;
+import java.util.Set;
+import java.util.UUID;
+
+import net.minecraft.server.*;
+
+import org.apache.commons.lang.Validate;
+import org.bukkit.BlockChangeDelegate;
+import org.bukkit.Bukkit;
+import org.bukkit.Chunk;
+import org.bukkit.ChunkSnapshot;
+import org.bukkit.Difficulty;
+import org.bukkit.Effect;
+import org.bukkit.Location;
+import org.bukkit.Particle;
+import org.bukkit.Sound;
+import org.bukkit.TreeType;
+import org.bukkit.World;
+import org.bukkit.WorldBorder;
+import org.bukkit.block.Biome;
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockFace;
+import org.bukkit.block.BlockState;
+import org.bukkit.craftbukkit.block.CraftBlock;
+import org.bukkit.craftbukkit.block.CraftBlockState;
+import org.bukkit.craftbukkit.entity.*;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.craftbukkit.metadata.BlockMetadataStore;
+import org.bukkit.craftbukkit.potion.CraftPotionUtil;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.craftbukkit.util.LongHash;
+import org.bukkit.entity.*;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.minecart.CommandMinecart;
+import org.bukkit.entity.minecart.ExplosiveMinecart;
+import org.bukkit.entity.minecart.HopperMinecart;
+import org.bukkit.entity.minecart.PoweredMinecart;
+import org.bukkit.entity.minecart.SpawnerMinecart;
+import org.bukkit.entity.minecart.StorageMinecart;
+import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
+import org.bukkit.event.world.SpawnChangeEvent;
+import org.bukkit.generator.BlockPopulator;
+import org.bukkit.generator.ChunkGenerator;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.metadata.MetadataValue;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.messaging.StandardMessenger;
+import org.bukkit.potion.PotionData;
+import org.bukkit.potion.PotionType;
+import org.bukkit.util.Vector;
+
+public class CraftWorld implements World {
+    public static final int CUSTOM_DIMENSION_OFFSET = 10;
+
+    private final WorldServer world;
+    private WorldBorder worldBorder;
+    private Environment environment;
+    private final CraftServer server = (CraftServer) Bukkit.getServer();
+    private final ChunkGenerator generator;
+    private final List<BlockPopulator> populators = new ArrayList<BlockPopulator>();
+    private final BlockMetadataStore blockMetadata = new BlockMetadataStore(this);
+    private int monsterSpawn = -1;
+    private int animalSpawn = -1;
+    private int waterAnimalSpawn = -1;
+    private int ambientSpawn = -1;
+    private int chunkLoadCount = 0;
+    private int chunkGCTickCount;
+
+    private static final Random rand = new Random();
+
+    public CraftWorld(WorldServer world, ChunkGenerator gen, Environment env) {
+        this.world = world;
+        this.generator = gen;
+
+        environment = env;
+
+        if (server.chunkGCPeriod > 0) {
+            chunkGCTickCount = rand.nextInt(server.chunkGCPeriod);
+        }
+    }
+
+    public Block getBlockAt(int x, int y, int z) {
+        return getChunkAt(x >> 4, z >> 4).getBlock(x & 0xF, y, z & 0xF);
+    }
+
+    public int getBlockTypeIdAt(int x, int y, int z) {
+        return CraftMagicNumbers.getId(world.getType(new BlockPosition(x, y, z)).getBlock());
+    }
+
+    public int getHighestBlockYAt(int x, int z) {
+        if (!isChunkLoaded(x >> 4, z >> 4)) {
+            loadChunk(x >> 4, z >> 4);
+        }
+
+        return world.getHighestBlockYAt(new BlockPosition(x, 0, z)).getY();
+    }
+
+    public Location getSpawnLocation() {
+        BlockPosition spawn = world.getSpawn();
+        return new Location(this, spawn.getX(), spawn.getY(), spawn.getZ());
+    }
+
+    public boolean setSpawnLocation(int x, int y, int z) {
+        try {
+            Location previousLocation = getSpawnLocation();
+            world.worldData.setSpawn(new BlockPosition(x, y, z));
+
+            // Notify anyone who's listening.
+            SpawnChangeEvent event = new SpawnChangeEvent(this, previousLocation);
+            server.getPluginManager().callEvent(event);
+
+            return true;
+        } catch (Exception e) {
+            return false;
+        }
+    }
+
+    public Chunk getChunkAt(int x, int z) {
+        return this.world.getChunkProviderServer().getChunkAt(x, z).bukkitChunk;
+    }
+
+    public Chunk getChunkAt(Block block) {
+        return getChunkAt(block.getX() >> 4, block.getZ() >> 4);
+    }
+
+    public boolean isChunkLoaded(int x, int z) {
+        return world.getChunkProviderServer().isLoaded(x, z);
+    }
+
+    public Chunk[] getLoadedChunks() {
+        Object[] chunks = world.getChunkProviderServer().chunks.values().toArray();
+        org.bukkit.Chunk[] craftChunks = new CraftChunk[chunks.length];
+
+        for (int i = 0; i < chunks.length; i++) {
+            net.minecraft.server.Chunk chunk = (net.minecraft.server.Chunk) chunks[i];
+            craftChunks[i] = chunk.bukkitChunk;
+        }
+
+        return craftChunks;
+    }
+
+    public void loadChunk(int x, int z) {
+        loadChunk(x, z, true);
+    }
+
+    public boolean unloadChunk(Chunk chunk) {
+        return unloadChunk(chunk.getX(), chunk.getZ());
+    }
+
+    public boolean unloadChunk(int x, int z) {
+        return unloadChunk(x, z, true);
+    }
+
+    public boolean unloadChunk(int x, int z, boolean save) {
+        return unloadChunk(x, z, save, false);
+    }
+
+    public boolean unloadChunkRequest(int x, int z) {
+        return unloadChunkRequest(x, z, true);
+    }
+
+    public boolean unloadChunkRequest(int x, int z, boolean safe) {
+        org.spigotmc.AsyncCatcher.catchOp( "chunk unload"); // Spigot
+        if (safe && isChunkInUse(x, z)) {
+            return false;
+        }
+
+        net.minecraft.server.Chunk chunk = world.getChunkProviderServer().getLoadedChunkAt(x, z);
+        if (chunk != null) {
+            world.getChunkProviderServer().unload(chunk);
+        }
+
+        return true;
+    }
+
+    public boolean unloadChunk(int x, int z, boolean save, boolean safe) {
+        org.spigotmc.AsyncCatcher.catchOp( "chunk unload"); // Spigot
+        if (isChunkInUse(x, z)) {
+            return false;
+        }
+
+        return unloadChunk0(x, z, save);
+    }
+
+    private boolean unloadChunk0(int x, int z, boolean save) {
+        net.minecraft.server.Chunk chunk = world.getChunkProviderServer().getChunkIfLoaded(x, z);
+        if (chunk == null) {
+            return true;
+        }
+
+        // If chunk had previously been queued to save, must do save to avoid loss of that data
+        return world.getChunkProviderServer().unloadChunk(chunk, chunk.mustSave || save);
+    }
+
+    public boolean regenerateChunk(int x, int z) {
+        if (!unloadChunk0(x, z, false)) {
+            return false;
+        }
+
+        final long chunkKey = ChunkCoordIntPair.a(x, z);
+        world.getChunkProviderServer().unloadQueue.remove(chunkKey);
+
+        net.minecraft.server.Chunk chunk = null;
+
+        chunk = world.getChunkProviderServer().chunkGenerator.getOrCreateChunk(x, z);
+        PlayerChunk playerChunk = world.getPlayerChunkMap().getChunk(x, z);
+        if (playerChunk != null) {
+            playerChunk.chunk = chunk;
+        }
+
+        if (chunk != null) {
+            world.getChunkProviderServer().chunks.put(chunkKey, chunk);
+
+            chunk.addEntities();
+            chunk.loadNearby(world.getChunkProviderServer(), world.getChunkProviderServer().chunkGenerator, true);
+
+            refreshChunk(x, z);
+        }
+
+        return chunk != null;
+    }
+
+    public boolean refreshChunk(int x, int z) {
+        if (!isChunkLoaded(x, z)) {
+            return false;
+        }
+
+        int px = x << 4;
+        int pz = z << 4;
+
+        // If there are more than 64 updates to a chunk at once, it will update all 'touched' sections within the chunk
+        // And will include biome data if all sections have been 'touched'
+        // This flags 65 blocks distributed across all the sections of the chunk, so that everything is sent, including biomes
+        int height = getMaxHeight() / 16;
+        for (int idx = 0; idx < 64; idx++) {
+            world.notify(new BlockPosition(px + (idx / height), ((idx % height) * 16), pz), Blocks.AIR.getBlockData(), Blocks.STONE.getBlockData(), 3);
+        }
+        world.notify(new BlockPosition(px + 15, (height * 16) - 1, pz + 15), Blocks.AIR.getBlockData(), Blocks.STONE.getBlockData(), 3);
+
+        return true;
+    }
+
+    public boolean isChunkInUse(int x, int z) {
+        return world.getPlayerChunkMap().isChunkInUse(x, z);
+    }
+
+    public boolean loadChunk(int x, int z, boolean generate) {
+        org.spigotmc.AsyncCatcher.catchOp( "chunk load"); // Spigot
+        chunkLoadCount++;
+        if (generate) {
+            // Use the default variant of loadChunk when generate == true.
+            return world.getChunkProviderServer().getChunkAt(x, z) != null;
+        }
+
+        return world.getChunkProviderServer().getOrLoadChunkAt(x, z) != null;
+    }
+
+    public boolean isChunkLoaded(Chunk chunk) {
+        return isChunkLoaded(chunk.getX(), chunk.getZ());
+    }
+
+    public void loadChunk(Chunk chunk) {
+        loadChunk(chunk.getX(), chunk.getZ());
+        ((CraftChunk) getChunkAt(chunk.getX(), chunk.getZ())).getHandle().bukkitChunk = chunk;
+    }
+
+    public WorldServer getHandle() {
+        return world;
+    }
+
+    public org.bukkit.entity.Item dropItem(Location loc, ItemStack item) {
+        Validate.notNull(item, "Cannot drop a Null item.");
+        Validate.isTrue(item.getTypeId() != 0, "Cannot drop AIR.");
+        EntityItem entity = new EntityItem(world, loc.getX(), loc.getY(), loc.getZ(), CraftItemStack.asNMSCopy(item));
+        entity.pickupDelay = 10;
+        world.addEntity(entity, SpawnReason.CUSTOM);
+        // TODO this is inconsistent with how Entity.getBukkitEntity() works.
+        // However, this entity is not at the moment backed by a server entity class so it may be left.
+        return new CraftItem(world.getServer(), entity);
+    }
+
+    private static void randomLocationWithinBlock(Location loc, double xs, double ys, double zs) {
+        double prevX = loc.getX();
+        double prevY = loc.getY();
+        double prevZ = loc.getZ();
+        loc.add(xs, ys, zs);
+        if (loc.getX() < Math.floor(prevX)) {
+            loc.setX(Math.floor(prevX));
+        }
+        if (loc.getX() >= Math.ceil(prevX)) {
+            loc.setX(Math.ceil(prevX - 0.01));
+        }
+        if (loc.getY() < Math.floor(prevY)) {
+            loc.setY(Math.floor(prevY));
+        }
+        if (loc.getY() >= Math.ceil(prevY)) {
+            loc.setY(Math.ceil(prevY - 0.01));
+        }
+        if (loc.getZ() < Math.floor(prevZ)) {
+            loc.setZ(Math.floor(prevZ));
+        }
+        if (loc.getZ() >= Math.ceil(prevZ)) {
+            loc.setZ(Math.ceil(prevZ - 0.01));
+        }
+    }
+
+    public org.bukkit.entity.Item dropItemNaturally(Location loc, ItemStack item) {
+        double xs = world.random.nextFloat() * 0.7F - 0.35D;
+        double ys = world.random.nextFloat() * 0.7F - 0.35D;
+        double zs = world.random.nextFloat() * 0.7F - 0.35D;
+        loc = loc.clone();
+        // Makes sure the new item is created within the block the location points to.
+        // This prevents item spill in 1-block wide farms.
+        randomLocationWithinBlock(loc, xs, ys, zs);
+        return dropItem(loc, item);
+    }
+
+    public Arrow spawnArrow(Location loc, Vector velocity, float speed, float spread) {
+        return spawnArrow(loc, velocity, speed, spread, Arrow.class);
+    }
+
+    public <T extends Arrow> T spawnArrow(Location loc, Vector velocity, float speed, float spread, Class<T> clazz) {
+        Validate.notNull(loc, "Can not spawn arrow with a null location");
+        Validate.notNull(velocity, "Can not spawn arrow with a null velocity");
+        Validate.notNull(clazz, "Can not spawn an arrow with no class");
+
+        EntityArrow arrow;
+        if (TippedArrow.class.isAssignableFrom(clazz)) {
+            arrow = new EntityTippedArrow(world);
+            ((EntityTippedArrow) arrow).setType(CraftPotionUtil.fromBukkit(new PotionData(PotionType.WATER, false, false)));
+        } else if (SpectralArrow.class.isAssignableFrom(clazz)) {
+            arrow = new EntitySpectralArrow(world);
+        } else {
+            arrow = new EntityTippedArrow(world);
+        }
+
+        arrow.setPositionRotation(loc.getX(), loc.getY(), loc.getZ(), loc.getYaw(), loc.getPitch());
+        arrow.shoot(velocity.getX(), velocity.getY(), velocity.getZ(), speed, spread);
+        world.addEntity(arrow);
+        return (T) arrow.getBukkitEntity();
+    }
+
+    public Entity spawnEntity(Location loc, EntityType entityType) {
+        return spawn(loc, entityType.getEntityClass());
+    }
+
+    public LightningStrike strikeLightning(Location loc) {
+        EntityLightning lightning = new EntityLightning(world, loc.getX(), loc.getY(), loc.getZ(), false);
+        world.strikeLightning(lightning);
+        return new CraftLightningStrike(server, lightning);
+    }
+
+    public LightningStrike strikeLightningEffect(Location loc) {
+        EntityLightning lightning = new EntityLightning(world, loc.getX(), loc.getY(), loc.getZ(), true);
+        world.strikeLightning(lightning);
+        return new CraftLightningStrike(server, lightning);
+    }
+
+    public boolean generateTree(Location loc, TreeType type) {
+        BlockPosition pos = new BlockPosition(loc.getBlockX(), loc.getBlockY(), loc.getBlockZ());
+
+        net.minecraft.server.WorldGenerator gen;
+        switch (type) {
+        case BIG_TREE:
+            gen = new WorldGenBigTree(true);
+            break;
+        case BIRCH:
+            gen = new WorldGenForest(true, false);
+            break;
+        case REDWOOD:
+            gen = new WorldGenTaiga2(true);
+            break;
+        case TALL_REDWOOD:
+            gen = new WorldGenTaiga1();
+            break;
+        case JUNGLE:
+            IBlockData iblockdata1 = Blocks.LOG.getBlockData().set(BlockLog1.VARIANT, BlockWood.EnumLogVariant.JUNGLE);
+            IBlockData iblockdata2 = Blocks.LEAVES.getBlockData().set(BlockLeaves1.VARIANT, BlockWood.EnumLogVariant.JUNGLE).set(BlockLeaves.CHECK_DECAY, Boolean.valueOf(false));
+            gen = new WorldGenJungleTree(true, 10, 20, iblockdata1, iblockdata2); // Magic values as in BlockSapling
+            break;
+        case SMALL_JUNGLE:
+            iblockdata1 = Blocks.LOG.getBlockData().set(BlockLog1.VARIANT, BlockWood.EnumLogVariant.JUNGLE);
+            iblockdata2 = Blocks.LEAVES.getBlockData().set(BlockLeaves1.VARIANT, BlockWood.EnumLogVariant.JUNGLE).set(BlockLeaves.CHECK_DECAY, Boolean.valueOf(false));
+            gen = new WorldGenTrees(true, 4 + rand.nextInt(7), iblockdata1, iblockdata2, false);
+            break;
+        case COCOA_TREE:
+            iblockdata1 = Blocks.LOG.getBlockData().set(BlockLog1.VARIANT, BlockWood.EnumLogVariant.JUNGLE);
+            iblockdata2 = Blocks.LEAVES.getBlockData().set(BlockLeaves1.VARIANT, BlockWood.EnumLogVariant.JUNGLE).set(BlockLeaves.CHECK_DECAY, Boolean.valueOf(false));
+            gen = new WorldGenTrees(true, 4 + rand.nextInt(7), iblockdata1, iblockdata2, true);
+            break;
+        case JUNGLE_BUSH:
+            iblockdata1 = Blocks.LOG.getBlockData().set(BlockLog1.VARIANT, BlockWood.EnumLogVariant.JUNGLE);
+            iblockdata2 = Blocks.LEAVES.getBlockData().set(BlockLeaves1.VARIANT, BlockWood.EnumLogVariant.OAK).set(BlockLeaves.CHECK_DECAY, Boolean.valueOf(false));
+            gen = new WorldGenGroundBush(iblockdata1, iblockdata2);
+            break;
+        case RED_MUSHROOM:
+            gen = new WorldGenHugeMushroom(Blocks.RED_MUSHROOM_BLOCK);
+            break;
+        case BROWN_MUSHROOM:
+            gen = new WorldGenHugeMushroom(Blocks.BROWN_MUSHROOM_BLOCK);
+            break;
+        case SWAMP:
+            gen = new WorldGenSwampTree();
+            break;
+        case ACACIA:
+            gen = new WorldGenAcaciaTree(true);
+            break;
+        case DARK_OAK:
+            gen = new WorldGenForestTree(true);
+            break;
+        case MEGA_REDWOOD:
+            gen = new WorldGenMegaTree(false, rand.nextBoolean());
+            break;
+        case TALL_BIRCH:
+            gen = new WorldGenForest(true, true);
+            break;
+        case CHORUS_PLANT:
+            BlockChorusFlower.a(world, pos, rand, 8);
+            return true;
+        case TREE:
+        default:
+            gen = new WorldGenTrees(true);
+            break;
+        }
+
+        return gen.generate(world, rand, pos);
+    }
+
+    public boolean generateTree(Location loc, TreeType type, BlockChangeDelegate delegate) {
+        world.captureTreeGeneration = true;
+        world.captureBlockStates = true;
+        boolean grownTree = generateTree(loc, type);
+        world.captureBlockStates = false;
+        world.captureTreeGeneration = false;
+        if (grownTree) { // Copy block data to delegate
+            for (BlockState blockstate : world.capturedBlockStates) {
+                int x = blockstate.getX();
+                int y = blockstate.getY();
+                int z = blockstate.getZ();
+                BlockPosition position = new BlockPosition(x, y, z);
+                net.minecraft.server.IBlockData oldBlock = world.getType(position);
+                int typeId = blockstate.getTypeId();
+                int data = blockstate.getRawData();
+                int flag = ((CraftBlockState)blockstate).getFlag();
+                delegate.setTypeIdAndData(x, y, z, typeId, data);
+                net.minecraft.server.IBlockData newBlock = world.getType(position);
+                world.notifyAndUpdatePhysics(position, null, oldBlock, newBlock, flag);
+            }
+            world.capturedBlockStates.clear();
+            return true;
+        } else {
+            world.capturedBlockStates.clear();
+            return false;
+        }
+    }
+
+    public TileEntity getTileEntityAt(final int x, final int y, final int z) {
+        return world.getTileEntity(new BlockPosition(x, y, z));
+    }
+
+    public String getName() {
+        return world.worldData.getName();
+    }
+
+    @Deprecated
+    public long getId() {
+        return world.worldData.getSeed();
+    }
+
+    public UUID getUID() {
+        return world.getDataManager().getUUID();
+    }
+
+    @Override
+    public String toString() {
+        return "CraftWorld{name=" + getName() + '}';
+    }
+
+    public long getTime() {
+        long time = getFullTime() % 24000;
+        if (time < 0) time += 24000;
+        return time;
+    }
+
+    public void setTime(long time) {
+        long margin = (time - getFullTime()) % 24000;
+        if (margin < 0) margin += 24000;
+        setFullTime(getFullTime() + margin);
+    }
+
+    public long getFullTime() {
+        return world.getDayTime();
+    }
+
+    public void setFullTime(long time) {
+        world.setDayTime(time);
+
+        // Forces the client to update to the new time immediately
+        for (Player p : getPlayers()) {
+            CraftPlayer cp = (CraftPlayer) p;
+            if (cp.getHandle().playerConnection == null) continue;
+
+            cp.getHandle().playerConnection.sendPacket(new PacketPlayOutUpdateTime(cp.getHandle().world.getTime(), cp.getHandle().getPlayerTime(), cp.getHandle().world.getGameRules().getBoolean("doDaylightCycle")));
+        }
+    }
+
+    public boolean createExplosion(double x, double y, double z, float power) {
+        return createExplosion(x, y, z, power, false, true);
+    }
+
+    public boolean createExplosion(double x, double y, double z, float power, boolean setFire) {
+        return createExplosion(x, y, z, power, setFire, true);
+    }
+
+    public boolean createExplosion(double x, double y, double z, float power, boolean setFire, boolean breakBlocks) {
+        return !world.createExplosion(null, x, y, z, power, setFire, breakBlocks).wasCanceled;
+    }
+
+    public boolean createExplosion(Location loc, float power) {
+        return createExplosion(loc, power, false);
+    }
+
+    public boolean createExplosion(Location loc, float power, boolean setFire) {
+        return createExplosion(loc.getX(), loc.getY(), loc.getZ(), power, setFire);
+    }
+
+    public Environment getEnvironment() {
+        return environment;
+    }
+
+    public void setEnvironment(Environment env) {
+        if (environment != env) {
+            environment = env;
+            switch (env) {
+                case NORMAL:
+                    world.worldProvider = new WorldProviderNormal();
+                    break;
+                case NETHER:
+                    world.worldProvider = new WorldProviderHell();
+                    break;
+                case THE_END:
+                    world.worldProvider = new WorldProviderTheEnd();
+                    break;
+            }
+        }
+    }
+
+    public Block getBlockAt(Location location) {
+        return getBlockAt(location.getBlockX(), location.getBlockY(), location.getBlockZ());
+    }
+
+    public int getBlockTypeIdAt(Location location) {
+        return getBlockTypeIdAt(location.getBlockX(), location.getBlockY(), location.getBlockZ());
+    }
+
+    public int getHighestBlockYAt(Location location) {
+        return getHighestBlockYAt(location.getBlockX(), location.getBlockZ());
+    }
+
+    public Chunk getChunkAt(Location location) {
+        return getChunkAt(location.getBlockX() >> 4, location.getBlockZ() >> 4);
+    }
+
+    public ChunkGenerator getGenerator() {
+        return generator;
+    }
+
+    public List<BlockPopulator> getPopulators() {
+        return populators;
+    }
+
+    public Block getHighestBlockAt(int x, int z) {
+        return getBlockAt(x, getHighestBlockYAt(x, z), z);
+    }
+
+    public Block getHighestBlockAt(Location location) {
+        return getHighestBlockAt(location.getBlockX(), location.getBlockZ());
+    }
+
+    public Biome getBiome(int x, int z) {
+        return CraftBlock.biomeBaseToBiome(this.world.getBiome(new BlockPosition(x, 0, z)));
+    }
+
+    public void setBiome(int x, int z, Biome bio) {
+        BiomeBase bb = CraftBlock.biomeToBiomeBase(bio);
+        if (this.world.isLoaded(new BlockPosition(x, 0, z))) {
+            net.minecraft.server.Chunk chunk = this.world.getChunkAtWorldCoords(new BlockPosition(x, 0, z));
+
+            if (chunk != null) {
+                byte[] biomevals = chunk.getBiomeIndex();
+                biomevals[((z & 0xF) << 4) | (x & 0xF)] = (byte) BiomeBase.REGISTRY_ID.a(bb);
+            }
+        }
+    }
+
+    public double getTemperature(int x, int z) {
+        return this.world.getBiome(new BlockPosition(x, 0, z)).getTemperature();
+    }
+
+    public double getHumidity(int x, int z) {
+        return this.world.getBiome(new BlockPosition(x, 0, z)).getHumidity();
+    }
+
+    public List<Entity> getEntities() {
+        List<Entity> list = new ArrayList<Entity>();
+        world.entityList = new ArrayList(world.entityQueue);
+        for (Object o : world.entityList) {
+            if (o instanceof net.minecraft.server.Entity) {
+                net.minecraft.server.Entity mcEnt = (net.minecraft.server.Entity) o;
+                Entity bukkitEntity = mcEnt.getBukkitEntity();
+
+                // Assuming that bukkitEntity isn't null
+                if (bukkitEntity != null) {
+                    list.add(bukkitEntity);
+                }
+            }
+        }
+
+        return list;
+    }
+
+    public List<LivingEntity> getLivingEntities() {
+        List<LivingEntity> list = new ArrayList<LivingEntity>();
+        world.entityList = new ArrayList(world.entityQueue);
+        for (Object o : world.entityList) {
+            if (o instanceof net.minecraft.server.Entity) {
+                net.minecraft.server.Entity mcEnt = (net.minecraft.server.Entity) o;
+                Entity bukkitEntity = mcEnt.getBukkitEntity();
+
+                // Assuming that bukkitEntity isn't null
+                if (bukkitEntity != null && bukkitEntity instanceof LivingEntity) {
+                    list.add((LivingEntity) bukkitEntity);
+                }
+            }
+        }
+
+        return list;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Deprecated
+    public <T extends Entity> Collection<T> getEntitiesByClass(Class<T>... classes) {
+        return (Collection<T>)getEntitiesByClasses(classes);
+    }
+
+    @SuppressWarnings("unchecked")
+    public <T extends Entity> Collection<T> getEntitiesByClass(Class<T> clazz) {
+        Collection<T> list = new ArrayList<T>();
+        world.entityList = new ArrayList(world.entityQueue);
+        for (Object entity: world.entityList) {
+            if (entity instanceof net.minecraft.server.Entity) {
+                Entity bukkitEntity = ((net.minecraft.server.Entity) entity).getBukkitEntity();
+
+                if (bukkitEntity == null) {
+                    continue;
+                }
+
+                Class<?> bukkitClass = bukkitEntity.getClass();
+
+                if (clazz.isAssignableFrom(bukkitClass)) {
+                    list.add((T) bukkitEntity);
+                }
+            }
+        }
+
+        return list;
+    }
+
+    public Collection<Entity> getEntitiesByClasses(Class<?>... classes) {
+        Collection<Entity> list = new ArrayList<Entity>();
+        world.entityList = new ArrayList(world.entityQueue);
+        for (Object entity: world.entityList) {
+            if (entity instanceof net.minecraft.server.Entity) {
+                Entity bukkitEntity = ((net.minecraft.server.Entity) entity).getBukkitEntity();
+
+                if (bukkitEntity == null) {
+                    continue;
+                }
+
+                Class<?> bukkitClass = bukkitEntity.getClass();
+
+                for (Class<?> clazz : classes) {
+                    if (clazz.isAssignableFrom(bukkitClass)) {
+                        list.add(bukkitEntity);
+                        break;
+                    }
+                }
+            }
+        }
+
+        return list;
+    }
+
+    @Override
+    public Collection<Entity> getNearbyEntities(Location location, double x, double y, double z) {
+        if (location == null || !location.getWorld().equals(this)) {
+            return Collections.emptyList();
+        }
+
+        AxisAlignedBB bb = new AxisAlignedBB(location.getX() - x, location.getY() - y, location.getZ() - z, location.getX() + x, location.getY() + y, location.getZ() + z);
+        List<net.minecraft.server.Entity> entityList = getHandle().getEntities((net.minecraft.server.Entity) null, bb, null);
+        List<Entity> bukkitEntityList = new ArrayList<org.bukkit.entity.Entity>(entityList.size());
+        for (Object entity : entityList) {
+            bukkitEntityList.add(((net.minecraft.server.Entity) entity).getBukkitEntity());
+        }
+        return bukkitEntityList;
+    }
+
+    public List<Player> getPlayers() {
+        List<Player> list = new ArrayList<Player>(world.players.size());
+
+        for (EntityHuman human : world.players) {
+            HumanEntity bukkitEntity = human.getBukkitEntity();
+
+            if ((bukkitEntity != null) && (bukkitEntity instanceof Player)) {
+                list.add((Player) bukkitEntity);
+            }
+        }
+
+        return list;
+    }
+
+    public void save() {
+    // Spigot start
+        save(true);
+    }
+    public void save(boolean forceSave) {
+    // Spigot end
+        this.server.checkSaveState();
+        try {
+            boolean oldSave = world.savingDisabled;
+
+            world.savingDisabled = false;
+            world.save(forceSave, null); // Spigot
+
+            world.savingDisabled = oldSave;
+        } catch (ExceptionWorldConflict ex) {
+            ex.printStackTrace();
+        }
+    }
+
+    public boolean isAutoSave() {
+        return !world.savingDisabled;
+    }
+
+    public void setAutoSave(boolean value) {
+        world.savingDisabled = !value;
+    }
+
+    public void setDifficulty(Difficulty difficulty) {
+        this.getHandle().worldData.setDifficulty(EnumDifficulty.getById(difficulty.getValue()));
+    }
+
+    public Difficulty getDifficulty() {
+        return Difficulty.getByValue(this.getHandle().getDifficulty().ordinal());
+    }
+
+    public BlockMetadataStore getBlockMetadata() {
+        return blockMetadata;
+    }
+
+    public boolean hasStorm() {
+        return world.worldData.hasStorm();
+    }
+
+    public void setStorm(boolean hasStorm) {
+        world.worldData.setStorm(hasStorm);
+    }
+
+    public int getWeatherDuration() {
+        return world.worldData.getWeatherDuration();
+    }
+
+    public void setWeatherDuration(int duration) {
+        world.worldData.setWeatherDuration(duration);
+    }
+
+    public boolean isThundering() {
+        return world.worldData.isThundering();
+    }
+
+    public void setThundering(boolean thundering) {
+        world.worldData.setThundering(thundering);
+    }
+
+    public int getThunderDuration() {
+        return world.worldData.getThunderDuration();
+    }
+
+    public void setThunderDuration(int duration) {
+        world.worldData.setThunderDuration(duration);
+    }
+
+    public long getSeed() {
+        return world.worldData.getSeed();
+    }
+
+    public boolean getPVP() {
+        return world.pvpMode;
+    }
+
+    public void setPVP(boolean pvp) {
+        world.pvpMode = pvp;
+    }
+
+    public void playEffect(Player player, Effect effect, int data) {
+        playEffect(player.getLocation(), effect, data, 0);
+    }
+
+    public void playEffect(Location location, Effect effect, int data) {
+        playEffect(location, effect, data, 64);
+    }
+
+    public <T> void playEffect(Location loc, Effect effect, T data) {
+        playEffect(loc, effect, data, 64);
+    }
+
+    public <T> void playEffect(Location loc, Effect effect, T data, int radius) {
+        if (data != null) {
+            Validate.isTrue(effect.getData() != null && effect.getData().isAssignableFrom(data.getClass()), "Wrong kind of data for this effect!");
+        } else {
+            Validate.isTrue(effect.getData() == null, "Wrong kind of data for this effect!");
+        }
+
+        if (data != null && data.getClass().equals( org.bukkit.material.MaterialData.class )) {
+            org.bukkit.material.MaterialData materialData = (org.bukkit.material.MaterialData) data;
+            Validate.isTrue( materialData.getItemType().isBlock(), "Material must be block" );
+            spigot().playEffect( loc, effect, materialData.getItemType().getId(), materialData.getData(), 0, 0, 0, 1, 1, radius );
+        } else {
+            int dataValue = data == null ? 0 : CraftEffect.getDataValue( effect, data );
+            playEffect( loc, effect, dataValue, radius );
+        }
+    }
+
+    public void playEffect(Location location, Effect effect, int data, int radius) {
+        spigot().playEffect( location, effect, data, 0, 0, 0, 0, 1, 1, radius );
+    }
+
+    public <T extends Entity> T spawn(Location location, Class<T> clazz) throws IllegalArgumentException {
+        return spawn(location, clazz, SpawnReason.CUSTOM);
+    }
+
+    public FallingBlock spawnFallingBlock(Location location, org.bukkit.Material material, byte data) throws IllegalArgumentException {
+        Validate.notNull(location, "Location cannot be null");
+        Validate.notNull(material, "Material cannot be null");
+        Validate.isTrue(material.isBlock(), "Material must be a block");
+
+        EntityFallingBlock entity = new EntityFallingBlock(world, location.getX(), location.getY(), location.getZ(), CraftMagicNumbers.getBlock(material).fromLegacyData(data));
+        entity.ticksLived = 1;
+
+        world.addEntity(entity, SpawnReason.CUSTOM);
+        return (FallingBlock) entity.getBukkitEntity();
+    }
+
+    public FallingBlock spawnFallingBlock(Location location, int blockId, byte blockData) throws IllegalArgumentException {
+        return spawnFallingBlock(location, org.bukkit.Material.getMaterial(blockId), blockData);
+    }
+
+    @SuppressWarnings("unchecked")
+    public net.minecraft.server.Entity createEntity(Location location, Class<? extends Entity> clazz) throws IllegalArgumentException {
+        if (location == null || clazz == null) {
+            throw new IllegalArgumentException("Location or entity class cannot be null");
+        }
+
+        net.minecraft.server.Entity entity = null;
+
+        double x = location.getX();
+        double y = location.getY();
+        double z = location.getZ();
+        float pitch = location.getPitch();
+        float yaw = location.getYaw();
+
+        // order is important for some of these
+        if (Boat.class.isAssignableFrom(clazz)) {
+            entity = new EntityBoat(world, x, y, z);
+        } else if (FallingBlock.class.isAssignableFrom(clazz)) {
+            entity = new EntityFallingBlock(world, x, y, z, world.getType(new BlockPosition(x, y, z)));
+        } else if (Projectile.class.isAssignableFrom(clazz)) {
+            if (Snowball.class.isAssignableFrom(clazz)) {
+                entity = new EntitySnowball(world, x, y, z);
+            } else if (Egg.class.isAssignableFrom(clazz)) {
+                entity = new EntityEgg(world, x, y, z);
+            } else if (Arrow.class.isAssignableFrom(clazz)) {
+                if (TippedArrow.class.isAssignableFrom(clazz)) {
+                    entity = new EntityTippedArrow(world);
+                    ((EntityTippedArrow) entity).setType(CraftPotionUtil.fromBukkit(new PotionData(PotionType.WATER, false, false)));
+                } else if (SpectralArrow.class.isAssignableFrom(clazz)) {
+                    entity = new EntitySpectralArrow(world);
+                } else {
+                    entity = new EntityTippedArrow(world);
+                }
+                entity.setPositionRotation(x, y, z, 0, 0);
+            } else if (ThrownExpBottle.class.isAssignableFrom(clazz)) {
+                entity = new EntityThrownExpBottle(world);
+                entity.setPositionRotation(x, y, z, 0, 0);
+            } else if (EnderPearl.class.isAssignableFrom(clazz)) {
+                entity = new EntityEnderPearl(world);
+                entity.setPositionRotation(x, y, z, 0, 0);
+            } else if (ThrownPotion.class.isAssignableFrom(clazz)) {
+                if (LingeringPotion.class.isAssignableFrom(clazz)) {
+                    entity = new EntityPotion(world, x, y, z, CraftItemStack.asNMSCopy(new ItemStack(org.bukkit.Material.LINGERING_POTION, 1)));
+                } else {
+                    entity = new EntityPotion(world, x, y, z, CraftItemStack.asNMSCopy(new ItemStack(org.bukkit.Material.SPLASH_POTION, 1)));
+                }
+            } else if (Fireball.class.isAssignableFrom(clazz)) {
+                if (SmallFireball.class.isAssignableFrom(clazz)) {
+                    entity = new EntitySmallFireball(world);
+                } else if (WitherSkull.class.isAssignableFrom(clazz)) {
+                    entity = new EntityWitherSkull(world);
+                } else if (DragonFireball.class.isAssignableFrom(clazz)) {
+                    entity = new EntityDragonFireball(world);
+                } else {
+                    entity = new EntityLargeFireball(world);
+                }
+                entity.setPositionRotation(x, y, z, yaw, pitch);
+                Vector direction = location.getDirection().multiply(10);
+                ((EntityFireball) entity).setDirection(direction.getX(), direction.getY(), direction.getZ());
+            } else if (ShulkerBullet.class.isAssignableFrom(clazz)) {
+                entity = new EntityShulkerBullet(world);
+                entity.setPositionRotation(x, y, z, yaw, pitch);
+            }
+        } else if (Minecart.class.isAssignableFrom(clazz)) {
+            if (PoweredMinecart.class.isAssignableFrom(clazz)) {
+                entity = new EntityMinecartFurnace(world, x, y, z);
+            } else if (StorageMinecart.class.isAssignableFrom(clazz)) {
+                entity = new EntityMinecartChest(world, x, y, z);
+            } else if (ExplosiveMinecart.class.isAssignableFrom(clazz)) {
+                entity = new EntityMinecartTNT(world, x, y, z);
+            } else if (HopperMinecart.class.isAssignableFrom(clazz)) {
+                entity = new EntityMinecartHopper(world, x, y, z);
+            } else if (SpawnerMinecart.class.isAssignableFrom(clazz)) {
+                entity = new EntityMinecartMobSpawner(world, x, y, z);
+            } else if (CommandMinecart.class.isAssignableFrom(clazz)) {
+                entity = new EntityMinecartCommandBlock(world, x, y, z);
+            } else { // Default to rideable minecart for pre-rideable compatibility
+                entity = new EntityMinecartRideable(world, x, y, z);
+            }
+        } else if (EnderSignal.class.isAssignableFrom(clazz)) {
+            entity = new EntityEnderSignal(world, x, y, z);
+        } else if (EnderCrystal.class.isAssignableFrom(clazz)) {
+            entity = new EntityEnderCrystal(world);
+            entity.setPositionRotation(x, y, z, 0, 0);
+        } else if (LivingEntity.class.isAssignableFrom(clazz)) {
+            if (Chicken.class.isAssignableFrom(clazz)) {
+                entity = new EntityChicken(world);
+            } else if (Cow.class.isAssignableFrom(clazz)) {
+                if (MushroomCow.class.isAssignableFrom(clazz)) {
+                    entity = new EntityMushroomCow(world);
+                } else {
+                    entity = new EntityCow(world);
+                }
+            } else if (Golem.class.isAssignableFrom(clazz)) {
+                if (Snowman.class.isAssignableFrom(clazz)) {
+                    entity = new EntitySnowman(world);
+                } else if (IronGolem.class.isAssignableFrom(clazz)) {
+                    entity = new EntityIronGolem(world);
+                } else if (Shulker.class.isAssignableFrom(clazz)) {
+                    entity = new EntityShulker(world);
+                }
+            } else if (Creeper.class.isAssignableFrom(clazz)) {
+                entity = new EntityCreeper(world);
+            } else if (Ghast.class.isAssignableFrom(clazz)) {
+                entity = new EntityGhast(world);
+            } else if (Pig.class.isAssignableFrom(clazz)) {
+                entity = new EntityPig(world);
+            } else if (Player.class.isAssignableFrom(clazz)) {
+                // need a net server handler for this one
+            } else if (Sheep.class.isAssignableFrom(clazz)) {
+                entity = new EntitySheep(world);
+            } else if (Horse.class.isAssignableFrom(clazz)) {
+                entity = new EntityHorse(world);
+            } else if (Skeleton.class.isAssignableFrom(clazz)) {
+                entity = new EntitySkeleton(world);
+            } else if (Slime.class.isAssignableFrom(clazz)) {
+                if (MagmaCube.class.isAssignableFrom(clazz)) {
+                    entity = new EntityMagmaCube(world);
+                } else {
+                    entity = new EntitySlime(world);
+                }
+            } else if (Spider.class.isAssignableFrom(clazz)) {
+                if (CaveSpider.class.isAssignableFrom(clazz)) {
+                    entity = new EntityCaveSpider(world);
+                } else {
+                    entity = new EntitySpider(world);
+                }
+            } else if (Squid.class.isAssignableFrom(clazz)) {
+                entity = new EntitySquid(world);
+            } else if (Tameable.class.isAssignableFrom(clazz)) {
+                if (Wolf.class.isAssignableFrom(clazz)) {
+                    entity = new EntityWolf(world);
+                } else if (Ocelot.class.isAssignableFrom(clazz)) {
+                    entity = new EntityOcelot(world);
+                }
+            } else if (PigZombie.class.isAssignableFrom(clazz)) {
+                entity = new EntityPigZombie(world);
+            } else if (Zombie.class.isAssignableFrom(clazz)) {
+                entity = new EntityZombie(world);
+            } else if (Giant.class.isAssignableFrom(clazz)) {
+                entity = new EntityGiantZombie(world);
+            } else if (Silverfish.class.isAssignableFrom(clazz)) {
+                entity = new EntitySilverfish(world);
+            } else if (Enderman.class.isAssignableFrom(clazz)) {
+                entity = new EntityEnderman(world);
+            } else if (Blaze.class.isAssignableFrom(clazz)) {
+                entity = new EntityBlaze(world);
+            } else if (Villager.class.isAssignableFrom(clazz)) {
+                entity = new EntityVillager(world);
+            } else if (Witch.class.isAssignableFrom(clazz)) {
+                entity = new EntityWitch(world);
+            } else if (Wither.class.isAssignableFrom(clazz)) {
+                entity = new EntityWither(world);
+            } else if (ComplexLivingEntity.class.isAssignableFrom(clazz)) {
+                if (EnderDragon.class.isAssignableFrom(clazz)) {
+                    entity = new EntityEnderDragon(world);
+                }
+            } else if (Ambient.class.isAssignableFrom(clazz)) {
+                if (Bat.class.isAssignableFrom(clazz)) {
+                    entity = new EntityBat(world);
+                }
+            } else if (Rabbit.class.isAssignableFrom(clazz)) {
+                entity = new EntityRabbit(world);
+            } else if (Endermite.class.isAssignableFrom(clazz)) {
+                entity = new EntityEndermite(world);
+            } else if (Guardian.class.isAssignableFrom(clazz)) {
+                entity = new EntityGuardian(world);
+            } else if (ArmorStand.class.isAssignableFrom(clazz)) {
+                entity = new EntityArmorStand(world, x, y, z);
+            } else if (PolarBear.class.isAssignableFrom(clazz)) {
+                entity = new EntityPolarBear(world);
+            }
+
+            if (entity != null) {
+                entity.setLocation(x, y, z, yaw, pitch);
+            }
+        } else if (Hanging.class.isAssignableFrom(clazz)) {
+            Block block = getBlockAt(location);
+            BlockFace face = BlockFace.SELF;
+
+            int width = 16; // 1 full block, also painting smallest size.
+            int height = 16; // 1 full block, also painting smallest size.
+
+            if (ItemFrame.class.isAssignableFrom(clazz)) {
+                width = 12;
+                height = 12;
+            } else if (LeashHitch.class.isAssignableFrom(clazz)) {
+                width = 9;
+                height = 9;
+            }
+
+            BlockFace[] faces = new BlockFace[]{BlockFace.EAST, BlockFace.NORTH, BlockFace.WEST, BlockFace.SOUTH};
+            final BlockPosition pos = new BlockPosition((int) x, (int) y, (int) z);
+            for (BlockFace dir : faces) {
+                net.minecraft.server.Block nmsBlock = CraftMagicNumbers.getBlock(block.getRelative(dir));
+                if (nmsBlock.getBlockData().getMaterial().isBuildable() || BlockDiodeAbstract.isDiode(nmsBlock.getBlockData())) {
+                    boolean taken = false;
+                    AxisAlignedBB bb = EntityHanging.calculateBoundingBox(null, pos, CraftBlock.blockFaceToNotch(dir).opposite(), width, height);
+                    List<net.minecraft.server.Entity> list = (List<net.minecraft.server.Entity>) world.getEntities(null, bb);
+                    for (Iterator<net.minecraft.server.Entity> it = list.iterator(); !taken && it.hasNext();) {
+                        net.minecraft.server.Entity e = it.next();
+                        if (e instanceof EntityHanging) {
+                            taken = true; // Hanging entities do not like hanging entities which intersect them.
+                        }
+                    }
+
+                    if (!taken) {
+                        face = dir;
+                        break;
+                    }
+                }
+            }
+
+            if (LeashHitch.class.isAssignableFrom(clazz)) {
+                entity = new EntityLeash(world, new BlockPosition((int) x, (int) y, (int) z));
+                entity.attachedToPlayer = true;
+            } else {
+                EnumDirection dir = CraftBlock.blockFaceToNotch(face).opposite();
+                if (Painting.class.isAssignableFrom(clazz)) {
+                    entity = new EntityPainting(world, new BlockPosition((int) x, (int) y, (int) z), dir);
+                } else if (ItemFrame.class.isAssignableFrom(clazz)) {
+                    entity = new EntityItemFrame(world, new BlockPosition((int) x, (int) y, (int) z), dir);
+                }
+            }
+
+            if (entity != null && !((EntityHanging) entity).survives()) {
+                throw new IllegalArgumentException("Cannot spawn hanging entity for " + clazz.getName() + " at " + location);
+            }
+        } else if (TNTPrimed.class.isAssignableFrom(clazz)) {
+            entity = new EntityTNTPrimed(world, x, y, z, null);
+        } else if (ExperienceOrb.class.isAssignableFrom(clazz)) {
+            entity = new EntityExperienceOrb(world, x, y, z, 0);
+        } else if (Weather.class.isAssignableFrom(clazz)) {
+            // not sure what this can do
+            if (LightningStrike.class.isAssignableFrom(clazz)) {
+                entity = new EntityLightning(world, x, y, z, false);
+                // what is this, I don't even
+            }
+        } else if (Firework.class.isAssignableFrom(clazz)) {
+            entity = new EntityFireworks(world, x, y, z, null);
+        } else if (AreaEffectCloud.class.isAssignableFrom(clazz)) {
+            entity = new EntityAreaEffectCloud(world, x, y, z);
+        }
+
+        if (entity != null) {
+            // Spigot start
+            if (entity instanceof EntityOcelot)
+            {
+                ( (EntityOcelot) entity ).spawnBonus = false;
+            }
+            // Spigot end
+            return entity;
+        }
+
+        throw new IllegalArgumentException("Cannot spawn an entity for " + clazz.getName());
+    }
+
+    @SuppressWarnings("unchecked")
+    public <T extends Entity> T addEntity(net.minecraft.server.Entity entity, SpawnReason reason) throws IllegalArgumentException {
+        Preconditions.checkArgument(entity != null, "Cannot spawn null entity");
+
+        if (entity instanceof EntityInsentient) {
+            ((EntityInsentient) entity).prepare(getHandle().D(new BlockPosition(entity)), (GroupDataEntity) null);
+        }
+
+        world.addEntity(entity, reason);
+        return (T) entity.getBukkitEntity();
+    }
+
+    public <T extends Entity> T spawn(Location location, Class<T> clazz, SpawnReason reason) throws IllegalArgumentException {
+        net.minecraft.server.Entity entity = createEntity(location, clazz);
+
+        return addEntity(entity, reason);
+    }
+
+    public ChunkSnapshot getEmptyChunkSnapshot(int x, int z, boolean includeBiome, boolean includeBiomeTempRain) {
+        return CraftChunk.getEmptyChunkSnapshot(x, z, this, includeBiome, includeBiomeTempRain);
+    }
+
+    public void setSpawnFlags(boolean allowMonsters, boolean allowAnimals) {
+        world.setSpawnFlags(allowMonsters, allowAnimals);
+    }
+
+    public boolean getAllowAnimals() {
+        return world.allowAnimals;
+    }
+
+    public boolean getAllowMonsters() {
+        return world.allowMonsters;
+    }
+
+    public int getMaxHeight() {
+        return world.getHeight();
+    }
+
+    public int getSeaLevel() {
+        return 64;
+    }
+
+    public boolean getKeepSpawnInMemory() {
+        return world.keepSpawnInMemory;
+    }
+
+    public void setKeepSpawnInMemory(boolean keepLoaded) {
+        world.keepSpawnInMemory = keepLoaded;
+        // Grab the worlds spawn chunk
+        BlockPosition chunkcoordinates = this.world.getSpawn();
+        int chunkCoordX = chunkcoordinates.getX() >> 4;
+        int chunkCoordZ = chunkcoordinates.getZ() >> 4;
+        // Cycle through the 25x25 Chunks around it to load/unload the chunks.
+        for (int x = -12; x <= 12; x++) {
+            for (int z = -12; z <= 12; z++) {
+                if (keepLoaded) {
+                    loadChunk(chunkCoordX + x, chunkCoordZ + z);
+                } else {
+                    if (isChunkLoaded(chunkCoordX + x, chunkCoordZ + z)) {
+                        unloadChunk(chunkCoordX + x, chunkCoordZ + z);
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    public int hashCode() {
+        return getUID().hashCode();
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+
+        final CraftWorld other = (CraftWorld) obj;
+
+        return this.getUID() == other.getUID();
+    }
+
+    public File getWorldFolder() {
+        return ((WorldNBTStorage) world.getDataManager()).getDirectory();
+    }
+
+    public void sendPluginMessage(Plugin source, String channel, byte[] message) {
+        StandardMessenger.validatePluginMessage(server.getMessenger(), source, channel, message);
+
+        for (Player player : getPlayers()) {
+            player.sendPluginMessage(source, channel, message);
+        }
+    }
+
+    public Set<String> getListeningPluginChannels() {
+        Set<String> result = new HashSet<String>();
+
+        for (Player player : getPlayers()) {
+            result.addAll(player.getListeningPluginChannels());
+        }
+
+        return result;
+    }
+
+    public org.bukkit.WorldType getWorldType() {
+        return org.bukkit.WorldType.getByName(world.getWorldData().getType().name());
+    }
+
+    public boolean canGenerateStructures() {
+        return world.getWorldData().shouldGenerateMapFeatures();
+    }
+
+    public long getTicksPerAnimalSpawns() {
+        return world.ticksPerAnimalSpawns;
+    }
+
+    public void setTicksPerAnimalSpawns(int ticksPerAnimalSpawns) {
+        world.ticksPerAnimalSpawns = ticksPerAnimalSpawns;
+    }
+
+    public long getTicksPerMonsterSpawns() {
+        return world.ticksPerMonsterSpawns;
+    }
+
+    public void setTicksPerMonsterSpawns(int ticksPerMonsterSpawns) {
+        world.ticksPerMonsterSpawns = ticksPerMonsterSpawns;
+    }
+
+    public void setMetadata(String metadataKey, MetadataValue newMetadataValue) {
+        server.getWorldMetadata().setMetadata(this, metadataKey, newMetadataValue);
+    }
+
+    public List<MetadataValue> getMetadata(String metadataKey) {
+        return server.getWorldMetadata().getMetadata(this, metadataKey);
+    }
+
+    public boolean hasMetadata(String metadataKey) {
+        return server.getWorldMetadata().hasMetadata(this, metadataKey);
+    }
+
+    public void removeMetadata(String metadataKey, Plugin owningPlugin) {
+        server.getWorldMetadata().removeMetadata(this, metadataKey, owningPlugin);
+    }
+
+    public int getMonsterSpawnLimit() {
+        if (monsterSpawn < 0) {
+            return server.getMonsterSpawnLimit();
+        }
+
+        return monsterSpawn;
+    }
+
+    public void setMonsterSpawnLimit(int limit) {
+        monsterSpawn = limit;
+    }
+
+    public int getAnimalSpawnLimit() {
+        if (animalSpawn < 0) {
+            return server.getAnimalSpawnLimit();
+        }
+
+        return animalSpawn;
+    }
+
+    public void setAnimalSpawnLimit(int limit) {
+        animalSpawn = limit;
+    }
+
+    public int getWaterAnimalSpawnLimit() {
+        if (waterAnimalSpawn < 0) {
+            return server.getWaterAnimalSpawnLimit();
+        }
+
+        return waterAnimalSpawn;
+    }
+
+    public void setWaterAnimalSpawnLimit(int limit) {
+        waterAnimalSpawn = limit;
+    }
+
+    public int getAmbientSpawnLimit() {
+        if (ambientSpawn < 0) {
+            return server.getAmbientSpawnLimit();
+        }
+
+        return ambientSpawn;
+    }
+
+    public void setAmbientSpawnLimit(int limit) {
+        ambientSpawn = limit;
+    }
+
+
+    public void playSound(Location loc, Sound sound, float volume, float pitch) {
+        if (loc == null || sound == null) return;
+
+        double x = loc.getX();
+        double y = loc.getY();
+        double z = loc.getZ();
+
+        getHandle().a(null, x, y, z, CraftSound.getSoundEffect(CraftSound.getSound(sound)), SoundCategory.MASTER, volume, pitch); // PAIL: rename
+    }
+
+    public void playSound(Location loc, String sound, float volume, float pitch) {
+        if (loc == null || sound == null) return;
+
+        double x = loc.getX();
+        double y = loc.getY();
+        double z = loc.getZ();
+
+        PacketPlayOutCustomSoundEffect packet = new PacketPlayOutCustomSoundEffect(sound, SoundCategory.MASTER, x, y, z, volume, pitch);
+        world.getMinecraftServer().getPlayerList().sendPacketNearby(null, x, y, z, volume > 1.0F ? 16.0F * volume : 16.0D, this.world.dimension, packet);
+    }
+
+    public String getGameRuleValue(String rule) {
+        return getHandle().getGameRules().get(rule);
+    }
+
+    public boolean setGameRuleValue(String rule, String value) {
+        // No null values allowed
+        if (rule == null || value == null) return false;
+
+        if (!isGameRule(rule)) return false;
+
+        getHandle().getGameRules().set(rule, value);
+        return true;
+    }
+
+    public String[] getGameRules() {
+        return getHandle().getGameRules().getGameRules();
+    }
+
+    public boolean isGameRule(String rule) {
+        return getHandle().getGameRules().contains(rule);
+    }
+
+    @Override
+    public WorldBorder getWorldBorder() {
+        if (this.worldBorder == null) {
+            this.worldBorder = new CraftWorldBorder(this);
+        }
+
+        return this.worldBorder;
+    }
+
+    @Override
+    public void spawnParticle(Particle particle, Location location, int count) {
+        spawnParticle(particle, location.getX(), location.getY(), location.getZ(), count);
+    }
+
+    @Override
+    public void spawnParticle(Particle particle, double x, double y, double z, int count) {
+        spawnParticle(particle, x, y, z, count, null);
+    }
+
+    @Override
+    public <T> void spawnParticle(Particle particle, Location location, int count, T data) {
+        spawnParticle(particle, location.getX(), location.getY(), location.getZ(), count, data);
+    }
+
+    @Override
+    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, T data) {
+        spawnParticle(particle, x, y, z, count, 0, 0, 0, data);
+    }
+
+    @Override
+    public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ) {
+        spawnParticle(particle, location.getX(), location.getY(), location.getZ(), count, offsetX, offsetY, offsetZ);
+    }
+
+    @Override
+    public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ) {
+        spawnParticle(particle, x, y, z, count, offsetX, offsetY, offsetZ, null);
+    }
+
+    @Override
+    public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, T data) {
+        spawnParticle(particle, location.getX(), location.getY(), location.getZ(), count, offsetX, offsetY, offsetZ, data);
+    }
+
+    @Override
+    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, T data) {
+        spawnParticle(particle, x, y, z, count, offsetX, offsetY, offsetZ, 1, data);
+    }
+
+    @Override
+    public void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra) {
+        spawnParticle(particle, location.getX(), location.getY(), location.getZ(), count, offsetX, offsetY, offsetZ, extra);
+    }
+
+    @Override
+    public void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra) {
+        spawnParticle(particle, x, y, z, count, offsetX, offsetY, offsetZ, extra, null);
+    }
+
+    @Override
+    public <T> void spawnParticle(Particle particle, Location location, int count, double offsetX, double offsetY, double offsetZ, double extra, T data) {
+        spawnParticle(particle, location.getX(), location.getY(), location.getZ(), count, offsetX, offsetY, offsetZ, extra, data);
+    }
+
+    @Override
+    public <T> void spawnParticle(Particle particle, double x, double y, double z, int count, double offsetX, double offsetY, double offsetZ, double extra, T data) {
+        if (data != null && !particle.getDataType().isInstance(data)) {
+            throw new IllegalArgumentException("data should be " + particle.getDataType() + " got " + data.getClass());
+        }
+        getHandle().sendParticles(
+                null, // Sender
+                CraftParticle.toNMS(particle), // Particle
+                true, // Extended range
+                x, y, z, // Position
+                count,  // Count
+                offsetX, offsetY, offsetZ, // Random offset
+                extra, // Speed?
+                CraftParticle.toData(particle, data)
+
+        );
+
+    }
+
+    public void processChunkGC() {
+        chunkGCTickCount++;
+
+        if (chunkLoadCount >= server.chunkGCLoadThresh && server.chunkGCLoadThresh > 0) {
+            chunkLoadCount = 0;
+        } else if (chunkGCTickCount >= server.chunkGCPeriod && server.chunkGCPeriod > 0) {
+            chunkGCTickCount = 0;
+        } else {
+            return;
+        }
+
+        ChunkProviderServer cps = world.getChunkProviderServer();
+        for (net.minecraft.server.Chunk chunk : cps.chunks.values()) {
+            // If in use, skip it
+            if (isChunkInUse(chunk.locX, chunk.locZ)) {
+                continue;
+            }
+
+            // Already unloading?
+            if (cps.unloadQueue.contains(ChunkCoordIntPair.a(chunk.locX, chunk.locZ))) {
+                continue;
+            }
+
+            // Add unload request
+            cps.unload(chunk);
+        }
+    }
+    // Spigot start
+    private final Spigot spigot = new Spigot()
+    {
+        @Override
+        public void playEffect( Location location, Effect effect, int id, int data, float offsetX, float offsetY, float offsetZ, float speed, int particleCount, int radius )
+        {
+            Validate.notNull( location, "Location cannot be null" );
+            Validate.notNull( effect, "Effect cannot be null" );
+            Validate.notNull( location.getWorld(), "World cannot be null" );
+            Packet packet;
+            if ( effect.getType() != Effect.Type.PARTICLE )
+            {
+                int packetData = effect.getId();
+                packet = new PacketPlayOutWorldEvent( packetData, new BlockPosition(location.getBlockX(), location.getBlockY(), location.getBlockZ() ), id, false );
+            } else
+            {
+                net.minecraft.server.EnumParticle particle = null;
+                int[] extra = null;
+                for ( net.minecraft.server.EnumParticle p : net.minecraft.server.EnumParticle.values() )
+                {
+                    if ( effect.getName().startsWith( p.b().replace("_", "") ) )
+                    {
+                        particle = p;
+                        if ( effect.getData() != null ) 
+                        {
+                            if ( effect.getData().equals( org.bukkit.Material.class ) )
+                            {
+                                extra = new int[]{ id };
+                            } else 
+                            {
+                                extra = new int[]{ (data << 12) | (id & 0xFFF) };
+                            }
+                        }
+                        break;
+                    }
+                }
+                if ( extra == null )
+                {
+                    extra = new int[0];
+                }
+                packet = new PacketPlayOutWorldParticles( particle, true, (float) location.getX(), (float) location.getY(), (float) location.getZ(), offsetX, offsetY, offsetZ, speed, particleCount, extra );
+            }
+            int distance;
+            radius *= radius;
+            for ( Player player : getPlayers() )
+            {
+                if ( ( (CraftPlayer) player ).getHandle().playerConnection == null )
+                {
+                    continue;
+                }
+                if ( !location.getWorld().equals( player.getWorld() ) )
+                {
+                    continue;
+                }
+                distance = (int) player.getLocation().distanceSquared( location );
+                if ( distance <= radius )
+                {
+                    ( (CraftPlayer) player ).getHandle().playerConnection.sendPacket( packet );
+                }
+            }
+        }
+
+        @Override
+        public void playEffect( Location location, Effect effect )
+        {
+            CraftWorld.this.playEffect( location, effect, 0 );
+        }
+
+        @Override
+        public LightningStrike strikeLightning(Location loc, boolean isSilent)
+        {
+            EntityLightning lightning = new EntityLightning( world, loc.getX(), loc.getY(), loc.getZ(), false, isSilent );
+            world.strikeLightning( lightning );
+            return new CraftLightningStrike( server, lightning );
+        }
+
+        @Override
+        public LightningStrike strikeLightningEffect(Location loc, boolean isSilent)
+        {
+            EntityLightning lightning = new EntityLightning( world, loc.getX(), loc.getY(), loc.getZ(), true, isSilent );
+            world.strikeLightning( lightning );
+            return new CraftLightningStrike( server, lightning );
+        }
+    };
+
+    public Spigot spigot()
+    {
+        return spigot;
+    }
+    // Spigot end
+}
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
--- src_origin/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java	2016-08-25 22:39:54.701602243 +0800
+++ src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java	2016-08-26 03:24:17.159198720 +0800
@@ -1,1038 +1,1039 @@
-package org.bukkit.craftbukkit.event;
-
-import java.net.InetAddress;
-import java.util.ArrayList;
-import java.util.EnumMap;
-import java.util.List;
-import java.util.Map;
-
-import com.google.common.base.Function;
-import com.google.common.base.Functions;
-
-import net.minecraft.server.*;
-
-import org.bukkit.Bukkit;
-import org.bukkit.Material;
-import org.bukkit.Server;
-import org.bukkit.Statistic.Type;
-import org.bukkit.block.Block;
-import org.bukkit.block.BlockFace;
-import org.bukkit.block.BlockState;
-import org.bukkit.craftbukkit.CraftServer;
-import org.bukkit.craftbukkit.CraftStatistic;
-import org.bukkit.craftbukkit.CraftWorld;
-import org.bukkit.craftbukkit.block.CraftBlock;
-import org.bukkit.craftbukkit.block.CraftBlockState;
-import org.bukkit.craftbukkit.entity.CraftEntity;
-import org.bukkit.craftbukkit.entity.CraftLivingEntity;
-import org.bukkit.craftbukkit.entity.CraftPlayer;
-import org.bukkit.craftbukkit.inventory.CraftInventoryCrafting;
-import org.bukkit.craftbukkit.inventory.CraftItemStack;
-import org.bukkit.craftbukkit.inventory.CraftMetaBook;
-import org.bukkit.craftbukkit.util.CraftDamageSource;
-import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.entity.AreaEffectCloud;
-import org.bukkit.entity.Arrow;
-import org.bukkit.entity.Creeper;
-import org.bukkit.entity.EntityType;
-import org.bukkit.entity.Firework;
-import org.bukkit.entity.Horse;
-import org.bukkit.entity.LightningStrike;
-import org.bukkit.entity.LivingEntity;
-import org.bukkit.entity.Pig;
-import org.bukkit.entity.PigZombie;
-import org.bukkit.entity.Player;
-import org.bukkit.entity.Projectile;
-import org.bukkit.entity.ThrownExpBottle;
-import org.bukkit.entity.ThrownPotion;
-import org.bukkit.event.Cancellable;
-import org.bukkit.event.Event;
-import org.bukkit.event.block.*;
-import org.bukkit.event.block.BlockIgniteEvent.IgniteCause;
-import org.bukkit.event.entity.*;
-import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
-import org.bukkit.event.entity.EntityDamageEvent.DamageCause;
-import org.bukkit.event.entity.EntityDamageEvent.DamageModifier;
-import org.bukkit.event.inventory.InventoryCloseEvent;
-import org.bukkit.event.inventory.InventoryOpenEvent;
-import org.bukkit.event.inventory.PrepareAnvilEvent;
-import org.bukkit.event.inventory.PrepareItemCraftEvent;
-import org.bukkit.event.player.*;
-import org.bukkit.event.server.ServerListPingEvent;
-import org.bukkit.inventory.EquipmentSlot;
-import org.bukkit.inventory.InventoryView;
-import org.bukkit.inventory.meta.BookMeta;
-
-public class CraftEventFactory {
-    public static final DamageSource MELTING = CraftDamageSource.copyOf(DamageSource.BURN);
-    public static final DamageSource POISON = CraftDamageSource.copyOf(DamageSource.MAGIC);
-    public static org.bukkit.block.Block blockDamage; // For use in EntityDamageByBlockEvent
-    public static Entity entityDamage; // For use in EntityDamageByEntityEvent
-
-    // helper methods
-    private static boolean canBuild(CraftWorld world, Player player, int x, int z) {
-        WorldServer worldServer = world.getHandle();
-        int spawnSize = Bukkit.getServer().getSpawnRadius();
-
-        if (world.getHandle().dimension != 0) return true;
-        if (spawnSize <= 0) return true;
-        if (((CraftServer) Bukkit.getServer()).getHandle().getOPs().isEmpty()) return true;
-        if (player.isOp()) return true;
-
-        BlockPosition chunkcoordinates = worldServer.getSpawn();
-
-        int distanceFromSpawn = Math.max(Math.abs(x - chunkcoordinates.getX()), Math.abs(z - chunkcoordinates.getY()));
-        return distanceFromSpawn > spawnSize;
-    }
-
-    public static <T extends Event> T callEvent(T event) {
-        Bukkit.getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    /**
-     * Block place methods
-     */
-    public static BlockMultiPlaceEvent callBlockMultiPlaceEvent(World world, EntityHuman who, EnumHand hand, List<BlockState> blockStates, int clickedX, int clickedY, int clickedZ) {
-        CraftWorld craftWorld = world.getWorld();
-        CraftServer craftServer = world.getServer();
-        Player player = (Player) who.getBukkitEntity();
-
-        Block blockClicked = craftWorld.getBlockAt(clickedX, clickedY, clickedZ);
-
-        boolean canBuild = true;
-        for (int i = 0; i < blockStates.size(); i++) {
-            if (!canBuild(craftWorld, player, blockStates.get(i).getX(), blockStates.get(i).getZ())) {
-                canBuild = false;
-                break;
-            }
-        }
-
-        org.bukkit.inventory.ItemStack item;
-        if (hand == EnumHand.MAIN_HAND) {
-            item = player.getInventory().getItemInMainHand();
-        } else {
-            item = player.getInventory().getItemInOffHand();
-        }
-
-        BlockMultiPlaceEvent event = new BlockMultiPlaceEvent(blockStates, blockClicked, item, player, canBuild);
-        craftServer.getPluginManager().callEvent(event);
-
-        return event;
-    }
-
-    public static BlockPlaceEvent callBlockPlaceEvent(World world, EntityHuman who, EnumHand hand, BlockState replacedBlockState, int clickedX, int clickedY, int clickedZ) {
-        CraftWorld craftWorld = world.getWorld();
-        CraftServer craftServer = world.getServer();
-
-        Player player = (Player) who.getBukkitEntity();
-
-        Block blockClicked = craftWorld.getBlockAt(clickedX, clickedY, clickedZ);
-        Block placedBlock = replacedBlockState.getBlock();
-
-        boolean canBuild = canBuild(craftWorld, player, placedBlock.getX(), placedBlock.getZ());
-
-        org.bukkit.inventory.ItemStack item;
-        EquipmentSlot equipmentSlot;
-        if (hand == EnumHand.MAIN_HAND) {
-            item = player.getInventory().getItemInMainHand();
-            equipmentSlot = EquipmentSlot.HAND;
-        } else {
-            item = player.getInventory().getItemInOffHand();
-            equipmentSlot = EquipmentSlot.OFF_HAND;
-        }
-
-        BlockPlaceEvent event = new BlockPlaceEvent(placedBlock, replacedBlockState, blockClicked, item, player, canBuild, equipmentSlot);
-        craftServer.getPluginManager().callEvent(event);
-
-        return event;
-    }
-
-    /**
-     * Bucket methods
-     */
-    public static PlayerBucketEmptyEvent callPlayerBucketEmptyEvent(EntityHuman who, int clickedX, int clickedY, int clickedZ, EnumDirection clickedFace, ItemStack itemInHand) {
-        return (PlayerBucketEmptyEvent) getPlayerBucketEvent(false, who, clickedX, clickedY, clickedZ, clickedFace, itemInHand, Items.BUCKET);
-    }
-
-    public static PlayerBucketFillEvent callPlayerBucketFillEvent(EntityHuman who, int clickedX, int clickedY, int clickedZ, EnumDirection clickedFace, ItemStack itemInHand, net.minecraft.server.Item bucket) {
-        return (PlayerBucketFillEvent) getPlayerBucketEvent(true, who, clickedX, clickedY, clickedZ, clickedFace, itemInHand, bucket);
-    }
-
-    private static PlayerEvent getPlayerBucketEvent(boolean isFilling, EntityHuman who, int clickedX, int clickedY, int clickedZ, EnumDirection clickedFace, ItemStack itemstack, net.minecraft.server.Item item) {
-        Player player = (who == null) ? null : (Player) who.getBukkitEntity();
-        CraftItemStack itemInHand = CraftItemStack.asNewCraftStack(item);
-        Material bucket = CraftMagicNumbers.getMaterial(itemstack.getItem());
-
-        CraftWorld craftWorld = (CraftWorld) player.getWorld();
-        CraftServer craftServer = (CraftServer) player.getServer();
-
-        Block blockClicked = craftWorld.getBlockAt(clickedX, clickedY, clickedZ);
-        BlockFace blockFace = CraftBlock.notchToBlockFace(clickedFace);
-
-        PlayerEvent event = null;
-        if (isFilling) {
-            event = new PlayerBucketFillEvent(player, blockClicked, blockFace, bucket, itemInHand);
-            ((PlayerBucketFillEvent) event).setCancelled(!canBuild(craftWorld, player, clickedX, clickedZ));
-        } else {
-            event = new PlayerBucketEmptyEvent(player, blockClicked, blockFace, bucket, itemInHand);
-            ((PlayerBucketEmptyEvent) event).setCancelled(!canBuild(craftWorld, player, clickedX, clickedZ));
-        }
-
-        craftServer.getPluginManager().callEvent(event);
-
-        return event;
-    }
-
-    /**
-     * Player Interact event
-     */
-    public static PlayerInteractEvent callPlayerInteractEvent(EntityHuman who, Action action, ItemStack itemstack, EnumHand hand) {
-        if (action != Action.LEFT_CLICK_AIR && action != Action.RIGHT_CLICK_AIR) {
-            throw new AssertionError(String.format("%s performing %s with %s", who, action, itemstack));
-        }
-        return callPlayerInteractEvent(who, action, null, EnumDirection.SOUTH, itemstack, hand);
-    }
-
-    public static PlayerInteractEvent callPlayerInteractEvent(EntityHuman who, Action action, BlockPosition position, EnumDirection direction, ItemStack itemstack, EnumHand hand) {
-        return callPlayerInteractEvent(who, action, position, direction, itemstack, false, hand);
-    }
-    
-    public static PlayerInteractEvent callPlayerInteractEvent(EntityHuman who, Action action, BlockPosition position, EnumDirection direction, ItemStack itemstack, boolean cancelledBlock, EnumHand hand) {
-        Player player = (who == null) ? null : (Player) who.getBukkitEntity();
-        CraftItemStack itemInHand = CraftItemStack.asCraftMirror(itemstack);
-
-        CraftWorld craftWorld = (CraftWorld) player.getWorld();
-        CraftServer craftServer = (CraftServer) player.getServer();
-
-        Block blockClicked = null;
-        if (position != null) {
-            blockClicked = craftWorld.getBlockAt(position.getX(), position.getY(), position.getZ());
-        } else {
-            switch (action) {
-                case LEFT_CLICK_BLOCK:
-                    action = Action.LEFT_CLICK_AIR;
-                    break;
-                case RIGHT_CLICK_BLOCK:
-                    action = Action.RIGHT_CLICK_AIR;
-                    break;
-            }
-        }
-        BlockFace blockFace = CraftBlock.notchToBlockFace(direction);
-
-        if (itemInHand.getType() == Material.AIR || itemInHand.getAmount() == 0) {
-            itemInHand = null;
-        }
-
-        PlayerInteractEvent event = new PlayerInteractEvent(player, action, itemInHand, blockClicked, blockFace, (hand == null) ? null : ((hand == EnumHand.OFF_HAND) ? EquipmentSlot.OFF_HAND : EquipmentSlot.HAND));
-        if (cancelledBlock) {
-            event.setUseInteractedBlock(Event.Result.DENY);
-        }
-        craftServer.getPluginManager().callEvent(event);
-
-        return event;
-    }
-
-    /**
-     * EntityShootBowEvent
-     */
-    public static EntityShootBowEvent callEntityShootBowEvent(EntityLiving who, ItemStack itemstack, EntityArrow entityArrow, float force) {
-        LivingEntity shooter = (LivingEntity) who.getBukkitEntity();
-        CraftItemStack itemInHand = CraftItemStack.asCraftMirror(itemstack);
-        Arrow arrow = (Arrow) entityArrow.getBukkitEntity();
-
-        if (itemInHand != null && (itemInHand.getType() == Material.AIR || itemInHand.getAmount() == 0)) {
-            itemInHand = null;
-        }
-
-        EntityShootBowEvent event = new EntityShootBowEvent(shooter, itemInHand, arrow, force);
-        Bukkit.getPluginManager().callEvent(event);
-
-        return event;
-    }
-
-    /**
-     * BlockDamageEvent
-     */
-    public static BlockDamageEvent callBlockDamageEvent(EntityHuman who, int x, int y, int z, ItemStack itemstack, boolean instaBreak) {
-        Player player = (who == null) ? null : (Player) who.getBukkitEntity();
-        CraftItemStack itemInHand = CraftItemStack.asCraftMirror(itemstack);
-
-        CraftWorld craftWorld = (CraftWorld) player.getWorld();
-        CraftServer craftServer = (CraftServer) player.getServer();
-
-        Block blockClicked = craftWorld.getBlockAt(x, y, z);
-
-        BlockDamageEvent event = new BlockDamageEvent(player, blockClicked, itemInHand, instaBreak);
-        craftServer.getPluginManager().callEvent(event);
-
-        return event;
-    }
-
-    /**
-     * CreatureSpawnEvent
-     */
-    public static CreatureSpawnEvent callCreatureSpawnEvent(EntityLiving entityliving, SpawnReason spawnReason) {
-        LivingEntity entity = (LivingEntity) entityliving.getBukkitEntity();
-        CraftServer craftServer = (CraftServer) entity.getServer();
-
-        CreatureSpawnEvent event = new CreatureSpawnEvent(entity, spawnReason);
-        craftServer.getPluginManager().callEvent(event);
-        return event;
-    }
-
-    /**
-     * EntityTameEvent
-     */
-    public static EntityTameEvent callEntityTameEvent(EntityInsentient entity, EntityHuman tamer) {
-        org.bukkit.entity.Entity bukkitEntity = entity.getBukkitEntity();
-        org.bukkit.entity.AnimalTamer bukkitTamer = (tamer != null ? tamer.getBukkitEntity() : null);
-        CraftServer craftServer = (CraftServer) bukkitEntity.getServer();
-
-        entity.persistent = true;
-
-        EntityTameEvent event = new EntityTameEvent((LivingEntity) bukkitEntity, bukkitTamer);
-        craftServer.getPluginManager().callEvent(event);
-        return event;
-    }
-
-    /**
-     * ItemSpawnEvent
-     */
-    public static ItemSpawnEvent callItemSpawnEvent(EntityItem entityitem) {
-        org.bukkit.entity.Item entity = (org.bukkit.entity.Item) entityitem.getBukkitEntity();
-        CraftServer craftServer = (CraftServer) entity.getServer();
-
-        ItemSpawnEvent event = new ItemSpawnEvent(entity, entity.getLocation());
-
-        craftServer.getPluginManager().callEvent(event);
-        return event;
-    }
-
-    /**
-     * ItemDespawnEvent
-     */
-    public static ItemDespawnEvent callItemDespawnEvent(EntityItem entityitem) {
-        org.bukkit.entity.Item entity = (org.bukkit.entity.Item) entityitem.getBukkitEntity();
-
-        ItemDespawnEvent event = new ItemDespawnEvent(entity, entity.getLocation());
-
-        entity.getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    /**
-     * ItemMergeEvent
-     */
-    public static ItemMergeEvent callItemMergeEvent(EntityItem merging, EntityItem mergingWith) {
-        org.bukkit.entity.Item entityMerging = (org.bukkit.entity.Item) merging.getBukkitEntity();
-        org.bukkit.entity.Item entityMergingWith = (org.bukkit.entity.Item) mergingWith.getBukkitEntity();
-
-        ItemMergeEvent event = new ItemMergeEvent(entityMerging, entityMergingWith);
-
-        Bukkit.getPluginManager().callEvent(event);
-        return event;
-    }
-
-    /**
-     * PotionSplashEvent
-     */
-    public static PotionSplashEvent callPotionSplashEvent(EntityPotion potion, Map<LivingEntity, Double> affectedEntities) {
-        ThrownPotion thrownPotion = (ThrownPotion) potion.getBukkitEntity();
-
-        PotionSplashEvent event = new PotionSplashEvent(thrownPotion, affectedEntities);
-        Bukkit.getPluginManager().callEvent(event);
-        return event;
-    }
-
-	public static LingeringPotionSplashEvent callLingeringPotionSplashEvent(EntityPotion potion, EntityAreaEffectCloud cloud) {
-        ThrownPotion thrownPotion = (ThrownPotion) potion.getBukkitEntity();
-        AreaEffectCloud effectCloud = (AreaEffectCloud) cloud.getBukkitEntity();
-
-        LingeringPotionSplashEvent event = new LingeringPotionSplashEvent(thrownPotion, effectCloud);
-        Bukkit.getPluginManager().callEvent(event);
-        return event;
-	}
-
-    /**
-     * BlockFadeEvent
-     */
-    public static BlockFadeEvent callBlockFadeEvent(Block block, net.minecraft.server.Block type) {
-        BlockState state = block.getState();
-        state.setTypeId(net.minecraft.server.Block.getId(type));
-
-        BlockFadeEvent event = new BlockFadeEvent(block, state);
-        Bukkit.getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static boolean handleBlockSpreadEvent(Block block, Block source, net.minecraft.server.Block type, int data) {
-        BlockState state = block.getState();
-        state.setTypeId(net.minecraft.server.Block.getId(type));
-        state.setRawData((byte) data);
-
-        BlockSpreadEvent event = new BlockSpreadEvent(block, source, state);
-        Bukkit.getPluginManager().callEvent(event);
-
-        if (!event.isCancelled()) {
-            state.update(true);
-        }
-        return !event.isCancelled();
-    }
-
-    public static EntityDeathEvent callEntityDeathEvent(EntityLiving victim) {
-        return callEntityDeathEvent(victim, new ArrayList<org.bukkit.inventory.ItemStack>(0));
-    }
-
-    public static EntityDeathEvent callEntityDeathEvent(EntityLiving victim, List<org.bukkit.inventory.ItemStack> drops) {
-        CraftLivingEntity entity = (CraftLivingEntity) victim.getBukkitEntity();
-        EntityDeathEvent event = new EntityDeathEvent(entity, drops, victim.getExpReward());
-        CraftWorld world = (CraftWorld) entity.getWorld();
-        Bukkit.getServer().getPluginManager().callEvent(event);
-
-        victim.expToDrop = event.getDroppedExp();
-
-        for (org.bukkit.inventory.ItemStack stack : event.getDrops()) {
-            if (stack == null || stack.getType() == Material.AIR || stack.getAmount() == 0) continue;
-
-            world.dropItemNaturally(entity.getLocation(), stack);
-        }
-
-        return event;
-    }
-
-    public static PlayerDeathEvent callPlayerDeathEvent(EntityPlayer victim, List<org.bukkit.inventory.ItemStack> drops, String deathMessage, boolean keepInventory) {
-        CraftPlayer entity = victim.getBukkitEntity();
-        PlayerDeathEvent event = new PlayerDeathEvent(entity, drops, victim.getExpReward(), 0, deathMessage);
-        event.setKeepInventory(keepInventory);
-        org.bukkit.World world = entity.getWorld();
-        Bukkit.getServer().getPluginManager().callEvent(event);
-
-        victim.keepLevel = event.getKeepLevel();
-        victim.newLevel = event.getNewLevel();
-        victim.newTotalExp = event.getNewTotalExp();
-        victim.expToDrop = event.getDroppedExp();
-        victim.newExp = event.getNewExp();
-
-        if (event.getKeepInventory()) {
-            return event;
-        }
-
-        for (org.bukkit.inventory.ItemStack stack : event.getDrops()) {
-            if (stack == null || stack.getType() == Material.AIR) continue;
-
-            world.dropItemNaturally(entity.getLocation(), stack);
-        }
-
-        return event;
-    }
-
-    /**
-     * Server methods
-     */
-    public static ServerListPingEvent callServerListPingEvent(Server craftServer, InetAddress address, String motd, int numPlayers, int maxPlayers) {
-        ServerListPingEvent event = new ServerListPingEvent(address, motd, numPlayers, maxPlayers);
-        craftServer.getPluginManager().callEvent(event);
-        return event;
-    }
-
-    private static EntityDamageEvent handleEntityDamageEvent(Entity entity, DamageSource source, Map<DamageModifier, Double> modifiers, Map<DamageModifier, Function<? super Double, Double>> modifierFunctions) {
-        if (source.isExplosion()) {
-            DamageCause damageCause;
-            Entity damager = entityDamage;
-            entityDamage = null;
-            EntityDamageEvent event;
-            if (damager == null) {
-                event = new EntityDamageByBlockEvent(null, entity.getBukkitEntity(), DamageCause.BLOCK_EXPLOSION, modifiers, modifierFunctions);
-            } else if (entity instanceof EntityEnderDragon && /*PAIL FIXME ((EntityEnderDragon) entity).target == damager*/ false) {
-                event = new EntityDamageEvent(entity.getBukkitEntity(), DamageCause.ENTITY_EXPLOSION, modifiers, modifierFunctions);
-            } else {
-                if (damager instanceof org.bukkit.entity.TNTPrimed) {
-                    damageCause = DamageCause.BLOCK_EXPLOSION;
-                } else {
-                    damageCause = DamageCause.ENTITY_EXPLOSION;
-                }
-                event = new EntityDamageByEntityEvent(damager.getBukkitEntity(), entity.getBukkitEntity(), damageCause, modifiers, modifierFunctions);
-            }
-
-            callEvent(event);
-
-            if (!event.isCancelled()) {
-                event.getEntity().setLastDamageCause(event);
-            }
-            return event;
-        } else if (source instanceof EntityDamageSource) {
-            Entity damager = source.getEntity();
-            DamageCause cause = DamageCause.ENTITY_ATTACK;
-
-            if (source instanceof EntityDamageSourceIndirect) {
-                damager = ((EntityDamageSourceIndirect) source).getProximateDamageSource();
-                if (damager.getBukkitEntity() instanceof ThrownPotion) {
-                    cause = DamageCause.MAGIC;
-                } else if (damager.getBukkitEntity() instanceof Projectile) {
-                    cause = DamageCause.PROJECTILE;
-                }
-            } else if ("thorns".equals(source.translationIndex)) {
-                cause = DamageCause.THORNS;
-            }
-
-            return callEntityDamageEvent(damager, entity, cause, modifiers, modifierFunctions);
-        } else if (source == DamageSource.OUT_OF_WORLD) {
-            EntityDamageEvent event = callEvent(new EntityDamageByBlockEvent(null, entity.getBukkitEntity(), DamageCause.VOID, modifiers, modifierFunctions));
-            if (!event.isCancelled()) {
-                event.getEntity().setLastDamageCause(event);
-            }
-            return event;
-        } else if (source == DamageSource.LAVA) {
-            EntityDamageEvent event = callEvent(new EntityDamageByBlockEvent(null, entity.getBukkitEntity(), DamageCause.LAVA, modifiers, modifierFunctions));
-            if (!event.isCancelled()) {
-                event.getEntity().setLastDamageCause(event);
-            }
-            return event;
-        } else if (blockDamage != null) {
-            DamageCause cause = null;
-            Block damager = blockDamage;
-            blockDamage = null;
-            if (source == DamageSource.CACTUS) {
-                cause = DamageCause.CONTACT;
-            } else if (source == DamageSource.HOT_FLOOR) {
-                cause = DamageCause.HOT_FLOOR;
-            } else {
-                throw new IllegalStateException(String.format("Unhandled damage of %s by %s from %s", entity, damager, source.translationIndex));
-            }
-            EntityDamageEvent event = callEvent(new EntityDamageByBlockEvent(damager, entity.getBukkitEntity(), cause, modifiers, modifierFunctions));
-            if (!event.isCancelled()) {
-                event.getEntity().setLastDamageCause(event);
-            }
-            return event;
-        } else if (entityDamage != null) {
-            DamageCause cause = null;
-            CraftEntity damager = entityDamage.getBukkitEntity();
-            entityDamage = null;
-            if (source == DamageSource.ANVIL || source == DamageSource.FALLING_BLOCK) {
-                cause = DamageCause.FALLING_BLOCK;
-            } else if (damager instanceof LightningStrike) {
-                cause = DamageCause.LIGHTNING;
-            } else if (source == DamageSource.FALL) {
-                cause = DamageCause.FALL;
-            } else if (source == DamageSource.DRAGON_BREATH) {
-                cause = DamageCause.DRAGON_BREATH;
-            } else {
-                throw new IllegalStateException(String.format("Unhandled damage of %s by %s from %s", entity, damager.getHandle(), source.translationIndex));
-            }
-            EntityDamageEvent event = callEvent(new EntityDamageByEntityEvent(damager, entity.getBukkitEntity(), cause, modifiers, modifierFunctions));
-            if (!event.isCancelled()) {
-                event.getEntity().setLastDamageCause(event);
-            }
-            return event;
-        }
-
-        DamageCause cause = null;
-        if (source == DamageSource.FIRE) {
-            cause = DamageCause.FIRE;
-        } else if (source == DamageSource.STARVE) {
-            cause = DamageCause.STARVATION;
-        } else if (source == DamageSource.WITHER) {
-            cause = DamageCause.WITHER;
-        } else if (source == DamageSource.STUCK) {
-            cause = DamageCause.SUFFOCATION;
-        } else if (source == DamageSource.DROWN) {
-            cause = DamageCause.DROWNING;
-        } else if (source == DamageSource.BURN) {
-            cause = DamageCause.FIRE_TICK;
-        } else if (source == MELTING) {
-            cause = DamageCause.MELTING;
-        } else if (source == POISON) {
-            cause = DamageCause.POISON;
-        } else if (source == DamageSource.MAGIC) {
-            cause = DamageCause.MAGIC;
-        } else if (source == DamageSource.FALL) {
-            cause = DamageCause.FALL;
-        } else if (source == DamageSource.FLY_INTO_WALL) {
-            cause = DamageCause.FLY_INTO_WALL;
-        } else if (source == DamageSource.GENERIC) {
-            cause = DamageCause.CUSTOM;
-        }
-
-        if (cause != null) {
-            return callEntityDamageEvent(null, entity, cause, modifiers, modifierFunctions);
-        }
-
-        throw new IllegalStateException(String.format("Unhandled damage of %s from %s", entity, source.translationIndex));
-    }
-
-    private static EntityDamageEvent callEntityDamageEvent(Entity damager, Entity damagee, DamageCause cause, Map<DamageModifier, Double> modifiers, Map<DamageModifier, Function<? super Double, Double>> modifierFunctions) {
-        EntityDamageEvent event;
-        if (damager != null) {
-            event = new EntityDamageByEntityEvent(damager.getBukkitEntity(), damagee.getBukkitEntity(), cause, modifiers, modifierFunctions);
-        } else {
-            event = new EntityDamageEvent(damagee.getBukkitEntity(), cause, modifiers, modifierFunctions);
-        }
-
-        callEvent(event);
-
-        if (!event.isCancelled()) {
-            event.getEntity().setLastDamageCause(event);
-        }
-
-        return event;
-    }
-
-    private static final Function<? super Double, Double> ZERO = Functions.constant(-0.0);
-
-    public static EntityDamageEvent handleLivingEntityDamageEvent(Entity damagee, DamageSource source, double rawDamage, double hardHatModifier, double blockingModifier, double armorModifier, double resistanceModifier, double magicModifier, double absorptionModifier, Function<Double, Double> hardHat, Function<Double, Double> blocking, Function<Double, Double> armor, Function<Double, Double> resistance, Function<Double, Double> magic, Function<Double, Double> absorption) {
-            Map<DamageModifier, Double> modifiers = new EnumMap<DamageModifier, Double>(DamageModifier.class);
-        Map<DamageModifier, Function<? super Double, Double>> modifierFunctions = new EnumMap<DamageModifier, Function<? super Double, Double>>(DamageModifier.class);
-        modifiers.put(DamageModifier.BASE, rawDamage);
-        modifierFunctions.put(DamageModifier.BASE, ZERO);
-        if (source == DamageSource.FALLING_BLOCK || source == DamageSource.ANVIL) {
-            modifiers.put(DamageModifier.HARD_HAT, hardHatModifier);
-            modifierFunctions.put(DamageModifier.HARD_HAT, hardHat);
-        }
-        if (damagee instanceof EntityHuman) {
-            modifiers.put(DamageModifier.BLOCKING, blockingModifier);
-            modifierFunctions.put(DamageModifier.BLOCKING, blocking);
-        }
-        modifiers.put(DamageModifier.ARMOR, armorModifier);
-        modifierFunctions.put(DamageModifier.ARMOR, armor);
-        modifiers.put(DamageModifier.RESISTANCE, resistanceModifier);
-        modifierFunctions.put(DamageModifier.RESISTANCE, resistance);
-        modifiers.put(DamageModifier.MAGIC, magicModifier);
-        modifierFunctions.put(DamageModifier.MAGIC, magic);
-        modifiers.put(DamageModifier.ABSORPTION, absorptionModifier);
-        modifierFunctions.put(DamageModifier.ABSORPTION, absorption);
-        return handleEntityDamageEvent(damagee, source, modifiers, modifierFunctions);
-    }
-
-    // Non-Living Entities such as EntityEnderCrystal and EntityFireball need to call this
-    public static boolean handleNonLivingEntityDamageEvent(Entity entity, DamageSource source, double damage) {
-        return handleNonLivingEntityDamageEvent(entity, source, damage, true);
-    }
-
-    public static boolean handleNonLivingEntityDamageEvent(Entity entity, DamageSource source, double damage, boolean cancelOnZeroDamage) {
-        if (entity instanceof EntityEnderCrystal && !(source instanceof EntityDamageSource)) {
-            return false;
-        }
-
-        final EnumMap<DamageModifier, Double> modifiers = new EnumMap<DamageModifier, Double>(DamageModifier.class);
-        final EnumMap<DamageModifier, Function<? super Double, Double>> functions = new EnumMap(DamageModifier.class);
-
-        modifiers.put(DamageModifier.BASE, damage);
-        functions.put(DamageModifier.BASE, ZERO);
-
-        final EntityDamageEvent event = handleEntityDamageEvent(entity, source, modifiers, functions);
-        if (event == null) {
-            return false;
-        }
-        return event.isCancelled() || (cancelOnZeroDamage && event.getDamage() == 0);
-    }
-
-    public static PlayerLevelChangeEvent callPlayerLevelChangeEvent(Player player, int oldLevel, int newLevel) {
-        PlayerLevelChangeEvent event = new PlayerLevelChangeEvent(player, oldLevel, newLevel);
-        Bukkit.getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static PlayerExpChangeEvent callPlayerExpChangeEvent(EntityHuman entity, int expAmount) {
-        Player player = (Player) entity.getBukkitEntity();
-        PlayerExpChangeEvent event = new PlayerExpChangeEvent(player, expAmount);
-        Bukkit.getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static boolean handleBlockGrowEvent(World world, int x, int y, int z, net.minecraft.server.Block type, int data) {
-        Block block = world.getWorld().getBlockAt(x, y, z);
-        CraftBlockState state = (CraftBlockState) block.getState();
-        state.setTypeId(net.minecraft.server.Block.getId(type));
-        state.setRawData((byte) data);
-
-        BlockGrowEvent event = new BlockGrowEvent(block, state);
-        Bukkit.getPluginManager().callEvent(event);
-
-        if (!event.isCancelled()) {
-            state.update(true);
-        }
-        
-        return !event.isCancelled();
-    }
-
-    public static FoodLevelChangeEvent callFoodLevelChangeEvent(EntityHuman entity, int level) {
-        FoodLevelChangeEvent event = new FoodLevelChangeEvent(entity.getBukkitEntity(), level);
-        entity.getBukkitEntity().getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static PigZapEvent callPigZapEvent(Entity pig, Entity lightning, Entity pigzombie) {
-        PigZapEvent event = new PigZapEvent((Pig) pig.getBukkitEntity(), (LightningStrike) lightning.getBukkitEntity(), (PigZombie) pigzombie.getBukkitEntity());
-        pig.getBukkitEntity().getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static HorseJumpEvent callHorseJumpEvent(Entity horse, float power) {
-        HorseJumpEvent event = new HorseJumpEvent((Horse) horse.getBukkitEntity(), power);
-        horse.getBukkitEntity().getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static EntityChangeBlockEvent callEntityChangeBlockEvent(org.bukkit.entity.Entity entity, Block block, Material material) {
-        return callEntityChangeBlockEvent(entity, block, material, 0);
-    }
-
-    public static EntityChangeBlockEvent callEntityChangeBlockEvent(Entity entity, Block block, Material material) {
-        return callEntityChangeBlockEvent(entity.getBukkitEntity(), block, material, 0);
-    }
-
-    public static EntityChangeBlockEvent callEntityChangeBlockEvent(Entity entity, Block block, Material material, boolean cancelled) {
-        return callEntityChangeBlockEvent(entity.getBukkitEntity(), block, material, 0, cancelled);
-    }
-
-    public static EntityChangeBlockEvent callEntityChangeBlockEvent(Entity entity, BlockPosition position, net.minecraft.server.Block type, int data) {
-        Block block = entity.world.getWorld().getBlockAt(position.getX(), position.getY(), position.getZ());
-        Material material = CraftMagicNumbers.getMaterial(type);
-
-        return callEntityChangeBlockEvent(entity.getBukkitEntity(), block, material, data);
-    }
-
-    public static EntityChangeBlockEvent callEntityChangeBlockEvent(org.bukkit.entity.Entity entity, Block block, Material material, int data) {
-        return callEntityChangeBlockEvent(entity, block, material, data, false);
-    }
-
-    public static EntityChangeBlockEvent callEntityChangeBlockEvent(org.bukkit.entity.Entity entity, Block block, Material material, int data, boolean cancelled) {
-        EntityChangeBlockEvent event = new EntityChangeBlockEvent(entity, block, material, (byte) data);
-        event.setCancelled(cancelled);
-        entity.getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static CreeperPowerEvent callCreeperPowerEvent(Entity creeper, Entity lightning, CreeperPowerEvent.PowerCause cause) {
-        CreeperPowerEvent event = new CreeperPowerEvent((Creeper) creeper.getBukkitEntity(), (LightningStrike) lightning.getBukkitEntity(), cause);
-        creeper.getBukkitEntity().getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static EntityTargetEvent callEntityTargetEvent(Entity entity, Entity target, EntityTargetEvent.TargetReason reason) {
-        EntityTargetEvent event = new EntityTargetEvent(entity.getBukkitEntity(), target == null ? null : target.getBukkitEntity(), reason);
-        entity.getBukkitEntity().getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static EntityTargetLivingEntityEvent callEntityTargetLivingEvent(Entity entity, EntityLiving target, EntityTargetEvent.TargetReason reason) {
-        EntityTargetLivingEntityEvent event = new EntityTargetLivingEntityEvent(entity.getBukkitEntity(), (LivingEntity) target.getBukkitEntity(), reason);
-        entity.getBukkitEntity().getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static EntityBreakDoorEvent callEntityBreakDoorEvent(Entity entity, int x, int y, int z) {
-        org.bukkit.entity.Entity entity1 = entity.getBukkitEntity();
-        Block block = entity1.getWorld().getBlockAt(x, y, z);
-
-        EntityBreakDoorEvent event = new EntityBreakDoorEvent((LivingEntity) entity1, block);
-        entity1.getServer().getPluginManager().callEvent(event);
-
-        return event;
-    }
-
-    public static Container callInventoryOpenEvent(EntityPlayer player, Container container) {
-        return callInventoryOpenEvent(player, container, false);
-    }
-
-    public static Container callInventoryOpenEvent(EntityPlayer player, Container container, boolean cancelled) {
-        if (player.activeContainer != player.defaultContainer) { // fire INVENTORY_CLOSE if one already open
-            player.playerConnection.a(new PacketPlayInCloseWindow(player.activeContainer.windowId));
-        }
-
-        CraftServer server = player.world.getServer();
-        CraftPlayer craftPlayer = player.getBukkitEntity();
-        player.activeContainer.transferTo(container, craftPlayer);
-
-        InventoryOpenEvent event = new InventoryOpenEvent(container.getBukkitView());
-        event.setCancelled(cancelled);
-        server.getPluginManager().callEvent(event);
-
-        if (event.isCancelled()) {
-            container.transferTo(player.activeContainer, craftPlayer);
-            return null;
-        }
-
-        return container;
-    }
-
-    public static ItemStack callPreCraftEvent(InventoryCrafting matrix, ItemStack result, InventoryView lastCraftView, boolean isRepair) {
-        CraftInventoryCrafting inventory = new CraftInventoryCrafting(matrix, matrix.resultInventory);
-        inventory.setResult(CraftItemStack.asCraftMirror(result));
-
-        PrepareItemCraftEvent event = new PrepareItemCraftEvent(inventory, lastCraftView, isRepair);
-        Bukkit.getPluginManager().callEvent(event);
-
-        org.bukkit.inventory.ItemStack bitem = event.getInventory().getResult();
-
-        return CraftItemStack.asNMSCopy(bitem);
-    }
-
-    public static ProjectileLaunchEvent callProjectileLaunchEvent(Entity entity) {
-        Projectile bukkitEntity = (Projectile) entity.getBukkitEntity();
-        ProjectileLaunchEvent event = new ProjectileLaunchEvent(bukkitEntity);
-        Bukkit.getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static ProjectileHitEvent callProjectileHitEvent(Entity entity) {
-        ProjectileHitEvent event = new ProjectileHitEvent((Projectile) entity.getBukkitEntity());
-        entity.world.getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static ExpBottleEvent callExpBottleEvent(Entity entity, int exp) {
-        ThrownExpBottle bottle = (ThrownExpBottle) entity.getBukkitEntity();
-        ExpBottleEvent event = new ExpBottleEvent(bottle, exp);
-        Bukkit.getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static BlockRedstoneEvent callRedstoneChange(World world, int x, int y, int z, int oldCurrent, int newCurrent) {
-        BlockRedstoneEvent event = new BlockRedstoneEvent(world.getWorld().getBlockAt(x, y, z), oldCurrent, newCurrent);
-        world.getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static NotePlayEvent callNotePlayEvent(World world, int x, int y, int z, byte instrument, byte note) {
-        NotePlayEvent event = new NotePlayEvent(world.getWorld().getBlockAt(x, y, z), org.bukkit.Instrument.getByType(instrument), new org.bukkit.Note(note));
-        world.getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static void callPlayerItemBreakEvent(EntityHuman human, ItemStack brokenItem) {
-        CraftItemStack item = CraftItemStack.asCraftMirror(brokenItem);
-        PlayerItemBreakEvent event = new PlayerItemBreakEvent((Player) human.getBukkitEntity(), item);
-        Bukkit.getPluginManager().callEvent(event);
-    }
-
-    public static BlockIgniteEvent callBlockIgniteEvent(World world, int x, int y, int z, int igniterX, int igniterY, int igniterZ) {
-        org.bukkit.World bukkitWorld = world.getWorld();
-        Block igniter = bukkitWorld.getBlockAt(igniterX, igniterY, igniterZ);
-        IgniteCause cause;
-        switch (igniter.getType()) {
-            case LAVA:
-            case STATIONARY_LAVA:
-                cause = IgniteCause.LAVA;
-                break;
-            case DISPENSER:
-                cause = IgniteCause.FLINT_AND_STEEL;
-                break;
-            case FIRE: // Fire or any other unknown block counts as SPREAD.
-            default:
-                cause = IgniteCause.SPREAD;
-        }
-
-        BlockIgniteEvent event = new BlockIgniteEvent(bukkitWorld.getBlockAt(x, y, z), cause, igniter);
-        world.getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static BlockIgniteEvent callBlockIgniteEvent(World world, int x, int y, int z, Entity igniter) {
-        org.bukkit.World bukkitWorld = world.getWorld();
-        org.bukkit.entity.Entity bukkitIgniter = igniter.getBukkitEntity();
-        IgniteCause cause;
-        switch (bukkitIgniter.getType()) {
-        case ENDER_CRYSTAL:
-            cause = IgniteCause.ENDER_CRYSTAL;
-            break;
-        case LIGHTNING:
-            cause = IgniteCause.LIGHTNING;
-            break;
-        case SMALL_FIREBALL:
-        case FIREBALL:
-            cause = IgniteCause.FIREBALL;
-            break;
-        default:
-            cause = IgniteCause.FLINT_AND_STEEL;
-        }
-
-        BlockIgniteEvent event = new BlockIgniteEvent(bukkitWorld.getBlockAt(x, y, z), cause, bukkitIgniter);
-        world.getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static BlockIgniteEvent callBlockIgniteEvent(World world, int x, int y, int z, Explosion explosion) {
-        org.bukkit.World bukkitWorld = world.getWorld();
-        org.bukkit.entity.Entity igniter = explosion.source == null ? null : explosion.source.getBukkitEntity();
-
-        BlockIgniteEvent event = new BlockIgniteEvent(bukkitWorld.getBlockAt(x, y, z), IgniteCause.EXPLOSION, igniter);
-        world.getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static BlockIgniteEvent callBlockIgniteEvent(World world, int x, int y, int z, IgniteCause cause, Entity igniter) {
-        BlockIgniteEvent event = new BlockIgniteEvent(world.getWorld().getBlockAt(x, y, z), cause, igniter.getBukkitEntity());
-        world.getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static void handleInventoryCloseEvent(EntityHuman human) {
-        InventoryCloseEvent event = new InventoryCloseEvent(human.activeContainer.getBukkitView());
-        human.world.getServer().getPluginManager().callEvent(event);
-        human.activeContainer.transferTo(human.defaultContainer, human.getBukkitEntity());
-    }
-
-    public static void handleEditBookEvent(EntityPlayer player, ItemStack newBookItem) {
-        int itemInHandIndex = player.inventory.itemInHandIndex;
-
-        PlayerEditBookEvent editBookEvent = new PlayerEditBookEvent(player.getBukkitEntity(), player.inventory.itemInHandIndex, (BookMeta) CraftItemStack.getItemMeta(player.inventory.getItemInHand()), (BookMeta) CraftItemStack.getItemMeta(newBookItem), newBookItem.getItem() == Items.WRITTEN_BOOK);
-        player.world.getServer().getPluginManager().callEvent(editBookEvent);
-        ItemStack itemInHand = player.inventory.getItem(itemInHandIndex);
-
-        // If they've got the same item in their hand, it'll need to be updated.
-        if (itemInHand != null && itemInHand.getItem() == Items.WRITABLE_BOOK) {
-            if (!editBookEvent.isCancelled()) {
-                if (editBookEvent.isSigning()) {
-                    itemInHand.setItem(Items.WRITTEN_BOOK);
-                }
-                CraftMetaBook meta = (CraftMetaBook) editBookEvent.getNewBookMeta();
-                List<IChatBaseComponent> pages = meta.pages;
-                for (int i = 0; i < pages.size(); i++) {
-                    pages.set(i, stripEvents(pages.get(i)));
-                }
-                CraftItemStack.setItemMeta(itemInHand, meta);
-            }
-
-            // Client will have updated its idea of the book item; we need to overwrite that
-            Slot slot = player.activeContainer.getSlot(player.inventory, itemInHandIndex);
-            player.playerConnection.sendPacket(new PacketPlayOutSetSlot(player.activeContainer.windowId, slot.rawSlotIndex, itemInHand));
-        }
-    }
-
-    private static IChatBaseComponent stripEvents(IChatBaseComponent c) {
-        ChatModifier modi = c.getChatModifier();
-        if (modi != null) {
-            modi.setChatClickable(null);
-            modi.setChatHoverable(null);
-        }
-        c.setChatModifier(modi);
-        if (c instanceof ChatMessage) {
-            ChatMessage cm = (ChatMessage) c;
-            Object[] oo = cm.j();
-            for (int i = 0; i < oo.length; i++) {
-                Object o = oo[i];
-                if (o instanceof IChatBaseComponent) {
-                    oo[i] = stripEvents((IChatBaseComponent) o);
-                }
-            }
-        }
-        List<IChatBaseComponent> ls = c.a();
-        if (ls != null) {
-            for (int i = 0; i < ls.size(); i++) {
-                ls.set(i, stripEvents(ls.get(i)));
-            }
-        }
-        return c;
-    }
-
-    public static PlayerUnleashEntityEvent callPlayerUnleashEntityEvent(EntityInsentient entity, EntityHuman player) {
-        PlayerUnleashEntityEvent event = new PlayerUnleashEntityEvent(entity.getBukkitEntity(), (Player) player.getBukkitEntity());
-        entity.world.getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static PlayerLeashEntityEvent callPlayerLeashEntityEvent(EntityInsentient entity, Entity leashHolder, EntityHuman player) {
-        PlayerLeashEntityEvent event = new PlayerLeashEntityEvent(entity.getBukkitEntity(), leashHolder.getBukkitEntity(), (Player) player.getBukkitEntity());
-        entity.world.getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static Cancellable handleStatisticsIncrease(EntityHuman entityHuman, net.minecraft.server.Statistic statistic, int current, int incrementation) {
-        Player player = ((EntityPlayer) entityHuman).getBukkitEntity();
-        Event event;
-        if (statistic instanceof net.minecraft.server.Achievement) {
-            if (current != 0) {
-                return null;
-            }
-            event = new PlayerAchievementAwardedEvent(player, CraftStatistic.getBukkitAchievement((net.minecraft.server.Achievement) statistic));
-        } else {
-            org.bukkit.Statistic stat = CraftStatistic.getBukkitStatistic(statistic);
-            if (stat == null) {
-                System.err.println("Unhandled statistic: " + statistic);
-                return null;
-            }
-            switch (stat) {
-                case FALL_ONE_CM:
-                case BOAT_ONE_CM:
-                case CLIMB_ONE_CM:
-                case DIVE_ONE_CM:
-                case FLY_ONE_CM:
-                case HORSE_ONE_CM:
-                case MINECART_ONE_CM:
-                case PIG_ONE_CM:
-                case PLAY_ONE_TICK:
-                case SWIM_ONE_CM:
-                case WALK_ONE_CM:
-                case SPRINT_ONE_CM:
-                case CROUCH_ONE_CM:
-                case TIME_SINCE_DEATH:
-                case SNEAK_TIME:
-                    // Do not process event for these - too spammy
-                    return null;
-                default:
-            }
-            if (stat.getType() == Type.UNTYPED) {
-                event = new PlayerStatisticIncrementEvent(player, stat, current, current + incrementation);
-            } else if (stat.getType() == Type.ENTITY) {
-                EntityType entityType = CraftStatistic.getEntityTypeFromStatistic(statistic);
-                event = new PlayerStatisticIncrementEvent(player, stat, current, current + incrementation, entityType);
-            } else {
-                Material material = CraftStatistic.getMaterialFromStatistic(statistic);
-                event = new PlayerStatisticIncrementEvent(player, stat, current, current + incrementation, material);
-            }
-        }
-        entityHuman.world.getServer().getPluginManager().callEvent(event);
-        return (Cancellable) event;
-    }
-
-    public static FireworkExplodeEvent callFireworkExplodeEvent(EntityFireworks firework) {
-        FireworkExplodeEvent event = new FireworkExplodeEvent((Firework) firework.getBukkitEntity());
-        firework.world.getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static PrepareAnvilEvent callPrepareAnvilEvent(InventoryView view, ItemStack item) {
-        PrepareAnvilEvent event = new PrepareAnvilEvent(view, CraftItemStack.asCraftMirror(item).clone());
-        event.getView().getPlayer().getServer().getPluginManager().callEvent(event);
-        event.getInventory().setItem(2, event.getResult());
-        return event;
-    }
-
-    /**
-     * Mob spawner event.
-     */
-    public static SpawnerSpawnEvent callSpawnerSpawnEvent(Entity spawnee, BlockPosition pos) {
-        org.bukkit.craftbukkit.entity.CraftEntity entity = spawnee.getBukkitEntity();
-        BlockState state = entity.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ()).getState();
-        if (!(state instanceof org.bukkit.block.CreatureSpawner)) {
-            state = null;
-        }
-
-        SpawnerSpawnEvent event = new SpawnerSpawnEvent(entity, (org.bukkit.block.CreatureSpawner) state);
-        entity.getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-    public static EntityToggleGlideEvent callToggleGlideEvent(EntityLiving entity, boolean gliding) {
-        EntityToggleGlideEvent event = new EntityToggleGlideEvent((LivingEntity) entity.getBukkitEntity(), gliding);
-        entity.world.getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-
-	public static AreaEffectCloudApplyEvent callAreaEffectCloudApplyEvent(EntityAreaEffectCloud cloud, List<LivingEntity> entities) {
-		AreaEffectCloudApplyEvent event = new AreaEffectCloudApplyEvent((AreaEffectCloud) cloud.getBukkitEntity(), entities);
-		cloud.world.getServer().getPluginManager().callEvent(event);
-		return event;
-	}
-
-    public static EntityBreedEvent callEntityBreedEvent(EntityLiving child, EntityLiving mother, EntityLiving father, EntityLiving breeder, ItemStack bredWith, int experience) {
-        org.bukkit.entity.LivingEntity breederEntity = (LivingEntity)(breeder == null ? null : breeder.getBukkitEntity());
-        CraftItemStack bredWithStack = bredWith == null ? null : CraftItemStack.asCraftMirror(bredWith).clone();
-
-        EntityBreedEvent event = new EntityBreedEvent((LivingEntity) child.getBukkitEntity(), (LivingEntity) mother.getBukkitEntity(), (LivingEntity) father.getBukkitEntity(), breederEntity, bredWithStack, experience);
-        child.world.getServer().getPluginManager().callEvent(event);
-        return event;
-    }
-}
+package org.bukkit.craftbukkit.event;
+
+import java.net.InetAddress;
+import java.util.ArrayList;
+import java.util.EnumMap;
+import java.util.List;
+import java.util.Map;
+
+import com.google.common.base.Function;
+import com.google.common.base.Functions;
+
+import net.minecraft.server.*;
+
+import org.bukkit.Bukkit;
+import org.bukkit.Material;
+import org.bukkit.Server;
+import org.bukkit.Statistic.Type;
+import org.bukkit.block.Block;
+import org.bukkit.block.BlockFace;
+import org.bukkit.block.BlockState;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftStatistic;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.block.CraftBlock;
+import org.bukkit.craftbukkit.block.CraftBlockState;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.entity.CraftLivingEntity;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.inventory.CraftInventoryCrafting;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.craftbukkit.inventory.CraftMetaBook;
+import org.bukkit.craftbukkit.util.CraftDamageSource;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.entity.AreaEffectCloud;
+import org.bukkit.entity.Arrow;
+import org.bukkit.entity.Creeper;
+import org.bukkit.entity.EntityType;
+import org.bukkit.entity.Firework;
+import org.bukkit.entity.Horse;
+import org.bukkit.entity.LightningStrike;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.entity.Pig;
+import org.bukkit.entity.PigZombie;
+import org.bukkit.entity.Player;
+import org.bukkit.entity.Projectile;
+import org.bukkit.entity.ThrownExpBottle;
+import org.bukkit.entity.ThrownPotion;
+import org.bukkit.event.Cancellable;
+import org.bukkit.event.Event;
+import org.bukkit.event.block.*;
+import org.bukkit.event.block.BlockIgniteEvent.IgniteCause;
+import org.bukkit.event.entity.*;
+import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
+import org.bukkit.event.entity.EntityDamageEvent.DamageCause;
+import org.bukkit.event.entity.EntityDamageEvent.DamageModifier;
+import org.bukkit.event.inventory.InventoryCloseEvent;
+import org.bukkit.event.inventory.InventoryOpenEvent;
+import org.bukkit.event.inventory.PrepareAnvilEvent;
+import org.bukkit.event.inventory.PrepareItemCraftEvent;
+import org.bukkit.event.player.*;
+import org.bukkit.event.server.ServerListPingEvent;
+import org.bukkit.inventory.EquipmentSlot;
+import org.bukkit.inventory.InventoryView;
+import org.bukkit.inventory.meta.BookMeta;
+
+public class CraftEventFactory {
+    public static final DamageSource MELTING = CraftDamageSource.copyOf(DamageSource.BURN);
+    public static final DamageSource POISON = CraftDamageSource.copyOf(DamageSource.MAGIC);
+    public static org.bukkit.block.Block blockDamage; // For use in EntityDamageByBlockEvent
+    public static Entity entityDamage; // For use in EntityDamageByEntityEvent
+
+    // helper methods
+    private static boolean canBuild(CraftWorld world, Player player, int x, int z) {
+        WorldServer worldServer = world.getHandle();
+        int spawnSize = Bukkit.getServer().getSpawnRadius();
+
+        if (world.getHandle().dimension != 0) return true;
+        if (spawnSize <= 0) return true;
+        if (((CraftServer) Bukkit.getServer()).getHandle().getOPs().isEmpty()) return true;
+        if (player.isOp()) return true;
+
+        BlockPosition chunkcoordinates = worldServer.getSpawn();
+
+        int distanceFromSpawn = Math.max(Math.abs(x - chunkcoordinates.getX()), Math.abs(z - chunkcoordinates.getY()));
+        return distanceFromSpawn > spawnSize;
+    }
+
+    public static <T extends Event> T callEvent(T event) {
+        Bukkit.getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    /**
+     * Block place methods
+     */
+    public static BlockMultiPlaceEvent callBlockMultiPlaceEvent(World world, EntityHuman who, EnumHand hand, List<BlockState> blockStates, int clickedX, int clickedY, int clickedZ) {
+        CraftWorld craftWorld = world.getWorld();
+        CraftServer craftServer = world.getServer();
+        Player player = (Player) who.getBukkitEntity();
+
+        Block blockClicked = craftWorld.getBlockAt(clickedX, clickedY, clickedZ);
+
+        boolean canBuild = true;
+        for (int i = 0; i < blockStates.size(); i++) {
+            if (!canBuild(craftWorld, player, blockStates.get(i).getX(), blockStates.get(i).getZ())) {
+                canBuild = false;
+                break;
+            }
+        }
+
+        org.bukkit.inventory.ItemStack item;
+        if (hand == EnumHand.MAIN_HAND) {
+            item = player.getInventory().getItemInMainHand();
+        } else {
+            item = player.getInventory().getItemInOffHand();
+        }
+
+        BlockMultiPlaceEvent event = new BlockMultiPlaceEvent(blockStates, blockClicked, item, player, canBuild);
+        craftServer.getPluginManager().callEvent(event);
+
+        return event;
+    }
+
+    public static BlockPlaceEvent callBlockPlaceEvent(World world, EntityHuman who, EnumHand hand, BlockState replacedBlockState, int clickedX, int clickedY, int clickedZ) {
+        CraftWorld craftWorld = world.getWorld();
+        CraftServer craftServer = world.getServer();
+
+        Player player = (Player) who.getBukkitEntity();
+
+        Block blockClicked = craftWorld.getBlockAt(clickedX, clickedY, clickedZ);
+        Block placedBlock = replacedBlockState.getBlock();
+
+        boolean canBuild = canBuild(craftWorld, player, placedBlock.getX(), placedBlock.getZ());
+
+        org.bukkit.inventory.ItemStack item;
+        EquipmentSlot equipmentSlot;
+        if (hand == EnumHand.MAIN_HAND) {
+            item = player.getInventory().getItemInMainHand();
+            equipmentSlot = EquipmentSlot.HAND;
+        } else {
+            item = player.getInventory().getItemInOffHand();
+            equipmentSlot = EquipmentSlot.OFF_HAND;
+        }
+
+        BlockPlaceEvent event = new BlockPlaceEvent(placedBlock, replacedBlockState, blockClicked, item, player, canBuild, equipmentSlot);
+        craftServer.getPluginManager().callEvent(event);
+
+        return event;
+    }
+
+    /**
+     * Bucket methods
+     */
+    public static PlayerBucketEmptyEvent callPlayerBucketEmptyEvent(EntityHuman who, int clickedX, int clickedY, int clickedZ, EnumDirection clickedFace, ItemStack itemInHand) {
+        return (PlayerBucketEmptyEvent) getPlayerBucketEvent(false, who, clickedX, clickedY, clickedZ, clickedFace, itemInHand, Items.BUCKET);
+    }
+
+    public static PlayerBucketFillEvent callPlayerBucketFillEvent(EntityHuman who, int clickedX, int clickedY, int clickedZ, EnumDirection clickedFace, ItemStack itemInHand, net.minecraft.server.Item bucket) {
+        return (PlayerBucketFillEvent) getPlayerBucketEvent(true, who, clickedX, clickedY, clickedZ, clickedFace, itemInHand, bucket);
+    }
+
+    private static PlayerEvent getPlayerBucketEvent(boolean isFilling, EntityHuman who, int clickedX, int clickedY, int clickedZ, EnumDirection clickedFace, ItemStack itemstack, net.minecraft.server.Item item) {
+        Player player = (who == null) ? null : (Player) who.getBukkitEntity();
+        CraftItemStack itemInHand = CraftItemStack.asNewCraftStack(item);
+        Material bucket = CraftMagicNumbers.getMaterial(itemstack.getItem());
+
+        CraftWorld craftWorld = (CraftWorld) player.getWorld();
+        CraftServer craftServer = (CraftServer) player.getServer();
+
+        Block blockClicked = craftWorld.getBlockAt(clickedX, clickedY, clickedZ);
+        BlockFace blockFace = CraftBlock.notchToBlockFace(clickedFace);
+
+        PlayerEvent event = null;
+        if (isFilling) {
+            event = new PlayerBucketFillEvent(player, blockClicked, blockFace, bucket, itemInHand);
+            ((PlayerBucketFillEvent) event).setCancelled(!canBuild(craftWorld, player, clickedX, clickedZ));
+        } else {
+            event = new PlayerBucketEmptyEvent(player, blockClicked, blockFace, bucket, itemInHand);
+            ((PlayerBucketEmptyEvent) event).setCancelled(!canBuild(craftWorld, player, clickedX, clickedZ));
+        }
+
+        craftServer.getPluginManager().callEvent(event);
+
+        return event;
+    }
+
+    /**
+     * Player Interact event
+     */
+    public static PlayerInteractEvent callPlayerInteractEvent(EntityHuman who, Action action, ItemStack itemstack, EnumHand hand) {
+        if (action != Action.LEFT_CLICK_AIR && action != Action.RIGHT_CLICK_AIR) {
+            throw new AssertionError(String.format("%s performing %s with %s", who, action, itemstack));
+        }
+        return callPlayerInteractEvent(who, action, null, EnumDirection.SOUTH, itemstack, hand);
+    }
+
+    public static PlayerInteractEvent callPlayerInteractEvent(EntityHuman who, Action action, BlockPosition position, EnumDirection direction, ItemStack itemstack, EnumHand hand) {
+        return callPlayerInteractEvent(who, action, position, direction, itemstack, false, hand);
+    }
+    
+    public static PlayerInteractEvent callPlayerInteractEvent(EntityHuman who, Action action, BlockPosition position, EnumDirection direction, ItemStack itemstack, boolean cancelledBlock, EnumHand hand) {
+        Player player = (who == null) ? null : (Player) who.getBukkitEntity();
+        CraftItemStack itemInHand = CraftItemStack.asCraftMirror(itemstack);
+
+        CraftWorld craftWorld = (CraftWorld) player.getWorld();
+        CraftServer craftServer = (CraftServer) player.getServer();
+
+        Block blockClicked = null;
+        if (position != null) {
+            blockClicked = craftWorld.getBlockAt(position.getX(), position.getY(), position.getZ());
+        } else {
+            switch (action) {
+                case LEFT_CLICK_BLOCK:
+                    action = Action.LEFT_CLICK_AIR;
+                    break;
+                case RIGHT_CLICK_BLOCK:
+                    action = Action.RIGHT_CLICK_AIR;
+                    break;
+            }
+        }
+        BlockFace blockFace = CraftBlock.notchToBlockFace(direction);
+
+        if (itemInHand.getType() == Material.AIR || itemInHand.getAmount() == 0) {
+            itemInHand = null;
+        }
+
+        PlayerInteractEvent event = new PlayerInteractEvent(player, action, itemInHand, blockClicked, blockFace, (hand == null) ? null : ((hand == EnumHand.OFF_HAND) ? EquipmentSlot.OFF_HAND : EquipmentSlot.HAND));
+        if (cancelledBlock) {
+            event.setUseInteractedBlock(Event.Result.DENY);
+        }
+        craftServer.getPluginManager().callEvent(event);
+
+        return event;
+    }
+
+    /**
+     * EntityShootBowEvent
+     */
+    public static EntityShootBowEvent callEntityShootBowEvent(EntityLiving who, ItemStack itemstack, EntityArrow entityArrow, float force) {
+        LivingEntity shooter = (LivingEntity) who.getBukkitEntity();
+        CraftItemStack itemInHand = CraftItemStack.asCraftMirror(itemstack);
+        Arrow arrow = (Arrow) entityArrow.getBukkitEntity();
+
+        if (itemInHand != null && (itemInHand.getType() == Material.AIR || itemInHand.getAmount() == 0)) {
+            itemInHand = null;
+        }
+
+        EntityShootBowEvent event = new EntityShootBowEvent(shooter, itemInHand, arrow, force);
+        Bukkit.getPluginManager().callEvent(event);
+
+        return event;
+    }
+
+    /**
+     * BlockDamageEvent
+     */
+    public static BlockDamageEvent callBlockDamageEvent(EntityHuman who, int x, int y, int z, ItemStack itemstack, boolean instaBreak) {
+        Player player = (who == null) ? null : (Player) who.getBukkitEntity();
+        CraftItemStack itemInHand = CraftItemStack.asCraftMirror(itemstack);
+
+        CraftWorld craftWorld = (CraftWorld) player.getWorld();
+        CraftServer craftServer = (CraftServer) player.getServer();
+
+        Block blockClicked = craftWorld.getBlockAt(x, y, z);
+
+        BlockDamageEvent event = new BlockDamageEvent(player, blockClicked, itemInHand, instaBreak);
+        craftServer.getPluginManager().callEvent(event);
+
+        return event;
+    }
+
+    /**
+     * CreatureSpawnEvent
+     */
+    public static CreatureSpawnEvent callCreatureSpawnEvent(EntityLiving entityliving, SpawnReason spawnReason) {
+        LivingEntity entity = (LivingEntity) entityliving.getBukkitEntity();
+        CraftServer craftServer = (CraftServer) entity.getServer();
+
+        CreatureSpawnEvent event = new CreatureSpawnEvent(entity, spawnReason);
+        craftServer.getPluginManager().callEvent(event);
+        return event;
+    }
+
+    /**
+     * EntityTameEvent
+     */
+    public static EntityTameEvent callEntityTameEvent(EntityInsentient entity, EntityHuman tamer) {
+        org.bukkit.entity.Entity bukkitEntity = entity.getBukkitEntity();
+        org.bukkit.entity.AnimalTamer bukkitTamer = (tamer != null ? tamer.getBukkitEntity() : null);
+        CraftServer craftServer = (CraftServer) bukkitEntity.getServer();
+
+        entity.persistent = true;
+
+        EntityTameEvent event = new EntityTameEvent((LivingEntity) bukkitEntity, bukkitTamer);
+        craftServer.getPluginManager().callEvent(event);
+        return event;
+    }
+
+    /**
+     * ItemSpawnEvent
+     */
+    public static ItemSpawnEvent callItemSpawnEvent(EntityItem entityitem) {
+        org.bukkit.entity.Item entity = (org.bukkit.entity.Item) entityitem.getBukkitEntity();
+        CraftServer craftServer = (CraftServer) entity.getServer();
+
+        ItemSpawnEvent event = new ItemSpawnEvent(entity, entity.getLocation());
+
+        craftServer.getPluginManager().callEvent(event);
+        return event;
+    }
+
+    /**
+     * ItemDespawnEvent
+     */
+    public static ItemDespawnEvent callItemDespawnEvent(EntityItem entityitem) {
+        org.bukkit.entity.Item entity = (org.bukkit.entity.Item) entityitem.getBukkitEntity();
+
+        ItemDespawnEvent event = new ItemDespawnEvent(entity, entity.getLocation());
+
+        entity.getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    /**
+     * ItemMergeEvent
+     */
+    public static ItemMergeEvent callItemMergeEvent(EntityItem merging, EntityItem mergingWith) {
+        org.bukkit.entity.Item entityMerging = (org.bukkit.entity.Item) merging.getBukkitEntity();
+        org.bukkit.entity.Item entityMergingWith = (org.bukkit.entity.Item) mergingWith.getBukkitEntity();
+
+        ItemMergeEvent event = new ItemMergeEvent(entityMerging, entityMergingWith);
+
+        Bukkit.getPluginManager().callEvent(event);
+        return event;
+    }
+
+    /**
+     * PotionSplashEvent
+     */
+    public static PotionSplashEvent callPotionSplashEvent(EntityPotion potion, Map<LivingEntity, Double> affectedEntities) {
+        ThrownPotion thrownPotion = (ThrownPotion) potion.getBukkitEntity();
+
+        PotionSplashEvent event = new PotionSplashEvent(thrownPotion, affectedEntities);
+        Bukkit.getPluginManager().callEvent(event);
+        return event;
+    }
+
+	public static LingeringPotionSplashEvent callLingeringPotionSplashEvent(EntityPotion potion, EntityAreaEffectCloud cloud) {
+        ThrownPotion thrownPotion = (ThrownPotion) potion.getBukkitEntity();
+        AreaEffectCloud effectCloud = (AreaEffectCloud) cloud.getBukkitEntity();
+
+        LingeringPotionSplashEvent event = new LingeringPotionSplashEvent(thrownPotion, effectCloud);
+        Bukkit.getPluginManager().callEvent(event);
+        return event;
+	}
+
+    /**
+     * BlockFadeEvent
+     */
+    public static BlockFadeEvent callBlockFadeEvent(Block block, net.minecraft.server.Block type) {
+        BlockState state = block.getState();
+        state.setTypeId(net.minecraft.server.Block.getId(type));
+
+        BlockFadeEvent event = new BlockFadeEvent(block, state);
+        Bukkit.getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static boolean handleBlockSpreadEvent(Block block, Block source, net.minecraft.server.Block type, int data) {
+        BlockState state = block.getState();
+        state.setTypeId(net.minecraft.server.Block.getId(type));
+        state.setRawData((byte) data);
+
+        BlockSpreadEvent event = new BlockSpreadEvent(block, source, state);
+        Bukkit.getPluginManager().callEvent(event);
+
+        if (!event.isCancelled()) {
+            state.update(true);
+        }
+        return !event.isCancelled();
+    }
+
+    public static EntityDeathEvent callEntityDeathEvent(EntityLiving victim) {
+        return callEntityDeathEvent(victim, new ArrayList<org.bukkit.inventory.ItemStack>(0));
+    }
+
+    public static EntityDeathEvent callEntityDeathEvent(EntityLiving victim, List<org.bukkit.inventory.ItemStack> drops) {
+        CraftLivingEntity entity = (CraftLivingEntity) victim.getBukkitEntity();
+        EntityDeathEvent event = new EntityDeathEvent(entity, drops, victim.getExpReward());
+        CraftWorld world = (CraftWorld) entity.getWorld();
+        Bukkit.getServer().getPluginManager().callEvent(event);
+
+        victim.expToDrop = event.getDroppedExp();
+
+        for (org.bukkit.inventory.ItemStack stack : event.getDrops()) {
+            if (stack == null || stack.getType() == Material.AIR || stack.getAmount() == 0) continue;
+
+            world.dropItemNaturally(entity.getLocation(), stack);
+        }
+
+        return event;
+    }
+
+    public static PlayerDeathEvent callPlayerDeathEvent(EntityPlayer victim, List<org.bukkit.inventory.ItemStack> drops, String deathMessage, boolean keepInventory) {
+        CraftPlayer entity = victim.getBukkitEntity();
+        PlayerDeathEvent event = new PlayerDeathEvent(entity, drops, victim.getExpReward(), 0, deathMessage);
+        event.setKeepInventory(keepInventory);
+        org.bukkit.World world = entity.getWorld();
+        Bukkit.getServer().getPluginManager().callEvent(event);
+
+        victim.keepLevel = event.getKeepLevel();
+        victim.newLevel = event.getNewLevel();
+        victim.newTotalExp = event.getNewTotalExp();
+        victim.expToDrop = event.getDroppedExp();
+        victim.newExp = event.getNewExp();
+
+        if (event.getKeepInventory()) {
+            return event;
+        }
+
+        for (org.bukkit.inventory.ItemStack stack : event.getDrops()) {
+            if (stack == null || stack.getType() == Material.AIR) continue;
+
+            world.dropItemNaturally(entity.getLocation(), stack);
+        }
+
+        return event;
+    }
+
+    /**
+     * Server methods
+     */
+    public static ServerListPingEvent callServerListPingEvent(Server craftServer, InetAddress address, String motd, int numPlayers, int maxPlayers) {
+        ServerListPingEvent event = new ServerListPingEvent(address, motd, numPlayers, maxPlayers);
+        craftServer.getPluginManager().callEvent(event);
+        return event;
+    }
+
+    private static EntityDamageEvent handleEntityDamageEvent(Entity entity, DamageSource source, Map<DamageModifier, Double> modifiers, Map<DamageModifier, Function<? super Double, Double>> modifierFunctions) {
+        if (source.isExplosion()) {
+            DamageCause damageCause;
+            Entity damager = entityDamage;
+            entityDamage = null;
+            EntityDamageEvent event;
+            if (damager == null) {
+                event = new EntityDamageByBlockEvent(null, entity.getBukkitEntity(), DamageCause.BLOCK_EXPLOSION, modifiers, modifierFunctions);
+            } else if (entity instanceof EntityEnderDragon && /*PAIL FIXME ((EntityEnderDragon) entity).target == damager*/ false) {
+                event = new EntityDamageEvent(entity.getBukkitEntity(), DamageCause.ENTITY_EXPLOSION, modifiers, modifierFunctions);
+            } else {
+                if (damager instanceof org.bukkit.entity.TNTPrimed) {
+                    damageCause = DamageCause.BLOCK_EXPLOSION;
+                } else {
+                    damageCause = DamageCause.ENTITY_EXPLOSION;
+                }
+                event = new EntityDamageByEntityEvent(damager.getBukkitEntity(), entity.getBukkitEntity(), damageCause, modifiers, modifierFunctions);
+            }
+
+            callEvent(event);
+
+            if (!event.isCancelled()) {
+                event.getEntity().setLastDamageCause(event);
+            }
+            return event;
+        } else if (source instanceof EntityDamageSource) {
+            Entity damager = source.getEntity();
+            DamageCause cause = DamageCause.ENTITY_ATTACK;
+
+            if (source instanceof EntityDamageSourceIndirect) {
+                damager = ((EntityDamageSourceIndirect) source).getProximateDamageSource();
+                if (damager.getBukkitEntity() instanceof ThrownPotion) {
+                    cause = DamageCause.MAGIC;
+                } else if (damager.getBukkitEntity() instanceof Projectile) {
+                    cause = DamageCause.PROJECTILE;
+                }
+            } else if ("thorns".equals(source.translationIndex)) {
+                cause = DamageCause.THORNS;
+            }
+
+            return callEntityDamageEvent(damager, entity, cause, modifiers, modifierFunctions);
+        } else if (source == DamageSource.OUT_OF_WORLD) {
+            EntityDamageEvent event = callEvent(new EntityDamageByBlockEvent(null, entity.getBukkitEntity(), DamageCause.VOID, modifiers, modifierFunctions));
+            if (!event.isCancelled()) {
+                event.getEntity().setLastDamageCause(event);
+            }
+            return event;
+        } else if (source == DamageSource.LAVA) {
+            EntityDamageEvent event = callEvent(new EntityDamageByBlockEvent(null, entity.getBukkitEntity(), DamageCause.LAVA, modifiers, modifierFunctions));
+            if (!event.isCancelled()) {
+                event.getEntity().setLastDamageCause(event);
+            }
+            return event;
+        } else if (blockDamage != null) {
+            DamageCause cause = null;
+            Block damager = blockDamage;
+            blockDamage = null;
+            if (source == DamageSource.CACTUS) {
+                cause = DamageCause.CONTACT;
+            } else if (source == DamageSource.HOT_FLOOR) {
+                cause = DamageCause.HOT_FLOOR;
+            } else {
+                //throw new IllegalStateException(String.format("Unhandled damage of %s by %s from %s", entity, damager, source.translationIndex));
+                cause = DamageCause.CONTACT;
+            }
+            EntityDamageEvent event = callEvent(new EntityDamageByBlockEvent(damager, entity.getBukkitEntity(), cause, modifiers, modifierFunctions));
+            if (!event.isCancelled()) {
+                event.getEntity().setLastDamageCause(event);
+            }
+            return event;
+        } else if (entityDamage != null) {
+            DamageCause cause = null;
+            CraftEntity damager = entityDamage.getBukkitEntity();
+            entityDamage = null;
+            if (source == DamageSource.ANVIL || source == DamageSource.FALLING_BLOCK) {
+                cause = DamageCause.FALLING_BLOCK;
+            } else if (damager instanceof LightningStrike) {
+                cause = DamageCause.LIGHTNING;
+            } else if (source == DamageSource.FALL) {
+                cause = DamageCause.FALL;
+            } else if (source == DamageSource.DRAGON_BREATH) {
+                cause = DamageCause.DRAGON_BREATH;
+            } else {
+                throw new IllegalStateException(String.format("Unhandled damage of %s by %s from %s", entity, damager.getHandle(), source.translationIndex));
+            }
+            EntityDamageEvent event = callEvent(new EntityDamageByEntityEvent(damager, entity.getBukkitEntity(), cause, modifiers, modifierFunctions));
+            if (!event.isCancelled()) {
+                event.getEntity().setLastDamageCause(event);
+            }
+            return event;
+        }
+
+        DamageCause cause = null;
+        if (source == DamageSource.FIRE) {
+            cause = DamageCause.FIRE;
+        } else if (source == DamageSource.STARVE) {
+            cause = DamageCause.STARVATION;
+        } else if (source == DamageSource.WITHER) {
+            cause = DamageCause.WITHER;
+        } else if (source == DamageSource.STUCK) {
+            cause = DamageCause.SUFFOCATION;
+        } else if (source == DamageSource.DROWN) {
+            cause = DamageCause.DROWNING;
+        } else if (source == DamageSource.BURN) {
+            cause = DamageCause.FIRE_TICK;
+        } else if (source == MELTING) {
+            cause = DamageCause.MELTING;
+        } else if (source == POISON) {
+            cause = DamageCause.POISON;
+        } else if (source == DamageSource.MAGIC) {
+            cause = DamageCause.MAGIC;
+        } else if (source == DamageSource.FALL) {
+            cause = DamageCause.FALL;
+        } else if (source == DamageSource.FLY_INTO_WALL) {
+            cause = DamageCause.FLY_INTO_WALL;
+        } else if (source == DamageSource.GENERIC) {
+            cause = DamageCause.CUSTOM;
+        }
+
+        if (cause != null) {
+            return callEntityDamageEvent(null, entity, cause, modifiers, modifierFunctions);
+        }
+        return callEntityDamageEvent(null, entity, DamageCause.CONTACT, modifiers, modifierFunctions);
+        //throw new IllegalStateException(String.format("Unhandled damage of %s from %s", entity, source.translationIndex));
+    }
+
+    private static EntityDamageEvent callEntityDamageEvent(Entity damager, Entity damagee, DamageCause cause, Map<DamageModifier, Double> modifiers, Map<DamageModifier, Function<? super Double, Double>> modifierFunctions) {
+        EntityDamageEvent event;
+        if (damager != null) {
+            event = new EntityDamageByEntityEvent(damager.getBukkitEntity(), damagee.getBukkitEntity(), cause, modifiers, modifierFunctions);
+        } else {
+            event = new EntityDamageEvent(damagee.getBukkitEntity(), cause, modifiers, modifierFunctions);
+        }
+
+        callEvent(event);
+
+        if (!event.isCancelled()) {
+            event.getEntity().setLastDamageCause(event);
+        }
+
+        return event;
+    }
+
+    private static final Function<? super Double, Double> ZERO = Functions.constant(-0.0);
+
+    public static EntityDamageEvent handleLivingEntityDamageEvent(Entity damagee, DamageSource source, double rawDamage, double hardHatModifier, double blockingModifier, double armorModifier, double resistanceModifier, double magicModifier, double absorptionModifier, Function<Double, Double> hardHat, Function<Double, Double> blocking, Function<Double, Double> armor, Function<Double, Double> resistance, Function<Double, Double> magic, Function<Double, Double> absorption) {
+            Map<DamageModifier, Double> modifiers = new EnumMap<DamageModifier, Double>(DamageModifier.class);
+        Map<DamageModifier, Function<? super Double, Double>> modifierFunctions = new EnumMap<DamageModifier, Function<? super Double, Double>>(DamageModifier.class);
+        modifiers.put(DamageModifier.BASE, rawDamage);
+        modifierFunctions.put(DamageModifier.BASE, ZERO);
+        if (source == DamageSource.FALLING_BLOCK || source == DamageSource.ANVIL) {
+            modifiers.put(DamageModifier.HARD_HAT, hardHatModifier);
+            modifierFunctions.put(DamageModifier.HARD_HAT, hardHat);
+        }
+        if (damagee instanceof EntityHuman) {
+            modifiers.put(DamageModifier.BLOCKING, blockingModifier);
+            modifierFunctions.put(DamageModifier.BLOCKING, blocking);
+        }
+        modifiers.put(DamageModifier.ARMOR, armorModifier);
+        modifierFunctions.put(DamageModifier.ARMOR, armor);
+        modifiers.put(DamageModifier.RESISTANCE, resistanceModifier);
+        modifierFunctions.put(DamageModifier.RESISTANCE, resistance);
+        modifiers.put(DamageModifier.MAGIC, magicModifier);
+        modifierFunctions.put(DamageModifier.MAGIC, magic);
+        modifiers.put(DamageModifier.ABSORPTION, absorptionModifier);
+        modifierFunctions.put(DamageModifier.ABSORPTION, absorption);
+        return handleEntityDamageEvent(damagee, source, modifiers, modifierFunctions);
+    }
+
+    // Non-Living Entities such as EntityEnderCrystal and EntityFireball need to call this
+    public static boolean handleNonLivingEntityDamageEvent(Entity entity, DamageSource source, double damage) {
+        return handleNonLivingEntityDamageEvent(entity, source, damage, true);
+    }
+
+    public static boolean handleNonLivingEntityDamageEvent(Entity entity, DamageSource source, double damage, boolean cancelOnZeroDamage) {
+        if (entity instanceof EntityEnderCrystal && !(source instanceof EntityDamageSource)) {
+            return false;
+        }
+
+        final EnumMap<DamageModifier, Double> modifiers = new EnumMap<DamageModifier, Double>(DamageModifier.class);
+        final EnumMap<DamageModifier, Function<? super Double, Double>> functions = new EnumMap(DamageModifier.class);
+
+        modifiers.put(DamageModifier.BASE, damage);
+        functions.put(DamageModifier.BASE, ZERO);
+
+        final EntityDamageEvent event = handleEntityDamageEvent(entity, source, modifiers, functions);
+        if (event == null) {
+            return false;
+        }
+        return event.isCancelled() || (cancelOnZeroDamage && event.getDamage() == 0);
+    }
+
+    public static PlayerLevelChangeEvent callPlayerLevelChangeEvent(Player player, int oldLevel, int newLevel) {
+        PlayerLevelChangeEvent event = new PlayerLevelChangeEvent(player, oldLevel, newLevel);
+        Bukkit.getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static PlayerExpChangeEvent callPlayerExpChangeEvent(EntityHuman entity, int expAmount) {
+        Player player = (Player) entity.getBukkitEntity();
+        PlayerExpChangeEvent event = new PlayerExpChangeEvent(player, expAmount);
+        Bukkit.getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static boolean handleBlockGrowEvent(World world, int x, int y, int z, net.minecraft.server.Block type, int data) {
+        Block block = world.getWorld().getBlockAt(x, y, z);
+        CraftBlockState state = (CraftBlockState) block.getState();
+        state.setTypeId(net.minecraft.server.Block.getId(type));
+        state.setRawData((byte) data);
+
+        BlockGrowEvent event = new BlockGrowEvent(block, state);
+        Bukkit.getPluginManager().callEvent(event);
+
+        if (!event.isCancelled()) {
+            state.update(true);
+        }
+        
+        return !event.isCancelled();
+    }
+
+    public static FoodLevelChangeEvent callFoodLevelChangeEvent(EntityHuman entity, int level) {
+        FoodLevelChangeEvent event = new FoodLevelChangeEvent(entity.getBukkitEntity(), level);
+        entity.getBukkitEntity().getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static PigZapEvent callPigZapEvent(Entity pig, Entity lightning, Entity pigzombie) {
+        PigZapEvent event = new PigZapEvent((Pig) pig.getBukkitEntity(), (LightningStrike) lightning.getBukkitEntity(), (PigZombie) pigzombie.getBukkitEntity());
+        pig.getBukkitEntity().getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static HorseJumpEvent callHorseJumpEvent(Entity horse, float power) {
+        HorseJumpEvent event = new HorseJumpEvent((Horse) horse.getBukkitEntity(), power);
+        horse.getBukkitEntity().getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static EntityChangeBlockEvent callEntityChangeBlockEvent(org.bukkit.entity.Entity entity, Block block, Material material) {
+        return callEntityChangeBlockEvent(entity, block, material, 0);
+    }
+
+    public static EntityChangeBlockEvent callEntityChangeBlockEvent(Entity entity, Block block, Material material) {
+        return callEntityChangeBlockEvent(entity.getBukkitEntity(), block, material, 0);
+    }
+
+    public static EntityChangeBlockEvent callEntityChangeBlockEvent(Entity entity, Block block, Material material, boolean cancelled) {
+        return callEntityChangeBlockEvent(entity.getBukkitEntity(), block, material, 0, cancelled);
+    }
+
+    public static EntityChangeBlockEvent callEntityChangeBlockEvent(Entity entity, BlockPosition position, net.minecraft.server.Block type, int data) {
+        Block block = entity.world.getWorld().getBlockAt(position.getX(), position.getY(), position.getZ());
+        Material material = CraftMagicNumbers.getMaterial(type);
+
+        return callEntityChangeBlockEvent(entity.getBukkitEntity(), block, material, data);
+    }
+
+    public static EntityChangeBlockEvent callEntityChangeBlockEvent(org.bukkit.entity.Entity entity, Block block, Material material, int data) {
+        return callEntityChangeBlockEvent(entity, block, material, data, false);
+    }
+
+    public static EntityChangeBlockEvent callEntityChangeBlockEvent(org.bukkit.entity.Entity entity, Block block, Material material, int data, boolean cancelled) {
+        EntityChangeBlockEvent event = new EntityChangeBlockEvent(entity, block, material, (byte) data);
+        event.setCancelled(cancelled);
+        entity.getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static CreeperPowerEvent callCreeperPowerEvent(Entity creeper, Entity lightning, CreeperPowerEvent.PowerCause cause) {
+        CreeperPowerEvent event = new CreeperPowerEvent((Creeper) creeper.getBukkitEntity(), (LightningStrike) lightning.getBukkitEntity(), cause);
+        creeper.getBukkitEntity().getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static EntityTargetEvent callEntityTargetEvent(Entity entity, Entity target, EntityTargetEvent.TargetReason reason) {
+        EntityTargetEvent event = new EntityTargetEvent(entity.getBukkitEntity(), target == null ? null : target.getBukkitEntity(), reason);
+        entity.getBukkitEntity().getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static EntityTargetLivingEntityEvent callEntityTargetLivingEvent(Entity entity, EntityLiving target, EntityTargetEvent.TargetReason reason) {
+        EntityTargetLivingEntityEvent event = new EntityTargetLivingEntityEvent(entity.getBukkitEntity(), (LivingEntity) target.getBukkitEntity(), reason);
+        entity.getBukkitEntity().getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static EntityBreakDoorEvent callEntityBreakDoorEvent(Entity entity, int x, int y, int z) {
+        org.bukkit.entity.Entity entity1 = entity.getBukkitEntity();
+        Block block = entity1.getWorld().getBlockAt(x, y, z);
+
+        EntityBreakDoorEvent event = new EntityBreakDoorEvent((LivingEntity) entity1, block);
+        entity1.getServer().getPluginManager().callEvent(event);
+
+        return event;
+    }
+
+    public static Container callInventoryOpenEvent(EntityPlayer player, Container container) {
+        return callInventoryOpenEvent(player, container, false);
+    }
+
+    public static Container callInventoryOpenEvent(EntityPlayer player, Container container, boolean cancelled) {
+        if (player.activeContainer != player.defaultContainer) { // fire INVENTORY_CLOSE if one already open
+            player.playerConnection.a(new PacketPlayInCloseWindow(player.activeContainer.windowId));
+        }
+
+        CraftServer server = player.world.getServer();
+        CraftPlayer craftPlayer = player.getBukkitEntity();
+        player.activeContainer.transferTo(container, craftPlayer);
+
+        InventoryOpenEvent event = new InventoryOpenEvent(container.getBukkitView());
+        event.setCancelled(cancelled);
+        server.getPluginManager().callEvent(event);
+
+        if (event.isCancelled()) {
+            container.transferTo(player.activeContainer, craftPlayer);
+            return null;
+        }
+
+        return container;
+    }
+
+    public static ItemStack callPreCraftEvent(InventoryCrafting matrix, ItemStack result, InventoryView lastCraftView, boolean isRepair) {
+        CraftInventoryCrafting inventory = new CraftInventoryCrafting(matrix, matrix.resultInventory);
+        inventory.setResult(CraftItemStack.asCraftMirror(result));
+
+        PrepareItemCraftEvent event = new PrepareItemCraftEvent(inventory, lastCraftView, isRepair);
+        Bukkit.getPluginManager().callEvent(event);
+
+        org.bukkit.inventory.ItemStack bitem = event.getInventory().getResult();
+
+        return CraftItemStack.asNMSCopy(bitem);
+    }
+
+    public static ProjectileLaunchEvent callProjectileLaunchEvent(Entity entity) {
+        Projectile bukkitEntity = (Projectile) entity.getBukkitEntity();
+        ProjectileLaunchEvent event = new ProjectileLaunchEvent(bukkitEntity);
+        Bukkit.getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static ProjectileHitEvent callProjectileHitEvent(Entity entity) {
+        ProjectileHitEvent event = new ProjectileHitEvent((Projectile) entity.getBukkitEntity());
+        entity.world.getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static ExpBottleEvent callExpBottleEvent(Entity entity, int exp) {
+        ThrownExpBottle bottle = (ThrownExpBottle) entity.getBukkitEntity();
+        ExpBottleEvent event = new ExpBottleEvent(bottle, exp);
+        Bukkit.getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static BlockRedstoneEvent callRedstoneChange(World world, int x, int y, int z, int oldCurrent, int newCurrent) {
+        BlockRedstoneEvent event = new BlockRedstoneEvent(world.getWorld().getBlockAt(x, y, z), oldCurrent, newCurrent);
+        world.getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static NotePlayEvent callNotePlayEvent(World world, int x, int y, int z, byte instrument, byte note) {
+        NotePlayEvent event = new NotePlayEvent(world.getWorld().getBlockAt(x, y, z), org.bukkit.Instrument.getByType(instrument), new org.bukkit.Note(note));
+        world.getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static void callPlayerItemBreakEvent(EntityHuman human, ItemStack brokenItem) {
+        CraftItemStack item = CraftItemStack.asCraftMirror(brokenItem);
+        PlayerItemBreakEvent event = new PlayerItemBreakEvent((Player) human.getBukkitEntity(), item);
+        Bukkit.getPluginManager().callEvent(event);
+    }
+
+    public static BlockIgniteEvent callBlockIgniteEvent(World world, int x, int y, int z, int igniterX, int igniterY, int igniterZ) {
+        org.bukkit.World bukkitWorld = world.getWorld();
+        Block igniter = bukkitWorld.getBlockAt(igniterX, igniterY, igniterZ);
+        IgniteCause cause;
+        switch (igniter.getType()) {
+            case LAVA:
+            case STATIONARY_LAVA:
+                cause = IgniteCause.LAVA;
+                break;
+            case DISPENSER:
+                cause = IgniteCause.FLINT_AND_STEEL;
+                break;
+            case FIRE: // Fire or any other unknown block counts as SPREAD.
+            default:
+                cause = IgniteCause.SPREAD;
+        }
+
+        BlockIgniteEvent event = new BlockIgniteEvent(bukkitWorld.getBlockAt(x, y, z), cause, igniter);
+        world.getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static BlockIgniteEvent callBlockIgniteEvent(World world, int x, int y, int z, Entity igniter) {
+        org.bukkit.World bukkitWorld = world.getWorld();
+        org.bukkit.entity.Entity bukkitIgniter = igniter.getBukkitEntity();
+        IgniteCause cause;
+        switch (bukkitIgniter.getType()) {
+        case ENDER_CRYSTAL:
+            cause = IgniteCause.ENDER_CRYSTAL;
+            break;
+        case LIGHTNING:
+            cause = IgniteCause.LIGHTNING;
+            break;
+        case SMALL_FIREBALL:
+        case FIREBALL:
+            cause = IgniteCause.FIREBALL;
+            break;
+        default:
+            cause = IgniteCause.FLINT_AND_STEEL;
+        }
+
+        BlockIgniteEvent event = new BlockIgniteEvent(bukkitWorld.getBlockAt(x, y, z), cause, bukkitIgniter);
+        world.getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static BlockIgniteEvent callBlockIgniteEvent(World world, int x, int y, int z, Explosion explosion) {
+        org.bukkit.World bukkitWorld = world.getWorld();
+        org.bukkit.entity.Entity igniter = explosion.source == null ? null : explosion.source.getBukkitEntity();
+
+        BlockIgniteEvent event = new BlockIgniteEvent(bukkitWorld.getBlockAt(x, y, z), IgniteCause.EXPLOSION, igniter);
+        world.getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static BlockIgniteEvent callBlockIgniteEvent(World world, int x, int y, int z, IgniteCause cause, Entity igniter) {
+        BlockIgniteEvent event = new BlockIgniteEvent(world.getWorld().getBlockAt(x, y, z), cause, igniter.getBukkitEntity());
+        world.getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static void handleInventoryCloseEvent(EntityHuman human) {
+        InventoryCloseEvent event = new InventoryCloseEvent(human.activeContainer.getBukkitView());
+        human.world.getServer().getPluginManager().callEvent(event);
+        human.activeContainer.transferTo(human.defaultContainer, human.getBukkitEntity());
+    }
+
+    public static void handleEditBookEvent(EntityPlayer player, ItemStack newBookItem) {
+        int itemInHandIndex = player.inventory.itemInHandIndex;
+
+        PlayerEditBookEvent editBookEvent = new PlayerEditBookEvent(player.getBukkitEntity(), player.inventory.itemInHandIndex, (BookMeta) CraftItemStack.getItemMeta(player.inventory.getItemInHand()), (BookMeta) CraftItemStack.getItemMeta(newBookItem), newBookItem.getItem() == Items.WRITTEN_BOOK);
+        player.world.getServer().getPluginManager().callEvent(editBookEvent);
+        ItemStack itemInHand = player.inventory.getItem(itemInHandIndex);
+
+        // If they've got the same item in their hand, it'll need to be updated.
+        if (itemInHand != null && itemInHand.getItem() == Items.WRITABLE_BOOK) {
+            if (!editBookEvent.isCancelled()) {
+                if (editBookEvent.isSigning()) {
+                    itemInHand.setItem(Items.WRITTEN_BOOK);
+                }
+                CraftMetaBook meta = (CraftMetaBook) editBookEvent.getNewBookMeta();
+                List<IChatBaseComponent> pages = meta.pages;
+                for (int i = 0; i < pages.size(); i++) {
+                    pages.set(i, stripEvents(pages.get(i)));
+                }
+                CraftItemStack.setItemMeta(itemInHand, meta);
+            }
+
+            // Client will have updated its idea of the book item; we need to overwrite that
+            Slot slot = player.activeContainer.getSlot(player.inventory, itemInHandIndex);
+            player.playerConnection.sendPacket(new PacketPlayOutSetSlot(player.activeContainer.windowId, slot.rawSlotIndex, itemInHand));
+        }
+    }
+
+    private static IChatBaseComponent stripEvents(IChatBaseComponent c) {
+        ChatModifier modi = c.getChatModifier();
+        if (modi != null) {
+            modi.setChatClickable(null);
+            modi.setChatHoverable(null);
+        }
+        c.setChatModifier(modi);
+        if (c instanceof ChatMessage) {
+            ChatMessage cm = (ChatMessage) c;
+            Object[] oo = cm.j();
+            for (int i = 0; i < oo.length; i++) {
+                Object o = oo[i];
+                if (o instanceof IChatBaseComponent) {
+                    oo[i] = stripEvents((IChatBaseComponent) o);
+                }
+            }
+        }
+        List<IChatBaseComponent> ls = c.a();
+        if (ls != null) {
+            for (int i = 0; i < ls.size(); i++) {
+                ls.set(i, stripEvents(ls.get(i)));
+            }
+        }
+        return c;
+    }
+
+    public static PlayerUnleashEntityEvent callPlayerUnleashEntityEvent(EntityInsentient entity, EntityHuman player) {
+        PlayerUnleashEntityEvent event = new PlayerUnleashEntityEvent(entity.getBukkitEntity(), (Player) player.getBukkitEntity());
+        entity.world.getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static PlayerLeashEntityEvent callPlayerLeashEntityEvent(EntityInsentient entity, Entity leashHolder, EntityHuman player) {
+        PlayerLeashEntityEvent event = new PlayerLeashEntityEvent(entity.getBukkitEntity(), leashHolder.getBukkitEntity(), (Player) player.getBukkitEntity());
+        entity.world.getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static Cancellable handleStatisticsIncrease(EntityHuman entityHuman, net.minecraft.server.Statistic statistic, int current, int incrementation) {
+        Player player = ((EntityPlayer) entityHuman).getBukkitEntity();
+        Event event;
+        if (statistic instanceof net.minecraft.server.Achievement) {
+            if (current != 0) {
+                return null;
+            }
+            event = new PlayerAchievementAwardedEvent(player, CraftStatistic.getBukkitAchievement((net.minecraft.server.Achievement) statistic));
+        } else {
+            org.bukkit.Statistic stat = CraftStatistic.getBukkitStatistic(statistic);
+            if (stat == null) {
+                System.err.println("Unhandled statistic: " + statistic);
+                return null;
+            }
+            switch (stat) {
+                case FALL_ONE_CM:
+                case BOAT_ONE_CM:
+                case CLIMB_ONE_CM:
+                case DIVE_ONE_CM:
+                case FLY_ONE_CM:
+                case HORSE_ONE_CM:
+                case MINECART_ONE_CM:
+                case PIG_ONE_CM:
+                case PLAY_ONE_TICK:
+                case SWIM_ONE_CM:
+                case WALK_ONE_CM:
+                case SPRINT_ONE_CM:
+                case CROUCH_ONE_CM:
+                case TIME_SINCE_DEATH:
+                case SNEAK_TIME:
+                    // Do not process event for these - too spammy
+                    return null;
+                default:
+            }
+            if (stat.getType() == Type.UNTYPED) {
+                event = new PlayerStatisticIncrementEvent(player, stat, current, current + incrementation);
+            } else if (stat.getType() == Type.ENTITY) {
+                EntityType entityType = CraftStatistic.getEntityTypeFromStatistic(statistic);
+                event = new PlayerStatisticIncrementEvent(player, stat, current, current + incrementation, entityType);
+            } else {
+                Material material = CraftStatistic.getMaterialFromStatistic(statistic);
+                event = new PlayerStatisticIncrementEvent(player, stat, current, current + incrementation, material);
+            }
+        }
+        entityHuman.world.getServer().getPluginManager().callEvent(event);
+        return (Cancellable) event;
+    }
+
+    public static FireworkExplodeEvent callFireworkExplodeEvent(EntityFireworks firework) {
+        FireworkExplodeEvent event = new FireworkExplodeEvent((Firework) firework.getBukkitEntity());
+        firework.world.getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static PrepareAnvilEvent callPrepareAnvilEvent(InventoryView view, ItemStack item) {
+        PrepareAnvilEvent event = new PrepareAnvilEvent(view, CraftItemStack.asCraftMirror(item).clone());
+        event.getView().getPlayer().getServer().getPluginManager().callEvent(event);
+        event.getInventory().setItem(2, event.getResult());
+        return event;
+    }
+
+    /**
+     * Mob spawner event.
+     */
+    public static SpawnerSpawnEvent callSpawnerSpawnEvent(Entity spawnee, BlockPosition pos) {
+        org.bukkit.craftbukkit.entity.CraftEntity entity = spawnee.getBukkitEntity();
+        BlockState state = entity.getWorld().getBlockAt(pos.getX(), pos.getY(), pos.getZ()).getState();
+        if (!(state instanceof org.bukkit.block.CreatureSpawner)) {
+            state = null;
+        }
+
+        SpawnerSpawnEvent event = new SpawnerSpawnEvent(entity, (org.bukkit.block.CreatureSpawner) state);
+        entity.getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+    public static EntityToggleGlideEvent callToggleGlideEvent(EntityLiving entity, boolean gliding) {
+        EntityToggleGlideEvent event = new EntityToggleGlideEvent((LivingEntity) entity.getBukkitEntity(), gliding);
+        entity.world.getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+
+	public static AreaEffectCloudApplyEvent callAreaEffectCloudApplyEvent(EntityAreaEffectCloud cloud, List<LivingEntity> entities) {
+		AreaEffectCloudApplyEvent event = new AreaEffectCloudApplyEvent((AreaEffectCloud) cloud.getBukkitEntity(), entities);
+		cloud.world.getServer().getPluginManager().callEvent(event);
+		return event;
+	}
+
+    public static EntityBreedEvent callEntityBreedEvent(EntityLiving child, EntityLiving mother, EntityLiving father, EntityLiving breeder, ItemStack bredWith, int experience) {
+        org.bukkit.entity.LivingEntity breederEntity = (LivingEntity)(breeder == null ? null : breeder.getBukkitEntity());
+        CraftItemStack bredWithStack = bredWith == null ? null : CraftItemStack.asCraftMirror(bredWith).clone();
+
+        EntityBreedEvent event = new EntityBreedEvent((LivingEntity) child.getBukkitEntity(), (LivingEntity) mother.getBukkitEntity(), (LivingEntity) father.getBukkitEntity(), breederEntity, bredWithStack, experience);
+        child.world.getServer().getPluginManager().callEvent(event);
+        return event;
+    }
+}
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-08-25 22:39:55.718602338 +0800
+++ src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-08-26 03:24:18.146198812 +0800
@@ -1,117 +1,127 @@
-package org.bukkit.craftbukkit.util;
-
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Set;
-import java.util.TreeSet;
-
-public class HashTreeSet<V> implements Set<V> {
-
-    private HashSet<V> hash = new HashSet<V>();
-    private TreeSet<V> tree = new TreeSet<V>();
-
-    public HashTreeSet() {
-
-    }
-
-    @Override
-    public int size() {
-        return hash.size();
-    }
-
-    @Override
-    public boolean isEmpty() {
-        return hash.isEmpty();
-    }
-
-    @Override
-    public boolean contains(Object o) {
-        return hash.contains(o);
-    }
-
-    @Override
-    public Iterator<V> iterator() {
-        return new Iterator<V>() {
-
-            private Iterator<V> it = tree.iterator();
-            private V last;
-
-            @Override
-            public boolean hasNext() {
-                return it.hasNext();
-            }
-
-            @Override
-            public V next() {
-                return last = it.next();
-            }
-
-            @Override
-            public void remove() {
-                if (last == null) {
-                    throw new IllegalStateException();
-                }
-                it.remove();
-                hash.remove(last);
-                last = null;
-            }
-        };
-    }
-
-    @Override
-    public Object[] toArray() {
-        return hash.toArray();
-    }
-
-    @Override
-    public Object[] toArray(Object[] a) {
-        return hash.toArray(a);
-    }
-
-    @Override
-    public boolean add(V e) {
-        hash.add(e);
-        return tree.add(e);
-    }
-
-    @Override
-    public boolean remove(Object o) {
-        hash.remove(o);
-        return tree.remove(o);
-    }
-
-    @Override
-    public boolean containsAll(Collection c) {
-        return hash.containsAll(c);
-    }
-
-    @Override
-    public boolean addAll(Collection c) {
-        tree.addAll(c);
-        return hash.addAll(c);
-    }
-
-    @Override
-    public boolean retainAll(Collection c) {
-        tree.retainAll(c);
-        return hash.retainAll(c);
-    }
-
-    @Override
-    public boolean removeAll(Collection c) {
-        tree.removeAll(c);
-        return hash.removeAll(c);
-    }
-
-    @Override
-    public void clear() {
-        hash.clear();
-        tree.clear();
-    }
-
-    public V first() {
-        return tree.first();
-    }
-
-}
+package org.bukkit.craftbukkit.util;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+import java.util.SortedSet;
+import java.util.TreeSet;
+import java.util.concurrent.ConcurrentSkipListSet;
+
+public class HashTreeSet<V> implements Set<V> {
+
+    private HashSet<V> hash = new HashSet<V>();
+    //private TreeSet<V> tree = new TreeSet<V>();
+    private ConcurrentSkipListSet<V> tree = new ConcurrentSkipListSet<V>();
+    
+    public HashTreeSet() {
+
+    }
+
+    @Override
+    public int size() {
+        return hash.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return hash.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return hash.contains(o);
+    }
+
+    @Override
+    public Iterator<V> iterator() {
+        return new Iterator<V>() {
+
+            private Iterator<V> it = tree.iterator();
+            private V last;
+
+            @Override
+            public boolean hasNext() {
+                return it.hasNext();
+            }
+
+            @Override
+            public V next() {
+                return last = it.next();
+            }
+
+            @Override
+            public void remove() {
+                if (last == null) {
+                    throw new IllegalStateException();
+                }
+                it.remove();
+                hash.remove(last);
+                last = null;
+            }
+        };
+    }
+
+    @Override
+    public Object[] toArray() {
+        return hash.toArray();
+    }
+
+    @Override
+    public Object[] toArray(Object[] a) {
+        return hash.toArray(a);
+    }
+
+    @Override
+    public boolean add(V e) {
+        hash.add(e);
+        return tree.add(e);
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        hash.remove(o);
+        return tree.remove(o);
+    }
+
+    @Override
+    public boolean containsAll(Collection c) {
+        return hash.containsAll(c);
+    }
+
+    @Override
+    public boolean addAll(Collection c) {
+        tree.addAll(c);
+        return hash.addAll(c);
+    }
+
+    @Override
+    public boolean retainAll(Collection c) {
+        tree.retainAll(c);
+        return hash.retainAll(c);
+    }
+
+    @Override
+    public boolean removeAll(Collection c) {
+        tree.removeAll(c);
+        return hash.removeAll(c);
+    }
+
+    @Override
+    public void clear() {
+        hash.clear();
+        tree.clear();
+    }
+
+    public V first() {
+        //return tree.first();
+        if (tree.first() != null) {
+            return tree.first();
+        } else {
+            this.remove(tree.first());
+            return this.first();
+        }
+    }
+
+}
diff -Naur src_origin/main/java/org/spigotmc/ActivationRange.java src/main/java/org/spigotmc/ActivationRange.java
--- src_origin/main/java/org/spigotmc/ActivationRange.java	2016-08-25 22:39:49.698601775 +0800
+++ src/main/java/org/spigotmc/ActivationRange.java	2016-08-26 03:24:12.102198247 +0800
@@ -1,287 +1,289 @@
-package org.spigotmc;
-
-import java.util.List;
-import java.util.Set;
-import net.minecraft.server.AxisAlignedBB;
-import net.minecraft.server.Chunk;
-import net.minecraft.server.Entity;
-import net.minecraft.server.EntityAmbient;
-import net.minecraft.server.EntityAnimal;
-import net.minecraft.server.EntityArrow;
-import net.minecraft.server.EntityComplexPart;
-import net.minecraft.server.EntityCreature;
-import net.minecraft.server.EntityCreeper;
-import net.minecraft.server.EntityEnderCrystal;
-import net.minecraft.server.EntityEnderDragon;
-import net.minecraft.server.EntityFireball;
-import net.minecraft.server.EntityFireworks;
-import net.minecraft.server.EntityHuman;
-import net.minecraft.server.EntityLiving;
-import net.minecraft.server.EntityMonster;
-import net.minecraft.server.EntityProjectile;
-import net.minecraft.server.EntitySheep;
-import net.minecraft.server.EntitySlice;
-import net.minecraft.server.EntitySlime;
-import net.minecraft.server.EntityTNTPrimed;
-import net.minecraft.server.EntityVillager;
-import net.minecraft.server.EntityWeather;
-import net.minecraft.server.EntityWither;
-import net.minecraft.server.MathHelper;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.server.World;
-import org.bukkit.craftbukkit.SpigotTimings;
-
-public class ActivationRange
-{
-
-    static AxisAlignedBB maxBB = new AxisAlignedBB( 0, 0, 0, 0, 0, 0 );
-    static AxisAlignedBB miscBB = new AxisAlignedBB( 0, 0, 0, 0, 0, 0 );
-    static AxisAlignedBB animalBB = new AxisAlignedBB( 0, 0, 0, 0, 0, 0 );
-    static AxisAlignedBB monsterBB = new AxisAlignedBB( 0, 0, 0, 0, 0, 0 );
-
-    /**
-     * Initializes an entities type on construction to specify what group this
-     * entity is in for activation ranges.
-     *
-     * @param entity
-     * @return group id
-     */
-    public static byte initializeEntityActivationType(Entity entity)
-    {
-        if ( entity instanceof EntityMonster || entity instanceof EntitySlime )
-        {
-            return 1; // Monster
-        } else if ( entity instanceof EntityCreature || entity instanceof EntityAmbient )
-        {
-            return 2; // Animal
-        } else
-        {
-            return 3; // Misc
-        }
-    }
-
-    /**
-     * These entities are excluded from Activation range checks.
-     *
-     * @param entity
-     * @param world
-     * @return boolean If it should always tick.
-     */
-    public static boolean initializeEntityActivationState(Entity entity, SpigotWorldConfig config)
-    {
-        if ( ( entity.activationType == 3 && config.miscActivationRange == 0 )
-                || ( entity.activationType == 2 && config.animalActivationRange == 0 )
-                || ( entity.activationType == 1 && config.monsterActivationRange == 0 )
-                || entity instanceof EntityHuman
-                || entity instanceof EntityProjectile
-                || entity instanceof EntityEnderDragon
-                || entity instanceof EntityComplexPart
-                || entity instanceof EntityWither
-                || entity instanceof EntityFireball
-                || entity instanceof EntityWeather
-                || entity instanceof EntityTNTPrimed
-                || entity instanceof EntityEnderCrystal
-                || entity instanceof EntityFireworks )
-        {
-            return true;
-        }
-
-        return false;
-    }
-
-    /**
-     * Find what entities are in range of the players in the world and set
-     * active if in range.
-     *
-     * @param world
-     */
-    public static void activateEntities(World world)
-    {
-        SpigotTimings.entityActivationCheckTimer.startTiming();
-        final int miscActivationRange = world.spigotConfig.miscActivationRange;
-        final int animalActivationRange = world.spigotConfig.animalActivationRange;
-        final int monsterActivationRange = world.spigotConfig.monsterActivationRange;
-
-        int maxRange = Math.max( monsterActivationRange, animalActivationRange );
-        maxRange = Math.max( maxRange, miscActivationRange );
-        maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange );
-
-        for ( EntityHuman player : world.players )
-        {
-
-            player.activatedTick = MinecraftServer.currentTick;
-            maxBB = player.getBoundingBox().grow( maxRange, 256, maxRange );
-            miscBB = player.getBoundingBox().grow( miscActivationRange, 256, miscActivationRange );
-            animalBB = player.getBoundingBox().grow( animalActivationRange, 256, animalActivationRange );
-            monsterBB = player.getBoundingBox().grow( monsterActivationRange, 256, monsterActivationRange );
-
-            int i = MathHelper.floor( maxBB.a / 16.0D );
-            int j = MathHelper.floor( maxBB.d / 16.0D );
-            int k = MathHelper.floor( maxBB.c / 16.0D );
-            int l = MathHelper.floor( maxBB.f / 16.0D );
-
-            for ( int i1 = i; i1 <= j; ++i1 )
-            {
-                for ( int j1 = k; j1 <= l; ++j1 )
-                {
-                    if ( world.getWorld().isChunkLoaded( i1, j1 ) )
-                    {
-                        activateChunkEntities( world.getChunkAt( i1, j1 ) );
-                    }
-                }
-            }
-        }
-        SpigotTimings.entityActivationCheckTimer.stopTiming();
-    }
-
-    /**
-     * Checks for the activation state of all entities in this chunk.
-     *
-     * @param chunk
-     */
-    private static void activateChunkEntities(Chunk chunk)
-    {
-        for ( List<Entity> slice : chunk.entitySlices )
-        {
-            for ( Entity entity : slice )
-            {
-                if ( MinecraftServer.currentTick > entity.activatedTick )
-                {
-                    if ( entity.defaultActivationState )
-                    {
-                        entity.activatedTick = MinecraftServer.currentTick;
-                        continue;
-                    }
-                    switch ( entity.activationType )
-                    {
-                        case 1:
-                            if ( monsterBB.b( entity.getBoundingBox() ) )
-                            {
-                                entity.activatedTick = MinecraftServer.currentTick;
-                            }
-                            break;
-                        case 2:
-                            if ( animalBB.b( entity.getBoundingBox() ) )
-                            {
-                                entity.activatedTick = MinecraftServer.currentTick;
-                            }
-                            break;
-                        case 3:
-                        default:
-                            if ( miscBB.b( entity.getBoundingBox() ) )
-                            {
-                                entity.activatedTick = MinecraftServer.currentTick;
-                            }
-                    }
-                }
-            }
-        }
-    }
-
-    /**
-     * If an entity is not in range, do some more checks to see if we should
-     * give it a shot.
-     *
-     * @param entity
-     * @return
-     */
-    public static boolean checkEntityImmunities(Entity entity)
-    {
-        // quick checks.
-        if ( entity.inWater || entity.fireTicks > 0 )
-        {
-            return true;
-        }
-        if ( !( entity instanceof EntityArrow ) )
-        {
-            if ( !entity.onGround || !entity.passengers.isEmpty() || entity.isPassenger() )
-            {
-                return true;
-            }
-        } else if ( !( (EntityArrow) entity ).inGround )
-        {
-            return true;
-        }
-        // special cases.
-        if ( entity instanceof EntityLiving )
-        {
-            EntityLiving living = (EntityLiving) entity;
-            if ( /*TODO: Missed mapping? living.attackTicks > 0 || */ living.hurtTicks > 0 || living.effects.size() > 0 )
-            {
-                return true;
-            }
-            if ( entity instanceof EntityCreature && ( (EntityCreature) entity ).getGoalTarget() != null )
-            {
-                return true;
-            }
-            if ( entity instanceof EntityVillager && ( (EntityVillager) entity ).df()/* Getter for first boolean */ )
-            {
-                return true;
-            }
-            if ( entity instanceof EntityAnimal )
-            {
-                EntityAnimal animal = (EntityAnimal) entity;
-                if ( animal.isBaby() || animal.isInLove() )
-                {
-                    return true;
-                }
-                if ( entity instanceof EntitySheep && ( (EntitySheep) entity ).isSheared() )
-                {
-                    return true;
-                }
-            }
-            if (entity instanceof EntityCreeper && ((EntityCreeper) entity).isIgnited()) { // isExplosive
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Checks if the entity is active for this tick.
-     *
-     * @param entity
-     * @return
-     */
-    public static boolean checkIfActive(Entity entity)
-    {
-        SpigotTimings.checkIfActiveTimer.startTiming();
-        // Never safe to skip fireworks or entities not yet added to chunk
-        // PAIL: inChunk
-        if ( !entity.ab || entity instanceof EntityFireworks ) {
-            SpigotTimings.checkIfActiveTimer.stopTiming();
-            return true;
-        }
-
-        boolean isActive = entity.activatedTick >= MinecraftServer.currentTick || entity.defaultActivationState;
-
-        // Should this entity tick?
-        if ( !isActive )
-        {
-            if ( ( MinecraftServer.currentTick - entity.activatedTick - 1 ) % 20 == 0 )
-            {
-                // Check immunities every 20 ticks.
-                if ( checkEntityImmunities( entity ) )
-                {
-                    // Triggered some sort of immunity, give 20 full ticks before we check again.
-                    entity.activatedTick = MinecraftServer.currentTick + 20;
-                }
-                isActive = true;
-            }
-            // Add a little performance juice to active entities. Skip 1/4 if not immune.
-        } else if ( !entity.defaultActivationState && entity.ticksLived % 4 == 0 && !checkEntityImmunities( entity ) )
-        {
-            isActive = false;
-        }
-        int x = MathHelper.floor( entity.locX );
-        int z = MathHelper.floor( entity.locZ );
-        // Make sure not on edge of unloaded chunk
-        Chunk chunk = entity.world.getChunkIfLoaded( x >> 4, z >> 4 );
-        if ( isActive && !( chunk != null && chunk.areNeighborsLoaded( 1 ) ) )
-        {
-            isActive = false;
-        }
-        SpigotTimings.checkIfActiveTimer.stopTiming();
-        return isActive;
-    }
-}
+package org.spigotmc;
+
+import java.util.List;
+import java.util.Queue;
+import java.util.Set;
+import net.minecraft.server.AxisAlignedBB;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityAmbient;
+import net.minecraft.server.EntityAnimal;
+import net.minecraft.server.EntityArrow;
+import net.minecraft.server.EntityComplexPart;
+import net.minecraft.server.EntityCreature;
+import net.minecraft.server.EntityCreeper;
+import net.minecraft.server.EntityEnderCrystal;
+import net.minecraft.server.EntityEnderDragon;
+import net.minecraft.server.EntityFireball;
+import net.minecraft.server.EntityFireworks;
+import net.minecraft.server.EntityHuman;
+import net.minecraft.server.EntityLiving;
+import net.minecraft.server.EntityMonster;
+import net.minecraft.server.EntityProjectile;
+import net.minecraft.server.EntitySheep;
+import net.minecraft.server.EntitySlice;
+import net.minecraft.server.EntitySlime;
+import net.minecraft.server.EntityTNTPrimed;
+import net.minecraft.server.EntityVillager;
+import net.minecraft.server.EntityWeather;
+import net.minecraft.server.EntityWither;
+import net.minecraft.server.MathHelper;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.World;
+import org.bukkit.craftbukkit.SpigotTimings;
+
+public class ActivationRange
+{
+
+    static AxisAlignedBB maxBB = new AxisAlignedBB( 0, 0, 0, 0, 0, 0 );
+    static AxisAlignedBB miscBB = new AxisAlignedBB( 0, 0, 0, 0, 0, 0 );
+    static AxisAlignedBB animalBB = new AxisAlignedBB( 0, 0, 0, 0, 0, 0 );
+    static AxisAlignedBB monsterBB = new AxisAlignedBB( 0, 0, 0, 0, 0, 0 );
+
+    /**
+     * Initializes an entities type on construction to specify what group this
+     * entity is in for activation ranges.
+     *
+     * @param entity
+     * @return group id
+     */
+    public static byte initializeEntityActivationType(Entity entity)
+    {
+        if ( entity instanceof EntityMonster || entity instanceof EntitySlime )
+        {
+            return 1; // Monster
+        } else if ( entity instanceof EntityCreature || entity instanceof EntityAmbient )
+        {
+            return 2; // Animal
+        } else
+        {
+            return 3; // Misc
+        }
+    }
+
+    /**
+     * These entities are excluded from Activation range checks.
+     *
+     * @param entity
+     * @param world
+     * @return boolean If it should always tick.
+     */
+    public static boolean initializeEntityActivationState(Entity entity, SpigotWorldConfig config)
+    {
+        if ( ( entity.activationType == 3 && config.miscActivationRange == 0 )
+                || ( entity.activationType == 2 && config.animalActivationRange == 0 )
+                || ( entity.activationType == 1 && config.monsterActivationRange == 0 )
+                || entity instanceof EntityHuman
+                || entity instanceof EntityProjectile
+                || entity instanceof EntityEnderDragon
+                || entity instanceof EntityComplexPart
+                || entity instanceof EntityWither
+                || entity instanceof EntityFireball
+                || entity instanceof EntityWeather
+                || entity instanceof EntityTNTPrimed
+                || entity instanceof EntityEnderCrystal
+                || entity instanceof EntityFireworks )
+        {
+            return true;
+        }
+
+        return false;
+    }
+
+    /**
+     * Find what entities are in range of the players in the world and set
+     * active if in range.
+     *
+     * @param world
+     */
+    public static void activateEntities(World world)
+    {
+        SpigotTimings.entityActivationCheckTimer.startTiming();
+        final int miscActivationRange = world.spigotConfig.miscActivationRange;
+        final int animalActivationRange = world.spigotConfig.animalActivationRange;
+        final int monsterActivationRange = world.spigotConfig.monsterActivationRange;
+
+        int maxRange = Math.max( monsterActivationRange, animalActivationRange );
+        maxRange = Math.max( maxRange, miscActivationRange );
+        maxRange = Math.min( ( world.spigotConfig.viewDistance << 4 ) - 8, maxRange );
+
+        for ( EntityHuman player : world.players )
+        {
+
+            player.activatedTick = MinecraftServer.currentTick;
+            maxBB = player.getBoundingBox().grow( maxRange, 256, maxRange );
+            miscBB = player.getBoundingBox().grow( miscActivationRange, 256, miscActivationRange );
+            animalBB = player.getBoundingBox().grow( animalActivationRange, 256, animalActivationRange );
+            monsterBB = player.getBoundingBox().grow( monsterActivationRange, 256, monsterActivationRange );
+
+            int i = MathHelper.floor( maxBB.a / 16.0D );
+            int j = MathHelper.floor( maxBB.d / 16.0D );
+            int k = MathHelper.floor( maxBB.c / 16.0D );
+            int l = MathHelper.floor( maxBB.f / 16.0D );
+
+            for ( int i1 = i; i1 <= j; ++i1 )
+            {
+                for ( int j1 = k; j1 <= l; ++j1 )
+                {
+                    if ( world.getWorld().isChunkLoaded( i1, j1 ) )
+                    {
+                        activateChunkEntities( world.getChunkAt( i1, j1 ) );
+                    }
+                }
+            }
+        }
+        SpigotTimings.entityActivationCheckTimer.stopTiming();
+    }
+
+    /**
+     * Checks for the activation state of all entities in this chunk.
+     *
+     * @param chunk
+     */
+    private static void activateChunkEntities(Chunk chunk)
+    {
+        //for ( List<Entity> slice : chunk.entitySlices )
+        for ( Queue<Entity> slice : chunk.entitySlices )
+        {
+            for ( Entity entity : slice )
+            {
+                if ( MinecraftServer.currentTick > entity.activatedTick )
+                {
+                    if ( entity.defaultActivationState )
+                    {
+                        entity.activatedTick = MinecraftServer.currentTick;
+                        continue;
+                    }
+                    switch ( entity.activationType )
+                    {
+                        case 1:
+                            if ( monsterBB.b( entity.getBoundingBox() ) )
+                            {
+                                entity.activatedTick = MinecraftServer.currentTick;
+                            }
+                            break;
+                        case 2:
+                            if ( animalBB.b( entity.getBoundingBox() ) )
+                            {
+                                entity.activatedTick = MinecraftServer.currentTick;
+                            }
+                            break;
+                        case 3:
+                        default:
+                            if ( miscBB.b( entity.getBoundingBox() ) )
+                            {
+                                entity.activatedTick = MinecraftServer.currentTick;
+                            }
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * If an entity is not in range, do some more checks to see if we should
+     * give it a shot.
+     *
+     * @param entity
+     * @return
+     */
+    public static boolean checkEntityImmunities(Entity entity)
+    {
+        // quick checks.
+        if ( entity.inWater || entity.fireTicks > 0 )
+        {
+            return true;
+        }
+        if ( !( entity instanceof EntityArrow ) )
+        {
+            if ( !entity.onGround || !entity.passengers.isEmpty() || entity.isPassenger() )
+            {
+                return true;
+            }
+        } else if ( !( (EntityArrow) entity ).inGround )
+        {
+            return true;
+        }
+        // special cases.
+        if ( entity instanceof EntityLiving )
+        {
+            EntityLiving living = (EntityLiving) entity;
+            if ( /*TODO: Missed mapping? living.attackTicks > 0 || */ living.hurtTicks > 0 || living.effects.size() > 0 )
+            {
+                return true;
+            }
+            if ( entity instanceof EntityCreature && ( (EntityCreature) entity ).getGoalTarget() != null )
+            {
+                return true;
+            }
+            if ( entity instanceof EntityVillager && ( (EntityVillager) entity ).df()/* Getter for first boolean */ )
+            {
+                return true;
+            }
+            if ( entity instanceof EntityAnimal )
+            {
+                EntityAnimal animal = (EntityAnimal) entity;
+                if ( animal.isBaby() || animal.isInLove() )
+                {
+                    return true;
+                }
+                if ( entity instanceof EntitySheep && ( (EntitySheep) entity ).isSheared() )
+                {
+                    return true;
+                }
+            }
+            if (entity instanceof EntityCreeper && ((EntityCreeper) entity).isIgnited()) { // isExplosive
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Checks if the entity is active for this tick.
+     *
+     * @param entity
+     * @return
+     */
+    public static boolean checkIfActive(Entity entity)
+    {
+        SpigotTimings.checkIfActiveTimer.startTiming();
+        // Never safe to skip fireworks or entities not yet added to chunk
+        // PAIL: inChunk
+        if ( !entity.ab || entity instanceof EntityFireworks ) {
+            SpigotTimings.checkIfActiveTimer.stopTiming();
+            return true;
+        }
+
+        boolean isActive = entity.activatedTick >= MinecraftServer.currentTick || entity.defaultActivationState;
+
+        // Should this entity tick?
+        if ( !isActive )
+        {
+            if ( ( MinecraftServer.currentTick - entity.activatedTick - 1 ) % 20 == 0 )
+            {
+                // Check immunities every 20 ticks.
+                if ( checkEntityImmunities( entity ) )
+                {
+                    // Triggered some sort of immunity, give 20 full ticks before we check again.
+                    entity.activatedTick = MinecraftServer.currentTick + 20;
+                }
+                isActive = true;
+            }
+            // Add a little performance juice to active entities. Skip 1/4 if not immune.
+        } else if ( !entity.defaultActivationState && entity.ticksLived % 4 == 0 && !checkEntityImmunities( entity ) )
+        {
+            isActive = false;
+        }
+        int x = MathHelper.floor( entity.locX );
+        int z = MathHelper.floor( entity.locZ );
+        // Make sure not on edge of unloaded chunk
+        Chunk chunk = entity.world.getChunkIfLoaded( x >> 4, z >> 4 );
+        if ( isActive && !( chunk != null && chunk.areNeighborsLoaded( 1 ) ) )
+        {
+            isActive = false;
+        }
+        SpigotTimings.checkIfActiveTimer.stopTiming();
+        return isActive;
+    }
+}
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2016-08-25 22:39:49.682601773 +0800
+++ src/main/java/org/spigotmc/AsyncCatcher.java	2016-08-26 03:24:12.088198245 +0800
@@ -1,17 +1,22 @@
-package org.spigotmc;
-
-import net.minecraft.server.MinecraftServer;
-
-public class AsyncCatcher
-{
-
-    public static boolean enabled = true;
-
-    public static void catchOp(String reason)
-    {
-        if ( enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread )
-        {
-            throw new IllegalStateException( "Asynchronous " + reason + "!" );
-        }
-    }
-}
+package org.spigotmc;
+
+import java.util.concurrent.ForkJoinTask;
+import net.minecraft.server.MinecraftServer;
+
+public class AsyncCatcher
+{
+
+    public static boolean enabled = true;
+
+    public static void catchOp(String reason)
+    {
+        /*
+        if ( enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread )
+        {
+            SpigotWorldConfig.TickTask = ForkJoinTask.adapt(Thread.currentThread());
+            SpigotWorldConfig.TickPool.submit(SpigotWorldConfig.TickTask);
+            //MinecraftServer.LOGGER.warn("Asynchronous " + reason + "!");
+            //throw new IllegalStateException( "Asynchronous " + reason + "!" );
+        }*/
+    }
+}
diff -Naur src_origin/main/java/org/spigotmc/SpigotWorldConfig.java src/main/java/org/spigotmc/SpigotWorldConfig.java
--- src_origin/main/java/org/spigotmc/SpigotWorldConfig.java	2016-08-25 22:39:49.750601780 +0800
+++ src/main/java/org/spigotmc/SpigotWorldConfig.java	2016-08-26 03:24:12.103198247 +0800
@@ -1,297 +1,409 @@
-package org.spigotmc;
-
-import java.util.List;
-import org.bukkit.Bukkit;
-import org.bukkit.configuration.file.YamlConfiguration;
-
-public class SpigotWorldConfig
-{
-
-    private final String worldName;
-    private final YamlConfiguration config;
-    private boolean verbose;
-
-    public SpigotWorldConfig(String worldName)
-    {
-        this.worldName = worldName;
-        this.config = SpigotConfig.config;
-        init();
-    }
-
-    public void init()
-    {
-        this.verbose = getBoolean( "verbose", true );
-
-        log( "-------- World Settings For [" + worldName + "] --------" );
-        SpigotConfig.readConfig( SpigotWorldConfig.class, this );
-    }
-
-    private void log(String s)
-    {
-        if ( verbose )
-        {
-            Bukkit.getLogger().info( s );
-        }
-    }
-
-    private void set(String path, Object val)
-    {
-        config.set( "world-settings.default." + path, val );
-    }
-
-    private boolean getBoolean(String path, boolean def)
-    {
-        config.addDefault( "world-settings.default." + path, def );
-        return config.getBoolean( "world-settings." + worldName + "." + path, config.getBoolean( "world-settings.default." + path ) );
-    }
-
-    private double getDouble(String path, double def)
-    {
-        config.addDefault( "world-settings.default." + path, def );
-        return config.getDouble( "world-settings." + worldName + "." + path, config.getDouble( "world-settings.default." + path ) );
-    }
-
-    private int getInt(String path, int def)
-    {
-        config.addDefault( "world-settings.default." + path, def );
-        return config.getInt( "world-settings." + worldName + "." + path, config.getInt( "world-settings.default." + path ) );
-    }
-
-    private <T> List getList(String path, T def)
-    {
-        config.addDefault( "world-settings.default." + path, def );
-        return (List<T>) config.getList( "world-settings." + worldName + "." + path, config.getList( "world-settings.default." + path ) );
-    }
-
-    private String getString(String path, String def)
-    {
-        config.addDefault( "world-settings.default." + path, def );
-        return config.getString( "world-settings." + worldName + "." + path, config.getString( "world-settings.default." + path ) );
-    }
-
-    // Crop growth rates
-    public int cactusModifier;
-    public int caneModifier;
-    public int melonModifier;
-    public int mushroomModifier;
-    public int pumpkinModifier;
-    public int saplingModifier;
-    public int wheatModifier;
-    public int wartModifier;
-    public int vineModifier;
-    public int cocoaModifier;
-    private int getAndValidateGrowth(String crop)
-    {
-        int modifier = getInt( "growth." + crop.toLowerCase(java.util.Locale.ENGLISH) + "-modifier", 100 );
-        if ( modifier == 0 )
-        {
-            log( "Cannot set " + crop + " growth to zero, defaulting to 100" );
-            modifier = 100;
-        }
-        log( crop + " Growth Modifier: " + modifier + "%" );
-
-        return modifier;
-    }
-    private void growthModifiers()
-    {
-        cactusModifier = getAndValidateGrowth( "Cactus" );
-        caneModifier = getAndValidateGrowth( "Cane" );
-        melonModifier = getAndValidateGrowth( "Melon" );
-        mushroomModifier = getAndValidateGrowth( "Mushroom" );
-        pumpkinModifier = getAndValidateGrowth( "Pumpkin" );
-        saplingModifier = getAndValidateGrowth( "Sapling" );
-        wheatModifier = getAndValidateGrowth( "Wheat" );
-        wartModifier = getAndValidateGrowth( "NetherWart" );
-        vineModifier = getAndValidateGrowth( "Vine" );
-        cocoaModifier = getAndValidateGrowth( "Cocoa" );
-    }
-
-    public double itemMerge;
-    private void itemMerge()
-    {
-        itemMerge = getDouble("merge-radius.item", 2.5 );
-        log( "Item Merge Radius: " + itemMerge );
-    }
-
-    public double expMerge;
-    private void expMerge()
-    {
-        expMerge = getDouble("merge-radius.exp", 3.0 );
-        log( "Experience Merge Radius: " + expMerge );
-    }
-
-    public int viewDistance;
-    private void viewDistance()
-    {
-        viewDistance = getInt( "view-distance", Bukkit.getViewDistance() );
-        log( "View Distance: " + viewDistance );
-    }
-
-    public byte mobSpawnRange;
-    private void mobSpawnRange()
-    {
-        mobSpawnRange = (byte) getInt( "mob-spawn-range", 4 );
-        log( "Mob Spawn Range: " + mobSpawnRange );
-    }
-
-    public int itemDespawnRate;
-    private void itemDespawnRate()
-    {
-        itemDespawnRate = getInt( "item-despawn-rate", 6000 );
-        log( "Item Despawn Rate: " + itemDespawnRate );
-    }
-
-    public int animalActivationRange = 32;
-    public int monsterActivationRange = 32;
-    public int miscActivationRange = 16;
-    private void activationRange()
-    {
-        animalActivationRange = getInt( "entity-activation-range.animals", animalActivationRange );
-        monsterActivationRange = getInt( "entity-activation-range.monsters", monsterActivationRange );
-        miscActivationRange = getInt( "entity-activation-range.misc", miscActivationRange );
-        log( "Entity Activation Range: An " + animalActivationRange + " / Mo " + monsterActivationRange + " / Mi " + miscActivationRange );
-    }
-
-    public int playerTrackingRange = 48;
-    public int animalTrackingRange = 48;
-    public int monsterTrackingRange = 48;
-    public int miscTrackingRange = 32;
-    public int otherTrackingRange = 64;
-    private void trackingRange()
-    {
-        playerTrackingRange = getInt( "entity-tracking-range.players", playerTrackingRange );
-        animalTrackingRange = getInt( "entity-tracking-range.animals", animalTrackingRange );
-        monsterTrackingRange = getInt( "entity-tracking-range.monsters", monsterTrackingRange );
-        miscTrackingRange = getInt( "entity-tracking-range.misc", miscTrackingRange );
-        otherTrackingRange = getInt( "entity-tracking-range.other", otherTrackingRange );
-        log( "Entity Tracking Range: Pl " + playerTrackingRange + " / An " + animalTrackingRange + " / Mo " + monsterTrackingRange + " / Mi " + miscTrackingRange + " / Other " + otherTrackingRange );
-    }
-
-    public int hopperTransfer;
-    public int hopperCheck;
-    public int hopperAmount;
-    private void hoppers()
-    {
-        // Set the tick delay between hopper item movements
-        hopperTransfer = getInt( "ticks-per.hopper-transfer", 8 );
-        // Set the tick delay between checking for items after the associated
-        // container is empty. Default to the hopperTransfer value to prevent
-        // hopper sorting machines from becoming out of sync.
-        hopperCheck = getInt( "ticks-per.hopper-check", hopperTransfer );
-        hopperAmount = getInt( "hopper-amount", 1 );
-        log( "Hopper Transfer: " + hopperTransfer + " Hopper Check: " + hopperCheck + " Hopper Amount: " + hopperAmount );
-    }
-
-    public boolean randomLightUpdates;
-    private void lightUpdates()
-    {
-        randomLightUpdates = getBoolean( "random-light-updates", false );
-        log( "Random Lighting Updates: " + randomLightUpdates );
-    }
-
-    public boolean saveStructureInfo;
-    private void structureInfo()
-    {
-        saveStructureInfo = getBoolean( "save-structure-info", true );
-        log( "Structure Info Saving: " + saveStructureInfo );
-        if ( !saveStructureInfo )
-        {
-            log( "*** WARNING *** You have selected to NOT save structure info. This may cause structures such as fortresses to not spawn mobs!" );
-            log( "*** WARNING *** Please use this option with caution, SpigotMC is not responsible for any issues this option may cause in the future!" );
-        }
-    }
-
-    public int arrowDespawnRate;
-    private void arrowDespawnRate()
-    {
-        arrowDespawnRate = getInt( "arrow-despawn-rate", 1200  );
-        log( "Arrow Despawn Rate: " + arrowDespawnRate );
-    }
-
-    public boolean zombieAggressiveTowardsVillager;
-    private void zombieAggressiveTowardsVillager()
-    {
-        zombieAggressiveTowardsVillager = getBoolean( "zombie-aggressive-towards-villager", true );
-        log( "Zombie Aggressive Towards Villager: " + zombieAggressiveTowardsVillager );
-    }
-
-    public boolean nerfSpawnerMobs;
-    private void nerfSpawnerMobs()
-    {
-        nerfSpawnerMobs = getBoolean( "nerf-spawner-mobs", false );
-        log( "Nerfing mobs spawned from spawners: " + nerfSpawnerMobs );
-    }
-
-    public boolean enableZombiePigmenPortalSpawns;
-    private void enableZombiePigmenPortalSpawns()
-    {
-        enableZombiePigmenPortalSpawns = getBoolean( "enable-zombie-pigmen-portal-spawns", true );
-        log( "Allow Zombie Pigmen to spawn from portal blocks: " + enableZombiePigmenPortalSpawns );
-    }
-
-    public int maxCollisionsPerEntity;
-    private void maxEntityCollision()
-    {
-        maxCollisionsPerEntity = getInt( "max-entity-collisions", 8 );
-        log( "Max Entity Collisions: " + maxCollisionsPerEntity );
-    }
-
-    public int dragonDeathSoundRadius;
-    private void keepDragonDeathPerWorld()
-    {
-        dragonDeathSoundRadius = getInt( "dragon-death-sound-radius", 0 );
-    }
-
-    public int witherSpawnSoundRadius;
-    private void witherSpawnSoundRadius()
-    {
-        witherSpawnSoundRadius = getInt( "wither-spawn-sound-radius", 0 );
-    }
-
-    public int villageSeed;
-    public int largeFeatureSeed;
-    private void initWorldGenSeeds()
-    {
-        villageSeed = getInt( "seed-village", 10387312 );
-        largeFeatureSeed = getInt( "seed-feature", 14357617 );
-        log( "Custom Map Seeds:  Village: " + villageSeed + " Feature: " + largeFeatureSeed );
-    }
-
-    public float walkExhaustion;
-    public float sprintExhaustion;
-    public float combatExhaustion;
-    public float regenExhaustion;
-    private void initHunger()
-    {
-        walkExhaustion = (float) getDouble( "hunger.walk-exhaustion", 0.2 );
-        sprintExhaustion = (float) getDouble( "hunger.sprint-exhaustion", 0.8 );
-        combatExhaustion = (float) getDouble( "hunger.combat-exhaustion", 0.3 );
-        regenExhaustion = (float) getDouble( "hunger.regen-exhaustion", 3 );
-    }
-
-    public int currentPrimedTnt = 0;
-    public int maxTntTicksPerTick;
-    private void maxTntPerTick() {
-        if ( SpigotConfig.version < 7 )
-        {
-            set( "max-tnt-per-tick", 100 );
-        }
-        maxTntTicksPerTick = getInt( "max-tnt-per-tick", 100 );
-        log( "Max TNT Explosions: " + maxTntTicksPerTick );
-    }
-
-    public int hangingTickFrequency;
-    private void hangingTickFrequency()
-    {
-        hangingTickFrequency = getInt( "hanging-tick-frequency", 100 );
-    }
-
-    public int tileMaxTickTime;
-    public int entityMaxTickTime;
-    private void maxTickTimes()
-    {
-        tileMaxTickTime = getInt("max-tick-time.tile", 50);
-        entityMaxTickTime = getInt("max-tick-time.entity", 50);
-        log("Tile Max Tick Time: " + tileMaxTickTime + "ms Entity max Tick Time: " + entityMaxTickTime + "ms");
-    }
-}
+package org.spigotmc;
+
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.ForkJoinTask;
+import java.util.concurrent.ForkJoinWorkerThread;
+import java.util.concurrent.ThreadFactory;
+import net.minecraft.server.Chunk;
+import org.bukkit.Bukkit;
+import org.bukkit.configuration.file.YamlConfiguration;
+
+public class SpigotWorldConfig
+{
+    //hose start
+    static public final int cpu_core = Runtime.getRuntime().availableProcessors();
+    /*
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fttp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("TileTickPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fmp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("MovePool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fpcp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("PlayerChunkPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };*/
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory ftp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("TickPool-" + thread.getPoolIndex());
+            //thread.setDaemon(true);
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    /*
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcfpt3 = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkFlushPool_T3-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcpp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkPopulate_Pool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    public static ForkJoinPool TileTickPool;
+    public static ForkJoinPool MovePool;
+    public static ForkJoinPool PlayerChunkPool;*/
+    public static ForkJoinTask<?> TickTask;
+    public static ForkJoinTask<Chunk> ChunkTask;
+    public static ForkJoinPool TickPool;
+    public static ForkJoinPool ChunkPool;
+    //public static ForkJoinPool ChunkPool;
+    
+    //static public FutureTask CollideTask;
+        
+    /*static final ThreadFactory tfcp = new ThreadFactoryBuilder().setNameFormat("Collide_Pool-%d").build();
+    static public final ExecutorService tickpool_executor = Executors.newFixedThreadPool(cpu_core, tfcp);*/
+    
+    public static int worldtickentitypool_core_multiple;
+    
+    public static int getthreadnumber(){
+        return cpu_core*worldtickentitypool_core_multiple;
+    }
+    
+    private void wetp_core_multiple()
+    {
+        worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 2);
+        //ChunkPool = new ForkJoinPool(getthreadnumber(), fcp, null, false);
+        
+        
+        TickPool = new ForkJoinPool(getthreadnumber(), ftp, null, false);
+        ChunkPool = new ForkJoinPool(getthreadnumber(), fcp, null, false);
+        /*
+        TileTickPool = new ForkJoinPool(getthreadnumber(), fttp, null, false);
+        MovePool = new ForkJoinPool(getthreadnumber(), fmp, null, false);
+        PlayerChunkPool = new ForkJoinPool(getthreadnumber(), fpcp, null, false);
+        
+        ChunkFlushPool_T3 = new ForkJoinPool(getthreadnumber(), fcfpt3, null, false);
+        ChunkPopulate_Pool = new ForkJoinPool(getthreadnumber(), fcpp, null, false);*/
+        //executor = new ThreadPoolExecutor(getthreadnumber(), getthreadnumber(), 1, TimeUnit.DAYS, queue);
+        log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
+    }
+    //hose end
+
+    private final String worldName;
+    private final YamlConfiguration config;
+    private boolean verbose;
+
+    public SpigotWorldConfig(String worldName)
+    {
+        this.worldName = worldName;
+        this.config = SpigotConfig.config;
+        init();
+    }
+
+    public void init()
+    {
+        this.verbose = getBoolean( "verbose", true );
+
+        log( "-------- World Settings For [" + worldName + "] --------" );
+        SpigotConfig.readConfig( SpigotWorldConfig.class, this );
+    }
+
+    private void log(String s)
+    {
+        if ( verbose )
+        {
+            Bukkit.getLogger().info( s );
+        }
+    }
+
+    private void set(String path, Object val)
+    {
+        config.set( "world-settings.default." + path, val );
+    }
+
+    private boolean getBoolean(String path, boolean def)
+    {
+        config.addDefault( "world-settings.default." + path, def );
+        return config.getBoolean( "world-settings." + worldName + "." + path, config.getBoolean( "world-settings.default." + path ) );
+    }
+
+    private double getDouble(String path, double def)
+    {
+        config.addDefault( "world-settings.default." + path, def );
+        return config.getDouble( "world-settings." + worldName + "." + path, config.getDouble( "world-settings.default." + path ) );
+    }
+
+    private int getInt(String path, int def)
+    {
+        config.addDefault( "world-settings.default." + path, def );
+        return config.getInt( "world-settings." + worldName + "." + path, config.getInt( "world-settings.default." + path ) );
+    }
+
+    private <T> List getList(String path, T def)
+    {
+        config.addDefault( "world-settings.default." + path, def );
+        return (List<T>) config.getList( "world-settings." + worldName + "." + path, config.getList( "world-settings.default." + path ) );
+    }
+
+    private String getString(String path, String def)
+    {
+        config.addDefault( "world-settings.default." + path, def );
+        return config.getString( "world-settings." + worldName + "." + path, config.getString( "world-settings.default." + path ) );
+    }
+
+    // Crop growth rates
+    public int cactusModifier;
+    public int caneModifier;
+    public int melonModifier;
+    public int mushroomModifier;
+    public int pumpkinModifier;
+    public int saplingModifier;
+    public int wheatModifier;
+    public int wartModifier;
+    public int vineModifier;
+    public int cocoaModifier;
+    private int getAndValidateGrowth(String crop)
+    {
+        int modifier = getInt( "growth." + crop.toLowerCase(java.util.Locale.ENGLISH) + "-modifier", 100 );
+        if ( modifier == 0 )
+        {
+            log( "Cannot set " + crop + " growth to zero, defaulting to 100" );
+            modifier = 100;
+        }
+        log( crop + " Growth Modifier: " + modifier + "%" );
+
+        return modifier;
+    }
+    private void growthModifiers()
+    {
+        cactusModifier = getAndValidateGrowth( "Cactus" );
+        caneModifier = getAndValidateGrowth( "Cane" );
+        melonModifier = getAndValidateGrowth( "Melon" );
+        mushroomModifier = getAndValidateGrowth( "Mushroom" );
+        pumpkinModifier = getAndValidateGrowth( "Pumpkin" );
+        saplingModifier = getAndValidateGrowth( "Sapling" );
+        wheatModifier = getAndValidateGrowth( "Wheat" );
+        wartModifier = getAndValidateGrowth( "NetherWart" );
+        vineModifier = getAndValidateGrowth( "Vine" );
+        cocoaModifier = getAndValidateGrowth( "Cocoa" );
+    }
+
+    public double itemMerge;
+    private void itemMerge()
+    {
+        itemMerge = getDouble("merge-radius.item", 2.5 );
+        log( "Item Merge Radius: " + itemMerge );
+    }
+
+    public double expMerge;
+    private void expMerge()
+    {
+        expMerge = getDouble("merge-radius.exp", 3.0 );
+        log( "Experience Merge Radius: " + expMerge );
+    }
+
+    public int viewDistance;
+    private void viewDistance()
+    {
+        viewDistance = getInt( "view-distance", Bukkit.getViewDistance() );
+        log( "View Distance: " + viewDistance );
+    }
+
+    public byte mobSpawnRange;
+    private void mobSpawnRange()
+    {
+        mobSpawnRange = (byte) getInt( "mob-spawn-range", 4 );
+        log( "Mob Spawn Range: " + mobSpawnRange );
+    }
+
+    public int itemDespawnRate;
+    private void itemDespawnRate()
+    {
+        itemDespawnRate = getInt( "item-despawn-rate", 6000 );
+        log( "Item Despawn Rate: " + itemDespawnRate );
+    }
+
+    public int animalActivationRange = 32;
+    public int monsterActivationRange = 32;
+    public int miscActivationRange = 16;
+    private void activationRange()
+    {
+        animalActivationRange = getInt( "entity-activation-range.animals", animalActivationRange );
+        monsterActivationRange = getInt( "entity-activation-range.monsters", monsterActivationRange );
+        miscActivationRange = getInt( "entity-activation-range.misc", miscActivationRange );
+        log( "Entity Activation Range: An " + animalActivationRange + " / Mo " + monsterActivationRange + " / Mi " + miscActivationRange );
+    }
+
+    public int playerTrackingRange = 48;
+    public int animalTrackingRange = 48;
+    public int monsterTrackingRange = 48;
+    public int miscTrackingRange = 32;
+    public int otherTrackingRange = 64;
+    private void trackingRange()
+    {
+        playerTrackingRange = getInt( "entity-tracking-range.players", playerTrackingRange );
+        animalTrackingRange = getInt( "entity-tracking-range.animals", animalTrackingRange );
+        monsterTrackingRange = getInt( "entity-tracking-range.monsters", monsterTrackingRange );
+        miscTrackingRange = getInt( "entity-tracking-range.misc", miscTrackingRange );
+        otherTrackingRange = getInt( "entity-tracking-range.other", otherTrackingRange );
+        log( "Entity Tracking Range: Pl " + playerTrackingRange + " / An " + animalTrackingRange + " / Mo " + monsterTrackingRange + " / Mi " + miscTrackingRange + " / Other " + otherTrackingRange );
+    }
+
+    public int hopperTransfer;
+    public int hopperCheck;
+    public int hopperAmount;
+    private void hoppers()
+    {
+        // Set the tick delay between hopper item movements
+        hopperTransfer = getInt( "ticks-per.hopper-transfer", 8 );
+        // Set the tick delay between checking for items after the associated
+        // container is empty. Default to the hopperTransfer value to prevent
+        // hopper sorting machines from becoming out of sync.
+        hopperCheck = getInt( "ticks-per.hopper-check", hopperTransfer );
+        hopperAmount = getInt( "hopper-amount", 1 );
+        log( "Hopper Transfer: " + hopperTransfer + " Hopper Check: " + hopperCheck + " Hopper Amount: " + hopperAmount );
+    }
+
+    public boolean randomLightUpdates;
+    private void lightUpdates()
+    {
+        randomLightUpdates = getBoolean( "random-light-updates", false );
+        log( "Random Lighting Updates: " + randomLightUpdates );
+    }
+
+    public boolean saveStructureInfo;
+    private void structureInfo()
+    {
+        saveStructureInfo = getBoolean( "save-structure-info", true );
+        log( "Structure Info Saving: " + saveStructureInfo );
+        if ( !saveStructureInfo )
+        {
+            log( "*** WARNING *** You have selected to NOT save structure info. This may cause structures such as fortresses to not spawn mobs!" );
+            log( "*** WARNING *** Please use this option with caution, SpigotMC is not responsible for any issues this option may cause in the future!" );
+        }
+    }
+
+    public int arrowDespawnRate;
+    private void arrowDespawnRate()
+    {
+        arrowDespawnRate = getInt( "arrow-despawn-rate", 1200  );
+        log( "Arrow Despawn Rate: " + arrowDespawnRate );
+    }
+
+    public boolean zombieAggressiveTowardsVillager;
+    private void zombieAggressiveTowardsVillager()
+    {
+        zombieAggressiveTowardsVillager = getBoolean( "zombie-aggressive-towards-villager", true );
+        log( "Zombie Aggressive Towards Villager: " + zombieAggressiveTowardsVillager );
+    }
+
+    public boolean nerfSpawnerMobs;
+    private void nerfSpawnerMobs()
+    {
+        nerfSpawnerMobs = getBoolean( "nerf-spawner-mobs", false );
+        log( "Nerfing mobs spawned from spawners: " + nerfSpawnerMobs );
+    }
+
+    public boolean enableZombiePigmenPortalSpawns;
+    private void enableZombiePigmenPortalSpawns()
+    {
+        enableZombiePigmenPortalSpawns = getBoolean( "enable-zombie-pigmen-portal-spawns", true );
+        log( "Allow Zombie Pigmen to spawn from portal blocks: " + enableZombiePigmenPortalSpawns );
+    }
+
+    public int maxCollisionsPerEntity;
+    private void maxEntityCollision()
+    {
+        maxCollisionsPerEntity = getInt( "max-entity-collisions", 8 );
+        log( "Max Entity Collisions: " + maxCollisionsPerEntity );
+    }
+
+    public int dragonDeathSoundRadius;
+    private void keepDragonDeathPerWorld()
+    {
+        dragonDeathSoundRadius = getInt( "dragon-death-sound-radius", 0 );
+    }
+
+    public int witherSpawnSoundRadius;
+    private void witherSpawnSoundRadius()
+    {
+        witherSpawnSoundRadius = getInt( "wither-spawn-sound-radius", 0 );
+    }
+
+    public int villageSeed;
+    public int largeFeatureSeed;
+    private void initWorldGenSeeds()
+    {
+        villageSeed = getInt( "seed-village", 10387312 );
+        largeFeatureSeed = getInt( "seed-feature", 14357617 );
+        log( "Custom Map Seeds:  Village: " + villageSeed + " Feature: " + largeFeatureSeed );
+    }
+
+    public float walkExhaustion;
+    public float sprintExhaustion;
+    public float combatExhaustion;
+    public float regenExhaustion;
+    private void initHunger()
+    {
+        walkExhaustion = (float) getDouble( "hunger.walk-exhaustion", 0.2 );
+        sprintExhaustion = (float) getDouble( "hunger.sprint-exhaustion", 0.8 );
+        combatExhaustion = (float) getDouble( "hunger.combat-exhaustion", 0.3 );
+        regenExhaustion = (float) getDouble( "hunger.regen-exhaustion", 3 );
+    }
+
+    public int currentPrimedTnt = 0;
+    public int maxTntTicksPerTick;
+    private void maxTntPerTick() {
+        if ( SpigotConfig.version < 7 )
+        {
+            set( "max-tnt-per-tick", 100 );
+        }
+        maxTntTicksPerTick = getInt( "max-tnt-per-tick", 100 );
+        log( "Max TNT Explosions: " + maxTntTicksPerTick );
+    }
+
+    public int hangingTickFrequency;
+    private void hangingTickFrequency()
+    {
+        hangingTickFrequency = getInt( "hanging-tick-frequency", 100 );
+    }
+
+    public int tileMaxTickTime;
+    public int entityMaxTickTime;
+    private void maxTickTimes()
+    {
+        tileMaxTickTime = getInt("max-tick-time.tile", 50);
+        entityMaxTickTime = getInt("max-tick-time.entity", 50);
+        log("Tile Max Tick Time: " + tileMaxTickTime + "ms Entity max Tick Time: " + entityMaxTickTime + "ms");
+    }
+}
