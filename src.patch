diff -Naur src_origin/main/java/net/minecraft/server/BlockRedstoneWire.java src/main/java/net/minecraft/server/BlockRedstoneWire.java
--- src_origin/main/java/net/minecraft/server/BlockRedstoneWire.java	2016-06-17 04:20:29.141705966 +0800
+++ src/main/java/net/minecraft/server/BlockRedstoneWire.java	2016-06-17 23:17:00.348456200 +0800
@@ -20,7 +20,8 @@
     public static final BlockStateInteger POWER = BlockStateInteger.of("power", 0, 15);
     protected static final AxisAlignedBB[] f = new AxisAlignedBB[] { new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 1.0D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 1.0D, 0.0625D, 1.0D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 1.0D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.0625D, 1.0D)};
     private boolean g = true;
-    private final Set<BlockPosition> B = Sets.newHashSet();
+    //private final Set<BlockPosition> B = Sets.newHashSet();
+    private final Set<BlockPosition> B = Sets.newConcurrentHashSet();
 
     public BlockRedstoneWire() {
         super(Material.ORIENTABLE);
diff -Naur src_origin/main/java/net/minecraft/server/Chunk.java src/main/java/net/minecraft/server/Chunk.java
--- src_origin/main/java/net/minecraft/server/Chunk.java	2016-06-17 04:20:29.232705958 +0800
+++ src/main/java/net/minecraft/server/Chunk.java	2016-06-17 23:17:00.937456146 +0800
@@ -15,6 +15,7 @@
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists; // CraftBukkit
+import java.util.Queue;
 import org.bukkit.Bukkit; // CraftBukkit
 
 public class Chunk {
@@ -32,7 +33,8 @@
     public final int locZ;
     private boolean m;
     public final Map<BlockPosition, TileEntity> tileEntities;
-    public final List<Entity>[] entitySlices; // Spigot
+    //public final List<Entity>[] entitySlices; // Spigot
+    public final Queue<Entity>[] entitySlices; // Hose
     private boolean done;
     private boolean lit;
     private boolean r;
@@ -82,14 +84,16 @@
         this.tileEntities = Maps.newHashMap();
         this.x = 4096;
         this.y = Queues.newConcurrentLinkedQueue();
-        this.entitySlices = (List[]) (new List[16]); // Spigot
+        //this.entitySlices = (List[]) (new List[16]); // Spigot
+        this.entitySlices = (Queue[]) (new ConcurrentLinkedQueue[16]); // Hose
         this.world = world;
         this.locX = i;
         this.locZ = j;
         this.heightMap = new int[256];
 
         for (int k = 0; k < this.entitySlices.length; ++k) {
-            this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            //this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[k] = new ConcurrentLinkedQueue(); // Hose
         }
 
         Arrays.fill(this.h, -999);
@@ -742,12 +746,13 @@
     public void addEntities() {
         this.j = true;
         this.world.b(this.tileEntities.values());
-        List[] aentityslice = this.entitySlices; // Spigot
+        //List[] aentityslice = this.entitySlices; // Spigot
+        Queue[] aentityslice = this.entitySlices; // Hose
         int i = aentityslice.length;
 
         for (int j = 0; j < i; ++j) {
-            List entityslice = aentityslice[j]; // Spigot
-
+            //List entityslice = aentityslice[j]; // Spigot
+            Queue entityslice = aentityslice[j]; // Hose
             this.world.a((Collection) entityslice);
         }
 
@@ -775,7 +780,8 @@
             this.world.b(tileentity);
         }
 
-        List[] aentityslice = this.entitySlices; // Spigot
+        //List[] aentityslice = this.entitySlices; // Spigot
+        Queue[] aentityslice = this.entitySlices; // Hose
         int i = aentityslice.length;
 
         for (int j = 0; j < i; ++j) {
@@ -1259,7 +1265,8 @@
         return this.tileEntities;
     }
 
-    public List<Entity>[] getEntitySlices() {
+    //public List<Entity>[] getEntitySlices() {
+    public Queue<Entity>[] getEntitySlices() {
         return this.entitySlices;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderServer.java src/main/java/net/minecraft/server/ChunkProviderServer.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderServer.java	2016-06-17 04:20:29.222705959 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderServer.java	2016-06-17 23:17:00.944456146 +0800
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
@@ -9,6 +10,7 @@
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
@@ -26,7 +28,8 @@
     public final Set<Long> unloadQueue = Sets.newHashSet();
     public final ChunkGenerator chunkGenerator;
     private final IChunkLoader chunkLoader;
-    public final Long2ObjectMap<Chunk> chunks = new Long2ObjectOpenHashMap(8192);
+    //public final Long2ObjectMap<Chunk> chunks = new Long2ObjectOpenHashMap(8192);
+    public final Map<Long, Chunk> chunks = Maps.newConcurrentMap();
     public final WorldServer world;
 
     public ChunkProviderServer(WorldServer worldserver, IChunkLoader ichunkloader, ChunkGenerator chunkgenerator) {
diff -Naur src_origin/main/java/net/minecraft/server/EntityBoat.java src/main/java/net/minecraft/server/EntityBoat.java
--- src_origin/main/java/net/minecraft/server/EntityBoat.java	2016-06-17 04:20:29.466705936 +0800
+++ src/main/java/net/minecraft/server/EntityBoat.java	2016-06-17 23:17:01.644456081 +0800
@@ -3,6 +3,7 @@
 import com.google.common.collect.Lists;
 import java.util.ArrayList;
 import java.util.List;
+import java.util.concurrent.RecursiveAction;
 import javax.annotation.Nullable;
 
 // CraftBukkit start
@@ -156,7 +157,7 @@
         }
     }
 
-    public void collide(Entity entity) {
+    public void collide_hose(Entity entity) {
         if (entity instanceof EntityBoat) {
             if (entity.getBoundingBox().b < this.getBoundingBox().e) {
                 // CraftBukkit start
@@ -180,6 +181,35 @@
             // CraftBukkit end
             super.collide(entity);
         }
+    }
+    
+    public void collide(Entity entity) {
+        collide c_task = new collide(entity);
+        c_task.fork();
+        /*
+        if (entity instanceof EntityBoat) {
+            if (entity.getBoundingBox().b < this.getBoundingBox().e) {
+                // CraftBukkit start
+                VehicleEntityCollisionEvent event = new VehicleEntityCollisionEvent((Vehicle) this.getBukkitEntity(), entity.getBukkitEntity());
+                this.world.getServer().getPluginManager().callEvent(event);
+
+                if (event.isCancelled()) {
+                    return;
+                }
+                // CraftBukkit end
+                super.collide(entity);
+            }
+        } else if (entity.getBoundingBox().b <= this.getBoundingBox().b) {
+            // CraftBukkit start
+            VehicleEntityCollisionEvent event = new VehicleEntityCollisionEvent((Vehicle) this.getBukkitEntity(), entity.getBukkitEntity());
+            this.world.getServer().getPluginManager().callEvent(event);
+
+            if (event.isCancelled()) {
+                return;
+            }
+            // CraftBukkit end
+            super.collide(entity);
+        }*/
 
     }
 
@@ -216,7 +246,7 @@
 
     private Location lastLocation; // CraftBukkit
 
-    public void m() {
+    public void m_hose() {
         this.aI = this.aH;
         this.aH = this.t();
         if (this.aH != EntityBoat.EnumStatus.UNDER_WATER && this.aH != EntityBoat.EnumStatus.UNDER_FLOWING_WATER) {
@@ -301,6 +331,96 @@
                 }
             }
         }
+    }
+    
+    public void m() {//move
+        move m_task = new move();
+        m_task.fork();
+        /*
+        this.aI = this.aH;
+        this.aH = this.t();
+        if (this.aH != EntityBoat.EnumStatus.UNDER_WATER && this.aH != EntityBoat.EnumStatus.UNDER_FLOWING_WATER) {
+            this.h = 0.0F;
+        } else {
+            ++this.h;
+        }
+
+        if (!this.world.isClientSide && this.h >= 60.0F) {
+            this.az();
+        }
+
+        if (this.o() > 0) {
+            this.b(this.o() - 1);
+        }
+
+        if (this.n() > 0.0F) {
+            this.setDamage(this.n() - 1.0F);
+        }
+        this.lastX = this.locX;
+        this.lastY = this.locY;
+        this.lastZ = this.locZ;
+        super.m();
+        this.s();
+        if (this.bA()) {
+            if (this.bx().size() == 0 || !(this.bx().get(0) instanceof EntityHuman)) {
+                this.a(false, false);
+            }
+
+            this.w();
+            if (this.world.isClientSide) {
+                this.x();
+                this.world.a((Packet) (new PacketPlayInBoatMove(this.a(0), this.a(1))));
+            }
+
+            this.move(this.motX, this.motY, this.motZ);
+        } else {
+            this.motX = 0.0D;
+            this.motY = 0.0D;
+            this.motZ = 0.0D;
+        }
+
+        // CraftBukkit start
+        org.bukkit.Server server = this.world.getServer();
+        org.bukkit.World bworld = this.world.getWorld();
+
+        Location to = new Location(bworld, this.locX, this.locY, this.locZ, this.yaw, this.pitch);
+        Vehicle vehicle = (Vehicle) this.getBukkitEntity();
+
+        server.getPluginManager().callEvent(new org.bukkit.event.vehicle.VehicleUpdateEvent(vehicle));
+
+        if (lastLocation != null && !lastLocation.equals(to)) {
+            VehicleMoveEvent event = new VehicleMoveEvent(vehicle, lastLocation, to);
+            server.getPluginManager().callEvent(event);
+        }
+        lastLocation = vehicle.getLocation();
+        // CraftBukkit end
+
+        for (int i = 0; i <= 1; ++i) {
+            if (this.a(i)) {
+                this.f[i] = (float) ((double) this.f[i] + 0.01D);
+            } else {
+                this.f[i] = 0.0F;
+            }
+        }
+
+        this.checkBlockCollisions();
+        List list = this.world.getEntities(this, this.getBoundingBox().grow(0.20000000298023224D, -0.009999999776482582D, 0.20000000298023224D), IEntitySelector.a(this));
+
+        if (!list.isEmpty()) {
+            boolean flag = !this.world.isClientSide && !(this.bw() instanceof EntityHuman);
+
+            for (int j = 0; j < list.size(); ++j) {
+                Entity entity = (Entity) list.get(j);
+
+                if (!entity.w(this)) {
+                    if (flag && this.bx().size() < 2 && !entity.isPassenger() && entity.width < this.width && entity instanceof EntityLiving && !(entity instanceof EntityWaterAnimal) && !(entity instanceof EntityHuman)) {
+                        entity.startRiding(this);
+                    } else {
+                        this.collide(entity);
+                    }
+                }
+            }
+        }*/
 
     }
 
@@ -841,4 +961,32 @@
 
         private EnumStatus() {}
     }
+    
+    class collide extends RecursiveAction {
+        Entity entity;
+
+        public collide(Entity entity){
+            this.entity = entity;
+
+        }
+
+        @Override
+        protected void compute() {
+            collide_hose(entity);
+        }
+
+    }
+    
+    class move extends RecursiveAction {
+
+        public move(){
+
+        }
+
+        @Override
+        protected void compute() {
+            m_hose();
+        }
+
+    }
 }
diff -Naur src_origin/main/java/net/minecraft/server/EntityInsentient.java src/main/java/net/minecraft/server/EntityInsentient.java
--- src_origin/main/java/net/minecraft/server/EntityInsentient.java	2016-06-17 04:20:29.581705926 +0800
+++ src/main/java/net/minecraft/server/EntityInsentient.java	2016-06-17 23:17:02.749455980 +0800
@@ -7,6 +7,7 @@
 import java.util.Map;
 import java.util.Random;
 import java.util.UUID;
+import java.util.concurrent.RecursiveAction;
 import javax.annotation.Nullable;
 
 // CraftBukkit start
@@ -16,6 +17,8 @@
 import org.bukkit.event.entity.EntityTargetEvent;
 import org.bukkit.event.entity.EntityUnleashEvent;
 import org.bukkit.event.entity.EntityUnleashEvent.UnleashReason;
+import org.hose.Tick_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class EntityInsentient extends EntityLiving {
@@ -24,7 +27,8 @@
     public int a_;
     protected int b_;
     private final ControllerLook lookController;
-    protected ControllerMove moveController;
+    //protected ControllerMove moveController;
+    public ControllerMove moveController;
     protected ControllerJump g;
     private final EntityAIBodyControl c;
     protected NavigationAbstract navigation;
@@ -645,7 +649,8 @@
 
         }
     }
-
+    
+    //MT_Pool mt_task;
     protected final void doTick() {
         ++this.ticksFarFromPlayer;
         this.world.methodProfiler.a("checkDespawn");
@@ -671,6 +676,8 @@
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("mob tick");
         this.M();
+        /*mt_task = new MT_Pool(this);
+        mt_task.fork();*/
         this.world.methodProfiler.b();
         if (this.isPassenger() && this.bB() instanceof EntityInsentient) {
             EntityInsentient entityinsentient = (EntityInsentient) this.bB();
@@ -682,14 +689,14 @@
         this.world.methodProfiler.a("controls");
         this.world.methodProfiler.a("move");
         this.moveController.c();
-        this.world.methodProfiler.c("look");
+         this.world.methodProfiler.c("look");
         this.lookController.a();
         this.world.methodProfiler.c("jump");
         this.g.b();
         this.world.methodProfiler.b();
         this.world.methodProfiler.b();
     }
-
+    
     protected void M() {}
 
     public int N() {
@@ -1270,4 +1277,17 @@
 
         private EnumEntityPositionType() {}
     }
+    
+    public class MT_Pool extends RecursiveAction {
+        EntityInsentient ei;
+
+        public MT_Pool(EntityInsentient ei){
+            this.ei = ei;
+        }
+
+        @Override
+        protected void compute() {
+            ei.M();
+        }
+    }
 }
diff -Naur src_origin/main/java/net/minecraft/server/Entity.java src/main/java/net/minecraft/server/Entity.java
--- src_origin/main/java/net/minecraft/server/Entity.java	2016-06-17 04:20:29.435705939 +0800
+++ src/main/java/net/minecraft/server/Entity.java	2016-06-17 23:17:01.674456079 +0800
@@ -2,15 +2,19 @@
 
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.RecursiveAction;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -37,6 +41,9 @@
 import org.bukkit.event.entity.EntityCombustEvent;
 import org.bukkit.event.entity.EntityPortalEvent;
 import org.bukkit.plugin.PluginManager;
+import org.hose.TE_Pool;
+import org.hose.Tick_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class Entity implements ICommandListener {
@@ -295,12 +302,16 @@
         this.a(new AxisAlignedBB(d0 - (double) f, d1, d2 - (double) f, d0 + (double) f, d1 + (double) f1, d2 + (double) f));
     }
 
+    //Tick_Pool t_task;
     public void m() {
         if (!this.world.isClientSide) {
             this.setFlag(6, this.aO());
         }
 
         this.U();
+        /*t_task = new Tick_Pool(this);
+        t_task.fork();*/
+        //SpigotWorldConfig.move_forks.add(t_task);
     }
 
     public void U() {
@@ -465,7 +476,7 @@
         return this.world.getCubes(this, axisalignedbb).isEmpty() && !this.world.containsLiquid(axisalignedbb);
     }
 
-    public void move(double d0, double d1, double d2) {
+    public void move_hose(double d0, double d1, double d2) {
         org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.startTiming(); // Spigot
         if (this.noclip) {
             this.a(this.getBoundingBox().c(d0, d1, d2));
@@ -760,8 +771,56 @@
                 }
             }
 
-            // CraftBukkit start - Move to the top of the method
-            /*
+            boolean flag2 = this.ai();
+
+            if (this.world.f(this.getBoundingBox().shrink(0.001D))) {
+                this.burn(1);
+                if (!flag2) {
+                    ++this.fireTicks;
+                    // CraftBukkit start - Not on fire yet
+                    if (this.fireTicks <= 0) { // Only throw events on the first combust, otherwise it spams
+                        EntityCombustEvent event = new org.bukkit.event.entity.EntityCombustByBlockEvent(null, getBukkitEntity(), 8);
+                        world.getServer().getPluginManager().callEvent(event);
+
+                        if (!event.isCancelled()) {
+                            setOnFire(event.getDuration());
+                        }
+                    } else {
+                        // CraftBukkit end
+                        this.setOnFire(8);
+                    }
+                }
+            } else if (this.fireTicks <= 0) {
+                this.fireTicks = -this.maxFireTicks;
+            }
+
+            if (flag2 && this.fireTicks > 0) {
+                this.a(SoundEffects.bG, 0.7F, 1.6F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
+                this.fireTicks = -this.maxFireTicks;
+            }
+
+            this.world.methodProfiler.b();
+        }
+        org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.stopTiming(); // Spigot
+    }
+    
+    TE_Pool te_task;
+    public void move(double d0, double d1, double d2) {
+        /*double[] pos = {d0, d1, d2};
+        SpigotWorldConfig.entity_move.put(this, pos);*/
+        /*
+        m_task = new move(d0, d1, d2);
+        SpigotWorldConfig.move_forks.add(m_task);*/
+        //m_task.fork();
+        
+        
+        org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.startTiming(); // Spigot
+        if (this.noclip) {
+            this.a(this.getBoundingBox().c(d0, d1, d2));
+            this.recalcPosition();
+        } else {
+            // CraftBukkit start - Don't do anything if we aren't moving
+            // We need to do this regardless of whether or not we are moving thanks to portals
             try {
                 this.checkBlockCollisions();
             } catch (Throwable throwable) {
@@ -771,8 +830,290 @@
                 this.appendEntityCrashDetails(crashreportsystemdetails);
                 throw new ReportedException(crashreport);
             }
-            */
+            // Check if we're moving
+            if (d0 == 0 && d1 == 0 && d2 == 0 && this.isVehicle() && this.isPassenger()) {
+                return;
+            }
             // CraftBukkit end
+            this.world.methodProfiler.a("move");
+            double d3 = this.locX;
+            double d4 = this.locY;
+            double d5 = this.locZ;
+
+            if (this.E) {
+                this.E = false;
+                d0 *= 0.25D;
+                d1 *= 0.05000000074505806D;
+                d2 *= 0.25D;
+                this.motX = 0.0D;
+                this.motY = 0.0D;
+                this.motZ = 0.0D;
+            }
+
+            double d6 = d0;
+            double d7 = d1;
+            double d8 = d2;
+            boolean flag = this.onGround && this.isSneaking() && this instanceof EntityHuman;
+
+            if (flag) {
+                for (double d9 = 0.05D; d0 != 0.0D && this.world.getCubes(this, this.getBoundingBox().c(d0, -1.0D, 0.0D)).isEmpty(); d6 = d0) {
+                    if (d0 < 0.05D && d0 >= -0.05D) {
+                        d0 = 0.0D;
+                    } else if (d0 > 0.0D) {
+                        d0 -= 0.05D;
+                    } else {
+                        d0 += 0.05D;
+                    }
+                }
+
+                for (; d2 != 0.0D && this.world.getCubes(this, this.getBoundingBox().c(0.0D, -1.0D, d2)).isEmpty(); d8 = d2) {
+                    if (d2 < 0.05D && d2 >= -0.05D) {
+                        d2 = 0.0D;
+                    } else if (d2 > 0.0D) {
+                        d2 -= 0.05D;
+                    } else {
+                        d2 += 0.05D;
+                    }
+                }
+
+                for (; d0 != 0.0D && d2 != 0.0D && this.world.getCubes(this, this.getBoundingBox().c(d0, -1.0D, d2)).isEmpty(); d8 = d2) {
+                    if (d0 < 0.05D && d0 >= -0.05D) {
+                        d0 = 0.0D;
+                    } else if (d0 > 0.0D) {
+                        d0 -= 0.05D;
+                    } else {
+                        d0 += 0.05D;
+                    }
+
+                    d6 = d0;
+                    if (d2 < 0.05D && d2 >= -0.05D) {
+                        d2 = 0.0D;
+                    } else if (d2 > 0.0D) {
+                        d2 -= 0.05D;
+                    } else {
+                        d2 += 0.05D;
+                    }
+                }
+            }
+
+            List list = this.world.getCubes(this, this.getBoundingBox().a(d0, d1, d2));
+            /*te_task = new TE_Pool(this, d0, d1, d2);
+            te_task.fork();
+            List list = te_task.join(); */
+            
+            AxisAlignedBB axisalignedbb = this.getBoundingBox();
+            int i = 0;
+
+            int j;
+
+            for (j = list.size(); i < j; ++i) {
+                d1 = ((AxisAlignedBB) list.get(i)).b(this.getBoundingBox(), d1);
+            }
+
+            this.a(this.getBoundingBox().c(0.0D, d1, 0.0D));
+            boolean flag1 = this.onGround || d7 != d1 && d7 < 0.0D;
+
+            j = 0;
+
+            int k;
+
+            for (k = list.size(); j < k; ++j) {
+                d0 = ((AxisAlignedBB) list.get(j)).a(this.getBoundingBox(), d0);
+            }
+
+            this.a(this.getBoundingBox().c(d0, 0.0D, 0.0D));
+            j = 0;
+
+            for (k = list.size(); j < k; ++j) {
+                d2 = ((AxisAlignedBB) list.get(j)).c(this.getBoundingBox(), d2);
+            }
+
+            this.a(this.getBoundingBox().c(0.0D, 0.0D, d2));
+            double d10;
+
+            if (this.P > 0.0F && flag1 && (d6 != d0 || d8 != d2)) {
+                double d11 = d0;
+                double d12 = d1;
+                double d13 = d2;
+                AxisAlignedBB axisalignedbb1 = this.getBoundingBox();
+
+                this.a(axisalignedbb);
+                d1 = (double) this.P;
+                List list1 = this.world.getCubes(this, this.getBoundingBox().a(d6, d1, d8));
+                /*te_task = new TE_Pool(this, d6, d1, d8);
+                te_task.fork();
+                List list1 = te_task.join();*/ 
+                AxisAlignedBB axisalignedbb2 = this.getBoundingBox();
+                AxisAlignedBB axisalignedbb3 = axisalignedbb2.a(d6, 0.0D, d8);
+
+                d10 = d1;
+                int l = 0;
+
+                for (int i1 = list1.size(); l < i1; ++l) {
+                    d10 = ((AxisAlignedBB) list1.get(l)).b(axisalignedbb3, d10);
+                }
+
+                axisalignedbb2 = axisalignedbb2.c(0.0D, d10, 0.0D);
+                double d14 = d6;
+                int j1 = 0;
+
+                for (int k1 = list1.size(); j1 < k1; ++j1) {
+                    d14 = ((AxisAlignedBB) list1.get(j1)).a(axisalignedbb2, d14);
+                }
+
+                axisalignedbb2 = axisalignedbb2.c(d14, 0.0D, 0.0D);
+                double d15 = d8;
+                int l1 = 0;
+
+                for (int i2 = list1.size(); l1 < i2; ++l1) {
+                    d15 = ((AxisAlignedBB) list1.get(l1)).c(axisalignedbb2, d15);
+                }
+
+                axisalignedbb2 = axisalignedbb2.c(0.0D, 0.0D, d15);
+                AxisAlignedBB axisalignedbb4 = this.getBoundingBox();
+                double d16 = d1;
+                int j2 = 0;
+
+                for (int k2 = list1.size(); j2 < k2; ++j2) {
+                    d16 = ((AxisAlignedBB) list1.get(j2)).b(axisalignedbb4, d16);
+                }
+
+                axisalignedbb4 = axisalignedbb4.c(0.0D, d16, 0.0D);
+                double d17 = d6;
+                int l2 = 0;
+
+                for (int i3 = list1.size(); l2 < i3; ++l2) {
+                    d17 = ((AxisAlignedBB) list1.get(l2)).a(axisalignedbb4, d17);
+                }
+
+                axisalignedbb4 = axisalignedbb4.c(d17, 0.0D, 0.0D);
+                double d18 = d8;
+                int j3 = 0;
+
+                for (int k3 = list1.size(); j3 < k3; ++j3) {
+                    d18 = ((AxisAlignedBB) list1.get(j3)).c(axisalignedbb4, d18);
+                }
+
+                axisalignedbb4 = axisalignedbb4.c(0.0D, 0.0D, d18);
+                double d19 = d14 * d14 + d15 * d15;
+                double d20 = d17 * d17 + d18 * d18;
+
+                if (d19 > d20) {
+                    d0 = d14;
+                    d2 = d15;
+                    d1 = -d10;
+                    this.a(axisalignedbb2);
+                } else {
+                    d0 = d17;
+                    d2 = d18;
+                    d1 = -d16;
+                    this.a(axisalignedbb4);
+                }
+
+                int l3 = 0;
+
+                for (int i4 = list1.size(); l3 < i4; ++l3) {
+                    d1 = ((AxisAlignedBB) list1.get(l3)).b(this.getBoundingBox(), d1);
+                }
+
+                this.a(this.getBoundingBox().c(0.0D, d1, 0.0D));
+                if (d11 * d11 + d13 * d13 >= d0 * d0 + d2 * d2) {
+                    d0 = d11;
+                    d1 = d12;
+                    d2 = d13;
+                    this.a(axisalignedbb1);
+                }
+            }
+
+            this.world.methodProfiler.b();
+            this.world.methodProfiler.a("rest");
+            this.recalcPosition();
+            this.positionChanged = d6 != d0 || d8 != d2;
+            this.B = d7 != d1;
+            this.onGround = this.B && d7 < 0.0D;
+            this.C = this.positionChanged || this.B;
+            j = MathHelper.floor(this.locX);
+            k = MathHelper.floor(this.locY - 0.20000000298023224D);
+            int j4 = MathHelper.floor(this.locZ);
+            BlockPosition blockposition = new BlockPosition(j, k, j4);
+            IBlockData iblockdata = this.world.getType(blockposition);
+
+            if (iblockdata.getMaterial() == Material.AIR) {
+                BlockPosition blockposition1 = blockposition.down();
+                IBlockData iblockdata1 = this.world.getType(blockposition1);
+                Block block = iblockdata1.getBlock();
+
+                if (block instanceof BlockFence || block instanceof BlockCobbleWall || block instanceof BlockFenceGate) {
+                    iblockdata = iblockdata1;
+                    blockposition = blockposition1;
+                }
+            }
+
+            this.a(d1, this.onGround, iblockdata, blockposition);
+            if (d6 != d0) {
+                this.motX = 0.0D;
+            }
+
+            if (d8 != d2) {
+                this.motZ = 0.0D;
+            }
+
+            Block block1 = iblockdata.getBlock();
+
+            if (d7 != d1) {
+                block1.a(this.world, this);
+            }
+
+            // CraftBukkit start
+            if (positionChanged && getBukkitEntity() instanceof Vehicle) {
+                Vehicle vehicle = (Vehicle) this.getBukkitEntity();
+                org.bukkit.block.Block bl = this.world.getWorld().getBlockAt(MathHelper.floor(this.locX), MathHelper.floor(this.locY), MathHelper.floor(this.locZ));
+
+                if (d6 > d0) {
+                    bl = bl.getRelative(BlockFace.EAST);
+                } else if (d6 < d0) {
+                    bl = bl.getRelative(BlockFace.WEST);
+                } else if (d8 > d2) {
+                    bl = bl.getRelative(BlockFace.SOUTH);
+                } else if (d8 < d2) {
+                    bl = bl.getRelative(BlockFace.NORTH);
+                }
+
+                VehicleBlockCollisionEvent event = new VehicleBlockCollisionEvent(vehicle, bl);
+                world.getServer().getPluginManager().callEvent(event);
+            }
+            // CraftBukkit end
+
+            if (this.playStepSound() && !flag && !this.isPassenger()) {
+                double d21 = this.locX - d3;
+                double d22 = this.locY - d4;
+
+                d10 = this.locZ - d5;
+                if (block1 != Blocks.LADDER) {
+                    d22 = 0.0D;
+                }
+
+                if (block1 != null && this.onGround) {
+                    block1.stepOn(this.world, blockposition, this);
+                }
+
+                this.J = (float) ((double) this.J + (double) MathHelper.sqrt(d21 * d21 + d10 * d10) * 0.6D);
+                this.K = (float) ((double) this.K + (double) MathHelper.sqrt(d21 * d21 + d22 * d22 + d10 * d10) * 0.6D);
+                if (this.K > (float) this.ax && iblockdata.getMaterial() != Material.AIR) {
+                    this.ax = (int) this.K + 1;
+                    if (this.isInWater()) {
+                        float f = MathHelper.sqrt(this.motX * this.motX * 0.20000000298023224D + this.motY * this.motY + this.motZ * this.motZ * 0.20000000298023224D) * 0.35F;
+
+                        if (f > 1.0F) {
+                            f = 1.0F;
+                        }
+
+                        this.a(this.aa(), f, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
+                    }
+
+                    this.a(blockposition, block1);
+                }
+            }
 
             boolean flag2 = this.ai();
 
@@ -2654,4 +2995,20 @@
 
         }
     }
+    
+    class move extends RecursiveAction {
+        double d0, d1, d2;
+        
+        move(double d0, double d1, double d2) {
+            this.d0 = d0;
+            this.d1 = d1;
+            this.d2 = d2;
+        }
+        
+        @Override
+        protected void compute() {
+            move_hose(d0, d1, d2);
+        }
+                 
+    }
 }
diff -Naur src_origin/main/java/net/minecraft/server/EntityLiving.java src/main/java/net/minecraft/server/EntityLiving.java
--- src_origin/main/java/net/minecraft/server/EntityLiving.java	2016-06-17 04:20:29.618705922 +0800
+++ src/main/java/net/minecraft/server/EntityLiving.java	2016-06-17 23:17:02.240456027 +0800
@@ -14,6 +14,7 @@
 import java.util.ArrayList;
 import com.google.common.base.Function;
 import com.google.common.collect.Lists;
+import java.util.concurrent.RecursiveAction;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.attribute.CraftAttributeMap;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
@@ -27,6 +28,7 @@
 // CraftBukkit end
 
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.hose.GE_Pool;
 
 public abstract class EntityLiving extends Entity {
 
@@ -1915,6 +1917,8 @@
         return f1;
     }
 
+    Collide co_task;
+    ai_move aim_task;
     public void n() {
         if (this.bC > 0) {
             --this.bC;
@@ -1959,6 +1963,8 @@
         } else if (this.ct()) {
             this.world.methodProfiler.a("newAi");
             this.doTick();
+            /*Tick t_task = new Tick(this);
+            t_task.fork();*/
             this.world.methodProfiler.b();
         }
         SpigotTimings.timerEntityAI.stopTiming(); // Spigot
@@ -1985,12 +1991,16 @@
         this.bh *= 0.9F;
         this.r();
         SpigotTimings.timerEntityAIMove.startTiming(); // Spigot
-        this.g(this.bf, this.bg);
+        //this.g(this.bf, this.bg);
+        aim_task = new ai_move(this);
+        aim_task.fork();
         SpigotTimings.timerEntityAIMove.stopTiming(); // Spigot
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("push");
         SpigotTimings.timerEntityAICollision.startTiming(); // Spigot
-        this.cs();
+        //this.cs();
+        co_task = new Collide(this);
+        co_task.fork();
         SpigotTimings.timerEntityAICollision.stopTiming(); // Spigot
         this.world.methodProfiler.b();
     }
@@ -2022,12 +2032,13 @@
 
     protected void doTick() {}
 
+    GE_Pool ge_task;
     protected void cs() {
         List list = this.world.getEntities(this, this.getBoundingBox(), IEntitySelector.a(this));
-
+        
         if (!list.isEmpty()) {
-                numCollisions = Math.max(0, numCollisions - world.spigotConfig.maxCollisionsPerEntity); // Spigot
-                for (int i = 0; i < list.size() && numCollisions < world.spigotConfig.maxCollisionsPerEntity; ++i) {
+            numCollisions = Math.max(0, numCollisions - world.spigotConfig.maxCollisionsPerEntity); // Spigot
+            for (int i = 0; i < list.size() && numCollisions < world.spigotConfig.maxCollisionsPerEntity; ++i) {
                 Entity entity = (Entity) list.get(i);
                 // TODO better check now?
                 // CraftBukkit start - Only handle mob (non-player) collisions every other tick
@@ -2418,4 +2429,50 @@
 
         }
     }
+    
+    class Collide extends RecursiveAction {
+        EntityLiving el;
+
+        public Collide(EntityLiving el){
+            this.el = el;
+
+        }
+
+        @Override
+        protected void compute() {
+            el.cs();
+        }
+
+    }
+    
+    class Tick extends RecursiveAction {
+        EntityLiving el;
+
+        public Tick(EntityLiving el){
+            this.el = el;
+
+        }
+
+        @Override
+        protected void compute() {
+            el.doTick();
+        }
+
+    }
+    
+    class ai_move extends RecursiveAction {
+        EntityLiving el;
+
+        public ai_move(EntityLiving el){
+            this.el = el;
+
+        }
+
+        @Override
+        protected void compute() {
+            el.g(el.bf, el.bg);
+        }
+
+    }
+    
 }
diff -Naur src_origin/main/java/net/minecraft/server/EntityTracker.java src/main/java/net/minecraft/server/EntityTracker.java
--- src_origin/main/java/net/minecraft/server/EntityTracker.java	2016-06-17 04:20:29.754705910 +0800
+++ src/main/java/net/minecraft/server/EntityTracker.java	2016-06-17 23:17:03.064455951 +0800
@@ -12,7 +12,8 @@
 
     private static final Logger a = LogManager.getLogger();
     private final WorldServer world;
-    private final Set<EntityTrackerEntry> c = Sets.newHashSet();
+    //private final Set<EntityTrackerEntry> c = Sets.newHashSet();
+    private final Set<EntityTrackerEntry> c = Sets.newConcurrentHashSet();
     public final IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
     private int e;
 
@@ -147,7 +148,7 @@
     }
 
     public void untrackEntity(Entity entity) {
-        org.spigotmc.AsyncCatcher.catchOp( "entity untrack"); // Spigot
+        //org.spigotmc.AsyncCatcher.catchOp( "entity untrack"); // Spigot
         if (entity instanceof EntityPlayer) {
             EntityPlayer entityplayer = (EntityPlayer) entity;
             Iterator iterator = this.c.iterator();
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2016-06-17 04:20:29.995705888 +0800
+++ src/main/java/net/minecraft/server/MinecraftServer.java	2016-06-17 23:17:03.833455881 +0800
@@ -33,6 +33,7 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
 import java.util.Random;
@@ -40,6 +41,7 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
+import java.util.concurrent.RecursiveAction;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
 import org.apache.commons.lang3.Validate;
@@ -51,6 +53,8 @@
 import org.bukkit.craftbukkit.CraftServer;
 // CraftBukkit end
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.hose.ChunkGen_Pool;
+import org.spigotmc.SpigotWorldConfig;
 
 public abstract class MinecraftServer implements Runnable, ICommandListener, IAsyncTaskHandler, IMojangStatistics {
 
@@ -359,6 +363,9 @@
             long j = av();
             i = 0;
 
+            //hose
+            List<int[]> chunkgen_list = new LinkedList();
+            int[] pos = new int[2];
             for (int k = -192; k <= 192 && this.isRunning(); k += 16) {
                 for (int l = -192; l <= 192 && this.isRunning(); l += 16) {
                     long i1 = av();
@@ -369,9 +376,13 @@
                     }
 
                     ++i;
-                    worldserver.getChunkProviderServer().getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    //worldserver.getChunkProviderServer().getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    pos[0] = blockposition.getX() + k >> 4;
+                    pos[1] = blockposition.getZ() + l >> 4;
+                    chunkgen_list.add(pos);
                 }
             }
+            SpigotWorldConfig.ChunkPool.invoke(new ChunkGen_Pool(worldserver, chunkgen_list));
         }
 
         for (WorldServer world : this.worlds) {
@@ -722,6 +733,7 @@
         org.spigotmc.CustomTimingsHandler.tick(); // Spigot
     }
 
+    //World_Pool w_task;
     public void D() {
         this.methodProfiler.a("jobs");
         Queue queue = this.j;
@@ -766,7 +778,7 @@
 
         for (i = 0; i < this.worlds.size(); ++i) { // CraftBukkit
             long j = System.nanoTime();
-
+            
             // if (i == 0 || this.getAllowNether()) {
                 WorldServer worldserver = this.worlds.get(i);
 
@@ -786,6 +798,9 @@
                 try {
                     worldserver.timings.doTick.startTiming(); // Spigot
                     worldserver.doTick();
+                    /*w_task = new World_Pool(worldserver);
+                    w_task.fork();
+                    w_task.join();*/
                     worldserver.timings.doTick.stopTiming(); // Spigot
                 } catch (Throwable throwable) {
                     // Spigot Start
@@ -802,6 +817,11 @@
                 try {
                     worldserver.timings.tickEntities.startTiming(); // Spigot
                     worldserver.tickEntities();
+                    //entity move
+                    /*for (RecursiveAction task : SpigotWorldConfig.move_forks) {
+                        task.fork();
+                    }
+                    SpigotWorldConfig.move_forks.clear();*/
                     worldserver.timings.tickEntities.stopTiming(); // Spigot
                 } catch (Throwable throwable1) {
                     // Spigot Start
@@ -1034,7 +1054,8 @@
     }
 
     public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        //return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "Hose"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1116,7 +1137,8 @@
     }
 
     public String getName() {
-        return "Server";
+        //return "Server";
+        return org.bukkit.ChatColor.GREEN + "Server";
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
diff -Naur src_origin/main/java/net/minecraft/server/PlayerChunkMap.java src/main/java/net/minecraft/server/PlayerChunkMap.java
--- src_origin/main/java/net/minecraft/server/PlayerChunkMap.java	2016-06-17 04:20:30.145705874 +0800
+++ src/main/java/net/minecraft/server/PlayerChunkMap.java	2016-06-17 23:17:04.108455856 +0800
@@ -4,6 +4,7 @@
 import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
@@ -17,6 +18,7 @@
 
 // CraftBukkit start
 import java.util.LinkedList;
+import java.util.Queue;
 // CraftBukkit end
 
 public class PlayerChunkMap {
@@ -42,10 +44,12 @@
     private final WorldServer world;
     private final List<EntityPlayer> managedPlayers = Lists.newArrayList();
     private final Long2ObjectMap<PlayerChunk> e = new Long2ObjectOpenHashMap(4096);
-    private final Set<PlayerChunk> f = Sets.newHashSet();
+    //private final Set<PlayerChunk> f = Sets.newHashSet();
+    private final Set<PlayerChunk> f = Sets.newConcurrentHashSet();
     private final List<PlayerChunk> g = Lists.newLinkedList();
     private final List<PlayerChunk> h = Lists.newLinkedList();
-    private final List<PlayerChunk> i = Lists.newArrayList();
+    //private final List<PlayerChunk> i = Lists.newArrayList();
+    private final Queue<PlayerChunk> i = Queues.newConcurrentLinkedQueue();
     private int j;
     private long k;
     private boolean l = true;
@@ -108,11 +112,18 @@
         if (i - this.k > 8000L) {
             this.k = i;
 
+            Iterator it = this.i.iterator();
+            while (it.hasNext()) {
+                playerchunk = (PlayerChunk) it.next();
+                playerchunk.d();
+                playerchunk.c();
+            }
+            /*
             for (j = 0; j < this.i.size(); ++j) {
                 playerchunk = (PlayerChunk) this.i.get(j);
                 playerchunk.d();
                 playerchunk.c();
-            }
+            }*/
         }
 
         if (!this.f.isEmpty()) {
diff -Naur src_origin/main/java/net/minecraft/server/SpawnerCreature.java src/main/java/net/minecraft/server/SpawnerCreature.java
--- src_origin/main/java/net/minecraft/server/SpawnerCreature.java	2016-06-17 04:20:30.309705859 +0800
+++ src/main/java/net/minecraft/server/SpawnerCreature.java	2016-06-17 23:17:04.410455828 +0800
@@ -1,8 +1,10 @@
 package net.minecraft.server;
 
+import com.google.common.collect.Sets;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
+import java.util.Set;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.util.LongHash;
@@ -13,7 +15,8 @@
 public final class SpawnerCreature {
 
     private static final int a = (int) Math.pow(17.0D, 2.0D);
-    private final LongHashSet b = new LongHashSet(); // CraftBukkit
+    //private final LongHashSet b = new LongHashSet(); // CraftBukkit
+    private final Set b = Sets.newConcurrentHashSet();
 
     public SpawnerCreature() {}
 
@@ -29,7 +32,9 @@
             int z = LongHash.lsw( coord );
             if ( !((ChunkProviderServer)server.chunkProvider).unloadQueue.contains( coord ) && server.isChunkLoaded( x, z, true ) )
             {
-                i += server.getChunkAt( x, z ).entityCount.get( oClass );
+                synchronized (this){
+                    i += server.getChunkAt( x, z ).entityCount.get( oClass );
+                }
             }
         }
         return i;
diff -Naur src_origin/main/java/net/minecraft/server/World.java src/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2016-06-17 04:20:30.435705848 +0800
+++ src/main/java/net/minecraft/server/World.java	2016-06-17 23:17:04.622455808 +0800
@@ -15,7 +15,10 @@
 
 // CraftBukkit start
 import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
 import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.RecursiveAction;
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
@@ -34,7 +37,8 @@
     private int a = 63;
     protected boolean d;
     // Spigot start - guard entity list from removals
-    public final List<Entity> entityList = new java.util.ArrayList<Entity>()
+    public final List<Entity> entityList = Lists.newCopyOnWriteArrayList();
+    /*public final List<Entity> entityList = new java.util.ArrayList<Entity>()
     {
         @Override
         public Entity remove(int index)
@@ -57,16 +61,19 @@
                 throw new java.util.ConcurrentModificationException();
             }
         }
-    };
+    };*/
     // Spigot end
-    protected final List<Entity> f = Lists.newArrayList();
+    //protected final List<Entity> f = Lists.newArrayList();
+    protected final Queue<Entity> f = Queues.newConcurrentLinkedQueue();
     public final List<TileEntity> tileEntityList = Lists.newArrayList();
     public final List<TileEntity> tileEntityListTick = Lists.newArrayList();
     private final List<TileEntity> b = Lists.newArrayList();
     private final List<TileEntity> tileEntityListUnload = Lists.newArrayList();
     public final List<EntityHuman> players = Lists.newArrayList();
-    public final List<Entity> j = Lists.newArrayList();
-    protected final IntHashMap<Entity> entitiesById = new IntHashMap();
+    //public final List<Entity> j = Lists.newArrayList();
+    public final Queue<Entity> j = Queues.newConcurrentLinkedQueue();
+    //protected final IntHashMap<Entity> entitiesById = new IntHashMap();
+    protected final Map<Integer, Entity> entitiesById = Maps.newConcurrentMap();
     private final long I = 16777215L;
     private int J;
     protected int l = (new Random()).nextInt();
@@ -950,7 +957,7 @@
     }
 
     public boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
-        org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
+        //org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
         if (entity == null) return false;
         // CraftBukkit end
         int i = MathHelper.floor(entity.locX / 16.0D);
@@ -1030,12 +1037,12 @@
 
         entity.valid = true; // CraftBukkit
     }
-
+    
     protected void c(Entity entity) {
         for (int i = 0; i < this.u.size(); ++i) {
             ((IWorldAccess) this.u.get(i)).b(entity);
         }
-
+        
         entity.valid = false; // CraftBukkit
     }
 
@@ -1343,9 +1350,39 @@
         this.methodProfiler.a("entities");
         this.methodProfiler.a("global");
 
-        int i;
+        //int i;
         Entity entity;
+        
+        Iterator it_j = this.j.iterator();
+        while (it_j.hasNext()) {
+            entity = (Entity) it_j.next();
+            // CraftBukkit start - Fixed an NPE
+            if (entity == null) {
+                continue;
+            }
+            // CraftBukkit end
+
+            try {
+                ++entity.ticksLived;
+                entity.m();
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Ticking entity");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being ticked");
+
+                if (entity == null) {
+                    crashreportsystemdetails.a("Entity", (Object) "~~NULL~~");
+                } else {
+                    entity.appendEntityCrashDetails(crashreportsystemdetails);
+                }
 
+                throw new ReportedException(crashreport);
+            }
+
+            if (entity.dead) {
+                this.j.remove(entity);
+            }
+        }
+        /*
         for (i = 0; i < this.j.size(); ++i) {
             entity = (Entity) this.j.get(i);
             // CraftBukkit start - Fixed an NPE
@@ -1373,13 +1410,24 @@
             if (entity.dead) {
                 this.j.remove(i--);
             }
-        }
+        }*/
 
         this.methodProfiler.c("remove");
         this.entityList.removeAll(this.f);
 
         int j;
 
+        Iterator it = this.f.iterator();
+        while (it.hasNext()) {
+            entity = (Entity) it.next();
+            int k = entity.ac;
+
+            j = entity.ae;
+            if (entity.ab && this.isChunkLoaded(k, j, true)) {
+                this.getChunkAt(k, j).b(entity);
+            }
+        }
+        /*
         for (i = 0; i < this.f.size(); ++i) {
             entity = (Entity) this.f.get(i);
             int k = entity.ac;
@@ -1388,11 +1436,16 @@
             if (entity.ab && this.isChunkLoaded(k, j, true)) {
                 this.getChunkAt(k, j).b(entity);
             }
-        }
+        }*/
 
+        Iterator it1 = this.f.iterator();
+        while (it1.hasNext()) {
+            this.c((Entity) it1.next());
+        }
+        /*
         for (i = 0; i < this.f.size(); ++i) {
             this.c((Entity) this.f.get(i));
-        }
+        }*/
 
         this.f.clear();
         this.l();
@@ -1413,8 +1466,12 @@
             tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
             entity = (Entity) this.entityList.get(this.tickPosition);
             // CraftBukkit end
+            //Entity entity1 = entity.bB();
+            /*if (entity.bB() == null) {
+                continue;
+            }*/
             Entity entity1 = entity.bB();
-
+            
             if (entity1 != null) {
                 if (!entity1.dead && entity1.w(entity)) {
                     continue;
@@ -1428,6 +1485,8 @@
                 try {
                     SpigotTimings.tickEntityTimer.startTiming(); // Spigot
                     this.g(entity);
+                    /*tg_task = new TG_Pool(this, entity);
+                    SpigotWorldConfig.move_forks.add(tg_task);*/
                     SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
                 } catch (Throwable throwable1) {
                     crashreport1 = CrashReport.a(throwable1, "Ticking entity");
@@ -1455,8 +1514,16 @@
 
             this.methodProfiler.b();
         }
+        /*
+        for (RecursiveAction task : SpigotWorldConfig.move_forks) {
+            task.fork();
+        }
+        for (RecursiveAction task : SpigotWorldConfig.move_forks) {
+            task.join();
+        }
+        SpigotWorldConfig.move_forks.clear();*/
         guardEntityList = false; // Spigot
-
+        
         timings.entityTick.stopTiming(); // Spigot
         this.methodProfiler.c("blockEntities");
         this.M = true;
@@ -2084,8 +2151,11 @@
         this.allowAnimals = flag1;
     }
 
+    WT_Pool wt_task;
     public void doTick() {
-        this.t();
+        //this.t();
+        wt_task = new WT_Pool();
+        wt_task.fork();
     }
 
     protected void I() {
@@ -2160,11 +2230,18 @@
                 this.o = MathHelper.a(this.o, 0.0F, 1.0F);
 
                 // CraftBukkit start
+                Iterator it = this.players.iterator();
+                while (it.hasNext()) {
+                    if (((EntityPlayer) it.next()).world == this) {
+                        ((EntityPlayer) it.next()).tickWeather();
+                    }
+                }
+                /*
                 for (int idx = 0; idx < this.players.size(); ++idx) {
                     if (((EntityPlayer) this.players.get(idx)).world == this) {
                         ((EntityPlayer) this.players.get(idx)).tickWeather();
                     }
-                }
+                }*/
                 // CraftBukkit end
             }
         }
@@ -2548,7 +2625,8 @@
 
     public int a(Class<?> oclass) {
         int i = 0;
-        Iterator iterator = this.entityList.iterator();
+        //Iterator iterator = this.entityList.iterator();
+        Iterator iterator = Queues.newConcurrentLinkedQueue(this.entityList).iterator();
 
         while (iterator.hasNext()) {
             Entity entity = (Entity) iterator.next();
@@ -3116,4 +3194,17 @@
     public LootTableRegistry ak() {
         return this.B;
     }
+    
+    public class WT_Pool extends RecursiveAction {
+
+        public WT_Pool(){
+            
+        }
+
+        @Override
+        protected void compute() {
+            t();
+        }
+    }
+    
 }
diff -Naur src_origin/main/java/net/minecraft/server/WorldManager.java src/main/java/net/minecraft/server/WorldManager.java
--- src_origin/main/java/net/minecraft/server/WorldManager.java	2016-06-17 04:20:30.465705845 +0800
+++ src/main/java/net/minecraft/server/WorldManager.java	2016-06-17 23:17:04.673455804 +0800
@@ -23,7 +23,7 @@
 
     }
 
-    public void b(Entity entity) {
+    public synchronized void b(Entity entity) {
         this.world.getTracker().untrackEntity(entity);
         this.world.getScoreboard().a(entity);
         if (entity instanceof EntityPlayer) {
diff -Naur src_origin/main/java/net/minecraft/server/WorldMap.java src/main/java/net/minecraft/server/WorldMap.java
--- src_origin/main/java/net/minecraft/server/WorldMap.java	2016-06-17 04:20:30.499705842 +0800
+++ src/main/java/net/minecraft/server/WorldMap.java	2016-06-17 23:17:04.686455803 +0800
@@ -25,7 +25,8 @@
     public byte scale;
     public byte[] colors = new byte[16384];
     public List<WorldMap.WorldMapHumanTracker> h = Lists.newArrayList();
-    public final Map<EntityHuman, WorldMap.WorldMapHumanTracker> j = Maps.newHashMap(); // Spigot
+    //public final Map<EntityHuman, WorldMap.WorldMapHumanTracker> j = Maps.newHashMap(); // Spigot
+    public final Map<EntityHuman, WorldMap.WorldMapHumanTracker> j = Maps.newConcurrentMap();
     public Map<UUID, MapIcon> decorations = Maps.newLinkedHashMap(); // Spigot
 
     // CraftBukkit start
diff -Naur src_origin/main/java/net/minecraft/server/WorldServer.java src/main/java/net/minecraft/server/WorldServer.java
--- src_origin/main/java/net/minecraft/server/WorldServer.java	2016-06-17 04:20:30.515705840 +0800
+++ src/main/java/net/minecraft/server/WorldServer.java	2016-06-17 23:17:04.715455800 +0800
@@ -3,6 +3,7 @@
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.io.File;
@@ -11,10 +12,12 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
 import java.util.Random;
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.UUID;
+import java.util.concurrent.RecursiveAction;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -38,6 +41,7 @@
     private final PlayerChunkMap manager;
     // private final Set<NextTickListEntry> nextTickListHash = Sets.newHashSet();
     private final HashTreeSet<NextTickListEntry> nextTickList = new HashTreeSet<NextTickListEntry>(); // CraftBukkit - HashTreeSet
+    //private final Set<NextTickListEntry> nextTickList = Sets.newLinkedHashSet();
     private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
     public boolean savingDisabled;
     private boolean O;
@@ -47,7 +51,8 @@
     protected final VillageSiege siegeManager = new VillageSiege(this);
     private final WorldServer.BlockActionDataList[] S = new WorldServer.BlockActionDataList[] { new WorldServer.BlockActionDataList(null), new WorldServer.BlockActionDataList(null)};
     private int T;
-    private final List<NextTickListEntry> U = Lists.newArrayList();
+    //private final List<NextTickListEntry> U = Lists.newArrayList();
+    private final Queue<NextTickListEntry> U = Queues.newConcurrentLinkedQueue();
 
     // CraftBukkit start
     public final int dimension;
@@ -392,6 +397,9 @@
         this.methodProfiler.b();
     }
 
+    //important calculation
+    light_tick l_task;
+    chunk_tick c_tick;
     protected void j() {
         this.i();
         if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
@@ -409,15 +417,20 @@
             this.methodProfiler.a("pollingChunks");
 
             for (Iterator iterator1 = this.manager.b(); iterator1.hasNext(); this.methodProfiler.b()) {
+                //chunk_tick_hose(chunk, i , flag, flag1);
                 this.methodProfiler.a("getChunk");
                 Chunk chunk = (Chunk) iterator1.next();
                 int j = chunk.locX * 16;
                 int k = chunk.locZ * 16;
 
                 this.methodProfiler.c("checkNextLight");
-                chunk.n();
+                //chunk.n();
+                l_task = new light_tick(chunk);
+                l_task.fork();
                 this.methodProfiler.c("tickChunk");
-                chunk.b(false);
+                //chunk.b(false);
+                c_tick = new chunk_tick(chunk);
+                c_tick.fork();
                 if ( !chunk.areNeighborsLoaded( 1 ) ) continue; // Spigot
                 this.methodProfiler.c("thunder");
                 int l;
@@ -503,7 +516,7 @@
 
                                 this.methodProfiler.a("randomTick");
                                 if (block.isTicking()) {
-                                    block.a((World) this, new BlockPosition(i2 + j, k2 + chunksection.getYPosition(), j2 + k), iblockdata, this.random);
+                                   block.a((World) this, new BlockPosition(i2 + j, k2 + chunksection.getYPosition(), j2 + k), iblockdata, this.random);
                                 }
 
                                 this.methodProfiler.b();
@@ -517,6 +530,112 @@
         }
     }
 
+    public void chunk_tick_hose(Chunk chunk, int i, boolean flag, boolean flag1) {
+        this.methodProfiler.a("getChunk");
+        int j = chunk.locX * 16;
+        int k = chunk.locZ * 16;
+
+        this.methodProfiler.c("checkNextLight");
+        //chunk.n();
+        l_task = new light_tick(chunk);
+        l_task.fork();
+        this.methodProfiler.c("tickChunk");
+        chunk.b(false);
+        if ( !chunk.areNeighborsLoaded( 1 ) ) return;
+        this.methodProfiler.c("thunder");
+        int l;
+        BlockPosition blockposition;
+
+        if (flag && flag1 && this.random.nextInt(100000) == 0) {
+            this.l = this.l * 3 + 1013904223;
+            l = this.l >> 2;
+            blockposition = this.a(new BlockPosition(j + (l & 15), 0, k + (l >> 8 & 15)));
+            if (this.isRainingAt(blockposition)) {
+                DifficultyDamageScaler difficultydamagescaler = this.D(blockposition);
+
+                if (this.random.nextDouble() < (double) difficultydamagescaler.b() * 0.05D) {
+                    EntityHorse entityhorse = new EntityHorse(this);
+
+                    entityhorse.setType(EnumHorseType.SKELETON);
+                    entityhorse.y(true);
+                    entityhorse.setAgeRaw(0);
+                    entityhorse.setPosition((double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ());
+                    this.addEntity(entityhorse, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.LIGHTNING); // CraftBukkit
+                    this.strikeLightning(new EntityLightning(this, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), true));
+                } else {
+                    this.strikeLightning(new EntityLightning(this, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ(), false));
+                }
+            }
+        }
+
+        this.methodProfiler.c("iceandsnow");
+        if (this.random.nextInt(16) == 0) {
+            this.l = this.l * 3 + 1013904223;
+            l = this.l >> 2;
+            blockposition = this.p(new BlockPosition(j + (l & 15), 0, k + (l >> 8 & 15)));
+            BlockPosition blockposition1 = blockposition.down();
+
+            if (this.v(blockposition1)) {
+                // CraftBukkit start
+                BlockState blockState = this.getWorld().getBlockAt(blockposition1.getX(), blockposition1.getY(), blockposition1.getZ()).getState();
+                blockState.setTypeId(Block.getId(Blocks.ICE));
+
+                BlockFormEvent iceBlockForm = new BlockFormEvent(blockState.getBlock(), blockState);
+                this.getServer().getPluginManager().callEvent(iceBlockForm);
+                if (!iceBlockForm.isCancelled()) {
+                    blockState.update(true);
+                }
+                // CraftBukkit end
+            }
+
+            if (flag && this.f(blockposition, true)) {
+                // CraftBukkit start
+                BlockState blockState = this.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()).getState();
+                blockState.setTypeId(Block.getId(Blocks.SNOW_LAYER));
+
+                BlockFormEvent snow = new BlockFormEvent(blockState.getBlock(), blockState);
+                this.getServer().getPluginManager().callEvent(snow);
+                if (!snow.isCancelled()) {
+                    blockState.update(true);
+                }
+                // CraftBukkit end
+            }
+
+            if (flag && this.getBiome(blockposition1).d()) {
+                this.getType(blockposition1).getBlock().h(this, blockposition1);
+            }
+        }
+
+        this.methodProfiler.c("tickBlocks");
+        if (i > 0) {
+            ChunkSection[] achunksection = chunk.getSections();
+            int i1 = achunksection.length;
+
+            for (int j1 = 0; j1 < i1; ++j1) {
+                ChunkSection chunksection = achunksection[j1];
+
+                if (chunksection != Chunk.a && chunksection.shouldTick()) {
+                    for (int k1 = 0; k1 < i; ++k1) {
+                        this.l = this.l * 3 + 1013904223;
+                        int l1 = this.l >> 2;
+                        int i2 = l1 & 15;
+                        int j2 = l1 >> 8 & 15;
+                        int k2 = l1 >> 16 & 15;
+                        IBlockData iblockdata = chunksection.getType(i2, k2, j2);
+                        Block block = iblockdata.getBlock();
+
+                        this.methodProfiler.a("randomTick");
+                        if (block.isTicking()) {
+                           block.a((World) this, new BlockPosition(i2 + j, k2 + chunksection.getYPosition(), j2 + k), iblockdata, this.random);
+                        }
+
+                        this.methodProfiler.b();
+                    }
+                }
+            }
+        }
+    }
+    
     protected BlockPosition a(BlockPosition blockposition) {
         BlockPosition blockposition1 = this.p(blockposition);
         AxisAlignedBB axisalignedbb = (new AxisAlignedBB(blockposition1, new BlockPosition(blockposition1.getX(), this.getHeight(), blockposition1.getZ()))).g(3.0D);
@@ -709,7 +828,8 @@
                 NextTickListEntry nextticklistentry;
 
                 for (int j = 0; j < i; ++j) {
-                    nextticklistentry = (NextTickListEntry) this.nextTickList.first();
+                    //nextticklistentry = (NextTickListEntry) this.nextTickList.first();
+                    nextticklistentry = (NextTickListEntry) this.nextTickList.iterator().next();
                     if (!flag && nextticklistentry.b > this.worldData.getTime()) {
                         break;
                     }
@@ -1124,7 +1244,8 @@
 
     protected void b(Entity entity) {
         super.b(entity);
-        this.entitiesById.a(entity.getId(), entity);
+        //this.entitiesById.a(entity.getId(), entity);
+        this.entitiesById.put(entity.getId(), entity);
         this.entitiesByUUID.put(entity.getUniqueID(), entity);
         Entity[] aentity = entity.aT();
 
@@ -1135,7 +1256,8 @@
             for (int j = 0; j < i; ++j) {
                 Entity entity1 = aentity1[j];
 
-                this.entitiesById.a(entity1.getId(), entity1);
+                //this.entitiesById.a(entity1.getId(), entity1);
+                this.entitiesById.put(entity1.getId(), entity1);
             }
         }
 
@@ -1143,7 +1265,8 @@
 
     protected void c(Entity entity) {
         super.c(entity);
-        this.entitiesById.d(entity.getId());
+        //this.entitiesById.d(entity.getId());
+        this.entitiesById.remove(entity.getId());
         this.entitiesByUUID.remove(entity.getUniqueID());
         Entity[] aentity = entity.aT();
 
@@ -1154,7 +1277,8 @@
             for (int j = 0; j < i; ++j) {
                 Entity entity1 = aentity1[j];
 
-                this.entitiesById.d(entity1.getId());
+                //this.entitiesById.d(entity1.getId());
+                this.entitiesById.remove(entity1.getId());
             }
         }
 
@@ -1393,4 +1517,57 @@
             this();
         }
     }
+    
+    class block_tick extends RecursiveAction {
+        WorldServer worldserver;
+        int i2, j, k2, j2, k;
+        ChunkSection chunksection;
+        IBlockData iblockdata;
+        
+        block_tick(WorldServer worldserver, int i2, int j, int k2, int j2, int k, ChunkSection chunksection, IBlockData iblockdata) {
+            this.worldserver = worldserver;
+            this.i2 = i2;
+            this.j = j;
+            this.k2 = k2;
+            this.j2 = j2;
+            this.k = k;
+            this.chunksection = chunksection;
+            this.iblockdata = iblockdata;
+        }
+        
+        @Override
+        protected void compute() {
+            iblockdata.getBlock().a((World) worldserver, new BlockPosition(i2 + j, k2 + chunksection.getYPosition(), j2 + k), iblockdata, worldserver.random);
+        }
+                 
+    }
+    
+    class light_tick extends RecursiveAction {
+        Chunk chunk;
+        
+        light_tick(Chunk chunk) {
+            this.chunk = chunk;
+        }
+        
+        @Override
+        protected void compute() {
+            chunk.n();
+        }
+                 
+    }
+    
+    class chunk_tick extends RecursiveAction {
+        Chunk chunk;
+        
+        chunk_tick(Chunk chunk) {
+            this.chunk = chunk;
+        }
+        
+        @Override
+        protected void compute() {
+            chunk.b(false);
+        }
+                 
+    }
+    
 }
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-06-17 04:20:32.973705615 +0800
+++ src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-06-17 23:17:09.961455319 +0800
@@ -1,16 +1,25 @@
 package org.bukkit.craftbukkit.util;
 
+import com.google.common.collect.Sets;
+import java.util.AbstractSet;
+import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Comparator;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
+import java.util.SortedSet;
 import java.util.TreeSet;
+import java.util.concurrent.ConcurrentSkipListSet;
 
 public class HashTreeSet<V> implements Set<V> {
 
-    private HashSet<V> hash = new HashSet<V>();
-    private TreeSet<V> tree = new TreeSet<V>();
-
+    /*private HashSet<V> hash = new HashSet<V>();
+    private TreeSet<V> tree = new TreeSet<V>();*/
+    private Set<V> hash = Sets.newConcurrentHashSet();
+    private TreeSet<V> tset = new TreeSet<V>();
+    private ConcurrentSkipListSet<V> tree = new ConcurrentSkipListSet<V>(new IterateOnlySortedSet<V>(tset));
+    
     public HashTreeSet() {
 
     }
@@ -113,5 +122,57 @@
     public V first() {
         return tree.first();
     }
+    
+    static class IterateOnlySortedSet<E> extends AbstractSet<E> implements SortedSet<E> {
+        private final ArrayList<E> elements;
+        private final Comparator<? super E> comparator;
+
+        public IterateOnlySortedSet(SortedSet<E> source) {
+          elements = new ArrayList<>(source);
+          comparator = source.comparator();
+        }
+
+        @Override
+        public Iterator<E> iterator() {
+          return elements.iterator();
+        }
+
+        @Override
+        public int size() {
+          return elements.size();
+        }
+
+        @Override
+        public Comparator<? super E> comparator() {
+          return comparator;
+        }
+
+        // remaining methods simply throw UnsupportedOperationException
+
+        @Override
+        public SortedSet<E> subSet(E fromElement, E toElement) {
+            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
+        }
+
+        @Override
+        public SortedSet<E> headSet(E toElement) {
+            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
+        }
+
+        @Override
+        public SortedSet<E> tailSet(E fromElement) {
+            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
+        }
+
+        @Override
+        public E first() {
+            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
+        }
+
+        @Override
+        public E last() {
+            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
+        }
+    }
 
 }
diff -Naur src_origin/main/java/org/hose/ChunkFlush_Pool.java src/main/java/org/hose/ChunkFlush_Pool.java
--- src_origin/main/java/org/hose/ChunkFlush_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChunkFlush_Pool.java	2016-06-17 23:16:58.485456371 +0800
@@ -0,0 +1,53 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.PlayerChunk;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkFlush_Pool extends RecursiveAction {//need to use callable
+    List<PlayerChunk> chunkflush_list;
+    
+    public ChunkFlush_Pool(List<PlayerChunk> chunkflush_list){
+        this.chunkflush_list = chunkflush_list;
+    }
+    
+    @Override
+    protected void compute() {
+        List<RecursiveAction> forks = new LinkedList();
+        for (PlayerChunk pc : chunkflush_list) {
+            chunkflush task = new chunkflush(pc);
+            forks.add(task);
+            task.fork();
+            //task.join();
+        }
+        /*
+        for (RecursiveAction task : forks) {
+            task.join();
+        }*/
+    }
+    
+    
+    class chunkflush extends RecursiveAction {
+        PlayerChunk pc;
+        
+        chunkflush(PlayerChunk pc) {
+            this.pc = pc;
+        }
+        
+        @Override
+        protected void compute() {
+            pc.d();
+        }
+                 
+    }
+}
diff -Naur src_origin/main/java/org/hose/ChunkGen_Pool.java src/main/java/org/hose/ChunkGen_Pool.java
--- src_origin/main/java/org/hose/ChunkGen_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChunkGen_Pool.java	2016-06-17 23:16:58.485456371 +0800
@@ -0,0 +1,54 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.WorldServer;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkGen_Pool extends RecursiveAction {
+    WorldServer worldserver;
+    List<int[]> position;
+    
+    public ChunkGen_Pool(WorldServer worldserver, List<int[]> position){
+        this.worldserver = worldserver;
+        this.position = position;
+        
+    }
+    
+    @Override
+    protected void compute() {
+        List<RecursiveAction> forks = new LinkedList();
+        for (int[] pt : position) {
+            chunkgen task = new chunkgen(worldserver, pt);
+            forks.add(task);
+            task.fork();
+        }
+        
+    }
+    
+    
+    class chunkgen extends RecursiveAction {
+        WorldServer worldserver;
+        int[] pt;
+        
+        chunkgen(WorldServer worldserver, int[] pt) {
+            this.worldserver = worldserver;
+            this.pt = pt;
+        }
+        
+        @Override
+        protected void compute() {
+            worldserver.getChunkProviderServer().getChunkAt(pt[0], pt[1]);
+        }
+                 
+    }
+}
diff -Naur src_origin/main/java/org/hose/ChunkPopulate_Pool.java src/main/java/org/hose/ChunkPopulate_Pool.java
--- src_origin/main/java/org/hose/ChunkPopulate_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChunkPopulate_Pool.java	2016-06-17 23:16:58.485456371 +0800
@@ -0,0 +1,35 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.Random;
+import java.util.concurrent.RecursiveAction;
+import org.bukkit.Chunk;
+import org.bukkit.World;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkPopulate_Pool extends RecursiveAction {//need to use callable
+    World world;
+    Random random;
+    Chunk chunk;
+    org.bukkit.generator.BlockPopulator populator;
+    
+    public ChunkPopulate_Pool(World world, Random random, Chunk chunk, org.bukkit.generator.BlockPopulator populator){
+        this.world = world;
+        this.random = random;
+        this.chunk = chunk;
+        this.populator = populator;
+    }
+    
+    @Override
+    protected void compute() {
+        populator.populate(world, random, chunk);
+    }
+
+}
diff -Naur src_origin/main/java/org/hose/GE_Pool.java src/main/java/org/hose/GE_Pool.java
--- src_origin/main/java/org/hose/GE_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/GE_Pool.java	2016-06-17 23:16:58.506456369 +0800
@@ -0,0 +1,32 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import java.util.concurrent.RecursiveTask;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityLiving;
+import net.minecraft.server.IEntitySelector;
+import net.minecraft.server.World;
+
+
+/**
+ *
+ * @author softpak
+ */
+public class GE_Pool extends RecursiveTask<List> {
+    EntityLiving el;
+    
+    public GE_Pool(EntityLiving el){
+        this.el = el;
+    }
+    
+    @Override
+    protected List compute() {
+        return el.world.getEntities(el, el.getBoundingBox(), IEntitySelector.a(el));
+    }
+}
diff -Naur src_origin/main/java/org/hose/TE_Pool.java src/main/java/org/hose/TE_Pool.java
--- src_origin/main/java/org/hose/TE_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/TE_Pool.java	2016-06-17 23:16:58.484456371 +0800
@@ -0,0 +1,34 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import java.util.concurrent.RecursiveTask;
+import net.minecraft.server.Entity;
+import net.minecraft.server.World;
+
+
+/**
+ *
+ * @author softpak
+ */
+public class TE_Pool extends RecursiveTask<List> {
+    Entity entity;
+    double d0, d1, d2;
+    
+    public TE_Pool(Entity entity, double d0, double d1, double d2){
+        this.entity = entity;
+        this.d0 = d0;
+        this.d1 = d1;
+        this.d2 = d2;
+    }
+    
+    @Override
+    protected List compute() {
+        return entity.world.getCubes(entity, entity.getBoundingBox().a(d0, d1, d2));
+    }
+}
diff -Naur src_origin/main/java/org/hose/Tick_Pool.java src/main/java/org/hose/Tick_Pool.java
--- src_origin/main/java/org/hose/Tick_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/Tick_Pool.java	2016-06-17 23:16:58.491456370 +0800
@@ -0,0 +1,32 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.Entity;
+import net.minecraft.server.World;
+
+
+/**
+ *
+ * @author softpak
+ */
+public class Tick_Pool extends RecursiveAction {
+    Entity entity;
+    World world;
+    
+    public Tick_Pool(Entity entity){
+        this.entity = entity;
+        //this.world = world;
+        
+    }
+    
+    @Override
+    protected void compute() {
+        entity.U();
+    }
+    
+}
diff -Naur src_origin/main/java/org/spigotmc/ActivationRange.java src/main/java/org/spigotmc/ActivationRange.java
--- src_origin/main/java/org/spigotmc/ActivationRange.java	2016-06-17 04:20:28.481706027 +0800
+++ src/main/java/org/spigotmc/ActivationRange.java	2016-06-17 23:16:58.551456365 +0800
@@ -1,6 +1,7 @@
 package org.spigotmc;
 
 import java.util.List;
+import java.util.Queue;
 import java.util.Set;
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.Chunk;
@@ -141,7 +142,8 @@
      */
     private static void activateChunkEntities(Chunk chunk)
     {
-        for ( List<Entity> slice : chunk.entitySlices )
+        //for ( List<Entity> slice : chunk.entitySlices )
+        for ( Queue<Entity> slice : chunk.entitySlices )
         {
             for ( Entity entity : slice )
             {
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2016-06-17 04:20:28.473706027 +0800
+++ src/main/java/org/spigotmc/AsyncCatcher.java	2016-06-17 23:16:58.585456362 +0800
@@ -11,6 +11,7 @@
     {
         if ( enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread )
         {
+            MinecraftServer.getServer().postToMainThread(Thread.currentThread());
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
         }
     }
diff -Naur src_origin/main/java/org/spigotmc/SpigotWorldConfig.java src/main/java/org/spigotmc/SpigotWorldConfig.java
--- src_origin/main/java/org/spigotmc/SpigotWorldConfig.java	2016-06-17 04:20:28.481706027 +0800
+++ src/main/java/org/spigotmc/SpigotWorldConfig.java	2016-06-17 23:16:58.662456355 +0800
@@ -1,12 +1,115 @@
 package org.spigotmc;
 
 import java.util.List;
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.ForkJoinWorkerThread;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
 public class SpigotWorldConfig
 {
 
+    //hose start
+    static public final int cpu_core = Runtime.getRuntime().availableProcessors();
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fetp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("EntityTickPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fttp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("TileTickPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fmp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("MovePool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fpcp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("PlayerChunkPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcfpt3 = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkFlushPool_T3-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcpp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkPopulate_Pool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    public static ForkJoinPool EntityTickPool;
+    public static ForkJoinPool TileTickPool;
+    public static ForkJoinPool MovePool;
+    public static ForkJoinPool PlayerChunkPool;
+    public static ForkJoinPool ChunkPool;
+    public static ForkJoinPool ChunkFlushPool_T3;
+    public static ForkJoinPool ChunkPopulate_Pool;
+    
+    /*
+    static public FutureTask CollideTask;
+        
+    static final ThreadFactory tfcp = new ThreadFactoryBuilder().setNameFormat("Collide_Pool-%d").build();
+    static public final ExecutorService collidepool_executor = Executors.newFixedThreadPool(cpu_core, tfcp);*/
+    
+    public static int worldtickentitypool_core_multiple;
+    
+    public static int getthreadnumber(){
+        return cpu_core*worldtickentitypool_core_multiple;
+    }
+    
+    private void wetp_core_multiple()
+    {
+        worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 4);
+        EntityTickPool = new ForkJoinPool(getthreadnumber(), fetp, null, false);
+        TileTickPool = new ForkJoinPool(getthreadnumber(), fttp, null, false);
+        MovePool = new ForkJoinPool(getthreadnumber(), fmp, null, false);
+        PlayerChunkPool = new ForkJoinPool(getthreadnumber(), fpcp, null, false);
+        ChunkPool = new ForkJoinPool(getthreadnumber(), fcp, null, false);
+        ChunkFlushPool_T3 = new ForkJoinPool(getthreadnumber(), fcfpt3, null, false);
+        ChunkPopulate_Pool = new ForkJoinPool(getthreadnumber(), fcpp, null, false);
+        //executor = new ThreadPoolExecutor(getthreadnumber(), getthreadnumber(), 1, TimeUnit.DAYS, queue);
+        log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
+    }
+    
+    
+       
+    //hose end
+    
     private final String worldName;
     private final YamlConfiguration config;
     private boolean verbose;
