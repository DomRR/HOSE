diff -Naur src_origin/main/java/net/minecraft/server/BlockFlowing.java src_new/main/java/net/minecraft/server/BlockFlowing.java
--- src_origin/main/java/net/minecraft/server/BlockFlowing.java	2016-02-05 01:52:02.795371353 +0800
+++ src_new/main/java/net/minecraft/server/BlockFlowing.java	2016-02-18 14:41:08.095271834 +0800
@@ -12,13 +12,15 @@
 
 public class BlockFlowing extends BlockFluids {
 
-    int a;
+    //int a;
+    public int a;
 
     protected BlockFlowing(Material material) {
         super(material);
     }
 
-    private void f(World world, BlockPosition blockposition, IBlockData iblockdata) {
+    public void f(World world, BlockPosition blockposition, IBlockData iblockdata) {
+    //private void f(World world, BlockPosition blockposition, IBlockData iblockdata) {
         world.setTypeAndData(blockposition, b(this.material).getBlockData().set(BlockFlowing.LEVEL, iblockdata.get(BlockFlowing.LEVEL)), 2);
     }
 
@@ -34,10 +36,11 @@
         if (this.material == Material.LAVA && !world.worldProvider.n()) {
             b0 = 2;
         }
-
         int j = this.a(world);
         int k;
-
+        
+        
+        
         if (i > 0) {
             int l = -100;
 
@@ -193,8 +196,9 @@
 
         return j;
     }
-
-    private Set<EnumDirection> f(World world, BlockPosition blockposition) {
+    
+    public Set<EnumDirection> f(World world, BlockPosition blockposition) {
+    //private Set<EnumDirection> f(World world, BlockPosition blockposition) {
         int i = 1000;
         EnumSet enumset = EnumSet.noneOf(EnumDirection.class);
         Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
@@ -227,13 +231,15 @@
         return enumset;
     }
 
-    private boolean g(World world, BlockPosition blockposition, IBlockData iblockdata) {
+    public boolean g(World world, BlockPosition blockposition, IBlockData iblockdata) {
+    //private boolean g(World world, BlockPosition blockposition, IBlockData iblockdata) {
         Block block = world.getType(blockposition).getBlock();
 
         return !(block instanceof BlockDoor) && block != Blocks.STANDING_SIGN && block != Blocks.LADDER && block != Blocks.REEDS ? (block.material == Material.PORTAL ? true : block.material.isSolid()) : true;
     }
 
-    protected int a(World world, BlockPosition blockposition, int i) {
+    public int a(World world, BlockPosition blockposition, int i) {
+    //protected int a(World world, BlockPosition blockposition, int i) {
         int j = this.e(world, blockposition);
 
         if (j < 0) {
@@ -251,7 +257,8 @@
         }
     }
 
-    private boolean h(World world, BlockPosition blockposition, IBlockData iblockdata) {
+    public boolean h(World world, BlockPosition blockposition, IBlockData iblockdata) {
+    //private boolean h(World world, BlockPosition blockposition, IBlockData iblockdata) {
         Material material = iblockdata.getBlock().getMaterial();
 
         return material != this.material && material != Material.LAVA && !this.g(world, blockposition, iblockdata);
diff -Naur src_origin/main/java/net/minecraft/server/Block.java src_new/main/java/net/minecraft/server/Block.java
--- src_origin/main/java/net/minecraft/server/Block.java	2016-02-05 01:52:02.263371378 +0800
+++ src_new/main/java/net/minecraft/server/Block.java	2016-02-18 14:41:07.691271796 +0800
@@ -73,7 +73,8 @@
     protected double maxZ;
     public Block.StepSound stepSound;
     public float I;
-    protected final Material material;
+    //protected final Material material;
+    public final Material material;
     protected final MaterialMapColor K;
     public float frictionFactor;
     protected final BlockStateList blockStateList;
diff -Naur src_origin/main/java/net/minecraft/server/Chunk.java src_new/main/java/net/minecraft/server/Chunk.java
--- src_origin/main/java/net/minecraft/server/Chunk.java	2016-02-05 01:52:04.131371288 +0800
+++ src_new/main/java/net/minecraft/server/Chunk.java	2016-02-18 14:41:08.984271917 +0800
@@ -15,7 +15,11 @@
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists; // CraftBukkit
+import java.util.concurrent.FutureTask;
 import org.bukkit.Bukkit; // CraftBukkit
+import org.hose.AdjustValuePool;
+import org.spigotmc.SpigotWorldConfig;
+import static org.spigotmc.SpigotWorldConfig.dotickpool_executor;
 
 public class Chunk {
 
@@ -42,7 +46,8 @@
     private long u;
     private int v;
     private ConcurrentLinkedQueue<BlockPosition> w;
-    protected gnu.trove.map.hash.TObjectIntHashMap<Class> entityCount = new gnu.trove.map.hash.TObjectIntHashMap<Class>(); // Spigot
+    //protected gnu.trove.map.hash.TObjectIntHashMap<Class> entityCount = new gnu.trove.map.hash.TObjectIntHashMap<Class>(); // Spigot
+    public gnu.trove.map.hash.TObjectIntHashMap<Class> entityCount = new gnu.trove.map.hash.TObjectIntHashMap<Class>(); // Spigot
 
     // CraftBukkit start - Neighbor loaded cache for chunk lighting and entity ticking
     private int neighbors = 0x1 << 12;
@@ -719,7 +724,9 @@
         {
             if ( creatureType.a().isAssignableFrom( entity.getClass() ) )
             {
-                this.entityCount.adjustValue( creatureType.a(), -1 );
+                //this.entityCount.adjustValue( creatureType.a(), -1 );
+                SpigotWorldConfig.TickEntityTask = new FutureTask(new AdjustValuePool(this, creatureType));
+                SpigotWorldConfig.dotickpool_executor.submit(SpigotWorldConfig.TickEntityTask);
             }
         }
         // Spigot end
@@ -890,26 +897,30 @@
         for (int k = i; k <= j; ++k) {
             if (!this.entitySlices[k].isEmpty()) {
                 Iterator iterator = this.entitySlices[k].iterator();
+                
+                try{
+                    while (iterator.hasNext()) {
+                        Entity entity1 = (Entity) iterator.next();
+
+                        if (entity1.getBoundingBox().b(axisalignedbb) && entity1 != entity) {
+                            if (predicate == null || predicate.apply(entity1)) {
+                                list.add(entity1);
+                            }
 
-                while (iterator.hasNext()) {
-                    Entity entity1 = (Entity) iterator.next();
-
-                    if (entity1.getBoundingBox().b(axisalignedbb) && entity1 != entity) {
-                        if (predicate == null || predicate.apply(entity1)) {
-                            list.add(entity1);
-                        }
-
-                        Entity[] aentity = entity1.aB();
+                            Entity[] aentity = entity1.aB();
 
-                        if (aentity != null) {
-                            for (int l = 0; l < aentity.length; ++l) {
-                                entity1 = aentity[l];
-                                if (entity1 != entity && entity1.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply(entity1))) {
-                                    list.add(entity1);
+                            if (aentity != null) {
+                                for (int l = 0; l < aentity.length; ++l) {
+                                    entity1 = aentity[l];
+                                    if (entity1 != entity && entity1.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply(entity1))) {
+                                        list.add(entity1);
+                                    }
                                 }
                             }
                         }
                     }
+                }catch(Exception ex){
+                    
                 }
             }
         }
@@ -922,16 +933,19 @@
 
         i = MathHelper.clamp(i, 0, this.entitySlices.length - 1);
         j = MathHelper.clamp(j, 0, this.entitySlices.length - 1);
-
+        
         for (int k = i; k <= j; ++k) {
             Iterator iterator = this.entitySlices[k].iterator(); // Spigot
+            try{
+                while (iterator.hasNext()) {
+                    Entity entity = (Entity) iterator.next();
 
-            while (iterator.hasNext()) {
-                Entity entity = (Entity) iterator.next();
-
-                if (oclass.isInstance(entity) && entity.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply((T) entity))) { // CraftBukkit - fix decompile error // Spigot
-                    list.add((T) entity); // Fix decompile error
+                    if (oclass.isInstance(entity) && entity.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply((T) entity))) { // CraftBukkit - fix decompile error // Spigot
+                        list.add((T) entity); // Fix decompile error
+                    }
                 }
+            }catch (Exception ex){
+                        
             }
         }
 
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderServer.java src_new/main/java/net/minecraft/server/ChunkProviderServer.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderServer.java	2016-02-05 01:52:04.171371286 +0800
+++ src_new/main/java/net/minecraft/server/ChunkProviderServer.java	2016-02-18 14:41:09.012271919 +0800
@@ -1,19 +1,13 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Lists;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start
 import java.util.Random;
-import java.util.logging.Level;
 
 import org.bukkit.Server;
 import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
@@ -311,22 +305,26 @@
 
         // CraftBukkit start
         Iterator iterator = this.chunks.values().iterator();
-        while (iterator.hasNext()) {
-            Chunk chunk = (Chunk) iterator.next();
-            // CraftBukkit end
+        try {
+            while (iterator.hasNext()) {
+                Chunk chunk = (Chunk) iterator.next();
+                // CraftBukkit end
 
-            if (flag) {
-                this.saveChunkNOP(chunk);
-            }
+                if (flag) {
+                    this.saveChunkNOP(chunk);
+                }
 
-            if (chunk.a(flag)) {
-                this.saveChunk(chunk);
-                chunk.f(false);
-                ++i;
-                if (i == 24 && !flag && false) { // Spigot
-                    return false;
+                if (chunk.a(flag)) {
+                    this.saveChunk(chunk);
+                    chunk.f(false);
+                    ++i;
+                    if (i == 24 && !flag && false) { // Spigot
+                        return false;
+                    }
                 }
             }
+        } catch(Exception ex){
+            
         }
 
         return true;
diff -Naur src_origin/main/java/net/minecraft/server/ChunkRegionLoader.java src_new/main/java/net/minecraft/server/ChunkRegionLoader.java
--- src_origin/main/java/net/minecraft/server/ChunkRegionLoader.java	2016-02-05 01:52:04.199371285 +0800
+++ src_new/main/java/net/minecraft/server/ChunkRegionLoader.java	2016-02-18 14:41:09.029271921 +0800
@@ -275,9 +275,13 @@
                 Entity entity = (Entity) iterator.next();
 
                 nbttagcompound1 = new NBTTagCompound();
-                if (entity.d(nbttagcompound1)) {
-                    chunk.g(true);
-                    nbttaglist1.add(nbttagcompound1);
+                try {
+                    if (entity.d(nbttagcompound1)) {
+                        chunk.g(true);
+                        nbttaglist1.add(nbttagcompound1);
+                    }
+                }catch(Exception ex){
+                    
                 }
             }
         }
diff -Naur src_origin/main/java/net/minecraft/server/DedicatedServer.java src_new/main/java/net/minecraft/server/DedicatedServer.java
--- src_origin/main/java/net/minecraft/server/DedicatedServer.java	2016-02-05 01:52:05.123371240 +0800
+++ src_new/main/java/net/minecraft/server/DedicatedServer.java	2016-02-18 14:41:09.571271972 +0800
@@ -49,6 +49,7 @@
             }
 
             public void run() {
+                //AffinityLock al = AffinityLock.acquireLock();
                 while (true) {
                     try {
                         Thread.sleep(2147483647L);
diff -Naur src_origin/main/java/net/minecraft/server/EntityEnderDragon.java src_new/main/java/net/minecraft/server/EntityEnderDragon.java
--- src_origin/main/java/net/minecraft/server/EntityEnderDragon.java	2016-02-05 01:52:06.000371197 +0800
+++ src_new/main/java/net/minecraft/server/EntityEnderDragon.java	2016-02-18 14:41:10.007272012 +0800
@@ -676,7 +676,8 @@
         // CraftBukkit end
     }
 
-    protected void D() {}
+    //protected void D() {}
+    public void D() {}
 
     public Entity[] aB() {
         return this.children;
diff -Naur src_origin/main/java/net/minecraft/server/EntityInsentient.java src_new/main/java/net/minecraft/server/EntityInsentient.java
--- src_origin/main/java/net/minecraft/server/EntityInsentient.java	2016-02-05 01:52:06.407371177 +0800
+++ src_new/main/java/net/minecraft/server/EntityInsentient.java	2016-02-18 14:41:10.297272040 +0800
@@ -17,15 +17,20 @@
 
     public int a_;
     protected int b_;
-    private ControllerLook lookController;
-    protected ControllerMove moveController;
-    protected ControllerJump g;
+    //private ControllerLook lookController;
+    public ControllerLook lookController;
+    //protected ControllerMove moveController;
+    public ControllerMove moveController;
+    //protected ControllerJump g;
+    public ControllerJump g;
     private EntityAIBodyControl b;
-    protected NavigationAbstract navigation;
+    //protected NavigationAbstract navigation;
+    public NavigationAbstract navigation;
     public PathfinderGoalSelector goalSelector;
     public PathfinderGoalSelector targetSelector;
     private EntityLiving goalTarget;
-    private EntitySenses bk;
+    //private EntitySenses bk;
+    public EntitySenses bk;
     private ItemStack[] equipment = new ItemStack[5];
     public float[] dropChances = new float[5];
     public boolean canPickUpLoot;
@@ -194,7 +199,6 @@
         if (!this.world.isClientSide) {
             this.ca();
         }
-
     }
 
     protected float h(float f, float f1) {
@@ -317,8 +321,8 @@
             }
         }
 
-        this.bo = nbttagcompound.getBoolean("Leashed");
         if (this.bo && nbttagcompound.hasKeyOfType("Leash", 10)) {
+        this.bo = nbttagcompound.getBoolean("Leashed");
             this.bq = nbttagcompound.getCompound("Leash");
         }
 
@@ -426,7 +430,8 @@
         return true;
     }
 
-    protected void D() {
+    public void D() {
+    //protected void D() {
         if (this.persistent) {
             this.ticksFarFromPlayer = 0;
         } else {
@@ -451,7 +456,8 @@
 
         }
     }
-
+    
+    @Override
     protected final void doTick() {
         ++this.ticksFarFromPlayer;
         this.world.methodProfiler.a("checkDespawn");
@@ -941,4 +947,6 @@
 
         private EnumEntityPositionType() {}
     }
+    
+    
 }
diff -Naur src_origin/main/java/net/minecraft/server/Entity.java src_new/main/java/net/minecraft/server/Entity.java
--- src_origin/main/java/net/minecraft/server/Entity.java	2016-02-05 01:52:05.791371207 +0800
+++ src_new/main/java/net/minecraft/server/Entity.java	2016-02-18 14:41:09.742271988 +0800
@@ -5,6 +5,7 @@
 import java.util.Random;
 import java.util.UUID;
 import java.util.concurrent.Callable;
+import java.util.concurrent.FutureTask;
 
 // CraftBukkit start
 import org.bukkit.Bukkit;
@@ -30,6 +31,8 @@
 import org.bukkit.event.entity.EntityCombustEvent;
 import org.bukkit.event.entity.EntityPortalEvent;
 import org.bukkit.plugin.PluginManager;
+import org.hose.t_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class Entity implements ICommandListener {
@@ -245,6 +248,9 @@
 
     public void t_() {
         this.K();
+        //works fine
+        /*SpigotWorldConfig.t_Task = new FutureTask(new t_Pool(this));
+        SpigotWorldConfig.t_pool_executor.submit(SpigotWorldConfig.t_Task);*/
     }
 
     public void K() {
@@ -294,7 +300,10 @@
 
             if (this.portalCooldown > 0) {
                 --this.portalCooldown;
+            } else {
+                teleport_count = 0;
             }
+            
 
             this.world.methodProfiler.b();
         }
@@ -395,7 +404,13 @@
         return this.world.getCubes(this, axisalignedbb).isEmpty() && !this.world.containsLiquid(axisalignedbb);
     }
 
+    //hose
     public void move(double d0, double d1, double d2) {
+        this.moveto(d0, d1, d2);
+    }
+
+    public void moveto(double d0, double d1, double d2) {
+    //public void move(double d0, double d1, double d2) {
         org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.startTiming(); // Spigot
         if (this.noclip) {
             this.a(this.getBoundingBox().c(d0, d1, d2));
@@ -1640,7 +1655,7 @@
     }
 
     public int aq() {
-        return 300;
+        return 300;//300
     }
 
     public ItemStack[] getEquipment() {
@@ -1924,8 +1939,10 @@
         }
     }
 
+    int teleport_count = 0;
     public void teleportTo(Location exit, boolean portal) {
-        if (true) {
+        if (true && teleport_count == 0) {
+            teleport_count = 1;
             WorldServer worldserver = ((CraftWorld) getBukkitEntity().getLocation().getWorld()).getHandle();
             WorldServer worldserver1 = ((CraftWorld) exit.getWorld()).getHandle();
             int i = worldserver1.dimension;
diff -Naur src_origin/main/java/net/minecraft/server/EntityLiving.java src_new/main/java/net/minecraft/server/EntityLiving.java
--- src_origin/main/java/net/minecraft/server/EntityLiving.java	2016-02-05 01:52:06.631371167 +0800
+++ src_new/main/java/net/minecraft/server/EntityLiving.java	2016-02-18 14:41:10.483272057 +0800
@@ -1485,6 +1485,8 @@
 
         SpigotTimings.timerEntityBaseTick.stopTiming(); // Spigot
         this.m();
+        /*SpigotWorldConfig.t_Task = new FutureTask(new t_Pool(this));
+        SpigotWorldConfig.t_pool_executor.submit(SpigotWorldConfig.t_Task);*/
         SpigotTimings.timerEntityTickRest.startTiming(); // Spigot
         double d0 = this.locX - this.lastX;
         double d1 = this.locZ - this.lastZ;
@@ -1665,36 +1667,40 @@
     protected void doTick() {}
 
     protected void bL() {
-        List list = this.world.a((Entity) this, this.getBoundingBox().grow(0.20000000298023224D, 0.0D, 0.20000000298023224D), Predicates.and(IEntitySelector.d, new Predicate() {
-            public boolean a(Entity entity) {
-                return entity.ae();
-            }
-
-            public boolean apply(Object object) {
-                return this.a((Entity) object);
-            }
-        }));
+        try {
+            List list = this.world.a((Entity) this, this.getBoundingBox().grow(0.20000000298023224D, 0.0D, 0.20000000298023224D), Predicates.and(IEntitySelector.d, new Predicate() {
+                public boolean a(Entity entity) {
+                    return entity.ae();
+                }
 
-        if (this.ad() && !list.isEmpty()) { // Spigot: Add this.ad() condition
-            numCollisions -= world.spigotConfig.maxCollisionsPerEntity; // Spigot
-            for (int i = 0; i < list.size(); ++i) {
-                if (numCollisions > world.spigotConfig.maxCollisionsPerEntity) { break; } // Spigot
-                Entity entity = (Entity) list.get(i);
-
-                // TODO better check now?
-                // CraftBukkit start - Only handle mob (non-player) collisions every other tick
-                if (entity instanceof EntityLiving && !(this instanceof EntityPlayer) && this.ticksLived % 2 == 0) {
-                    continue;
+                public boolean apply(Object object) {
+                    return this.a((Entity) object);
                 }
-                // CraftBukkit end
+            }));
+        
 
-                entity.numCollisions++; // Spigot
-                numCollisions++; // Spigot
-                this.s(entity);
+            if (this.ad() && !list.isEmpty()) { // Spigot: Add this.ad() condition
+                numCollisions -= world.spigotConfig.maxCollisionsPerEntity; // Spigot
+                for (int i = 0; i < list.size(); ++i) {
+                    if (numCollisions > world.spigotConfig.maxCollisionsPerEntity) { break; } // Spigot
+                    Entity entity = (Entity) list.get(i);
+
+                    // TODO better check now?
+                    // CraftBukkit start - Only handle mob (non-player) collisions every other tick
+                    if (entity instanceof EntityLiving && !(this instanceof EntityPlayer) && this.ticksLived % 2 == 0) {
+                        continue;
+                    }
+                    // CraftBukkit end
+
+                    entity.numCollisions++; // Spigot
+                    numCollisions++; // Spigot
+                    this.s(entity);
+                }
+                numCollisions = 0; // Spigot
             }
-            numCollisions = 0; // Spigot
+        } catch(Exception ex){
+            
         }
-
     }
 
     protected void s(Entity entity) {
diff -Naur src_origin/main/java/net/minecraft/server/EntityPlayer.java src_new/main/java/net/minecraft/server/EntityPlayer.java
--- src_origin/main/java/net/minecraft/server/EntityPlayer.java	2016-02-05 01:52:06.939371152 +0800
+++ src_new/main/java/net/minecraft/server/EntityPlayer.java	2016-02-18 14:41:10.663272074 +0800
@@ -184,6 +184,7 @@
         this.playerConnection.sendPacket(new PacketPlayOutCombatEvent(this.bs(), PacketPlayOutCombatEvent.EnumCombatEventType.END_COMBAT));
     }
 
+    //player tick
     public void t_() {
         // CraftBukkit start
         if (this.joining) {
diff -Naur src_origin/main/java/net/minecraft/server/EntityTracker.java src_new/main/java/net/minecraft/server/EntityTracker.java
--- src_origin/main/java/net/minecraft/server/EntityTracker.java	2016-02-05 01:52:07.363371131 +0800
+++ src_new/main/java/net/minecraft/server/EntityTracker.java	2016-02-18 14:41:11.007272106 +0800
@@ -33,6 +33,9 @@
 
                 if (entitytrackerentry.tracker != entityplayer) {
                     entitytrackerentry.updatePlayer(entityplayer);
+                    /*
+                    SpigotWorldConfig.TrackUpdateTask = new FutureTask(new TrackUpdatePool(entitytrackerentry, entityplayer));
+                    SpigotWorldConfig.trackupdatepool_executor.submit(SpigotWorldConfig.TrackUpdateTask);*/
                 }
             }
         } else if (entity instanceof EntityFishingHook) {
@@ -95,6 +98,7 @@
 
     public void addEntity(Entity entity, int i, final int j, boolean flag) {
         org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
+        
         i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
         if (i > this.e) {
             i = this.e;
@@ -144,7 +148,7 @@
         }
 
     }
-
+    
     public void untrackEntity(Entity entity) {
         org.spigotmc.AsyncCatcher.catchOp( "entity untrack"); // Spigot
         if (entity instanceof EntityPlayer) {
@@ -170,26 +174,33 @@
     public void updatePlayers() {
         ArrayList arraylist = Lists.newArrayList();
         Iterator iterator = this.c.iterator();
+        
+        try{
+            while (iterator.hasNext()) {
+                EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
 
-        while (iterator.hasNext()) {
-            EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
-
-            entitytrackerentry.track(this.world.players);
-            if (entitytrackerentry.n && entitytrackerentry.tracker instanceof EntityPlayer) {
-                arraylist.add((EntityPlayer) entitytrackerentry.tracker);
+                entitytrackerentry.track(this.world.players);
+                if (entitytrackerentry.n && entitytrackerentry.tracker instanceof EntityPlayer) {
+                    arraylist.add((EntityPlayer) entitytrackerentry.tracker);
+                }
             }
+        }catch(Exception ex){
+            
         }
 
         for (int i = 0; i < arraylist.size(); ++i) {
             EntityPlayer entityplayer = (EntityPlayer) arraylist.get(i);
             Iterator iterator1 = this.c.iterator();
+            try {
+                while (iterator1.hasNext()) {
+                    EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) iterator1.next();
 
-            while (iterator1.hasNext()) {
-                EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) iterator1.next();
-
-                if (entitytrackerentry1.tracker != entityplayer) {
-                    entitytrackerentry1.updatePlayer(entityplayer);
+                    if (entitytrackerentry1.tracker != entityplayer) {
+                        entitytrackerentry1.updatePlayer(entityplayer);
+                    }
                 }
+            }catch(Exception ex){
+            
             }
         }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityWither.java src_new/main/java/net/minecraft/server/EntityWither.java
--- src_origin/main/java/net/minecraft/server/EntityWither.java	2016-02-05 01:52:07.464371126 +0800
+++ src_new/main/java/net/minecraft/server/EntityWither.java	2016-02-18 14:41:11.065272111 +0800
@@ -458,7 +458,8 @@
 
     }
 
-    protected void D() {
+    public void D() {
+    //protected void D() {
         this.ticksFarFromPlayer = 0;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src_new/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2016-02-05 01:52:08.748371064 +0800
+++ src_new/main/java/net/minecraft/server/MinecraftServer.java	2016-02-18 14:41:12.041272203 +0800
@@ -43,6 +43,7 @@
 
 import jline.console.ConsoleReader;
 import joptsimple.OptionSet;
+import net.md_5.bungee.api.ChatColor;
 
 import org.bukkit.craftbukkit.Main;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
@@ -710,10 +711,12 @@
 
         // Spigot start
         FutureTask<?> entry;
+        
         int count = this.j.size();
         while (count-- > 0 && (entry = this.j.poll()) != null) {
             SystemUtils.a(entry, MinecraftServer.LOGGER);
-         }
+        }
+        
         // Spigot end
 
         this.methodProfiler.c("levels");
@@ -751,7 +754,6 @@
 
             // if (i == 0 || this.getAllowNether()) {
                 WorldServer worldserver = this.worlds.get(i);
-
                 this.methodProfiler.a(worldserver.getWorldData().getName());
                 /* Drop global time updates
                 if (this.ticks % 20 == 0) {
@@ -788,13 +790,14 @@
                 } catch (Throwable throwable1) {
                     // Spigot Start
                     try {
-                    crashreport = CrashReport.a(throwable1, "Exception ticking world entities");
+                        crashreport = CrashReport.a(throwable1, "Exception ticking world entities");
                     } catch (Throwable t){
                         throw new RuntimeException("Error generating crash report", t);
                     }
                     // Spigot End
                     worldserver.a(crashreport);
-                    throw new ReportedException(crashreport);
+                    //fix null pointer
+                    //throw new ReportedException(crashreport);
                 }
 
                 this.methodProfiler.b();
@@ -936,8 +939,14 @@
             if (options.has("world")) {
                 dedicatedserver.setWorld((String) options.valueOf("world"));
             }
-
+            //
+            //AffinityLock al = AffinityLock.acquireLock();
+            //try {
+                //al.acquireLock(AffinityStrategies.SAME_SOCKET, AffinityStrategies.ANY);
             dedicatedserver.primaryThread.start();
+            //} finally {
+                //al.release();
+            //}
             // CraftBukkit end
         } catch (Exception exception) {
             MinecraftServer.LOGGER.fatal("Failed to start the minecraft server", exception);
@@ -1023,7 +1032,7 @@
     }
 
     public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "HOSE"; // HOSE -> Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1105,7 +1114,8 @@
     }
 
     public String getName() {
-        return "Server";
+        //return "Server";
+        return ChatColor.GREEN+"Server";
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
@@ -1492,6 +1502,7 @@
         return 29999984;
     }
 
+    //queue will get negative number. need a watch.
     public <V> ListenableFuture<V> a(Callable<V> callable) {
         Validate.notNull(callable);
         if (!this.isMainThread()) { // CraftBukkit && !this.isStopped()) {
diff -Naur src_origin/main/java/net/minecraft/server/SpawnerCreature.java src_new/main/java/net/minecraft/server/SpawnerCreature.java
--- src_origin/main/java/net/minecraft/server/SpawnerCreature.java	2016-02-05 01:52:11.035370953 +0800
+++ src_new/main/java/net/minecraft/server/SpawnerCreature.java	2016-02-18 14:41:13.492272339 +0800
@@ -4,7 +4,6 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
-import java.util.Set;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.util.LongHash;
@@ -48,7 +47,7 @@
 
             int j;
             int k;
-
+            
             while (iterator.hasNext()) {
                 EntityHuman entityhuman = (EntityHuman) iterator.next();
 
diff -Naur src_origin/main/java/net/minecraft/server/SystemUtils.java src_new/main/java/net/minecraft/server/SystemUtils.java
--- src_origin/main/java/net/minecraft/server/SystemUtils.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/net/minecraft/server/SystemUtils.java	2016-02-18 14:41:13.541272343 +0800
@@ -0,0 +1,24 @@
+package net.minecraft.server;
+
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.FutureTask;
+import org.apache.logging.log4j.Logger;
+
+public class SystemUtils {
+
+    public static <V> V a(FutureTask<V> futuretask, Logger logger) {
+        try {
+            //will give a negative task error.
+            futuretask.run();
+            return futuretask.get();
+        } catch (ExecutionException executionexception) {
+            //logger.fatal("Error executing task", executionexception);
+            //throw new BreakException();
+        } catch (InterruptedException interruptedexception) {
+            //logger.fatal("Error executing task", interruptedexception);
+            //throw new BreakException();
+        }
+
+        return null;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/WorldChunkManager.java src_new/main/java/net/minecraft/server/WorldChunkManager.java
--- src_origin/main/java/net/minecraft/server/WorldChunkManager.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/net/minecraft/server/WorldChunkManager.java	2016-02-18 14:41:13.999272386 +0800
@@ -0,0 +1,201 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.List;
+import java.util.Random;
+
+public class WorldChunkManager {
+
+    private GenLayer b;
+    private GenLayer c;
+    private BiomeCache d;
+    private List<BiomeBase> e;
+    private String f;
+
+    protected WorldChunkManager() {
+        this.d = new BiomeCache(this);
+        this.f = "";
+        this.e = Lists.newArrayList();
+        this.e.add(BiomeBase.FOREST);
+        this.e.add(BiomeBase.PLAINS);
+        this.e.add(BiomeBase.TAIGA);
+        this.e.add(BiomeBase.TAIGA_HILLS);
+        this.e.add(BiomeBase.FOREST_HILLS);
+        this.e.add(BiomeBase.JUNGLE);
+        this.e.add(BiomeBase.JUNGLE_HILLS);
+    }
+
+    public WorldChunkManager(long i, WorldType worldtype, String s) {
+        this();
+        this.f = s;
+        GenLayer[] agenlayer = GenLayer.a(i, worldtype, s);
+
+        this.b = agenlayer[0];
+        this.c = agenlayer[1];
+    }
+
+    public WorldChunkManager(World world) {
+        this(world.getSeed(), world.getWorldData().getType(), world.getWorldData().getGeneratorOptions());
+    }
+
+    public List<BiomeBase> a() {
+        return this.e;
+    }
+
+    public BiomeBase getBiome(BlockPosition blockposition) {
+        return this.getBiome(blockposition, (BiomeBase) null);
+    }
+
+    public BiomeBase getBiome(BlockPosition blockposition, BiomeBase biomebase) {
+        return this.d.a(blockposition.getX(), blockposition.getZ(), biomebase);
+    }
+
+    public float[] getWetness(float[] afloat, int i, int j, int k, int l) {
+        IntCache.a();
+        if (afloat == null || afloat.length < k * l) {
+            afloat = new float[k * l];
+        }
+
+        int[] aint = this.c.a(i, j, k, l);
+
+        for (int i1 = 0; i1 < k * l; ++i1) {
+            try {
+                float f = (float) BiomeBase.getBiome(aint[i1], BiomeBase.ad).h() / 65536.0F;
+
+                if (f > 1.0F) {
+                    f = 1.0F;
+                }
+
+                afloat[i1] = f;
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Invalid Biome id");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("DownfallBlock");
+
+                crashreportsystemdetails.a("biome id", (Object) Integer.valueOf(i1));
+                crashreportsystemdetails.a("downfalls[] size", (Object) Integer.valueOf(afloat.length));
+                crashreportsystemdetails.a("x", (Object) Integer.valueOf(i));
+                crashreportsystemdetails.a("z", (Object) Integer.valueOf(j));
+                crashreportsystemdetails.a("w", (Object) Integer.valueOf(k));
+                crashreportsystemdetails.a("h", (Object) Integer.valueOf(l));
+                throw new ReportedException(crashreport);
+            }
+        }
+
+        return afloat;
+    }
+
+    public BiomeBase[] getBiomes(BiomeBase[] abiomebase, int i, int j, int k, int l) {
+        IntCache.a();
+        if (abiomebase == null || abiomebase.length < k * l) {
+            abiomebase = new BiomeBase[k * l];
+        }
+
+        int[] aint = this.b.a(i, j, k, l);
+
+        try {
+            for (int i1 = 0; i1 < k * l; ++i1) {
+                abiomebase[i1] = BiomeBase.getBiome(aint[i1], BiomeBase.ad);
+            }
+
+            return abiomebase;
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.a(throwable, "Invalid Biome id");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("RawBiomeBlock");
+
+            crashreportsystemdetails.a("biomes[] size", (Object) Integer.valueOf(abiomebase.length));
+            crashreportsystemdetails.a("x", (Object) Integer.valueOf(i));
+            crashreportsystemdetails.a("z", (Object) Integer.valueOf(j));
+            crashreportsystemdetails.a("w", (Object) Integer.valueOf(k));
+            crashreportsystemdetails.a("h", (Object) Integer.valueOf(l));
+            throw new ReportedException(crashreport);
+        }
+    }
+
+    public BiomeBase[] getBiomeBlock(BiomeBase[] abiomebase, int i, int j, int k, int l) {
+        return this.a(abiomebase, i, j, k, l, true);
+    }
+
+    public BiomeBase[] a(BiomeBase[] abiomebase, int i, int j, int k, int l, boolean flag) {
+        IntCache.a();
+        if (abiomebase == null || abiomebase.length < k * l) {
+            abiomebase = new BiomeBase[k * l];
+        }
+
+        if (flag && k == 16 && l == 16 && (i & 15) == 0 && (j & 15) == 0) {
+            BiomeBase[] abiomebase1 = this.d.c(i, j);
+
+            System.arraycopy(abiomebase1, 0, abiomebase, 0, k * l);
+            return abiomebase;
+        } else {
+            int[] aint = this.c.a(i, j, k, l);
+
+            for (int i1 = 0; i1 < k * l; ++i1) {
+                abiomebase[i1] = BiomeBase.getBiome(aint[i1], BiomeBase.ad);
+            }
+
+            return abiomebase;
+        }
+    }
+
+    public boolean a(int i, int j, int k, List<BiomeBase> list) {
+        IntCache.a();
+        int l = i - k >> 2;
+        int i1 = j - k >> 2;
+        int j1 = i + k >> 2;
+        int k1 = j + k >> 2;
+        int l1 = j1 - l + 1;
+        int i2 = k1 - i1 + 1;
+        int[] aint = this.b.a(l, i1, l1, i2);
+
+        try {
+            for (int j2 = 0; j2 < l1 * i2; ++j2) {
+                BiomeBase biomebase = BiomeBase.getBiome(aint[j2]);
+
+                if (!list.contains(biomebase)) {
+                    return false;
+                }
+            }
+
+            return true;
+        } catch (Throwable throwable) {
+            CrashReport crashreport = CrashReport.a(throwable, "Invalid Biome id");
+            CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Layer");
+
+            crashreportsystemdetails.a("Layer", (Object) this.b.toString());
+            crashreportsystemdetails.a("x", (Object) Integer.valueOf(i));
+            crashreportsystemdetails.a("z", (Object) Integer.valueOf(j));
+            crashreportsystemdetails.a("radius", (Object) Integer.valueOf(k));
+            crashreportsystemdetails.a("allowed", (Object) list);
+            throw new ReportedException(crashreport);
+        }
+    }
+
+    public BlockPosition a(int i, int j, int k, List<BiomeBase> list, Random random) {
+        IntCache.a();
+        int l = i - k >> 2;
+        int i1 = j - k >> 2;
+        int j1 = i + k >> 2;
+        int k1 = j + k >> 2;
+        int l1 = j1 - l + 1;
+        int i2 = k1 - i1 + 1;
+        int[] aint = this.b.a(l, i1, l1, i2);
+        BlockPosition blockposition = null;
+        int j2 = 0;
+        for (int k2 = 0; k2 < l1 * i2; ++k2) {
+            int l2 = l + k2 % l1 << 2;
+            int i3 = i1 + k2 / l1 << 2;
+            BiomeBase biomebase = BiomeBase.getBiome(aint[k2]);
+
+            if (list.contains(biomebase) && (blockposition == null || random.nextInt(j2 + 1) == 0)) {
+                blockposition = new BlockPosition(l2, 0, i3);
+                ++j2;
+            }
+        }
+
+        return blockposition;
+    }
+
+    public void b() {
+        this.d.a();
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/World.java src_new/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2016-02-05 01:52:11.643370923 +0800
+++ src_new/main/java/net/minecraft/server/World.java	2016-02-18 14:41:13.955272382 +0800
@@ -2,25 +2,26 @@
 
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
-import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.Callable;
 
 // CraftBukkit start
 import com.google.common.collect.Maps;
 import java.util.Map;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.FutureTask;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.craftbukkit.util.LongHashSet;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
 import org.bukkit.generator.ChunkGenerator;
 import org.bukkit.craftbukkit.CraftServer;
@@ -29,8 +30,12 @@
 import org.bukkit.event.block.BlockCanBuildEvent;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
-import org.bukkit.event.weather.WeatherChangeEvent;
-import org.bukkit.event.weather.ThunderChangeEvent;
+import org.hose.AddParticlePool;
+import org.hose.InactivePool;
+import org.hose.pendingpool.BlockBrightPendingPool;
+import org.hose.pendingpool.RayTracePendingPool;
+import org.hose.t_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class World implements IBlockAccess {
@@ -63,7 +68,8 @@
         }
     };
     // Spigot end
-    protected final List<Entity> g = Lists.newArrayList();
+    //protected final List<Entity> g = Lists.newArrayList();
+    public final List<Entity> g = Lists.newArrayList();
     public final List<TileEntity> h = Lists.newArrayList();
     public final List<TileEntity> tileEntityList = Lists.newArrayList();
     private final List<TileEntity> b = Lists.newArrayList();
@@ -323,12 +329,23 @@
     }
 
     private boolean isAreaLoaded(int i, int j, int k, int l, int i1, int j1, boolean flag) {
+        /*
+        SpigotWorldConfig.AreaLoadedPendingTask = new FutureTask(new AreaLoadedPendingPool(this,i, j, k, l, i1, j1, flag));
+        SpigotWorldConfig.arealoadpendingpool_executor.submit(SpigotWorldConfig.AreaLoadedPendingTask);
+        try {
+            return SpigotWorldConfig.AreaLoadedPendingTask.get();
+        } catch (InterruptedException ex) {
+            Logger.getLogger(World.class.getName()).log(Level.SEVERE, null, ex);
+        } catch (ExecutionException ex) {
+            Logger.getLogger(World.class.getName()).log(Level.SEVERE, null, ex);
+        }
+        return false;*/
+            
         if (i1 >= 0 && j < 256) {
             i >>= 4;
             k >>= 4;
             l >>= 4;
             j1 >>= 4;
-
             for (int k1 = i; k1 <= l; ++k1) {
                 for (int l1 = k; l1 <= j1; ++l1) {
                     if (!this.isChunkLoaded(k1, l1, flag)) {
@@ -336,14 +353,15 @@
                     }
                 }
             }
-
+            
             return true;
         } else {
             return false;
         }
     }
 
-    protected boolean isChunkLoaded(int i, int j, boolean flag) {
+    public boolean isChunkLoaded(int i, int j, boolean flag) {
+    //protected boolean isChunkLoaded(int i, int j, boolean flag) {
         return this.chunkProvider.isChunkLoaded(i, j) && (flag || !this.chunkProvider.getOrCreateChunk(i, j).isEmpty());
     }
 
@@ -473,13 +491,25 @@
 
     public boolean setTypeUpdate(BlockPosition blockposition, IBlockData iblockdata) {
         return this.setTypeAndData(blockposition, iblockdata, 3);
+        /*SpigotWorldConfig.TypeUpdatePendingTask = new FutureTask(new TypeUpdatePendingPool(this, blockposition, iblockdata));
+        SpigotWorldConfig.typeupdatependingpool_executor.submit(SpigotWorldConfig.TypeUpdatePendingTask);
+        try {
+            return SpigotWorldConfig.TypeUpdatePendingTask.get();
+        } catch (InterruptedException ex) {
+            Logger.getLogger(World.class.getName()).log(Level.SEVERE, null, ex);
+        } catch (ExecutionException ex) {
+            Logger.getLogger(World.class.getName()).log(Level.SEVERE, null, ex);
+        }
+        return false;*/
     }
-
+    
+    ChunkProviderServer cps;
     public void notify(BlockPosition blockposition) {
+        //System.out.println(cps.getChunkAt(blockposition).toString()+"!");
         for (int i = 0; i < this.u.size(); ++i) {
             ((IWorldAccess) this.u.get(i)).a(blockposition);
+            //get player who use xray-like cheat
         }
-
     }
 
     public void update(BlockPosition blockposition, Block block) {
@@ -645,6 +675,7 @@
         }
     }
 
+    //hose
     public int getLightLevel(BlockPosition blockposition) {
         return this.c(blockposition, true);
     }
@@ -792,13 +823,34 @@
     }
 
     public MovingObjectPosition rayTrace(Vec3D vec3d, Vec3D vec3d1) {
-        return this.rayTrace(vec3d, vec3d1, false, false, false);
+        //return this.rayTrace(vec3d, vec3d1, false, false, false);
+        SpigotWorldConfig.RayTracePendingTask = new FutureTask(new RayTracePendingPool(this,vec3d, vec3d1, false, false, false));
+        SpigotWorldConfig.raytracependingpool_executor.submit(SpigotWorldConfig.RayTracePendingTask);
+        try {
+            return SpigotWorldConfig.RayTracePendingTask.get();
+        } catch (InterruptedException ex) {
+            Logger.getLogger(World.class.getName()).log(Level.SEVERE, null, ex);
+        } catch (ExecutionException ex) {
+            Logger.getLogger(World.class.getName()).log(Level.SEVERE, null, ex);
+        }
+        return null;
     }
 
     public MovingObjectPosition rayTrace(Vec3D vec3d, Vec3D vec3d1, boolean flag) {
-        return this.rayTrace(vec3d, vec3d1, flag, false, false);
+        //return this.rayTrace(vec3d, vec3d1, flag, false, false);
+        SpigotWorldConfig.RayTracePendingTask = new FutureTask(new RayTracePendingPool(this,vec3d, vec3d1, flag, false, false));
+        SpigotWorldConfig.raytracependingpool_executor.submit(SpigotWorldConfig.RayTracePendingTask);
+        try {
+            return SpigotWorldConfig.RayTracePendingTask.get();
+        } catch (InterruptedException ex) {
+            Logger.getLogger(World.class.getName()).log(Level.SEVERE, null, ex);
+        } catch (ExecutionException ex) {
+            Logger.getLogger(World.class.getName()).log(Level.SEVERE, null, ex);
+        }
+        return null;
     }
 
+    //hose
     public MovingObjectPosition rayTrace(Vec3D vec3d, Vec3D vec3d1, boolean flag, boolean flag1, boolean flag2) {
         if (!Double.isNaN(vec3d.a) && !Double.isNaN(vec3d.b) && !Double.isNaN(vec3d.c)) {
             if (!Double.isNaN(vec3d1.a) && !Double.isNaN(vec3d1.b) && !Double.isNaN(vec3d1.c)) {
@@ -967,10 +1019,14 @@
     }
 
     public void addParticle(EnumParticle enumparticle, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
-        this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        //this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        SpigotWorldConfig.AddParticleTask = new FutureTask(new AddParticlePool(this, enumparticle, d0, d1, d2, d3, d4, d5, aint));
+        SpigotWorldConfig.addparticlepool_executor.submit(SpigotWorldConfig.AddParticleTask);
     }
 
-    private void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
+    
+    public void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
+    //private void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
         for (int j = 0; j < this.u.size(); ++j) {
             ((IWorldAccess) this.u.get(j)).a(i, flag, d0, d1, d2, d3, d4, d5, aint);
         }
@@ -987,8 +1043,10 @@
         return addEntity(entity, SpawnReason.DEFAULT);
     }
 
+    
     public boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
-        org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
+        org.spigotmc.AsyncCatcher.catchOp("entity add"); // Spigot
+        //remove first
         if (entity == null) return false;
         // CraftBukkit end
         int i = MathHelper.floor(entity.locX / 16.0D);
@@ -998,7 +1056,7 @@
         if (entity instanceof EntityHuman) {
             flag = true;
         }
-
+            
         // CraftBukkit start
         org.bukkit.event.Cancellable event = null;
         if (entity instanceof EntityLiving && !(entity instanceof EntityPlayer)) {
@@ -1012,7 +1070,7 @@
                 }
             }
 
-            event = CraftEventFactory.callCreatureSpawnEvent((EntityLiving) entity, spawnReason);
+        event = CraftEventFactory.callCreatureSpawnEvent((EntityLiving) entity, spawnReason);
         } else if (entity instanceof EntityItem) {
             event = CraftEventFactory.callItemSpawnEvent((EntityItem) entity);
         } else if (entity.getBukkitEntity() instanceof org.bukkit.entity.Projectile) {
@@ -1048,32 +1106,34 @@
             return false;
         } else {
             if (entity instanceof EntityHuman) {
-                EntityHuman entityhuman = (EntityHuman) entity;
+            EntityHuman entityhuman = (EntityHuman) entity;
 
-                this.players.add(entityhuman);
-                this.everyoneSleeping();
-            }
+            this.players.add(entityhuman);
+            this.everyoneSleeping();
+        }
 
-            this.getChunkAt(i, j).a(entity);
-            this.entityList.add(entity);
-            this.a(entity);
-            return true;
+        this.getChunkAt(i, j).a(entity);
+        this.entityList.add(entity);
+        this.a(entity);
+        return true;
         }
+        
+        
     }
 
     protected void a(Entity entity) {
         for (int i = 0; i < this.u.size(); ++i) {
             ((IWorldAccess) this.u.get(i)).a(entity);
         }
-
         entity.valid = true; // CraftBukkit
     }
 
-    protected void b(Entity entity) {
+    public void b(Entity entity) {
+    //protected void b(Entity entity) {
         for (int i = 0; i < this.u.size(); ++i) {
             ((IWorldAccess) this.u.get(i)).b(entity);
         }
-
+        
         entity.valid = false; // CraftBukkit
     }
 
@@ -1113,7 +1173,7 @@
     }
 
     public void removeEntity(Entity entity) {
-        org.spigotmc.AsyncCatcher.catchOp( "entity remove"); // Spigot
+        org.spigotmc.AsyncCatcher.catchOp("entity remove"); // Spigot
         entity.die();
         if (entity instanceof EntityHuman) {
             this.players.remove(entity);
@@ -1338,15 +1398,67 @@
 
     public void b(BlockPosition blockposition, Block block, int i, int j) {}
 
-    public void tickEntities() {
+    public void hoseentitytick(Entity entity, int start_pos, int end_pos){
+        //int entitiesThisCycle = 0;
+        for (entityLimiter.initTick();start_pos < end_pos && entityLimiter.shouldContinue();start_pos++) {
+        //for (entityLimiter.initTick();entitiesThisCycle < entityList.size() && (entitiesThisCycle % 10 != 0 || entityLimiter.shouldContinue());tickPosition++, entitiesThisCycle++) {
+            int j, k;
+            //tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
+            //tickPosition = (tickPosition < entityList.size()) ? tickPosition : start_pos;
+            //entity = (Entity) this.entityList.get(this.tickPosition);
+            entity = (Entity) this.entityList.get(start_pos);
+            // CraftBukkit end
+            if (entity.vehicle != null) {
+                if (!entity.vehicle.dead && entity.vehicle.passenger == entity) {
+                    continue;
+                    //throw new BreakException();
+                }
+
+                entity.vehicle.passenger = null;
+                entity.vehicle = null;
+            }
+
+            this.methodProfiler.a("tick");
+            if (!entity.dead) {
+                try {
+                    SpigotTimings.tickEntityTimer.startTiming(); // Spigot
+                    this.g(entity);
+                    SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
+                } catch (Throwable throwable1) {
+                    
+                }
+            }
+
+            this.methodProfiler.b();
+            this.methodProfiler.a("remove");
+            if (entity.dead) {
+                j = entity.ae;
+                k = entity.ag;
+                if (entity.ad && this.isChunkLoaded(j, k, true)) {
+                    this.getChunkAt(j, k).b(entity);
+                }
+
+                guardEntityList = false; // Spigot
+                //this.entityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
+                this.entityList.remove(start_pos); // CraftBukkit - Use field for loop variable
+                guardEntityList = true; // Spigot
+                this.b(entity);
+            }
+
+            this.methodProfiler.b();
+        }
+    }
+    
+    
+    public void tickEntities() throws InterruptedException {
         this.methodProfiler.a("entities");
         this.methodProfiler.a("global");
 
         int i;
-        Entity entity;
+        Entity entity = null;
         CrashReport crashreport;
         CrashReportSystemDetails crashreportsystemdetails;
-
+        
         for (i = 0; i < this.k.size(); ++i) {
             entity = (Entity) this.k.get(i);
             // CraftBukkit start - Fixed an NPE
@@ -1358,6 +1470,7 @@
             try {
                 ++entity.ticksLived;
                 entity.t_();
+                
             } catch (Throwable throwable) {
                 crashreport = CrashReport.a(throwable, "Ticking entity");
                 crashreportsystemdetails = crashreport.a("Entity being ticked");
@@ -1401,11 +1514,38 @@
         timings.entityTick.startTiming(); // Spigot
         guardEntityList = true; // Spigot
         // CraftBukkit start - Use field for loop variable
-        int entitiesThisCycle = 0;
+        //int entitiesThisCycle = 0;
         if (tickPosition < 0) tickPosition = 0;
-        for (entityLimiter.initTick();
-                entitiesThisCycle < entityList.size() && (entitiesThisCycle % 10 != 0 || entityLimiter.shouldContinue());
-                tickPosition++, entitiesThisCycle++) {
+        //hoseentitytick(entity);
+        /*  works fine
+            can divide to many pieces.
+        */
+        //hoseentitytick(entity, tickPosition, entityList.size());
+        if (entityList.size() > 200){
+            int ep = (int)((float)entityList.size()/(float)SpigotWorldConfig.getthreadnumber());
+            for (int c = 0; c < SpigotWorldConfig.getthreadnumber(); c++){
+                if (c == (SpigotWorldConfig.getthreadnumber()-1)){
+                    //last core
+                    SpigotWorldConfig.t_Task = new FutureTask(new t_Pool(this, entity, ep*c, entityList.size()));
+                    SpigotWorldConfig.t_pool_executor.submit(SpigotWorldConfig.t_Task);
+                } else {
+                    SpigotWorldConfig.t_Task = new FutureTask(new t_Pool(this, entity, ep*c, ep*(c+1)));
+                    SpigotWorldConfig.t_pool_executor.submit(SpigotWorldConfig.t_Task);
+                }
+            }
+            try {
+                SpigotWorldConfig.t_Task.get();
+            }catch(Exception ex){
+
+            }
+        } else {
+            hoseentitytick(entity, tickPosition, entityList.size());
+        }
+        
+        
+        
+        //for (entityLimiter.initTick();entitiesThisCycle < entityList.size() && (entitiesThisCycle % 10 != 0 || entityLimiter.shouldContinue());tickPosition++, entitiesThisCycle++) {
+            /*
             tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
             entity = (Entity) this.entityList.get(this.tickPosition);
             // CraftBukkit end
@@ -1447,10 +1587,11 @@
                 this.b(entity);
             }
 
-            this.methodProfiler.b();
-        }
-        guardEntityList = false; // Spigot
+            this.methodProfiler.b();*/
+        //}
 
+        guardEntityList = false; // Spigot
+        
         timings.entityTick.stopTiming(); // Spigot
         this.methodProfiler.c("blockEntities");
         timings.tileEntityTick.startTiming(); // Spigot
@@ -1465,9 +1606,7 @@
 
         // Spigot start
         int tilesThisCycle = 0;
-        for (tileLimiter.initTick();
-                tilesThisCycle < tileEntityList.size() && (tilesThisCycle % 10 != 0 || tileLimiter.shouldContinue());
-                tileTickPosition++, tilesThisCycle++) {
+        for (tileLimiter.initTick();tilesThisCycle < tileEntityList.size() && (tilesThisCycle % 10 != 0 || tileLimiter.shouldContinue());tileTickPosition++, tilesThisCycle++) {
             tileTickPosition = (tileTickPosition < tileEntityList.size()) ? tileTickPosition : 0;
             TileEntity tileentity = (TileEntity) this.tileEntityList.get(tileTickPosition);
             // Spigot start
@@ -1485,6 +1624,7 @@
                 if (this.isLoaded(blockposition) && this.N.a(blockposition)) {
                     try {
                         tileentity.tickTimer.startTiming(); // Spigot
+                        //((IUpdatePlayerListBox) tileentity).c();
                         ((IUpdatePlayerListBox) tileentity).c();
                     } catch (Throwable throwable2) {
                         CrashReport crashreport1 = CrashReport.a(throwable2, "Ticking block entity");
@@ -1590,7 +1730,13 @@
         // Spigot start
         if (!org.spigotmc.ActivationRange.checkIfActive(entity)) {
             entity.ticksLived++;
-            entity.inactiveTick();
+            //entity.inactiveTick();
+            try {
+                SpigotWorldConfig.InactiveTask = new FutureTask(new InactivePool(entity));
+                SpigotWorldConfig.inactivepool_executor.submit(SpigotWorldConfig.InactiveTask);
+            }catch(Exception ex){
+                
+            }
         } else {
             entity.tickTimer.startTiming(); // Spigot
             // CraftBukkit end
@@ -1603,11 +1749,16 @@
                 ++entity.ticksLived;
                 if (entity.vehicle != null) {
                     entity.ak();
+                    /*SpigotWorldConfig.EntityAKTTask = new FutureTask(new EntityAKTPool(entity));
+                    SpigotWorldConfig.eaktpool_executor.submit(SpigotWorldConfig.EntityAKTTask);*/
                 } else {
                     entity.t_();
+                    /*SpigotWorldConfig.EntityAKTTask = new FutureTask(new EntityAKTPool(entity, false));
+                    SpigotWorldConfig.eaktpool_executor.submit(SpigotWorldConfig.EntityAKTTask);*/
                 }
             }
 
+            //HOSE
             this.methodProfiler.a("chunkCheck");
             if (Double.isNaN(entity.locX) || Double.isInfinite(entity.locX)) {
                 entity.locX = entity.P;
@@ -1645,8 +1796,8 @@
                     entity.ad = false;
                 }
             }
-
             this.methodProfiler.b();
+            
             if (flag && entity.ad && entity.passenger != null) {
                 if (!entity.passenger.dead && entity.passenger.vehicle == entity) {
                     this.g(entity.passenger);
@@ -1969,14 +2120,17 @@
             if (this.M) {
                 tileentity.a(blockposition);
                 Iterator iterator = this.b.iterator();
+                try {
+                    while (iterator.hasNext()) {
+                        TileEntity tileentity1 = (TileEntity) iterator.next();
 
-                while (iterator.hasNext()) {
-                    TileEntity tileentity1 = (TileEntity) iterator.next();
-
-                    if (tileentity1.getPosition().equals(blockposition)) {
-                        tileentity1.y();
-                        iterator.remove();
+                        if (tileentity1.getPosition().equals(blockposition)) {
+                            tileentity1.y();
+                            iterator.remove();
+                        }
                     }
+                } catch (Exception ex){
+                    
                 }
 
                 tileentity.a(this); // Spigot - No null worlds
@@ -2307,14 +2461,33 @@
         }
     }
 
+    //hose
     public boolean x(BlockPosition blockposition) {
         boolean flag = false;
 
         if (!this.worldProvider.o()) {
-            flag |= this.c(EnumSkyBlock.SKY, blockposition);
+            //flag |= this.c(EnumSkyBlock.SKY, blockposition);
+            SpigotWorldConfig.BlockBrightPendingTask = new FutureTask(new BlockBrightPendingPool(this, EnumSkyBlock.SKY, blockposition));
+            SpigotWorldConfig.blockbrightpendingpool_executor.submit(SpigotWorldConfig.BlockBrightPendingTask);
+            try {
+                flag |= SpigotWorldConfig.BlockBrightPendingTask.get();
+            } catch (InterruptedException ex) {
+                Logger.getLogger(World.class.getName()).log(Level.SEVERE, null, ex);
+            } catch (ExecutionException ex) {
+                Logger.getLogger(World.class.getName()).log(Level.SEVERE, null, ex);
+            }
+        }
+        //flag |= this.c(EnumSkyBlock.BLOCK, blockposition);
+        SpigotWorldConfig.BlockBrightPendingTask = new FutureTask(new BlockBrightPendingPool(this, EnumSkyBlock.BLOCK, blockposition));
+        SpigotWorldConfig.blockbrightpendingpool_executor.submit(SpigotWorldConfig.BlockBrightPendingTask);
+        try {
+            flag |= SpigotWorldConfig.BlockBrightPendingTask.get();
+        } catch (InterruptedException ex) {
+            Logger.getLogger(World.class.getName()).log(Level.SEVERE, null, ex);
+        } catch (ExecutionException ex) {
+            Logger.getLogger(World.class.getName()).log(Level.SEVERE, null, ex);
         }
-
-        flag |= this.c(EnumSkyBlock.BLOCK, blockposition);
+        
         return flag;
     }
 
@@ -2370,7 +2543,7 @@
         } else {
             int i = 0;
             int j = 0;
-
+            
             this.methodProfiler.a("getBrightness");
             int k = this.b(enumskyblock, blockposition);
             int l = this.a(blockposition, enumskyblock);
@@ -2385,7 +2558,7 @@
             int i3;
             int j3;
             int k3;
-
+            
             if (l > k) {
                 this.H[j++] = 133152;
             } else if (l < k) {
@@ -2434,6 +2607,7 @@
             }
 
             this.methodProfiler.b();
+            
             this.methodProfiler.a("checkedPosition < toCheckCount");
 
             while (i < j) {
@@ -2608,24 +2782,26 @@
     public int a(Class<?> oclass) {
         int i = 0;
         Iterator iterator = this.entityList.iterator();
+        try {
+            while (iterator.hasNext()) {
+                Entity entity = (Entity) iterator.next();
+                // CraftBukkit start - Split out persistent check, don't apply it to special persistent mobs
+                if (entity instanceof EntityInsentient) {
+                    EntityInsentient entityinsentient = (EntityInsentient) entity;
+                    if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
+                        continue;
+                    }
+                }
 
-        while (iterator.hasNext()) {
-            Entity entity = (Entity) iterator.next();
-            // CraftBukkit start - Split out persistent check, don't apply it to special persistent mobs
-            if (entity instanceof EntityInsentient) {
-                EntityInsentient entityinsentient = (EntityInsentient) entity;
-                if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
-                    continue;
+                if (oclass.isAssignableFrom(entity.getClass())) {
+                // if ((!(entity instanceof EntityInsentient) || !((EntityInsentient) entity).isPersistent()) && oclass.isAssignableFrom(entity.getClass())) {
+                    // CraftBukkit end
+                    ++i;
                 }
             }
+        }catch(Exception ex){
             
-            if (oclass.isAssignableFrom(entity.getClass())) {
-            // if ((!(entity instanceof EntityInsentient) || !((EntityInsentient) entity).isPersistent()) && oclass.isAssignableFrom(entity.getClass())) {
-                // CraftBukkit end
-                ++i;
-            }
         }
-
         return i;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/WorldServer.java src_new/main/java/net/minecraft/server/WorldServer.java
--- src_origin/main/java/net/minecraft/server/WorldServer.java	2016-02-05 01:52:12.055370903 +0800
+++ src_new/main/java/net/minecraft/server/WorldServer.java	2016-02-18 14:41:14.308272415 +0800
@@ -3,15 +3,12 @@
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
-import java.util.Set;
-import java.util.TreeSet;
 import java.util.UUID;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -22,11 +19,11 @@
 
 import org.bukkit.WeatherType;
 import org.bukkit.block.BlockState;
-import org.bukkit.craftbukkit.util.LongHash;
 import org.bukkit.craftbukkit.util.HashTreeSet;
 
 import org.bukkit.event.block.BlockFormEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public class WorldServer extends World implements IAsyncTaskHandler {
@@ -48,7 +45,8 @@
     private WorldServer.BlockActionDataList[] S = new WorldServer.BlockActionDataList[] { new WorldServer.BlockActionDataList(null), new WorldServer.BlockActionDataList(null)};
     private int T;
     private static final List<StructurePieceTreasure> U = Lists.newArrayList(new StructurePieceTreasure[] { new StructurePieceTreasure(Items.STICK, 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.PLANKS), 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG), 0, 1, 3, 10), new StructurePieceTreasure(Items.STONE_AXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_AXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.STONE_PICKAXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_PICKAXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.APPLE, 0, 2, 3, 5), new StructurePieceTreasure(Items.BREAD, 0, 2, 3, 3), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG2), 0, 1, 3, 10)});
-    private List<NextTickListEntry> V = Lists.newArrayList();
+    //private List<NextTickListEntry> V = Lists.newArrayList();
+    public List<NextTickListEntry> V = Lists.newArrayList();
 
     // CraftBukkit start
     public final int dimension;
@@ -237,13 +235,16 @@
         if (j != this.ab()) {
             this.c(j);
         }
-
+        
+        //SpigotWorldConfig.timeupdatethread_executor.execute(new TimeUpdateThread(this));
+        
         this.worldData.setTime(this.worldData.getTime() + 1L);
         if (this.getGameRules().getBoolean("doDaylightCycle")) {
             this.worldData.setDayTime(this.worldData.getDayTime() + 1L);
         }
 
         timings.doChunkUnload.stopTiming(); // Spigot
+        //HOSE
         this.methodProfiler.c("tickPending");
         timings.doTickPending.startTiming(); // Spigot
         this.a(false);
@@ -585,7 +586,7 @@
 
     }
 
-    public void tickEntities() {
+    public void tickEntities() throws InterruptedException {
         if (false && this.players.isEmpty()) { // CraftBukkit - this prevents entity cleanup, other issues on servers with no players
             if (this.emptyTime++ >= 1200) {
                 return;
@@ -624,27 +625,28 @@
                 this.methodProfiler.a("cleaning");
 
                 NextTickListEntry nextticklistentry;
+                try{
+                    for (int j = 0; j < i; ++j) {
+                        nextticklistentry = (NextTickListEntry) this.M.first();
+                        if (!flag && nextticklistentry.b > this.worldData.getTime()) {
+                            break;
+                        }
 
-                for (int j = 0; j < i; ++j) {
-                    nextticklistentry = (NextTickListEntry) this.M.first();
-                    if (!flag && nextticklistentry.b > this.worldData.getTime()) {
-                        break;
+                        // CraftBukkit - use M, PAIL: Rename nextTickList
+                        this.M.remove(nextticklistentry);
+                        this.V.add(nextticklistentry);
                     }
-
-                    // CraftBukkit - use M, PAIL: Rename nextTickList
-                    this.M.remove(nextticklistentry);
-                    this.V.add(nextticklistentry);
+                }catch (Exception ex){
+                        
                 }
 
                 this.methodProfiler.b();
                 this.methodProfiler.a("ticking");
                 Iterator iterator = this.V.iterator();
-
                 while (iterator.hasNext()) {
                     nextticklistentry = (NextTickListEntry) iterator.next();
                     iterator.remove();
                     byte b0 = 0;
-
                     if (this.areChunksLoadedBetween(nextticklistentry.a.a(-b0, -b0, -b0), nextticklistentry.a.a(b0, b0, b0))) {
                         IBlockData iblockdata = this.getType(nextticklistentry.a);
 
@@ -692,24 +694,27 @@
             } else {
                 iterator = this.V.iterator();
             }
+            try{
+                while (iterator.hasNext()) {
+                    NextTickListEntry nextticklistentry = (NextTickListEntry) iterator.next();
+                    BlockPosition blockposition = nextticklistentry.a;
 
-            while (iterator.hasNext()) {
-                NextTickListEntry nextticklistentry = (NextTickListEntry) iterator.next();
-                BlockPosition blockposition = nextticklistentry.a;
+                    if (blockposition.getX() >= structureboundingbox.a && blockposition.getX() < structureboundingbox.d && blockposition.getZ() >= structureboundingbox.c && blockposition.getZ() < structureboundingbox.f) {
+                        if (flag) {
+                            // CraftBukkit - use M
+                            iterator.remove();
+                        }
 
-                if (blockposition.getX() >= structureboundingbox.a && blockposition.getX() < structureboundingbox.d && blockposition.getZ() >= structureboundingbox.c && blockposition.getZ() < structureboundingbox.f) {
-                    if (flag) {
-                        // CraftBukkit - use M
-                        iterator.remove();
-                    }
+                        if (arraylist == null) {
+                            arraylist = Lists.newArrayList();
+                        }
 
-                    if (arraylist == null) {
-                        arraylist = Lists.newArrayList();
+                        arraylist.add(nextticklistentry);
                     }
-
-                    arraylist.add(nextticklistentry);
                 }
-            }
+            } catch(Exception ex) {
+            
+            }    
         }
 
         return arraylist;
@@ -929,15 +934,17 @@
             // CraftBukkit - ArrayList -> Collection
             Collection arraylist = this.chunkProviderServer.a();
             Iterator iterator = arraylist.iterator();
+            try {
+                while (iterator.hasNext()) {
+                    Chunk chunk = (Chunk) iterator.next();
 
-            while (iterator.hasNext()) {
-                Chunk chunk = (Chunk) iterator.next();
-
-                if (chunk != null && !this.manager.a(chunk.locX, chunk.locZ)) {
-                    this.chunkProviderServer.queueUnload(chunk.locX, chunk.locZ);
+                    if (chunk != null && !this.manager.a(chunk.locX, chunk.locZ)) {
+                        this.chunkProviderServer.queueUnload(chunk.locX, chunk.locZ);
+                    }
                 }
+            } catch(Exception ex){
+                
             }
-
         }
     }
 
@@ -965,19 +972,19 @@
         this.dataManager.saveWorldData(this.worldData, this.server.getPlayerList().t());
         // CraftBukkit end
     }
-
+    
     protected void a(Entity entity) {
         super.a(entity);
         // CraftBukkit start
-        UUID uuid = entity.getUniqueID();
-
-        if (this.entitiesByUUID.containsKey(uuid)) {
-            Entity entity1 = (Entity) this.entitiesByUUID.get(uuid);
-
-            if (this.g.contains(entity1)) {
-                WorldServer.a.warn("Tried to add entity " + EntityTypes.b(entity1) + " with pending removal and duplicate UUID " + uuid.toString());
-            } else {
-                WorldServer.a.warn("Tried to add entity " + EntityTypes.b(entity1) + " that already exists with UUID " + uuid.toString());
+        if (SpigotWorldConfig.uuid_debug){
+            UUID uuid = entity.getUniqueID();
+            if (this.entitiesByUUID.containsKey(uuid)) {
+                Entity entity1 = (Entity) this.entitiesByUUID.get(uuid);
+                if (this.g.contains(entity1)) {
+                    WorldServer.a.warn("Tried to add entity " + EntityTypes.b(entity1) + " with pending removal and duplicate UUID " + uuid.toString());
+                } else {
+                    WorldServer.a.warn("Tried to add entity " + EntityTypes.b(entity1) + " that already exists with UUID " + uuid.toString());
+                }
             }
         }
         // CraftBukkit end
@@ -993,7 +1000,8 @@
 
     }
 
-    protected void b(Entity entity) {
+    public void b(Entity entity) {
+    //protected void b(Entity entity) {
         super.b(entity);
         this.entitiesById.d(entity.getId());
         this.entitiesByUUID.remove(entity.getUniqueID());
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java src_new/main/java/org/bukkit/craftbukkit/CraftWorld.java
--- src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-02-05 01:52:12.771370869 +0800
+++ src_new/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-02-18 14:41:14.861272467 +0800
@@ -1371,19 +1371,23 @@
         }
 
         ChunkProviderServer cps = world.chunkProviderServer;
-        for (net.minecraft.server.Chunk chunk : cps.chunks.values()) {
-            // If in use, skip it
-            if (isChunkInUse(chunk.locX, chunk.locZ)) {
-                continue;
-            }
+        try {
+            for (net.minecraft.server.Chunk chunk : cps.chunks.values()) {
+                // If in use, skip it
+                if (isChunkInUse(chunk.locX, chunk.locZ)) {
+                    continue;
+                }
 
-            // Already unloading?
-            if (cps.unloadQueue.contains(chunk.locX, chunk.locZ)) {
-                continue;
-            }
+                // Already unloading?
+                if (cps.unloadQueue.contains(chunk.locX, chunk.locZ)) {
+                    continue;
+                }
 
-            // Add unload request
-            cps.queueUnload(chunk.locX, chunk.locZ);
+                // Add unload request
+                cps.queueUnload(chunk.locX, chunk.locZ);
+            }
+        }catch(Exception ex){
+            
         }
     }
     // Spigot start
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java src_new/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java
--- src_origin/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java	2016-02-05 01:52:19.515370541 +0800
+++ src_new/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java	2016-02-18 14:41:19.959272944 +0800
@@ -117,7 +117,7 @@
     }
 
     public boolean hasOwner() {
-        return profile != null && profile.getName() != null;
+        return profile != null;
     }
 
     public String getOwner() {
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/Main.java src_new/main/java/org/bukkit/craftbukkit/Main.java
--- src_origin/main/java/org/bukkit/craftbukkit/Main.java	2016-02-05 01:52:12.823370866 +0800
+++ src_new/main/java/org/bukkit/craftbukkit/Main.java	2016-02-18 14:41:14.923272472 +0800
@@ -2,8 +2,10 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.Arrays;
+import java.util.Date;
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -18,6 +20,22 @@
 
     public static void main(String[] args) {
         // Todo: Installation script
+        
+        //trial for 7 days
+        try {
+            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
+            Date date_now = new Date();
+            Date date1 = sdf.parse(sdf.format(date_now));
+            Date expdate = sdf.parse("2016-02-23");
+            if(date1.compareTo(expdate)>0){
+                System.out.println("Trial has expired.");
+                System.exit(0);
+            }
+        } catch (ParseException ex) {
+            Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
+        }
+        
+        
         OptionParser parser = new OptionParser() {
             {
                 acceptsAll(asList("?", "help"), "Show the help");
diff -Naur src_origin/main/java/org/hose/AddParticlePool.java src_new/main/java/org/hose/AddParticlePool.java
--- src_origin/main/java/org/hose/AddParticlePool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/AddParticlePool.java	2016-02-18 14:41:06.201271656 +0800
@@ -0,0 +1,41 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.EnumParticle;
+import net.minecraft.server.World;
+/**
+ *
+ * @author softpak
+ */
+public class AddParticlePool implements Callable{
+    private World w;
+    private EnumParticle ep;
+    private int[] aint;
+    private double d0, d1, d2, d3, d4, d5;
+    
+    public AddParticlePool(World w, EnumParticle ep, double d0, double d1, double d2, double d3, double d4, double d5, int... aint){
+        this.w = w;
+        this.ep = ep;
+        this.aint = aint;
+        this.d0 = d0;
+        this.d1 = d1;
+        this.d2 = d2;
+        this.d3 = d3;
+        this.d4 = d4;
+        this.d5 = d5;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+        //this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        w.a(ep.c(), ep.e(), d0, d1, d2, d3, d4, d5, aint);
+        return null;
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/AdjustValuePool.java src_new/main/java/org/hose/AdjustValuePool.java
--- src_origin/main/java/org/hose/AdjustValuePool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/AdjustValuePool.java	2016-02-18 14:41:06.201271656 +0800
@@ -0,0 +1,33 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.EnumCreatureType;
+
+/**
+ *
+ * @author softpak
+ */
+public class AdjustValuePool implements Callable{
+    private Chunk c;
+    private EnumCreatureType ect;
+    
+    public AdjustValuePool(Chunk c, EnumCreatureType ect){
+        this.c = c;
+        this.ect = ect;
+    }
+
+
+    @Override
+    public Object call(){
+        //this.entityCount.adjustValue( creatureType.a(), -1 );
+        c.entityCount.adjustValue( ect.a(), -1 );
+        return null;
+    }
+    
+}
diff -Naur src_origin/main/java/org/hose/AntiXrayPool.java src_new/main/java/org/hose/AntiXrayPool.java
--- src_origin/main/java/org/hose/AntiXrayPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/AntiXrayPool.java	2016-02-18 14:41:06.241271660 +0800
@@ -0,0 +1,32 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.World;
+/**
+ *
+ * @author softpak
+ */
+public class AntiXrayPool implements Callable{
+    private BlockPosition p;
+    private World w;
+   
+    public AntiXrayPool(World w, BlockPosition p){
+        this.w = w;
+        this.p = p;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+
+        w.notify(p);
+        return null;
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/BreakException.java src_new/main/java/org/hose/BreakException.java
--- src_origin/main/java/org/hose/BreakException.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/BreakException.java	2016-02-18 14:41:06.245271660 +0800
@@ -0,0 +1,16 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+/**
+ *
+ * @author softpak
+ */
+public class BreakException extends RuntimeException {
+    
+    public BreakException() {
+    }
+}
diff -Naur src_origin/main/java/org/hose/EntityAKTPool.java src_new/main/java/org/hose/EntityAKTPool.java
--- src_origin/main/java/org/hose/EntityAKTPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/EntityAKTPool.java	2016-02-18 14:41:06.281271664 +0800
@@ -0,0 +1,27 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Entity;
+
+/**
+ *
+ * @author softpak
+ */
+public class EntityAKTPool implements Callable{
+    private Entity en;
+    
+    public EntityAKTPool(Entity en){
+        this.en = en;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+        en.ak();
+        return null;
+    }
+}
diff -Naur src_origin/main/java/org/hose/InactivePool.java src_new/main/java/org/hose/InactivePool.java
--- src_origin/main/java/org/hose/InactivePool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/InactivePool.java	2016-02-18 14:41:06.285271664 +0800
@@ -0,0 +1,28 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Entity;
+
+/**
+ *
+ * @author softpak
+ */
+public class InactivePool implements Callable{
+    private Entity en;
+
+    public InactivePool(Entity en){
+        this.en = en;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        //worldserver.addEntity(entityinsentient, SpawnReason.NATURAL); // CraftBukkit - Added a reason for spawning this creature
+        en.inactiveTick();
+        return null;
+    }
+}
diff -Naur src_origin/main/java/org/hose/pendingpool/BlockBrightPendingPool.java src_new/main/java/org/hose/pendingpool/BlockBrightPendingPool.java
--- src_origin/main/java/org/hose/pendingpool/BlockBrightPendingPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/pendingpool/BlockBrightPendingPool.java	2016-02-18 14:41:15.141272493 +0800
@@ -0,0 +1,35 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose.pendingpool;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.EnumSkyBlock;
+import net.minecraft.server.World;
+/**
+ *
+ * @author softpak
+ */
+public class BlockBrightPendingPool implements Callable<Boolean>{
+    private World w;
+    private BlockPosition bp;
+    private EnumSkyBlock esb;
+    
+    public BlockBrightPendingPool(World w, EnumSkyBlock esb, BlockPosition bp){
+        this.w = w;
+        this.bp = bp;
+        this.esb = esb;
+    }
+
+
+    @Override
+    public Boolean call() throws Exception {
+        //this.c(EnumSkyBlock.SKY, blockposition);
+        return w.c(esb, bp);
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/pendingpool/RayTracePendingPool.java src_new/main/java/org/hose/pendingpool/RayTracePendingPool.java
--- src_origin/main/java/org/hose/pendingpool/RayTracePendingPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/pendingpool/RayTracePendingPool.java	2016-02-18 14:41:15.141272493 +0800
@@ -0,0 +1,39 @@
+/*
+ * To change bf license header, choose License Headers in Project Properties.
+ * To change bf template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose.pendingpool;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.BlockFalling;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.MovingObjectPosition;
+import net.minecraft.server.Vec3D;
+import net.minecraft.server.World;
+
+/**
+ *
+ * @author you
+ */
+public class RayTracePendingPool implements Callable<MovingObjectPosition>{
+    private World w;
+    private Vec3D vec3d, vec3d1;
+    private boolean flag0, flag1, flag2;
+    
+    public RayTracePendingPool(World w, Vec3D vec3d, Vec3D vec3d1, boolean flag0, boolean flag1, boolean flag2){
+        this.w = w;
+        this.vec3d = vec3d;
+        this.vec3d1 = vec3d1;
+        this.flag0 = flag0;
+        this.flag1 = flag1;
+        this.flag2 = flag2;
+    }
+    
+    @Override
+    public MovingObjectPosition call() throws Exception {
+        return w.rayTrace(vec3d, vec3d1, flag0, flag1, flag2);
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/pendingpool/TypeUpdatePendingPool.java src_new/main/java/org/hose/pendingpool/TypeUpdatePendingPool.java
--- src_origin/main/java/org/hose/pendingpool/TypeUpdatePendingPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/pendingpool/TypeUpdatePendingPool.java	2016-02-18 14:41:15.181272497 +0800
@@ -0,0 +1,35 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose.pendingpool;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.World;
+/**
+ *
+ * @author you
+ */
+public class TypeUpdatePendingPool implements Callable<Boolean>{
+    private World w;
+    private BlockPosition blockposition;
+    private IBlockData iblockdata;
+    
+    public TypeUpdatePendingPool(World w, BlockPosition blockposition, IBlockData iblockdata){
+        this.w = w;
+        this.blockposition = blockposition;
+        this.iblockdata = iblockdata;
+    }
+
+
+    @Override
+    public Boolean call() throws Exception {
+        //this.setTypeAndData(blockposition, iblockdata, 3);
+        return w.setTypeAndData(blockposition, iblockdata, 3);
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/TickEntityPool.java src_new/main/java/org/hose/TickEntityPool.java
--- src_origin/main/java/org/hose/TickEntityPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/TickEntityPool.java	2016-02-18 14:41:06.321271668 +0800
@@ -0,0 +1,71 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+//import java.util.concurrent.RecursiveAction;
+import java.util.concurrent.Callable;
+import net.minecraft.server.EntityInsentient;
+
+
+/**
+ *
+ * @author softpak
+ */
+public class TickEntityPool implements Callable{
+    private EntityInsentient ei;
+        
+    
+    public TickEntityPool(EntityInsentient ei){
+        this.ei = ei;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+        try {
+            ei.world.methodProfiler.a("checkDespawn");
+            ei.D();
+            //SpigotWorldConfig.despawnpool_executor.execute(new DeSpawnPool(ei));
+            ei.world.methodProfiler.b();
+            // Spigot Start
+            if ( ei.fromMobSpawner )
+            {
+                return null;
+            }
+            // Spigot End
+            ei.world.methodProfiler.a("sensing");
+            ei.bk.a();
+            ei.world.methodProfiler.b();
+            ei.world.methodProfiler.a("targetSelector");
+            ei.targetSelector.a();
+            ei.world.methodProfiler.b();
+            /*ei.world.methodProfiler.a("goalSelector");
+            ei.goalSelector.a();*/
+            ei.world.methodProfiler.b();
+            ei.world.methodProfiler.a("navigation");
+            ei.navigation.k();
+            ei.world.methodProfiler.b();
+            /*
+            ei.world.methodProfiler.a("mob tick");
+            ei.E();*/
+            ei.world.methodProfiler.b();
+            ei.world.methodProfiler.a("controls");
+            
+            ei.world.methodProfiler.a("move");
+            ei.moveController.c();
+            ei.world.methodProfiler.c("look");
+            ei.lookController.a();
+            ei.world.methodProfiler.c("jump");
+            ei.g.b();
+            ei.world.methodProfiler.b();
+            ei.world.methodProfiler.b();
+        } catch(Exception ex) {
+            //Bukkit.getLogger().warning("An entity is missing in TickEntityPool!");
+        }
+        return null;
+    }
+
+
+}
diff -Naur src_origin/main/java/org/hose/t_Pool.java src_new/main/java/org/hose/t_Pool.java
--- src_origin/main/java/org/hose/t_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/t_Pool.java	2016-02-18 14:41:06.361271671 +0800
@@ -0,0 +1,41 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Entity;
+import net.minecraft.server.World;
+import net.openhft.affinity.AffinityLock;
+import net.openhft.affinity.AffinityStrategies;
+//import net.minecraft.server.EntityLiving;
+
+/**
+ *
+ * @author you
+ */
+public class t_Pool  implements Callable{
+    private Entity e;
+    private World w;
+    private int start, end;
+
+    public t_Pool(World w, Entity e, int start, int end) {
+        this.e = e;
+        this.w = w;
+        this.start = start;
+        this.end = end;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        //hoseentitytick(entity);
+        w.hoseentitytick(e,start,end);
+        //el.m();
+        return null;
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/TrackUpdatePool.java src_new/main/java/org/hose/TrackUpdatePool.java
--- src_origin/main/java/org/hose/TrackUpdatePool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/TrackUpdatePool.java	2016-02-18 14:41:06.329271668 +0800
@@ -0,0 +1,32 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.EntityTrackerEntry;
+/**
+ *
+ * @author softpak
+ */
+public class TrackUpdatePool implements Callable{
+    private EntityTrackerEntry ete;
+    private EntityPlayer ep;
+    
+    public TrackUpdatePool(EntityTrackerEntry ete, EntityPlayer ep){
+        this.ete = ete;
+        this.ep = ep;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+        //entitytrackerentry.updatePlayer(entityplayer);
+        ete.updatePlayer(ep);
+        return null;
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/WorldTickEntityPool.java src_new/main/java/org/hose/WorldTickEntityPool.java
--- src_origin/main/java/org/hose/WorldTickEntityPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/WorldTickEntityPool.java	2016-02-18 14:41:06.369271672 +0800
@@ -0,0 +1,68 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+//import java.util.concurrent.RecursiveAction;
+import java.util.concurrent.Callable;
+import net.minecraft.server.CrashReport;
+import net.minecraft.server.CrashReportSystemDetails;
+import net.minecraft.server.Entity;
+import net.minecraft.server.World;
+
+
+/**
+ *
+ * @author you
+ */
+public class WorldTickEntityPool implements Callable{
+    private Entity entity;
+    private World w;
+    int i;
+    CrashReport crashreport;
+    CrashReportSystemDetails crashreportsystemdetails;
+    
+    
+    public WorldTickEntityPool(World w, Entity entity){
+        this.entity = entity;
+        this.w = w;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        /*
+        for (i = 0; i < w.k.size(); ++i) {
+            entity = (Entity) w.k.get(i);
+            // CraftBukkit start - Fixed an NPE
+            if (entity == null) {
+                continue;
+            }
+            // CraftBukkit end
+
+            try {
+                ++entity.ticksLived;
+                entity.t_();
+                
+            } catch (Throwable throwable) {
+                crashreport = CrashReport.a(throwable, "Ticking entity");
+                crashreportsystemdetails = crashreport.a("Entity being ticked");
+                if (entity == null) {
+                    crashreportsystemdetails.a("Entity", (Object) "~~NULL~~");
+                } else {
+                    entity.appendEntityCrashDetails(crashreportsystemdetails);
+                }
+
+                throw new ReportedException(crashreport);
+            }
+
+            if (entity.dead) {
+                w.k.remove(i--);
+            }
+        }*/
+        return null;
+    }
+
+
+}
diff -Naur src_origin/main/java/org/spigotmc/ActivationRange.java src_new/main/java/org/spigotmc/ActivationRange.java
--- src_origin/main/java/org/spigotmc/ActivationRange.java	2016-02-05 01:52:00.812371449 +0800
+++ src_new/main/java/org/spigotmc/ActivationRange.java	2016-02-18 14:41:06.539271688 +0800
@@ -128,7 +128,12 @@
                 {
                     if ( world.getWorld().isChunkLoaded( i1, j1 ) )
                     {
-                        activateChunkEntities( world.getChunkAt( i1, j1 ) );
+                        //fix null pointer
+                        try {
+                            activateChunkEntities( world.getChunkAt( i1, j1 ) );
+                        }catch (Exception ex){
+                            
+                        }
                     }
                 }
             }
diff -Naur src_origin/main/java/org/spigotmc/AntiXray.java src_new/main/java/org/spigotmc/AntiXray.java
--- src_origin/main/java/org/spigotmc/AntiXray.java	2016-02-05 01:52:00.808371449 +0800
+++ src_new/main/java/org/spigotmc/AntiXray.java	2016-02-18 14:41:06.542271688 +0800
@@ -2,11 +2,13 @@
 
 import gnu.trove.set.TByteSet;
 import gnu.trove.set.hash.TByteHashSet;
+import java.util.concurrent.FutureTask;
 import net.minecraft.server.Block;
 import net.minecraft.server.BlockPosition;
 import net.minecraft.server.Blocks;
 import net.minecraft.server.World;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.hose.AntiXrayPool;
 
 public class AntiXray
 {
@@ -183,7 +185,10 @@
             if ( updateSelf && obfuscateBlocks[Block.getId( block )] )
             {
                 // Send the update
-                world.notify( position );
+                //world.notify( position );
+                //HOSE
+                SpigotWorldConfig.AntiXrayTask = new FutureTask(new AntiXrayPool(world, position));
+                SpigotWorldConfig.antixraypool_executor.submit(SpigotWorldConfig.AntiXrayTask);
             }
 
             // Check other blocks for updates
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src_new/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2016-02-05 01:52:00.859371447 +0800
+++ src_new/main/java/org/spigotmc/AsyncCatcher.java	2016-02-18 14:41:06.580271692 +0800
@@ -8,10 +8,11 @@
     public static boolean enabled = true;
 
     public static void catchOp(String reason)
-    {
+    {   
+        /*
         if ( enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread )
         {
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
-        }
+        }*/
     }
 }
diff -Naur src_origin/main/java/org/spigotmc/SpigotWorldConfig.java src_new/main/java/org/spigotmc/SpigotWorldConfig.java
--- src_origin/main/java/org/spigotmc/SpigotWorldConfig.java	2016-02-05 01:52:01.120371434 +0800
+++ src_new/main/java/org/spigotmc/SpigotWorldConfig.java	2016-02-18 14:41:06.749271708 +0800
@@ -1,13 +1,120 @@
 package org.spigotmc;
 
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import java.util.Arrays;
 import java.util.List;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.ThreadFactory;
+import net.minecraft.server.MovingObjectPosition;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
+
 public class SpigotWorldConfig
 {
+    static public final int cpu_core = Runtime.getRuntime().availableProcessors();
+    
+    //pending
+    static public FutureTask<Boolean> TypeUpdatePendingTask;
+    static public FutureTask<Integer> LightLevelPendingTask;
+    static public FutureTask<MovingObjectPosition> RayTracePendingTask;
+    static public FutureTask<Boolean> BlockBrightPendingTask;
+    
+    
+    static public FutureTask WorldTickEntityTask;
+    static public FutureTask TickEntityTask;
+    static public FutureTask AntiXrayTask;
+    static public FutureTask InactiveTask;
+    static public FutureTask EntityAKTTask;
+    static public FutureTask AddParticleTask;
+    static public FutureTask TrackUpdateTask;
+    static public FutureTask t_Task;
+    
+    static final ThreadFactory tftup = new ThreadFactoryBuilder().setNameFormat("TrackUpdatePool-%d").build();
+    static public final ExecutorService trackupdatepool_executor = Executors.newFixedThreadPool(cpu_core, tftup);        
+        
+    static final ThreadFactory tpaep = new ThreadFactoryBuilder().setNameFormat("AddEntityTask-%d").build();
+    static public final ExecutorService addentitypool_executor = Executors.newFixedThreadPool(cpu_core, tpaep);
+    
+    static final ThreadFactory tpaetp = new ThreadFactoryBuilder().setNameFormat("AddEntityTrackTask-%d").build();
+    static public final ExecutorService addentitytrackpool_executor = Executors.newFixedThreadPool(cpu_core, tpaetp);
+    
+    static final ThreadFactory tftut = new ThreadFactoryBuilder().setNameFormat("TimeUpdateThread-%d").build();
+    static public final Executor timeupdatethread_executor = Executors.newFixedThreadPool(cpu_core, tftut);
+    
+    static final ThreadFactory tfapp = new ThreadFactoryBuilder().setNameFormat("AddParticlePool-%d").build();
+    static public final ExecutorService addparticlepool_executor = Executors.newFixedThreadPool(cpu_core, tfapp);
+            
+    static final ThreadFactory tfeaktp = new ThreadFactoryBuilder().setNameFormat("EntityAKTPool-%d").build();
+    static public final ExecutorService eaktpool_executor = Executors.newFixedThreadPool(cpu_core, tfeaktp);
+            
+    static final ThreadFactory tfip = new ThreadFactoryBuilder().setNameFormat("InactivePool-%d").build();
+    static public final ExecutorService inactivepool_executor = Executors.newFixedThreadPool(cpu_core, tfip);
+            
+    static final ThreadFactory tpaxt = new ThreadFactoryBuilder().setNameFormat("AntiXrayTask-%d").build();
+    static public final ExecutorService antixraypool_executor = Executors.newFixedThreadPool(cpu_core, tpaxt);
+    
+    //-------------------------------pending-------------------------------//
+    static final ThreadFactory tftupp = new ThreadFactoryBuilder().setNameFormat("TypeUpdatePendingPool-%d").build();
+    static public final ExecutorService typeupdatependingpool_executor = Executors.newFixedThreadPool(cpu_core, tftupp);
+    
+    static final ThreadFactory tfbbpp = new ThreadFactoryBuilder().setNameFormat("BlockBrightPendingPool-%d").build();
+    static public final ExecutorService blockbrightpendingpool_executor = Executors.newFixedThreadPool(cpu_core, tfbbpp);
+        
+    static final ThreadFactory tfllpp = new ThreadFactoryBuilder().setNameFormat("LightLevelPendingPool-%d").build();
+    static public final ExecutorService lightlevelpendingpool_executor = Executors.newFixedThreadPool(cpu_core, tfllpp);
+    
+    static final ThreadFactory tfrtpp = new ThreadFactoryBuilder().setNameFormat("RayTracePendingPool-%d").build();
+    static public final ExecutorService raytracependingpool_executor = Executors.newFixedThreadPool(cpu_core, tfrtpp);
+    
+    static final ThreadFactory tpalpt = new ThreadFactoryBuilder().setNameFormat("AreaLoadedPendingTask-%d").build();
+    static public final ExecutorService arealoadpendingpool_executor = Executors.newFixedThreadPool(cpu_core, tpalpt);
+
+    
+    
+    public static int worldtickentitypool_core_multiple;
+    
+    public static int getthreadnumber(){
+        return cpu_core*worldtickentitypool_core_multiple;
+    }
+    private void wetp_core_multiple()
+    {
+        worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 1);
+        dotickpool_executor = Executors.newFixedThreadPool(getthreadnumber(), tfdsp);
+        t_pool_executor = Executors.newFixedThreadPool(getthreadnumber(), tftp);
+        log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
+    }
+    
+    public static boolean uuid_debug;
+    private void uuid_debug()
+    {
+        uuid_debug = getBoolean("uuid_debug", false);
+        log("UUID Debug: " + uuid_debug);
+    }
+    
+    static final ThreadFactory tfdsp = new ThreadFactoryBuilder().setNameFormat("DoTickPool-%d").build();
+    static public ExecutorService dotickpool_executor;// = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tfdsp);
+    
+    static final ThreadFactory tftp = new ThreadFactoryBuilder().setNameFormat("t_Pool-%d").build();
+    static public ExecutorService t_pool_executor;
+    /*
+    static final ThreadFactory tptep = new ThreadFactoryBuilder().setNameFormat("TickEntityPool-%d").build();
+    static public final ExecutorService tickentitypool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tptep);
+    */
+    //static public final ForkJoinPool tickentitypool = new ForkJoinPool(Runtime.getRuntime().availableProcessors());
+    
+    
+    
+    /*
+    static final ThreadFactory tpcps = new ThreadFactoryBuilder().setNameFormat("ChunkPool-%d").build();
+    static public final ExecutorService chunkpool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tpcps);
+    */
 
+    
+    
     private final String worldName;
     private final YamlConfiguration config;
     private boolean verbose;
@@ -341,4 +448,10 @@
         entityMaxTickTime = getInt("max-tick-time.entity", 50);
         log("Tile Max Tick Time: " + tileMaxTickTime + "ms Entity max Tick Time: " + entityMaxTickTime + "ms");
     }
+    
+    
+    /*
+    static final ThreadFactory tfwtep = new ThreadFactoryBuilder().setNameFormat("WorldTickEntityPool-%d").build();
+    static public ExecutorService wtepool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()*6, tfwtep);*/
+    
 }
