diff -Naur src_origin/main/java/net/minecraft/server/EntityPlayer.java src/main/java/net/minecraft/server/EntityPlayer.java
--- src_origin/main/java/net/minecraft/server/EntityPlayer.java	2016-04-03 23:27:22.123613930 +0800
+++ src/main/java/net/minecraft/server/EntityPlayer.java	2016-04-05 20:01:15.881591338 +0800
@@ -1033,9 +1033,6 @@
         if ("@".equals(s)) {
             return getBukkitEntity().hasPermission("minecraft.command.selector");
         }
-        if ("".equals(s)) {
-            return getBukkitEntity().isOp();
-        }
         return true;
         // CraftBukkit end
     }
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2016-04-03 23:27:22.612613930 +0800
+++ src/main/java/net/minecraft/server/MinecraftServer.java	2016-04-05 20:01:18.871591064 +0800
@@ -2,7 +2,6 @@
 
 import com.google.common.base.Charsets;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.ListenableFutureTask;
@@ -33,6 +32,7 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
 import java.util.Random;
@@ -46,6 +46,8 @@
 // CraftBukkit start
 // CraftBukkit end
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.hose.ChunkGen_Pool;
+import org.spigotmc.SpigotWorldConfig;
 
 public abstract class MinecraftServer implements Runnable, ICommandListener, IAsyncTaskHandler, IMojangStatistics {
 
@@ -353,7 +355,8 @@
             BlockPosition blockposition = worldserver.getSpawn();
             long j = av();
             i = 0;
-
+            List<int[]> chunkgen_list = new LinkedList();
+            int[] pos = new int[2];
             for (int k = -192; k <= 192 && this.isRunning(); k += 16) {
                 for (int l = -192; l <= 192 && this.isRunning(); l += 16) {
                     long i1 = av();
@@ -364,9 +367,13 @@
                     }
 
                     ++i;
-                    worldserver.getChunkProviderServer().getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    //worldserver.getChunkProviderServer().getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    pos[0] = blockposition.getX() + k >> 4;
+                    pos[1] = blockposition.getZ() + l >> 4;
+                    chunkgen_list.add(pos);
                 }
             }
+            SpigotWorldConfig.ChunkPool.invoke(new ChunkGen_Pool(worldserver, chunkgen_list));
         }
 
         for (WorldServer world : this.worlds) {
@@ -1022,7 +1029,8 @@
     }
 
     public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        //return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "HOSE"; // HOSE -> Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1104,7 +1112,8 @@
     }
 
     public String getName() {
-        return "Server";
+        //return "Server";
+        return org.bukkit.ChatColor.GREEN + "Server";
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
diff -Naur src_origin/main/java/net/minecraft/server/PlayerChunkMap.java src/main/java/net/minecraft/server/PlayerChunkMap.java
--- src_origin/main/java/net/minecraft/server/PlayerChunkMap.java	2016-04-03 23:27:22.917613931 +0800
+++ src/main/java/net/minecraft/server/PlayerChunkMap.java	2016-04-05 20:01:20.603590905 +0800
@@ -14,6 +14,8 @@
 
 // CraftBukkit start
 import java.util.LinkedList;
+import org.hose.PlayerChunkMap_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public class PlayerChunkMap {
@@ -212,7 +214,8 @@
         return (PlayerChunk) this.e.getEntry(d(i, j));
     }
 
-    private PlayerChunk c(int i, int j) {
+    public PlayerChunk c(int i, int j) {
+    //private PlayerChunk c(int i, int j) {
         long k = d(i, j);
         PlayerChunk playerchunk = (PlayerChunk) this.e.getEntry(k);
 
@@ -271,9 +274,11 @@
         }
 
         Collections.sort(chunkList, new ChunkCoordComparator(entityplayer));
+        /*
         for (ChunkCoordIntPair pair : chunkList) {
             this.c(pair.x, pair.z).a(entityplayer);
-        }
+        }*/
+        SpigotWorldConfig.PlayerChunkPool.invoke(new PlayerChunkMap_Pool(this, chunkList, entityplayer));
         // CraftBukkit end
 
         this.managedPlayers.add(entityplayer);
@@ -345,9 +350,11 @@
 
                 // CraftBukkit start - send nearest chunks first
                 Collections.sort(chunksToLoad, new ChunkCoordComparator(entityplayer));
+                /*
                 for (ChunkCoordIntPair pair : chunksToLoad) {
                     this.c(pair.x, pair.z).a(entityplayer);
-                }
+                }*/
+                SpigotWorldConfig.PlayerChunkPool.invoke(new PlayerChunkMap_Pool(this, chunksToLoad, entityplayer));
                 // CraftBukkit end
             }
         }
diff -Naur src_origin/main/java/net/minecraft/server/PlayerConnection.java src/main/java/net/minecraft/server/PlayerConnection.java
--- src_origin/main/java/net/minecraft/server/PlayerConnection.java	2016-04-03 23:27:22.930613931 +0800
+++ src/main/java/net/minecraft/server/PlayerConnection.java	2016-04-05 20:01:20.671590899 +0800
@@ -313,7 +313,7 @@
                 }
                 speed *= 2f; // TODO: Get the speed of the vehicle instead of the player
 
-                if (d10 - d9 > Math.max(100, Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2)) && (!this.minecraftServer.R() || !this.minecraftServer.Q().equals(entity.getName()))) { // Spigot
+                if (d10 - d9 > Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2) && (!this.minecraftServer.R() || !this.minecraftServer.Q().equals(entity.getName()))) { // Spigot
                 // CraftBukkit end
                     PlayerConnection.LOGGER.warn(entity.getName() + " (vehicle of " + this.player.getName() + ") moved too quickly! " + d6 + "," + d7 + "," + d8);
                     this.networkManager.sendPacket(new PacketPlayOutVehicleMove(entity));
@@ -522,7 +522,7 @@
                         if (!this.player.K() && (!this.player.x().getGameRules().getBoolean("disableElytraMovementCheck") || !this.player.cB())) {
                             float f2 = this.player.cB() ? 300.0F : 100.0F;
 
-                            if (d11 - d10 > Math.max(100, Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2)) && (!this.minecraftServer.R() || !this.minecraftServer.Q().equals(this.player.getName()))) { // Spigot
+                            if (d11 - d10 > Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2) && (!this.minecraftServer.R() || !this.minecraftServer.Q().equals(this.player.getName()))) { // Spigot
                         // CraftBukkit end
                                 PlayerConnection.LOGGER.warn(this.player.getName() + " moved too quickly! " + d7 + "," + d8 + "," + d9);
                                 this.a(this.player.locX, this.player.locY, this.player.locZ, this.player.yaw, this.player.pitch);
diff -Naur src_origin/main/java/net/minecraft/server/PlayerList.java src/main/java/net/minecraft/server/PlayerList.java
--- src_origin/main/java/net/minecraft/server/PlayerList.java	2016-04-03 23:27:22.954613931 +0800
+++ src/main/java/net/minecraft/server/PlayerList.java	2016-04-05 20:01:20.828590885 +0800
@@ -947,7 +947,7 @@
                         entity.getBukkitEntity().setVelocity(velocity);
                     }
                 }
-                // worldserver1.addEntity(entity);
+                worldserver1.addEntity(entity);
                 worldserver1.entityJoinedWorld(entity, false);
             }
 
diff -Naur src_origin/main/java/net/minecraft/server/TileEntity.java src/main/java/net/minecraft/server/TileEntity.java
--- src_origin/main/java/net/minecraft/server/TileEntity.java	2016-04-03 23:27:23.114613931 +0800
+++ src/main/java/net/minecraft/server/TileEntity.java	2016-04-05 20:01:21.978590779 +0800
@@ -20,11 +20,19 @@
     protected boolean d;
     private int h;
     protected Block e;
+    private static int entityCount;
+    private int id;
 
     public TileEntity() {
+        //add id
+        this.id = TileEntity.entityCount++;
         this.position = BlockPosition.ZERO;
         this.h = -1;
     }
+    
+    public int getId() {
+        return this.id;
+    }
 
     private static void a(Class<? extends TileEntity> oclass, String s) {
         if (TileEntity.f.containsKey(s)) {
diff -Naur src_origin/main/java/net/minecraft/server/World.java src/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2016-04-03 23:27:23.228613931 +0800
+++ src/main/java/net/minecraft/server/World.java	2016-04-05 20:01:22.829590701 +0800
@@ -15,7 +15,9 @@
 
 // CraftBukkit start
 import com.google.common.collect.Maps;
+import java.util.LinkedList;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
@@ -27,14 +29,21 @@
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 import org.bukkit.generator.ChunkGenerator;
+import org.hose.EntityTick_Pool;
+import org.hose.TileTick_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class World implements IBlockAccess {
 
+    List<Integer> ens_list = new LinkedList();
+    List<Integer> ents_list = new LinkedList();
     private int a = 63;
     protected boolean d;
     // Spigot start - guard entity list from removals
-    public final List<Entity> entityList = new java.util.ArrayList<Entity>()
+    public final Map<Integer, Entity> entityList_map = new ConcurrentHashMap();
+    public List<Entity> entityList = new ArrayList<Entity>();
+    /*public final List<Entity> entityList = new java.util.ArrayList<Entity>()
     {
         @Override
         public Entity remove(int index)
@@ -57,11 +66,12 @@
                 throw new java.util.ConcurrentModificationException();
             }
         }
-    };
+    };*/
     // Spigot end
     protected final List<Entity> f = Lists.newArrayList();
     public final List<TileEntity> tileEntityList = Lists.newArrayList();
-    public final List<TileEntity> tileEntityListTick = Lists.newArrayList();
+    //public final List<TileEntity> tileEntityListTick = Lists.newArrayList();
+    public final Map<Integer, TileEntity> tileEntityListTick = new ConcurrentHashMap();
     private final List<TileEntity> b = Lists.newArrayList();
     private final List<TileEntity> tileEntityListUnload = Lists.newArrayList();
     public final List<EntityHuman> players = Lists.newArrayList();
@@ -1004,7 +1014,9 @@
             }
 
             this.getChunkAt(i, j).a(entity);
-            this.entityList.add(entity);
+            //this.entityList.add(entity);
+            this.entityList_map.put(entity.getId(), entity);
+            this.entityList = new ArrayList<Entity>(entityList_map.values());
             this.b(entity);
             return true;
         }
@@ -1078,14 +1090,16 @@
             this.getChunkAt(i, j).b(entity);
         }
 
+        this.entityList_map.remove(entity.getId());
+        this.entityList = new ArrayList<Entity>(entityList_map.values());
         // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
-        int index = this.entityList.indexOf(entity);
+        /*int index = this.entityList.indexOf(entity);
         if (index != -1) {
             if (index <= this.tickPosition) {
                 this.tickPosition--;
             }
             this.entityList.remove(index);
-        }
+        }*/
         // CraftBukkit end
         } // Spigot
         this.c(entity);
@@ -1367,8 +1381,12 @@
         }
 
         this.methodProfiler.c("remove");
-        this.entityList.removeAll(this.f);
-
+        //this.entityList.removeAll(this.f);
+        for (Entity ent : this.f) {
+            this.entityList_map.remove(ent.getId());
+        }
+        this.entityList = new ArrayList<Entity>(entityList_map.values());
+        
         int j;
 
         for (i = 0; i < this.f.size(); ++i) {
@@ -1389,18 +1407,24 @@
         this.l();
         this.methodProfiler.c("regular");
 
-        CrashReportSystemDetails crashreportsystemdetails1;
-        CrashReport crashreport1;
+        //CrashReportSystemDetails crashreportsystemdetails1;
+        //CrashReport crashreport1;
 
         org.spigotmc.ActivationRange.activateEntities(this); // Spigot
         timings.entityTick.startTiming(); // Spigot
         guardEntityList = true; // Spigot
         // CraftBukkit start - Use field for loop variable
-        int entitiesThisCycle = 0;
-        if (tickPosition < 0) tickPosition = 0;
+        //int entitiesThisCycle = 0;
+        //if (tickPosition < 0) tickPosition = 0;
+        ens_list.clear();
+        Iterator ite = entityList_map.keySet().iterator();
         for (entityLimiter.initTick();
-                entitiesThisCycle < entityList.size() && (entitiesThisCycle % 10 != 0 || entityLimiter.shouldContinue());
-                tickPosition++, entitiesThisCycle++) {
+                //entitiesThisCycle < entityList.size() && (entitiesThisCycle % 10 != 0 || entityLimiter.shouldContinue());
+                ite.hasNext() && entityLimiter.shouldContinue();
+                //tickPosition++, entitiesThisCycle++) {
+                ) {
+            ens_list.add((int) ite.next());
+            /*
             tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
             entity = (Entity) this.entityList.get(this.tickPosition);
             // CraftBukkit end
@@ -1444,8 +1468,9 @@
                 this.c(entity);
             }
 
-            this.methodProfiler.b();
+            this.methodProfiler.b();*/
         }
+        SpigotWorldConfig.EntityTickPool.invoke(new EntityTick_Pool(this, ens_list));
         guardEntityList = false; // Spigot
 
         timings.entityTick.stopTiming(); // Spigot
@@ -1453,7 +1478,10 @@
         this.M = true;
         // CraftBukkit start - From below, clean up tile entities before ticking them
         if (!this.tileEntityListUnload.isEmpty()) {
-            this.tileEntityListTick.removeAll(this.tileEntityListUnload);
+            //this.tileEntityListTick.removeAll(this.tileEntityListUnload);
+            for (TileEntity tent : this.tileEntityListUnload) {
+                this.tileEntityListTick.remove(tent.getId());
+            }
             this.tileEntityList.removeAll(this.tileEntityListUnload);
             this.tileEntityListUnload.clear();
         }
@@ -1461,10 +1489,16 @@
 
         // Spigot start
         // Iterator iterator = this.tileEntityListTick.iterator();
-        int tilesThisCycle = 0;
+        //int tilesThisCycle = 0;
+        Iterator itt = tileEntityListTick.keySet().iterator();
+        ents_list.clear();
         for (tileLimiter.initTick();
-                tilesThisCycle < tileEntityListTick.size() && (tilesThisCycle % 10 != 0 || tileLimiter.shouldContinue());
-                tileTickPosition++, tilesThisCycle++) {
+                //tilesThisCycle < tileEntityListTick.size() && (tilesThisCycle % 10 != 0 || tileLimiter.shouldContinue());
+                itt.hasNext() && tileLimiter.shouldContinue();
+                //tileTickPosition++, tilesThisCycle++) {
+                ) {
+            ents_list.add((int) itt.next());
+            /*
             tileTickPosition = (tileTickPosition < tileEntityListTick.size()) ? tileTickPosition : 0;
             TileEntity tileentity = (TileEntity) this.tileEntityListTick.get(tileTickPosition);
             // Spigot start
@@ -1481,7 +1515,7 @@
 
                 if (this.isLoaded(blockposition) && this.N.a(blockposition)) {
                     try {
-                        this.methodProfiler.a(""/*tileentity.getClass().getSimpleName()*/); // CraftBukkit: SPIGOT-1900
+                        //this.methodProfiler.a(""/tileentity.getClass().getSimpleName()/); // CraftBukkit: SPIGOT-1900
                         tileentity.tickTimer.startTiming(); // Spigot
                         ((ITickable) tileentity).c();
                         this.methodProfiler.b();
@@ -1506,8 +1540,9 @@
                 if (this.isLoaded(tileentity.getPosition())) {
                     this.getChunkAtWorldCoords(tileentity.getPosition()).d(tileentity.getPosition());
                 }
-            }
+            }*/
         }
+        SpigotWorldConfig.TileTickPool.invoke(new TileTick_Pool(this, ents_list));
 
         timings.tileEntityTick.stopTiming(); // Spigot
         timings.tileEntityPending.startTiming(); // Spigot
@@ -1556,13 +1591,116 @@
         this.methodProfiler.b();
     }
 
+    CrashReportSystemDetails crashreportsystemdetails1;
+    CrashReport crashreport1;
+    public void entity_tick_hose(int id){
+        //tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
+        //entity = (Entity) this.entityList.get(this.tickPosition);
+        Entity entity = (Entity) this.entityList_map.get(id);
+        // CraftBukkit end
+        Entity entity1 = entity.by();
+
+        if (entity1 != null) {
+            if (!entity1.dead && entity1.w(entity)) {
+                //continue;
+                return;
+            }
+
+            entity.stopRiding();
+        }
+
+        this.methodProfiler.a("tick");
+        if (!entity.dead && !(entity instanceof EntityPlayer)) {
+            try {
+                SpigotTimings.tickEntityTimer.startTiming(); // Spigot
+                this.g(entity);
+                SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
+            } catch (Throwable throwable1) {
+                crashreport1 = CrashReport.a(throwable1, "Ticking entity");
+                crashreportsystemdetails1 = crashreport1.a("Entity being ticked");
+                entity.appendEntityCrashDetails(crashreportsystemdetails1);
+                throw new ReportedException(crashreport1);
+            }
+        }
+
+        this.methodProfiler.b();
+        this.methodProfiler.a("remove");
+        if (entity.dead) {
+            int j = entity.ab;
+            int l = entity.ad;
+
+            if (entity.aa && this.isChunkLoaded(j, l, true)) {
+                this.getChunkAt(j, l).b(entity);
+            }
+
+            guardEntityList = false; // Spigot
+            //this.entityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
+            this.entityList_map.remove(id); // CraftBukkit - Use field for loop variable
+            this.entityList = new ArrayList<Entity>(entityList_map.values());
+            guardEntityList = true; // Spigot
+            this.c(entity);
+        }
+
+        this.methodProfiler.b();
+    }
+    
+    public void tile_tick_hose(int id) {
+        //tileTickPosition = (tileTickPosition < tileEntityListTick.size()) ? tileTickPosition : 0;
+        //TileEntity tileentity = (TileEntity) this.tileEntityListTick.get(tileTickPosition);
+        TileEntity tileentity = (TileEntity) this.tileEntityListTick.get(id);
+        // Spigot start
+        if (tileentity == null) {
+            getServer().getLogger().severe("Spigot has detected a null entity and has removed it, preventing a crash");
+            //tilesThisCycle--;
+            //this.tileEntityListTick.remove(tileTickPosition--);
+            this.tileEntityListTick.remove(tileentity.getId());
+            //continue;
+            return;
+        }
+        // Spigot end
+
+        if (!tileentity.x() && tileentity.t()) {
+            BlockPosition blockposition = tileentity.getPosition();
+
+            if (this.isLoaded(blockposition) && this.N.a(blockposition)) {
+                try {
+                    this.methodProfiler.a(""/*tileentity.getClass().getSimpleName()*/); // CraftBukkit: SPIGOT-1900
+                    tileentity.tickTimer.startTiming(); // Spigot
+                    ((ITickable) tileentity).c();
+                    this.methodProfiler.b();
+                } catch (Throwable throwable2) {
+                    crashreport1 = CrashReport.a(throwable2, "Ticking block entity");
+                    crashreportsystemdetails1 = crashreport1.a("Block entity being ticked");
+                    tileentity.a(crashreportsystemdetails1);
+                    throw new ReportedException(crashreport1);
+                }
+                // Spigot start
+                finally {
+                    tileentity.tickTimer.stopTiming();
+                }
+                // Spigot end
+            }
+        }
+
+        if (tileentity.x()) {
+            //tilesThisCycle--;
+            //this.tileEntityListTick.remove(tileTickPosition--);
+            this.tileEntityListTick.remove(tileentity.getId());
+            this.tileEntityList.remove(tileentity);
+            if (this.isLoaded(tileentity.getPosition())) {
+                this.getChunkAtWorldCoords(tileentity.getPosition()).d(tileentity.getPosition());
+            }
+        }
+    }
+    
     protected void l() {}
 
     public boolean a(TileEntity tileentity) {
         boolean flag = this.tileEntityList.add(tileentity);
 
         if (flag && tileentity instanceof ITickable) {
-            this.tileEntityListTick.add(tileentity);
+            //this.tileEntityListTick.add(tileentity);
+            this.tileEntityListTick.put(tileentity.getId(), tileentity);
         }
 
         return flag;
@@ -1593,7 +1731,7 @@
         byte b0 = 32;
 
         // Spigot start
-        if (flag && !org.spigotmc.ActivationRange.checkIfActive(entity)) {
+        if (!org.spigotmc.ActivationRange.checkIfActive(entity)) {
             entity.ticksLived++;
             entity.inactiveTick();
         } else {
@@ -2025,7 +2163,8 @@
             if (tileentity != null) {
                 this.b.remove(tileentity);
                 this.tileEntityList.remove(tileentity);
-                this.tileEntityListTick.remove(tileentity);
+                //this.tileEntityListTick.remove(tileentity);
+                this.tileEntityListTick.remove(tileentity.getId());
             }
 
             this.getChunkAtWorldCoords(blockposition).d(blockposition);
@@ -2449,6 +2588,14 @@
 
     public <T extends Entity> List<T> a(Class<? extends T> oclass, Predicate<? super T> predicate) {
         ArrayList arraylist = Lists.newArrayList();
+        
+        for (Map.Entry me : this.entityList_map.entrySet()) {
+            Entity entity = (Entity) me.getValue();
+            if (oclass.isAssignableFrom(entity.getClass()) && predicate.apply((T) entity)) {
+                arraylist.add(entity);
+            }
+        }
+        /*
         Iterator iterator = this.entityList.iterator();
 
         while (iterator.hasNext()) {
@@ -2457,7 +2604,7 @@
             if (oclass.isAssignableFrom(entity.getClass()) && predicate.apply((T) entity)) {
                 arraylist.add(entity);
             }
-        }
+        }*/
 
         return arraylist;
     }
@@ -2533,6 +2680,24 @@
 
     public int a(Class<?> oclass) {
         int i = 0;
+        
+        for (Map.Entry me : this.entityList_map.entrySet()) {
+            Entity entity = (Entity) me.getValue();
+            // CraftBukkit start - Split out persistent check, don't apply it to special persistent mobs
+            if (entity instanceof EntityInsentient) {
+                EntityInsentient entityinsentient = (EntityInsentient) entity;
+                if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
+                    continue;
+                }
+            }
+            
+            if (oclass.isAssignableFrom(entity.getClass())) {
+            // if ((!(entity instanceof EntityInsentient) || !((EntityInsentient) entity).isPersistent()) && oclass.isAssignableFrom(entity.getClass())) {
+                // CraftBukkit end
+                ++i;
+            }
+        }
+        /*
         Iterator iterator = this.entityList.iterator();
 
         while (iterator.hasNext()) {
@@ -2550,7 +2715,7 @@
                 // CraftBukkit end
                 ++i;
             }
-        }
+        }*/
 
         return i;
     }
@@ -2567,10 +2732,12 @@
             if (entity == null) {
                 continue;
             }
-            this.entityList.add(entity);
+            //this.entityList.add(entity);
+            this.entityList_map.put(entity.getId(), entity);
             // CraftBukkit end
             this.b(entity);
         }
+        this.entityList = new ArrayList<Entity>(entityList_map.values());
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/WorldServer.java src/main/java/net/minecraft/server/WorldServer.java
--- src_origin/main/java/net/minecraft/server/WorldServer.java	2016-04-03 23:27:23.309613931 +0800
+++ src/main/java/net/minecraft/server/WorldServer.java	2016-04-05 20:01:23.407590648 +0800
@@ -669,12 +669,14 @@
                     this.getChunkAt(j, k).b(entity);
                 }
 
-                this.entityList.remove(entity);
+                //this.entityList.remove(entity);
+                this.entityList_map.remove(entity.getId());
                 this.c(entity);
             }
 
             this.methodProfiler.b();
         }
+        this.entityList = new ArrayList<Entity>(entityList_map.values());
 
     }
 
@@ -1082,10 +1084,12 @@
             Entity entity = (Entity) iterator.next();
 
             if (this.i(entity)) {
-                this.entityList.add(entity);
+                //this.entityList.add(entity);
+                this.entityList_map.put(entity.getId(), entity);
                 this.b(entity);
             }
         }
+        this.entityList = new ArrayList<Entity>(entityList_map.values());
 
     }
 
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java src/main/java/org/bukkit/craftbukkit/CraftWorld.java
--- src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-04-03 23:27:23.448613931 +0800
+++ src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-04-05 20:01:24.385590559 +0800
@@ -8,6 +8,7 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Iterator;
+import java.util.Map;
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
@@ -656,7 +657,8 @@
     public List<Entity> getEntities() {
         List<Entity> list = new ArrayList<Entity>();
 
-        for (Object o : world.entityList) {
+        for (Map.Entry me : world.entityList_map.entrySet()) {
+            Object o = me.getValue();
             if (o instanceof net.minecraft.server.Entity) {
                 net.minecraft.server.Entity mcEnt = (net.minecraft.server.Entity) o;
                 Entity bukkitEntity = mcEnt.getBukkitEntity();
@@ -667,6 +669,18 @@
                 }
             }
         }
+        /*
+        for (Object o : world.entityList) {
+            if (o instanceof net.minecraft.server.Entity) {
+                net.minecraft.server.Entity mcEnt = (net.minecraft.server.Entity) o;
+                Entity bukkitEntity = mcEnt.getBukkitEntity();
+
+                // Assuming that bukkitEntity isn't null
+                if (bukkitEntity != null) {
+                    list.add(bukkitEntity);
+                }
+            }
+        }*/
 
         return list;
     }
@@ -674,7 +688,8 @@
     public List<LivingEntity> getLivingEntities() {
         List<LivingEntity> list = new ArrayList<LivingEntity>();
 
-        for (Object o : world.entityList) {
+        for (Map.Entry me : world.entityList_map.entrySet()) {
+            Object o = me.getValue();
             if (o instanceof net.minecraft.server.Entity) {
                 net.minecraft.server.Entity mcEnt = (net.minecraft.server.Entity) o;
                 Entity bukkitEntity = mcEnt.getBukkitEntity();
@@ -685,6 +700,18 @@
                 }
             }
         }
+        /*
+        for (Object o : world.entityList) {
+            if (o instanceof net.minecraft.server.Entity) {
+                net.minecraft.server.Entity mcEnt = (net.minecraft.server.Entity) o;
+                Entity bukkitEntity = mcEnt.getBukkitEntity();
+
+                // Assuming that bukkitEntity isn't null
+                if (bukkitEntity != null && bukkitEntity instanceof LivingEntity) {
+                    list.add((LivingEntity) bukkitEntity);
+                }
+            }
+        }*/
 
         return list;
     }
@@ -699,7 +726,8 @@
     public <T extends Entity> Collection<T> getEntitiesByClass(Class<T> clazz) {
         Collection<T> list = new ArrayList<T>();
 
-        for (Object entity: world.entityList) {
+        for (Map.Entry me : world.entityList_map.entrySet()) {
+            Entity entity = (Entity) me.getValue();
             if (entity instanceof net.minecraft.server.Entity) {
                 Entity bukkitEntity = ((net.minecraft.server.Entity) entity).getBukkitEntity();
 
@@ -714,6 +742,23 @@
                 }
             }
         }
+        
+        /*
+        for (Object entity: world.entityList) {
+            if (entity instanceof net.minecraft.server.Entity) {
+                Entity bukkitEntity = ((net.minecraft.server.Entity) entity).getBukkitEntity();
+
+                if (bukkitEntity == null) {
+                    continue;
+                }
+
+                Class<?> bukkitClass = bukkitEntity.getClass();
+
+                if (clazz.isAssignableFrom(bukkitClass)) {
+                    list.add((T) bukkitEntity);
+                }
+            }
+        }*/
 
         return list;
     }
@@ -721,6 +766,26 @@
     public Collection<Entity> getEntitiesByClasses(Class<?>... classes) {
         Collection<Entity> list = new ArrayList<Entity>();
 
+        for (Map.Entry me : world.entityList_map.entrySet()) {
+             Entity entity = (Entity) me.getValue();
+             if (entity instanceof net.minecraft.server.Entity) {
+                Entity bukkitEntity = ((net.minecraft.server.Entity) entity).getBukkitEntity();
+
+                if (bukkitEntity == null) {
+                    continue;
+                }
+
+                Class<?> bukkitClass = bukkitEntity.getClass();
+
+                for (Class<?> clazz : classes) {
+                    if (clazz.isAssignableFrom(bukkitClass)) {
+                        list.add(bukkitEntity);
+                        break;
+                    }
+                }
+            }
+        }
+        /*
         for (Object entity: world.entityList) {
             if (entity instanceof net.minecraft.server.Entity) {
                 Entity bukkitEntity = ((net.minecraft.server.Entity) entity).getBukkitEntity();
@@ -738,7 +803,7 @@
                     }
                 }
             }
-        }
+        }*/
 
         return list;
     }
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
--- src_origin/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java	2016-04-03 23:27:24.112613932 +0800
+++ src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java	2016-04-05 20:01:29.317590106 +0800
@@ -242,7 +242,6 @@
         // entity.world = ((CraftWorld) location.getWorld()).getHandle();
         // Spigot end
         entity.setLocation(location.getX(), location.getY(), location.getZ(), location.getYaw(), location.getPitch());
-        entity.world.entityJoinedWorld(entity, false); // Spigot - register to new chunk
         // entity.setLocation() throws no event, and so cannot be cancelled
         return true;
     }
diff -Naur src_origin/main/java/org/hose/ChunkGen_Pool.java src/main/java/org/hose/ChunkGen_Pool.java
--- src_origin/main/java/org/hose/ChunkGen_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChunkGen_Pool.java	2016-04-05 20:01:07.535592103 +0800
@@ -0,0 +1,58 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.WorldServer;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkGen_Pool extends RecursiveAction {
+    WorldServer worldserver;
+    List<int[]> position;
+    
+    public ChunkGen_Pool(WorldServer worldserver, List<int[]> position){
+        this.worldserver = worldserver;
+        this.position = position;
+        
+    }
+    
+    @Override
+    protected void compute() {
+        List<RecursiveAction> forks = new LinkedList();
+        for (int[] pt : position) {
+            dotick task = new dotick(worldserver, pt);
+            forks.add(task);
+            task.fork();
+            task.join();
+        }
+        /*
+        for (RecursiveAction task : forks) {
+            task.join();
+        }*/
+    }
+    
+    
+    class dotick extends RecursiveAction {
+        WorldServer worldserver;
+        int[] pt;
+        
+        dotick(WorldServer worldserver, int[] pt) {
+            this.worldserver = worldserver;
+            this.pt = pt;
+        }
+        
+        @Override
+        protected void compute() {
+            worldserver.getChunkProviderServer().getChunkAt(pt[0], pt[1]);
+        }
+                 
+    }
+}
diff -Naur src_origin/main/java/org/hose/EntityTick_Pool.java src/main/java/org/hose/EntityTick_Pool.java
--- src_origin/main/java/org/hose/EntityTick_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/EntityTick_Pool.java	2016-04-05 20:01:07.579592099 +0800
@@ -0,0 +1,58 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.World;
+
+/**
+ *
+ * @author softpak
+ */
+public class EntityTick_Pool extends RecursiveAction {
+    World world;
+    List<Integer> entitys_list;
+    
+    public EntityTick_Pool(World world, List<Integer> entitys_list){
+        this.world = world;
+        this.entitys_list = entitys_list;
+        
+    }
+    
+    @Override
+    protected void compute() {
+        List<RecursiveAction> forks = new LinkedList();
+        for (int tp : entitys_list) {
+            dotick task = new dotick(world, tp);
+            forks.add(task);
+            task.fork();
+            task.join();
+        }
+        /*
+        for (RecursiveAction task : forks) {
+            task.join();
+        }*/
+    }
+    
+    
+    class dotick extends RecursiveAction {
+        World world;
+        int tp;
+        
+        dotick(World world, int tp) {
+            this.world = world;
+            this.tp = tp;
+        }
+        
+        @Override
+        protected void compute() {
+            world.entity_tick_hose(tp);
+        }
+                 
+    }
+}
diff -Naur src_origin/main/java/org/hose/PlayerChunkMap_Pool.java src/main/java/org/hose/PlayerChunkMap_Pool.java
--- src_origin/main/java/org/hose/PlayerChunkMap_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/PlayerChunkMap_Pool.java	2016-04-05 20:01:07.623592095 +0800
@@ -0,0 +1,61 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.PlayerChunkMap;
+
+/**
+ *
+ * @author softpak
+ */
+public class PlayerChunkMap_Pool extends RecursiveAction {//need to use callable
+    PlayerChunkMap pcm;
+    List<ChunkCoordIntPair> chunkList;
+    EntityPlayer entityplayer;
+    
+    public PlayerChunkMap_Pool(PlayerChunkMap pcm, List<ChunkCoordIntPair> chunkList, EntityPlayer entityplayer){
+        this.pcm = pcm;
+        this.chunkList = chunkList;
+        this.entityplayer = entityplayer;
+        
+    }
+    
+    @Override
+    protected void compute() {
+        List<RecursiveAction> forks = new LinkedList();
+        for (ChunkCoordIntPair cp : chunkList) {
+            getchunk task = new getchunk(pcm, cp.x, cp.z ,entityplayer);
+            forks.add(task);
+            task.fork();
+            task.join();
+        }
+    }
+    
+    
+    class getchunk extends RecursiveAction {
+        PlayerChunkMap pcm;
+        int x, z;
+        EntityPlayer entityplayer;
+        
+        getchunk(PlayerChunkMap pcm, int x, int z, EntityPlayer entityplayer) {
+            this.pcm = pcm;
+            this.x = x;
+            this.z = z;
+            this.entityplayer = entityplayer;
+        }
+        
+        @Override
+        protected void compute() {
+            pcm.c(x, z).a(entityplayer);
+        }
+                 
+    }
+}
diff -Naur src_origin/main/java/org/hose/TileTick_Pool.java src/main/java/org/hose/TileTick_Pool.java
--- src_origin/main/java/org/hose/TileTick_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/TileTick_Pool.java	2016-04-05 20:01:07.663592091 +0800
@@ -0,0 +1,58 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.World;
+
+/**
+ *
+ * @author softpak
+ */
+public class TileTick_Pool extends RecursiveAction {
+    World world;
+    List<Integer> tiles_list;
+    
+    public TileTick_Pool(World world, List<Integer> entitys_list){
+        this.world = world;
+        this.tiles_list = entitys_list;
+        
+    }
+    
+    @Override
+    protected void compute() {
+        List<RecursiveAction> forks = new LinkedList();
+        for (int tp : tiles_list) {
+            dotick task = new dotick(world, tp);
+            forks.add(task);
+            task.fork();
+            task.join();
+        }
+        /*
+        for (RecursiveAction task : forks) {
+            task.join();
+        }*/
+    }
+    
+    
+    class dotick extends RecursiveAction {
+        World world;
+        int tp;
+        
+        dotick(World world, int tp) {
+            this.world = world;
+            this.tp = tp;
+        }
+        
+        @Override
+        protected void compute() {
+            world.tile_tick_hose(tp);
+        }
+                 
+    }
+}
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2016-04-03 23:27:20.714613929 +0800
+++ src/main/java/org/spigotmc/AsyncCatcher.java	2016-04-05 20:01:07.903592069 +0800
@@ -5,7 +5,8 @@
 public class AsyncCatcher
 {
 
-    public static boolean enabled = true;
+    //public static boolean enabled = true;
+    public static boolean enabled = false;
 
     public static void catchOp(String reason)
     {
diff -Naur src_origin/main/java/org/spigotmc/SpigotWorldConfig.java src/main/java/org/spigotmc/SpigotWorldConfig.java
--- src_origin/main/java/org/spigotmc/SpigotWorldConfig.java	2016-04-03 23:27:20.782613929 +0800
+++ src/main/java/org/spigotmc/SpigotWorldConfig.java	2016-04-05 20:01:08.234592039 +0800
@@ -1,12 +1,21 @@
 package org.spigotmc;
 
 import java.util.List;
+import java.util.concurrent.ForkJoinPool;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
 public class SpigotWorldConfig
 {
-
+    //hose start
+    public static final ForkJoinPool EntityTickPool = new ForkJoinPool();
+    public static final ForkJoinPool TileTickPool = new ForkJoinPool();
+    public static final ForkJoinPool ChunkPool = new ForkJoinPool();
+    public static final ForkJoinPool PlayerChunkPool = new ForkJoinPool();
+    
+    
+    //hose end
+    
     private final String worldName;
     private final YamlConfiguration config;
     private boolean verbose;
