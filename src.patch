diff -Naur src_origin/main/java/net/minecraft/server/AttributeModifiable.java src/main/java/net/minecraft/server/AttributeModifiable.java
--- src_origin/main/java/net/minecraft/server/AttributeModifiable.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/AttributeModifiable.java	2016-03-16 23:43:28.874124842 +0800
@@ -0,0 +1,170 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CopyOnWriteArraySet;
+
+public class AttributeModifiable implements AttributeInstance {
+
+    private final AttributeMapBase a;
+    private final IAttribute b;
+    /*private final Map<Integer, Set<AttributeModifier>> c = Maps.newHashMap();
+    private final Map<String, Set<AttributeModifier>> d = Maps.newHashMap();
+    private final Map<UUID, AttributeModifier> e = Maps.newHashMap();*/
+    private final ConcurrentMap<Integer, CopyOnWriteArraySet<AttributeModifier>> c = Maps.newConcurrentMap();
+    private final ConcurrentMap<String, CopyOnWriteArraySet<AttributeModifier>> d = Maps.newConcurrentMap();
+    private final ConcurrentMap<UUID, AttributeModifier> e = Maps.newConcurrentMap();
+    private double f;
+    private boolean g = true;
+    private double h;
+
+    public AttributeModifiable(AttributeMapBase attributemapbase, IAttribute iattribute) {
+        this.a = attributemapbase;
+        this.b = iattribute;
+        this.f = iattribute.b();
+
+        for (int i = 0; i < 3; ++i) {
+            //this.c.put(Integer.valueOf(i), Sets.newHashSet());
+            this.c.put(Integer.valueOf(i), new CopyOnWriteArraySet());
+        }
+
+    }
+
+    public IAttribute getAttribute() {
+        return this.b;
+    }
+
+    public double b() {
+        return this.f;
+    }
+
+    public void setValue(double d0) {
+        if (d0 != this.b()) {
+            this.f = d0;
+            this.f();
+        }
+    }
+
+    public Collection<AttributeModifier> a(int i) {
+        return (Collection) this.c.get(Integer.valueOf(i));
+    }
+
+    public Collection<AttributeModifier> c() {
+        //HashSet hashset = Sets.newHashSet();
+        CopyOnWriteArraySet hashset = new CopyOnWriteArraySet();
+
+        for (int i = 0; i < 3; ++i) {
+            hashset.addAll(this.a(i));
+        }
+
+        return hashset;
+    }
+
+    public AttributeModifier a(UUID uuid) {
+        return (AttributeModifier) this.e.get(uuid);
+    }
+
+    public boolean a(AttributeModifier attributemodifier) {
+        return this.e.get(attributemodifier.a()) != null;
+    }
+
+    public void b(AttributeModifier attributemodifier) {
+        if (this.a(attributemodifier.a()) != null) {
+            throw new IllegalArgumentException("Modifier is already applied on this attribute!");
+        } else {
+            //Object object = (Set) this.d.get(attributemodifier.b());
+            Object object = (CopyOnWriteArraySet) this.d.get(attributemodifier.b());
+
+            if (object == null) {
+                //object = Sets.newHashSet();
+                object = new CopyOnWriteArraySet();
+                //this.d.put(attributemodifier.b(), object);
+                this.d.put(attributemodifier.b(), (CopyOnWriteArraySet)object);
+            }
+
+            ((Set) this.c.get(Integer.valueOf(attributemodifier.c()))).add(attributemodifier);
+            ((Set) object).add(attributemodifier);
+            this.e.put(attributemodifier.a(), attributemodifier);
+            this.f();
+        }
+    }
+
+    protected void f() {
+        this.g = true;
+        this.a.a((AttributeInstance) this);
+    }
+
+    public void c(AttributeModifier attributemodifier) {
+        for (int i = 0; i < 3; ++i) {
+            Set set = (Set) this.c.get(Integer.valueOf(i));
+
+            set.remove(attributemodifier);
+        }
+
+        Set set1 = (Set) this.d.get(attributemodifier.b());
+
+        if (set1 != null) {
+            set1.remove(attributemodifier);
+            if (set1.isEmpty()) {
+                this.d.remove(attributemodifier.b());
+            }
+        }
+
+        this.e.remove(attributemodifier.a());
+        this.f();
+    }
+
+    public double getValue() {
+        if (this.g) {
+            this.h = this.g();
+            this.g = false;
+        }
+
+        return this.h;
+    }
+
+    private double g() {
+        double d0 = this.b();
+
+        AttributeModifier attributemodifier;
+
+        for (Iterator iterator = this.b(0).iterator(); iterator.hasNext(); d0 += attributemodifier.d()) {
+            attributemodifier = (AttributeModifier) iterator.next();
+        }
+
+        double d1 = d0;
+
+        Iterator iterator1;
+        AttributeModifier attributemodifier1;
+
+        for (iterator1 = this.b(1).iterator(); iterator1.hasNext(); d1 += d0 * attributemodifier1.d()) {
+            attributemodifier1 = (AttributeModifier) iterator1.next();
+        }
+
+        for (iterator1 = this.b(2).iterator(); iterator1.hasNext(); d1 *= 1.0D + attributemodifier1.d()) {
+            attributemodifier1 = (AttributeModifier) iterator1.next();
+        }
+
+        return this.b.a(d1);
+    }
+
+    private Collection<AttributeModifier> b(int i) {
+        HashSet hashset = Sets.newHashSet(this.a(i));
+
+        for (IAttribute iattribute = this.b.d(); iattribute != null; iattribute = iattribute.d()) {
+            AttributeInstance attributeinstance = this.a.a(iattribute);
+
+            if (attributeinstance != null) {
+                hashset.addAll(attributeinstance.a(i));
+            }
+        }
+
+        return hashset;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/BiomeBase.java src/main/java/net/minecraft/server/BiomeBase.java
--- src_origin/main/java/net/minecraft/server/BiomeBase.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/BiomeBase.java	2016-03-16 23:43:28.886124842 +0800
@@ -0,0 +1,492 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import io.netty.util.internal.ConcurrentSet;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.Set;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public abstract class BiomeBase {
+
+    private static final Logger aD = LogManager.getLogger();
+    protected static final BiomeBase.BiomeTemperature a = new BiomeBase.BiomeTemperature(0.1F, 0.2F);
+    protected static final BiomeBase.BiomeTemperature b = new BiomeBase.BiomeTemperature(-0.5F, 0.0F);
+    protected static final BiomeBase.BiomeTemperature c = new BiomeBase.BiomeTemperature(-1.0F, 0.1F);
+    protected static final BiomeBase.BiomeTemperature d = new BiomeBase.BiomeTemperature(-1.8F, 0.1F);
+    protected static final BiomeBase.BiomeTemperature e = new BiomeBase.BiomeTemperature(0.125F, 0.05F);
+    protected static final BiomeBase.BiomeTemperature f = new BiomeBase.BiomeTemperature(0.2F, 0.2F);
+    protected static final BiomeBase.BiomeTemperature g = new BiomeBase.BiomeTemperature(0.45F, 0.3F);
+    protected static final BiomeBase.BiomeTemperature h = new BiomeBase.BiomeTemperature(1.5F, 0.025F);
+    protected static final BiomeBase.BiomeTemperature i = new BiomeBase.BiomeTemperature(1.0F, 0.5F);
+    protected static final BiomeBase.BiomeTemperature j = new BiomeBase.BiomeTemperature(0.0F, 0.025F);
+    protected static final BiomeBase.BiomeTemperature k = new BiomeBase.BiomeTemperature(0.1F, 0.8F);
+    protected static final BiomeBase.BiomeTemperature l = new BiomeBase.BiomeTemperature(0.2F, 0.3F);
+    protected static final BiomeBase.BiomeTemperature m = new BiomeBase.BiomeTemperature(-0.2F, 0.1F);
+    private static final BiomeBase[] biomes = new BiomeBase[256];
+    //public static final Set<BiomeBase> n = Sets.newHashSet();
+    //public static final Map<String, BiomeBase> o = Maps.newHashMap();
+    public static final Set<BiomeBase> n = new ConcurrentSet();
+    public static final Map<String, BiomeBase> o = Maps.newConcurrentMap();
+    public static final BiomeBase OCEAN = (new BiomeOcean(0)).b(112).a("Ocean").a(BiomeBase.c);
+    public static final BiomeBase PLAINS = (new BiomePlains(1)).b(9286496).a("Plains");
+    public static final BiomeBase DESERT = (new BiomeDesert(2)).b(16421912).a("Desert").b().a(2.0F, 0.0F).a(BiomeBase.e);
+    public static final BiomeBase EXTREME_HILLS = (new BiomeBigHills(3, false)).b(6316128).a("Extreme Hills").a(BiomeBase.i).a(0.2F, 0.3F);
+    public static final BiomeBase FOREST = (new BiomeForest(4, 0)).b(353825).a("Forest");
+    public static final BiomeBase TAIGA = (new BiomeTaiga(5, 0)).b(747097).a("Taiga").a(5159473).a(0.25F, 0.8F).a(BiomeBase.f);
+    public static final BiomeBase SWAMPLAND = (new BiomeSwamp(6)).b(522674).a("Swampland").a(9154376).a(BiomeBase.m).a(0.8F, 0.9F);
+    public static final BiomeBase RIVER = (new BiomeRiver(7)).b(255).a("River").a(BiomeBase.b);
+    public static final BiomeBase HELL = (new BiomeHell(8)).b(16711680).a("Hell").b().a(2.0F, 0.0F);
+    public static final BiomeBase SKY = (new BiomeTheEnd(9)).b(8421631).a("The End").b();
+    public static final BiomeBase FROZEN_OCEAN = (new BiomeOcean(10)).b(9474208).a("FrozenOcean").c().a(BiomeBase.c).a(0.0F, 0.5F);
+    public static final BiomeBase FROZEN_RIVER = (new BiomeRiver(11)).b(10526975).a("FrozenRiver").c().a(BiomeBase.b).a(0.0F, 0.5F);
+    public static final BiomeBase ICE_PLAINS = (new BiomeIcePlains(12, false)).b(16777215).a("Ice Plains").c().a(0.0F, 0.5F).a(BiomeBase.e);
+    public static final BiomeBase ICE_MOUNTAINS = (new BiomeIcePlains(13, false)).b(10526880).a("Ice Mountains").c().a(BiomeBase.g).a(0.0F, 0.5F);
+    public static final BiomeBase MUSHROOM_ISLAND = (new BiomeMushrooms(14)).b(16711935).a("MushroomIsland").a(0.9F, 1.0F).a(BiomeBase.l);
+    public static final BiomeBase MUSHROOM_SHORE = (new BiomeMushrooms(15)).b(10486015).a("MushroomIslandShore").a(0.9F, 1.0F).a(BiomeBase.j);
+    public static final BiomeBase BEACH = (new BiomeBeach(16)).b(16440917).a("Beach").a(0.8F, 0.4F).a(BiomeBase.j);
+    public static final BiomeBase DESERT_HILLS = (new BiomeDesert(17)).b(13786898).a("DesertHills").b().a(2.0F, 0.0F).a(BiomeBase.g);
+    public static final BiomeBase FOREST_HILLS = (new BiomeForest(18, 0)).b(2250012).a("ForestHills").a(BiomeBase.g);
+    public static final BiomeBase TAIGA_HILLS = (new BiomeTaiga(19, 0)).b(1456435).a("TaigaHills").a(5159473).a(0.25F, 0.8F).a(BiomeBase.g);
+    public static final BiomeBase SMALL_MOUNTAINS = (new BiomeBigHills(20, true)).b(7501978).a("Extreme Hills Edge").a(BiomeBase.i.a()).a(0.2F, 0.3F);
+    public static final BiomeBase JUNGLE = (new BiomeJungle(21, false)).b(5470985).a("Jungle").a(5470985).a(0.95F, 0.9F);
+    public static final BiomeBase JUNGLE_HILLS = (new BiomeJungle(22, false)).b(2900485).a("JungleHills").a(5470985).a(0.95F, 0.9F).a(BiomeBase.g);
+    public static final BiomeBase JUNGLE_EDGE = (new BiomeJungle(23, true)).b(6458135).a("JungleEdge").a(5470985).a(0.95F, 0.8F);
+    public static final BiomeBase DEEP_OCEAN = (new BiomeOcean(24)).b(48).a("Deep Ocean").a(BiomeBase.d);
+    public static final BiomeBase STONE_BEACH = (new BiomeStoneBeach(25)).b(10658436).a("Stone Beach").a(0.2F, 0.3F).a(BiomeBase.k);
+    public static final BiomeBase COLD_BEACH = (new BiomeBeach(26)).b(16445632).a("Cold Beach").a(0.05F, 0.3F).a(BiomeBase.j).c();
+    public static final BiomeBase BIRCH_FOREST = (new BiomeForest(27, 2)).a("Birch Forest").b(3175492);
+    public static final BiomeBase BIRCH_FOREST_HILLS = (new BiomeForest(28, 2)).a("Birch Forest Hills").b(2055986).a(BiomeBase.g);
+    public static final BiomeBase ROOFED_FOREST = (new BiomeForest(29, 3)).b(4215066).a("Roofed Forest");
+    public static final BiomeBase COLD_TAIGA = (new BiomeTaiga(30, 0)).b(3233098).a("Cold Taiga").a(5159473).c().a(-0.5F, 0.4F).a(BiomeBase.f).c(16777215);
+    public static final BiomeBase COLD_TAIGA_HILLS = (new BiomeTaiga(31, 0)).b(2375478).a("Cold Taiga Hills").a(5159473).c().a(-0.5F, 0.4F).a(BiomeBase.g).c(16777215);
+    public static final BiomeBase MEGA_TAIGA = (new BiomeTaiga(32, 1)).b(5858897).a("Mega Taiga").a(5159473).a(0.3F, 0.8F).a(BiomeBase.f);
+    public static final BiomeBase MEGA_TAIGA_HILLS = (new BiomeTaiga(33, 1)).b(4542270).a("Mega Taiga Hills").a(5159473).a(0.3F, 0.8F).a(BiomeBase.g);
+    public static final BiomeBase EXTREME_HILLS_PLUS = (new BiomeBigHills(34, true)).b(5271632).a("Extreme Hills+").a(BiomeBase.i).a(0.2F, 0.3F);
+    public static final BiomeBase SAVANNA = (new BiomeSavanna(35)).b(12431967).a("Savanna").a(1.2F, 0.0F).b().a(BiomeBase.e);
+    public static final BiomeBase SAVANNA_PLATEAU = (new BiomeSavanna(36)).b(10984804).a("Savanna Plateau").a(1.0F, 0.0F).b().a(BiomeBase.h);
+    public static final BiomeBase MESA = (new BiomeMesa(37, false, false)).b(14238997).a("Mesa");
+    public static final BiomeBase MESA_PLATEAU_F = (new BiomeMesa(38, false, true)).b(11573093).a("Mesa Plateau F").a(BiomeBase.h);
+    public static final BiomeBase MESA_PLATEAU = (new BiomeMesa(39, false, false)).b(13274213).a("Mesa Plateau").a(BiomeBase.h);
+    public static final BiomeBase ad = BiomeBase.OCEAN;
+    protected static final NoiseGenerator3 ae;
+    protected static final NoiseGenerator3 af;
+    protected static final WorldGenTallPlant ag;
+    public String ah;
+    public int ai;
+    public int aj;
+    public IBlockData ak;
+    public IBlockData al;
+    public int am;
+    public float an;
+    public float ao;
+    public float temperature;
+    public float humidity;
+    public int ar;
+    public BiomeDecorator as;
+    protected List<BiomeBase.BiomeMeta> at;
+    protected List<BiomeBase.BiomeMeta> au;
+    protected List<BiomeBase.BiomeMeta> av;
+    protected List<BiomeBase.BiomeMeta> aw;
+    protected boolean ax;
+    protected boolean ay;
+    public final int id;
+    protected WorldGenTrees aA;
+    protected WorldGenBigTree aB;
+    protected WorldGenSwampTree aC;
+
+    protected BiomeBase(int i) {
+        this.ak = Blocks.GRASS.getBlockData();
+        this.al = Blocks.DIRT.getBlockData();
+        this.am = 5169201;
+        this.an = BiomeBase.a.a;
+        this.ao = BiomeBase.a.b;
+        this.temperature = 0.5F;
+        this.humidity = 0.5F;
+        this.ar = 16777215;
+        this.at = Lists.newArrayList();
+        this.au = Lists.newArrayList();
+        this.av = Lists.newArrayList();
+        this.aw = Lists.newArrayList();
+        this.ay = true;
+        this.aA = new WorldGenTrees(false);
+        this.aB = new WorldGenBigTree(false);
+        this.aC = new WorldGenSwampTree();
+        this.id = i;
+        BiomeBase.biomes[i] = this;
+        this.as = this.a();
+        this.au.add(new BiomeBase.BiomeMeta(EntitySheep.class, 12, 4, 4));
+        this.au.add(new BiomeBase.BiomeMeta(EntityRabbit.class, 10, 3, 3));
+        this.au.add(new BiomeBase.BiomeMeta(EntityPig.class, 10, 4, 4));
+        this.au.add(new BiomeBase.BiomeMeta(EntityChicken.class, 10, 4, 4));
+        this.au.add(new BiomeBase.BiomeMeta(EntityCow.class, 8, 4, 4));
+        this.at.add(new BiomeBase.BiomeMeta(EntitySpider.class, 100, 4, 4));
+        this.at.add(new BiomeBase.BiomeMeta(EntityZombie.class, 100, 4, 4));
+        this.at.add(new BiomeBase.BiomeMeta(EntitySkeleton.class, 100, 4, 4));
+        this.at.add(new BiomeBase.BiomeMeta(EntityCreeper.class, 100, 4, 4));
+        this.at.add(new BiomeBase.BiomeMeta(EntitySlime.class, 100, 4, 4));
+        this.at.add(new BiomeBase.BiomeMeta(EntityEnderman.class, 10, 1, 4));
+        this.at.add(new BiomeBase.BiomeMeta(EntityWitch.class, 5, 1, 1));
+        this.av.add(new BiomeBase.BiomeMeta(EntitySquid.class, 10, 4, 4));
+        this.aw.add(new BiomeBase.BiomeMeta(EntityBat.class, 10, 8, 8));
+    }
+
+    protected BiomeDecorator a() {
+        return new BiomeDecorator();
+    }
+
+    protected BiomeBase a(float f, float f1) {
+        if (f > 0.1F && f < 0.2F) {
+            throw new IllegalArgumentException("Please avoid temperatures in the range 0.1 - 0.2 because of snow");
+        } else {
+            this.temperature = f;
+            this.humidity = f1;
+            return this;
+        }
+    }
+
+    protected final BiomeBase a(BiomeBase.BiomeTemperature biomebase_biometemperature) {
+        this.an = biomebase_biometemperature.a;
+        this.ao = biomebase_biometemperature.b;
+        return this;
+    }
+
+    protected BiomeBase b() {
+        this.ay = false;
+        return this;
+    }
+
+    public WorldGenTreeAbstract a(Random random) {
+        return (WorldGenTreeAbstract) (random.nextInt(10) == 0 ? this.aB : this.aA);
+    }
+
+    public WorldGenerator b(Random random) {
+        return new WorldGenGrass(BlockLongGrass.EnumTallGrassType.GRASS);
+    }
+
+    public BlockFlowers.EnumFlowerVarient a(Random random, BlockPosition blockposition) {
+        return random.nextInt(3) > 0 ? BlockFlowers.EnumFlowerVarient.DANDELION : BlockFlowers.EnumFlowerVarient.POPPY;
+    }
+
+    protected BiomeBase c() {
+        this.ax = true;
+        return this;
+    }
+
+    protected BiomeBase a(String s) {
+        this.ah = s;
+        return this;
+    }
+
+    protected BiomeBase a(int i) {
+        this.am = i;
+        return this;
+    }
+
+    protected BiomeBase b(int i) {
+        this.a(i, false);
+        return this;
+    }
+
+    protected BiomeBase c(int i) {
+        this.aj = i;
+        return this;
+    }
+
+    protected BiomeBase a(int i, boolean flag) {
+        this.ai = i;
+        if (flag) {
+            this.aj = (i & 16711422) >> 1;
+        } else {
+            this.aj = i;
+        }
+
+        return this;
+    }
+
+    public List<BiomeBase.BiomeMeta> getMobs(EnumCreatureType enumcreaturetype) {
+        switch (BiomeBase.SyntheticClass_1.switchMap[enumcreaturetype.ordinal()]) {
+        case 1:
+            return this.at;
+
+        case 2:
+            return this.au;
+
+        case 3:
+            return this.av;
+
+        case 4:
+            return this.aw;
+
+        default:
+            return Collections.emptyList();
+        }
+    }
+
+    public boolean d() {
+        return this.j();
+    }
+
+    public boolean e() {
+        return this.j() ? false : this.ay;
+    }
+
+    public boolean f() {
+        return this.humidity > 0.85F;
+    }
+
+    public float g() {
+        return 0.1F;
+    }
+
+    public final int h() {
+        return (int) (this.humidity * 65536.0F);
+    }
+
+    public final float a(BlockPosition blockposition) {
+        if (blockposition.getY() > 64) {
+            float f = (float) (BiomeBase.ae.a((double) blockposition.getX() * 1.0D / 8.0D, (double) blockposition.getZ() * 1.0D / 8.0D) * 4.0D);
+
+            return this.temperature - (f + (float) blockposition.getY() - 64.0F) * 0.05F / 30.0F;
+        } else {
+            return this.temperature;
+        }
+    }
+
+    public void a(World world, Random random, BlockPosition blockposition) {
+        this.as.a(world, random, this, blockposition);
+    }
+
+    public boolean j() {
+        return this.ax;
+    }
+
+    public void a(World world, Random random, ChunkSnapshot chunksnapshot, int i, int j, double d0) {
+        this.b(world, random, chunksnapshot, i, j, d0);
+    }
+
+    public final void b(World world, Random random, ChunkSnapshot chunksnapshot, int i, int j, double d0) {
+        int k = world.F();
+        IBlockData iblockdata = this.ak;
+        IBlockData iblockdata1 = this.al;
+        int l = -1;
+        int i1 = (int) (d0 / 3.0D + 3.0D + random.nextDouble() * 0.25D);
+        int j1 = i & 15;
+        int k1 = j & 15;
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+
+        for (int l1 = 255; l1 >= 0; --l1) {
+            if (l1 <= random.nextInt(5)) {
+                chunksnapshot.a(k1, l1, j1, Blocks.BEDROCK.getBlockData());
+            } else {
+                IBlockData iblockdata2 = chunksnapshot.a(k1, l1, j1);
+
+                if (iblockdata2.getBlock().getMaterial() == Material.AIR) {
+                    l = -1;
+                } else if (iblockdata2.getBlock() == Blocks.STONE) {
+                    if (l == -1) {
+                        if (i1 <= 0) {
+                            iblockdata = null;
+                            iblockdata1 = Blocks.STONE.getBlockData();
+                        } else if (l1 >= k - 4 && l1 <= k + 1) {
+                            iblockdata = this.ak;
+                            iblockdata1 = this.al;
+                        }
+
+                        if (l1 < k && (iblockdata == null || iblockdata.getBlock().getMaterial() == Material.AIR)) {
+                            if (this.a((BlockPosition) blockposition_mutableblockposition.c(i, l1, j)) < 0.15F) {
+                                iblockdata = Blocks.ICE.getBlockData();
+                            } else {
+                                iblockdata = Blocks.WATER.getBlockData();
+                            }
+                        }
+
+                        l = i1;
+                        if (l1 >= k - 1) {
+                            chunksnapshot.a(k1, l1, j1, iblockdata);
+                        } else if (l1 < k - 7 - i1) {
+                            iblockdata = null;
+                            iblockdata1 = Blocks.STONE.getBlockData();
+                            chunksnapshot.a(k1, l1, j1, Blocks.GRAVEL.getBlockData());
+                        } else {
+                            chunksnapshot.a(k1, l1, j1, iblockdata1);
+                        }
+                    } else if (l > 0) {
+                        --l;
+                        chunksnapshot.a(k1, l1, j1, iblockdata1);
+                        if (l == 0 && iblockdata1.getBlock() == Blocks.SAND) {
+                            l = random.nextInt(4) + Math.max(0, l1 - 63);
+                            iblockdata1 = iblockdata1.get(BlockSand.VARIANT) == BlockSand.EnumSandVariant.RED_SAND ? Blocks.RED_SANDSTONE.getBlockData() : Blocks.SANDSTONE.getBlockData();
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    protected BiomeBase k() {
+        return this.d(this.id + 128);
+    }
+
+    protected BiomeBase d(int i) {
+        return new BiomeBaseSub(i, this);
+    }
+
+    public Class<? extends BiomeBase> l() {
+        return this.getClass();
+    }
+
+    public boolean a(BiomeBase biomebase) {
+        return biomebase == this ? true : (biomebase == null ? false : this.l() == biomebase.l());
+    }
+
+    public BiomeBase.EnumTemperature m() {
+        return (double) this.temperature < 0.2D ? BiomeBase.EnumTemperature.COLD : ((double) this.temperature < 1.0D ? BiomeBase.EnumTemperature.MEDIUM : BiomeBase.EnumTemperature.WARM);
+    }
+
+    public static BiomeBase[] getBiomes() {
+        return BiomeBase.biomes;
+    }
+
+    //synchronized public static BiomeBase getBiome(int i) {
+    public static BiomeBase getBiome(int i) {
+        return getBiome(i, (BiomeBase) null);
+    }
+
+    public static BiomeBase getBiome(int i, BiomeBase biomebase) {
+        if (i >= 0 && i <= BiomeBase.biomes.length) {
+            BiomeBase biomebase1 = BiomeBase.biomes[i];
+
+            return biomebase1 == null ? biomebase : biomebase1;
+        } else {
+            BiomeBase.aD.warn("Biome ID is out of bounds: " + i + ", defaulting to 0 (Ocean)");
+            return BiomeBase.OCEAN;
+        }
+    }
+
+    static {
+        BiomeBase.PLAINS.k();
+        BiomeBase.DESERT.k();
+        BiomeBase.FOREST.k();
+        BiomeBase.TAIGA.k();
+        BiomeBase.SWAMPLAND.k();
+        BiomeBase.ICE_PLAINS.k();
+        BiomeBase.JUNGLE.k();
+        BiomeBase.JUNGLE_EDGE.k();
+        BiomeBase.COLD_TAIGA.k();
+        BiomeBase.SAVANNA.k();
+        BiomeBase.SAVANNA_PLATEAU.k();
+        BiomeBase.MESA.k();
+        BiomeBase.MESA_PLATEAU_F.k();
+        BiomeBase.MESA_PLATEAU.k();
+        BiomeBase.BIRCH_FOREST.k();
+        BiomeBase.BIRCH_FOREST_HILLS.k();
+        BiomeBase.ROOFED_FOREST.k();
+        BiomeBase.MEGA_TAIGA.k();
+        BiomeBase.EXTREME_HILLS.k();
+        BiomeBase.EXTREME_HILLS_PLUS.k();
+        BiomeBase.MEGA_TAIGA.d(BiomeBase.MEGA_TAIGA_HILLS.id + 128).a("Redwood Taiga Hills M");
+        BiomeBase[] abiomebase = BiomeBase.biomes;
+        int i = abiomebase.length;
+
+        for (int j = 0; j < i; ++j) {
+            BiomeBase biomebase = abiomebase[j];
+
+            if (biomebase != null) {
+                if (BiomeBase.o.containsKey(biomebase.ah)) {
+                    throw new Error("Biome \"" + biomebase.ah + "\" is defined as both ID " + ((BiomeBase) BiomeBase.o.get(biomebase.ah)).id + " and " + biomebase.id);
+                }
+
+                BiomeBase.o.put(biomebase.ah, biomebase);
+                if (biomebase.id < 128) {
+                    BiomeBase.n.add(biomebase);
+                }
+            }
+        }
+
+        BiomeBase.n.remove(BiomeBase.HELL);
+        BiomeBase.n.remove(BiomeBase.SKY);
+        BiomeBase.n.remove(BiomeBase.FROZEN_OCEAN);
+        BiomeBase.n.remove(BiomeBase.SMALL_MOUNTAINS);
+        ae = new NoiseGenerator3(new Random(1234L), 1);
+        af = new NoiseGenerator3(new Random(2345L), 1);
+        ag = new WorldGenTallPlant();
+    }
+
+    static class SyntheticClass_1 {
+
+        static final int[] switchMap = new int[EnumCreatureType.values().length];
+
+        static {
+            try {
+                BiomeBase.SyntheticClass_1.switchMap[EnumCreatureType.MONSTER.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror) {
+                ;
+            }
+
+            try {
+                BiomeBase.SyntheticClass_1.switchMap[EnumCreatureType.CREATURE.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror1) {
+                ;
+            }
+
+            try {
+                BiomeBase.SyntheticClass_1.switchMap[EnumCreatureType.WATER_CREATURE.ordinal()] = 3;
+            } catch (NoSuchFieldError nosuchfielderror2) {
+                ;
+            }
+
+            try {
+                BiomeBase.SyntheticClass_1.switchMap[EnumCreatureType.AMBIENT.ordinal()] = 4;
+            } catch (NoSuchFieldError nosuchfielderror3) {
+                ;
+            }
+
+        }
+    }
+
+    public static class BiomeMeta extends WeightedRandom.WeightedRandomChoice {
+
+        public Class<? extends EntityInsentient> b;
+        public int c;
+        public int d;
+
+        public BiomeMeta(Class<? extends EntityInsentient> oclass, int i, int j, int k) {
+            super(i);
+            this.b = oclass;
+            this.c = j;
+            this.d = k;
+        }
+
+        public String toString() {
+            return this.b.getSimpleName() + "*(" + this.c + "-" + this.d + "):" + this.a;
+        }
+    }
+
+    public static class BiomeTemperature {
+
+        public float a;
+        public float b;
+
+        public BiomeTemperature(float f, float f1) {
+            this.a = f;
+            this.b = f1;
+        }
+
+        public BiomeBase.BiomeTemperature a() {
+            return new BiomeBase.BiomeTemperature(this.a * 0.8F, this.b * 0.6F);
+        }
+    }
+
+    public static enum EnumTemperature {
+
+        OCEAN, COLD, MEDIUM, WARM;
+
+        private EnumTemperature() {}
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/BlockFurnace.java src/main/java/net/minecraft/server/BlockFurnace.java
--- src_origin/main/java/net/minecraft/server/BlockFurnace.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/BlockFurnace.java	2016-03-16 23:43:29.059124843 +0800
@@ -0,0 +1,148 @@
+package net.minecraft.server;
+
+import com.google.common.base.Predicate;
+import java.util.Random;
+
+public class BlockFurnace extends BlockContainer {
+
+    public static final BlockStateDirection FACING = BlockStateDirection.of("facing", (Predicate) EnumDirection.EnumDirectionLimit.HORIZONTAL);
+    private final boolean b;
+    private static boolean N;
+
+    protected BlockFurnace(boolean flag) {
+        super(Material.STONE);
+        this.j(this.blockStateList.getBlockData().set(BlockFurnace.FACING, EnumDirection.NORTH));
+        this.b = flag;
+    }
+
+    public Item getDropType(IBlockData iblockdata, Random random, int i) {
+        return Item.getItemOf(Blocks.FURNACE);
+    }
+
+    public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        this.e(world, blockposition, iblockdata);
+    }
+
+    private void e(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        if (!world.isClientSide) {
+            Block block = world.getType(blockposition.north()).getBlock();
+            Block block1 = world.getType(blockposition.south()).getBlock();
+            Block block2 = world.getType(blockposition.west()).getBlock();
+            Block block3 = world.getType(blockposition.east()).getBlock();
+            EnumDirection enumdirection = (EnumDirection) iblockdata.get(BlockFurnace.FACING);
+
+            if (enumdirection == EnumDirection.NORTH && block.o() && !block1.o()) {
+                enumdirection = EnumDirection.SOUTH;
+            } else if (enumdirection == EnumDirection.SOUTH && block1.o() && !block.o()) {
+                enumdirection = EnumDirection.NORTH;
+            } else if (enumdirection == EnumDirection.WEST && block2.o() && !block3.o()) {
+                enumdirection = EnumDirection.EAST;
+            } else if (enumdirection == EnumDirection.EAST && block3.o() && !block2.o()) {
+                enumdirection = EnumDirection.WEST;
+            }
+
+            world.setTypeAndData(blockposition, iblockdata.set(BlockFurnace.FACING, enumdirection), 2);
+        }
+    }
+
+    public boolean interact(World world, BlockPosition blockposition, IBlockData iblockdata, EntityHuman entityhuman, EnumDirection enumdirection, float f, float f1, float f2) {
+        if (world.isClientSide) {
+            return true;
+        } else {
+            TileEntity tileentity = world.getTileEntity(blockposition);
+
+            if (tileentity instanceof TileEntityFurnace) {
+                entityhuman.openContainer((TileEntityFurnace) tileentity);
+                entityhuman.b(StatisticList.Y);
+            }
+
+            return true;
+        }
+    }
+
+    public static void a(boolean flag, World world, BlockPosition blockposition) {
+        IBlockData iblockdata = world.getType(blockposition);
+        TileEntity tileentity = world.getTileEntity(blockposition);
+        
+        BlockFurnace.N = true;
+        
+        if (flag) {
+            world.setTypeAndData(blockposition, Blocks.LIT_FURNACE.getBlockData().set(BlockFurnace.FACING, iblockdata.get(BlockFurnace.FACING)), 3);
+            world.setTypeAndData(blockposition, Blocks.LIT_FURNACE.getBlockData().set(BlockFurnace.FACING, iblockdata.get(BlockFurnace.FACING)), 3);
+        } else {
+            world.setTypeAndData(blockposition, Blocks.FURNACE.getBlockData().set(BlockFurnace.FACING, iblockdata.get(BlockFurnace.FACING)), 3);
+            world.setTypeAndData(blockposition, Blocks.FURNACE.getBlockData().set(BlockFurnace.FACING, iblockdata.get(BlockFurnace.FACING)), 3);
+        }
+        
+        BlockFurnace.N = false;
+        
+        if (tileentity != null) {
+            tileentity.D();
+            world.setTileEntity(blockposition, tileentity);
+        }
+
+    }
+
+    public TileEntity a(World world, int i) {
+        return new TileEntityFurnace();
+    }
+
+    public IBlockData getPlacedState(World world, BlockPosition blockposition, EnumDirection enumdirection, float f, float f1, float f2, int i, EntityLiving entityliving) {
+        return this.getBlockData().set(BlockFurnace.FACING, entityliving.getDirection().opposite());
+    }
+
+    public void postPlace(World world, BlockPosition blockposition, IBlockData iblockdata, EntityLiving entityliving, ItemStack itemstack) {
+        world.setTypeAndData(blockposition, iblockdata.set(BlockFurnace.FACING, entityliving.getDirection().opposite()), 2);
+        if (itemstack.hasName()) {
+            TileEntity tileentity = world.getTileEntity(blockposition);
+
+            if (tileentity instanceof TileEntityFurnace) {
+                ((TileEntityFurnace) tileentity).a(itemstack.getName());
+            }
+        }
+
+    }
+
+    public void remove(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        if (!BlockFurnace.N) {
+            TileEntity tileentity = world.getTileEntity(blockposition);
+
+            if (tileentity instanceof TileEntityFurnace) {
+                InventoryUtils.dropInventory(world, blockposition, (TileEntityFurnace) tileentity);
+                world.updateAdjacentComparators(blockposition, this);
+            }
+        }
+
+        super.remove(world, blockposition, iblockdata);
+    }
+
+    public boolean isComplexRedstone() {
+        return true;
+    }
+
+    public int l(World world, BlockPosition blockposition) {
+        return Container.a(world.getTileEntity(blockposition));
+    }
+
+    public int b() {
+        return 3;
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        EnumDirection enumdirection = EnumDirection.fromType1(i);
+
+        if (enumdirection.k() == EnumDirection.EnumAxis.Y) {
+            enumdirection = EnumDirection.NORTH;
+        }
+
+        return this.getBlockData().set(BlockFurnace.FACING, enumdirection);
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        return ((EnumDirection) iblockdata.get(BlockFurnace.FACING)).a();
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockFurnace.FACING});
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java src/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java
--- src_origin/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java	2016-02-26 15:27:07.267203267 +0800
+++ src/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java	2016-03-16 23:43:29.104124843 +0800
@@ -3,6 +3,7 @@
 import com.google.common.collect.Lists;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 public abstract class BlockMinecartTrackAbstract extends Block {
 
@@ -247,7 +248,8 @@
         private final BlockMinecartTrackAbstract d;
         private IBlockData e;
         private final boolean f;
-        private final List<BlockPosition> g = Lists.newArrayList();
+        //private final List<BlockPosition> g = Lists.newArrayList();
+        private final List<BlockPosition> g = Lists.newCopyOnWriteArrayList();
 
         public MinecartTrackLogic(World world, BlockPosition blockposition, IBlockData iblockdata) {
             this.b = world;
diff -Naur src_origin/main/java/net/minecraft/server/BlockPiston.java src/main/java/net/minecraft/server/BlockPiston.java
--- src_origin/main/java/net/minecraft/server/BlockPiston.java	2016-02-26 15:27:07.429203282 +0800
+++ src/main/java/net/minecraft/server/BlockPiston.java	2016-03-16 23:43:29.133124843 +0800
@@ -4,11 +4,9 @@
 
 // CraftBukkit start
 import java.util.AbstractList;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.ListIterator;
 
 import com.google.common.collect.ImmutableList;
+import java.util.concurrent.CopyOnWriteArrayList;
 import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.event.block.BlockPistonRetractEvent;
 import org.bukkit.event.block.BlockPistonExtendEvent;
@@ -72,6 +70,7 @@
             if (!this.sticky) {
                 org.bukkit.block.Block block = world.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ());
                 BlockPistonRetractEvent event = new BlockPistonRetractEvent(block, ImmutableList.<org.bukkit.block.Block>of(), CraftBlock.notchToBlockFace(enumdirection));
+                event.setAsynchronous();
                 world.getServer().getPluginManager().callEvent(event);
 
                 if (event.isCancelled()) {
@@ -314,7 +313,9 @@
 
             final List<BlockPosition> moved = pistonextendschecker.getMovedBlocks();
             final List<BlockPosition> broken = pistonextendschecker.getBrokenBlocks();
-
+            /*final CopyOnWriteArrayList<BlockPosition> moved = pistonextendschecker.getMovedBlocks();
+            final CopyOnWriteArrayList<BlockPosition> broken = pistonextendschecker.getBrokenBlocks();*/
+            
             List<org.bukkit.block.Block> blocks = new AbstractList<org.bukkit.block.Block>() {
 
                 @Override
diff -Naur src_origin/main/java/net/minecraft/server/BlockPressurePlateAbstract.java src/main/java/net/minecraft/server/BlockPressurePlateAbstract.java
--- src_origin/main/java/net/minecraft/server/BlockPressurePlateAbstract.java	2016-02-26 15:27:07.523203291 +0800
+++ src/main/java/net/minecraft/server/BlockPressurePlateAbstract.java	2016-03-16 23:43:29.150124843 +0800
@@ -3,6 +3,7 @@
 import java.util.Random;
 
 import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
+import org.spigotmc.SpigotWorldConfig;
 
 public abstract class BlockPressurePlateAbstract extends Block {
 
@@ -76,6 +77,8 @@
 
     public void b(World world, BlockPosition blockposition, IBlockData iblockdata, Random random) {
         if (!world.isClientSide) {
+            //remove from list
+            SpigotWorldConfig.BlockＮextＴick_list.remove(iblockdata.hashCode());
             int i = this.e(iblockdata);
 
             if (i > 0) {
diff -Naur src_origin/main/java/net/minecraft/server/BlockRedstoneTorch.java src/main/java/net/minecraft/server/BlockRedstoneTorch.java
--- src_origin/main/java/net/minecraft/server/BlockRedstoneTorch.java	2016-02-26 15:27:07.667203304 +0800
+++ src/main/java/net/minecraft/server/BlockRedstoneTorch.java	2016-03-16 23:43:29.178124843 +0800
@@ -1,7 +1,6 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
@@ -15,7 +14,8 @@
 
     private boolean a(World world, BlockPosition blockposition, boolean flag) {
         if (!BlockRedstoneTorch.b.containsKey(world)) {
-            BlockRedstoneTorch.b.put(world, Lists.<BlockRedstoneTorch.RedstoneUpdateInfo>newArrayList()); // CraftBukkit - fix decompile error
+            //BlockRedstoneTorch.b.put(world, Lists.<BlockRedstoneTorch.RedstoneUpdateInfo>newArrayList()); // CraftBukkit - fix decompile error
+            BlockRedstoneTorch.b.put(world, Lists.<BlockRedstoneTorch.RedstoneUpdateInfo>newCopyOnWriteArrayList()); // CraftBukkit - fix decompile error
         }
 
         List list = (List) BlockRedstoneTorch.b.get(world);
diff -Naur src_origin/main/java/net/minecraft/server/BlockRedstoneWire.java src/main/java/net/minecraft/server/BlockRedstoneWire.java
--- src_origin/main/java/net/minecraft/server/BlockRedstoneWire.java	2016-02-26 15:27:07.697203307 +0800
+++ src/main/java/net/minecraft/server/BlockRedstoneWire.java	2016-03-16 23:43:29.184124843 +0800
@@ -1,14 +1,15 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
-import java.util.ArrayList;
 import java.util.EnumSet;
 import java.util.Iterator;
+import java.util.Queue;
 import java.util.Random;
 import java.util.Set;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArraySet;
 
 import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
+import org.spigotmc.SpigotWorldConfig;
 
 public class BlockRedstoneWire extends Block {
 
@@ -18,7 +19,8 @@
     public static final BlockStateEnum<BlockRedstoneWire.EnumRedstoneWireConnection> WEST = BlockStateEnum.of("west", BlockRedstoneWire.EnumRedstoneWireConnection.class);
     public static final BlockStateInteger POWER = BlockStateInteger.of("power", 0, 15);
     private boolean Q = true;
-    private final Set<BlockPosition> R = Sets.newHashSet();
+    //private final Set<BlockPosition> R = Sets.newHashSet();
+    private final Set<BlockPosition> R = new CopyOnWriteArraySet();
 
     public BlockRedstoneWire() {
         super(Material.ORIENTABLE);
@@ -64,15 +66,17 @@
     }
 
     private IBlockData e(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        SpigotWorldConfig.BlockＮextＴick_list.remove(iblockdata.hashCode());
         iblockdata = this.a(world, blockposition, blockposition, iblockdata);
-        ArrayList arraylist = Lists.newArrayList(this.R);
+        //ArrayList arraylist = Lists.newArrayList(this.R);
+        
+        Queue arraylist = new ConcurrentLinkedQueue(this.R);
 
         this.R.clear();
         Iterator iterator = arraylist.iterator();
 
         while (iterator.hasNext()) {
             BlockPosition blockposition1 = (BlockPosition) iterator.next();
-
             world.applyPhysics(blockposition1, this);
         }
 
diff -Naur src_origin/main/java/net/minecraft/server/BlockSapling.java src/main/java/net/minecraft/server/BlockSapling.java
--- src_origin/main/java/net/minecraft/server/BlockSapling.java	2016-02-26 15:27:07.744203311 +0800
+++ src/main/java/net/minecraft/server/BlockSapling.java	2016-03-16 23:43:29.195124843 +0800
@@ -4,6 +4,9 @@
 
 // CraftBukkit start
 import java.util.List;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 import org.bukkit.Location;
 import org.bukkit.TreeType;
@@ -39,11 +42,14 @@
                 this.grow(world, blockposition, iblockdata, random);
                 // CraftBukkit start
                 world.captureTreeGeneration = false;
-                if (world.capturedBlockStates.size() > 0) {
+                //if (world.capturedBlockStates.size() > 0) {
+                if (!world.capturedBlockStates.isEmpty()) {
                     TreeType treeType = BlockSapling.treeType;
                     BlockSapling.treeType = null;
                     Location location = new Location(world.getWorld(), blockposition.getX(), blockposition.getY(), blockposition.getZ());
-                    List<BlockState> blocks = (List<BlockState>) world.capturedBlockStates.clone();
+                    //List<BlockState> blocks = (List<BlockState>) world.capturedBlockStates.clone();
+                    Queue<BlockState> blocks = new ConcurrentLinkedQueue<BlockState>();
+                    blocks.addAll((Queue<BlockState>) world.capturedBlockStates);
                     world.capturedBlockStates.clear();
                     StructureGrowEvent event = null;
                     if (treeType != null) {
diff -Naur src_origin/main/java/net/minecraft/server/BlockTripwire.java src/main/java/net/minecraft/server/BlockTripwire.java
--- src_origin/main/java/net/minecraft/server/BlockTripwire.java	2016-02-26 15:27:07.936203329 +0800
+++ src/main/java/net/minecraft/server/BlockTripwire.java	2016-03-16 23:43:29.227124843 +0800
@@ -5,6 +5,7 @@
 import java.util.Random;
 
 import org.bukkit.event.entity.EntityInteractEvent; // CraftBukkit
+import org.spigotmc.SpigotWorldConfig;
 
 public class BlockTripwire extends Block {
 
@@ -133,6 +134,8 @@
     public void b(World world, BlockPosition blockposition, IBlockData iblockdata, Random random) {
         if (!world.isClientSide) {
             if (((Boolean) world.getType(blockposition).get(BlockTripwire.POWERED)).booleanValue()) {
+                //remove from list
+                SpigotWorldConfig.BlockＮextＴick_list.remove(iblockdata.hashCode());
                 this.e(world, blockposition);
             }
         }
diff -Naur src_origin/main/java/net/minecraft/server/ChatBaseComponent.java src/main/java/net/minecraft/server/ChatBaseComponent.java
--- src_origin/main/java/net/minecraft/server/ChatBaseComponent.java	2016-02-26 15:27:08.023203337 +0800
+++ src/main/java/net/minecraft/server/ChatBaseComponent.java	2016-03-16 23:43:29.249124843 +0800
@@ -8,7 +8,8 @@
 
 public abstract class ChatBaseComponent implements IChatBaseComponent {
 
-    protected List<IChatBaseComponent> a = Lists.newArrayList();
+    //protected List<IChatBaseComponent> a = Lists.newArrayList();
+    protected List<IChatBaseComponent> a = Lists.newCopyOnWriteArrayList();
     private ChatModifier b;
 
     public ChatBaseComponent() {}
diff -Naur src_origin/main/java/net/minecraft/server/Chunk.java src/main/java/net/minecraft/server/Chunk.java
--- src_origin/main/java/net/minecraft/server/Chunk.java	2016-02-26 15:27:08.084203343 +0800
+++ src/main/java/net/minecraft/server/Chunk.java	2016-03-16 23:43:29.267124843 +0800
@@ -1,13 +1,11 @@
 package net.minecraft.server;
 
 import com.google.common.base.Predicate;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
 import java.util.Random;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentLinkedQueue;
@@ -15,7 +13,11 @@
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists; // CraftBukkit
+import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentHashMap;
 import org.bukkit.Bukkit; // CraftBukkit
+import org.spigotmc.SpigotWorldConfig;
 
 public class Chunk {
 
@@ -30,8 +32,11 @@
     public final int locX;
     public final int locZ;
     private boolean k;
+    //cause tiles not functional
     public final Map<BlockPosition, TileEntity> tileEntities;
-    public final List<Entity>[] entitySlices; // Spigot
+    //public final ConcurrentMap<BlockPosition, TileEntity> tileEntities;
+    //public final List<Entity>[] entitySlices; // Spigot
+    public final Queue<Entity>[] entitySlices; // Spigot
     private boolean done;
     private boolean lit;
     private boolean p;
@@ -77,17 +82,20 @@
         this.e = new byte[256];
         this.f = new int[256];
         this.g = new boolean[256];
-        this.tileEntities = Maps.newHashMap();
+        //this.tileEntities = Maps.newHashMap();
+        this.tileEntities = new ConcurrentHashMap<BlockPosition, TileEntity>();
         this.v = 4096;
         this.w = Queues.newConcurrentLinkedQueue();
-        this.entitySlices = (List[]) (new List[16]); // Spigot
+        //this.entitySlices = (List[]) (new List[16]); // Spigot
+        this.entitySlices = (Queue[]) (new ConcurrentLinkedQueue[16]); // Spigot
         this.world = world;
         this.locX = i;
         this.locZ = j;
         this.heightMap = new int[256];
 
         for (int k = 0; k < this.entitySlices.length; ++k) {
-            this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            //this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[k] = new ConcurrentLinkedQueue(); // Spigot
         }
 
         Arrays.fill(this.f, -999);
@@ -846,10 +854,12 @@
 
         for (int i = 0; i < this.entitySlices.length; ++i) {
             // CraftBukkit start
-            List<Entity> newList = Lists.newArrayList(this.entitySlices[i]);
+            //List<Entity> newList = Lists.newArrayList(this.entitySlices[i]);
+            Queue<Entity> newList = new ConcurrentLinkedQueue<Entity>(this.entitySlices[i]);
             java.util.Iterator<Entity> iter = newList.iterator();
             while (iter.hasNext()) {
                 Entity entity = iter.next();
+                SpigotWorldConfig.Collision_list.remove(this.int_hash(entity.getId()));
                 // Spigot Start
                 if ( entity instanceof IInventory )
                 {
@@ -875,12 +885,18 @@
         }
 
     }
+    
+    private int int_hash(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
 
     public void e() {
         this.q = true;
     }
 
-    public void a(Entity entity, AxisAlignedBB axisalignedbb, List<Entity> list, Predicate<? super Entity> predicate) {
+    //public void a(Entity entity, AxisAlignedBB axisalignedbb, List<Entity> list, Predicate<? super Entity> predicate) {
+    public void a(Entity entity, AxisAlignedBB axisalignedbb, Queue<Entity> list, Predicate<? super Entity> predicate) {
         int i = MathHelper.floor((axisalignedbb.b - 2.0D) / 16.0D);
         int j = MathHelper.floor((axisalignedbb.e + 2.0D) / 16.0D);
 
@@ -916,7 +932,8 @@
 
     }
 
-    public <T extends Entity> void a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb, List<T> list, Predicate<? super T> predicate) {
+    //public <T extends Entity> void a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb, List<T> list, Predicate<? super T> predicate) {
+    public <T extends Entity> void a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb, Queue<T> list, Predicate<? super T> predicate) {
         int i = MathHelper.floor((axisalignedbb.b - 2.0D) / 16.0D);
         int j = MathHelper.floor((axisalignedbb.e + 2.0D) / 16.0D);
 
@@ -956,7 +973,7 @@
     public boolean isEmpty() {
         return false;
     }
-
+    
     public void loadNearby(IChunkProvider ichunkprovider, IChunkProvider ichunkprovider1, int i, int j) {
         world.timings.syncChunkLoadPostTimer.startTiming(); // Spigot
         boolean flag = ichunkprovider.isChunkLoaded(i, j - 1);
@@ -1306,10 +1323,12 @@
     }
 
     public Map<BlockPosition, TileEntity> getTileEntities() {
+    //public ConcurrentMap<BlockPosition, TileEntity> getTileEntities() {
         return this.tileEntities;
     }
 
-    public List<Entity>[] getEntitySlices() {
+    public Queue<Entity>[] getEntitySlices() {
+    //public List<Entity>[] getEntitySlices() {
         return this.entitySlices;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderGenerate.java src/main/java/net/minecraft/server/ChunkProviderGenerate.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderGenerate.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderGenerate.java	2016-03-16 23:43:29.253124843 +0800
@@ -0,0 +1,584 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.FutureTask;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.hose.GetChunkATPool;
+import org.hose.GetCreateChunkPool;
+import org.spigotmc.SpigotWorldConfig;
+
+public class ChunkProviderGenerate implements IChunkProvider {
+
+    private Random h;
+    private NoiseGeneratorOctaves i;
+    private NoiseGeneratorOctaves j;
+    private NoiseGeneratorOctaves k;
+    private NoiseGenerator3 l;
+    public NoiseGeneratorOctaves a;
+    public NoiseGeneratorOctaves b;
+    public NoiseGeneratorOctaves c;
+    private World m;
+    private final boolean n;
+    private WorldType o;
+    private final double[] p;
+    private final float[] q;
+    private CustomWorldSettingsFinal r;
+    private Block s;
+    private double[] t;
+    private WorldGenBase u;
+    private WorldGenStronghold v;
+    private WorldGenVillage w;
+    private WorldGenMineshaft x;
+    private WorldGenLargeFeature y;
+    private WorldGenBase z;
+    private WorldGenMonument A;
+    private BiomeBase[] B;
+    double[] d;
+    double[] e;
+    double[] f;
+    double[] g;
+
+    public ChunkProviderGenerate(World world, long i, boolean flag, String s) {
+        this.s = Blocks.WATER;
+        this.t = new double[256];
+        this.u = new WorldGenCaves();
+        this.v = new WorldGenStronghold();
+        this.w = new WorldGenVillage();
+        this.x = new WorldGenMineshaft();
+        this.y = new WorldGenLargeFeature();
+        this.z = new WorldGenCanyon();
+        this.A = new WorldGenMonument();
+        this.m = world;
+        this.n = flag;
+        this.o = world.getWorldData().getType();
+        this.h = new Random(i);
+        this.i = new NoiseGeneratorOctaves(this.h, 16);
+        this.j = new NoiseGeneratorOctaves(this.h, 16);
+        this.k = new NoiseGeneratorOctaves(this.h, 8);
+        this.l = new NoiseGenerator3(this.h, 4);
+        this.a = new NoiseGeneratorOctaves(this.h, 10);
+        this.b = new NoiseGeneratorOctaves(this.h, 16);
+        this.c = new NoiseGeneratorOctaves(this.h, 8);
+        this.p = new double[825];
+        this.q = new float[25];
+
+        for (int j = -2; j <= 2; ++j) {
+            for (int k = -2; k <= 2; ++k) {
+                float f = 10.0F / MathHelper.c((float) (j * j + k * k) + 0.2F);
+
+                this.q[j + 2 + (k + 2) * 5] = f;
+            }
+        }
+
+        if (s != null) {
+            this.r = CustomWorldSettingsFinal.CustomWorldSettings.a(s).b();
+            this.s = this.r.E ? Blocks.LAVA : Blocks.WATER;
+            world.b(this.r.q);
+        }
+
+    }
+
+    public void a(int i, int j, ChunkSnapshot chunksnapshot) {
+        this.B = this.m.getWorldChunkManager().getBiomes(this.B, i * 4 - 2, j * 4 - 2, 10, 10);
+        this.a(i * 4, 0, j * 4);
+
+        for (int k = 0; k < 4; ++k) {
+            int l = k * 5;
+            int i1 = (k + 1) * 5;
+
+            for (int j1 = 0; j1 < 4; ++j1) {
+                int k1 = (l + j1) * 33;
+                int l1 = (l + j1 + 1) * 33;
+                int i2 = (i1 + j1) * 33;
+                int j2 = (i1 + j1 + 1) * 33;
+
+                for (int k2 = 0; k2 < 32; ++k2) {
+                    double d0 = 0.125D;
+                    double d1 = this.p[k1 + k2];
+                    double d2 = this.p[l1 + k2];
+                    double d3 = this.p[i2 + k2];
+                    double d4 = this.p[j2 + k2];
+                    double d5 = (this.p[k1 + k2 + 1] - d1) * d0;
+                    double d6 = (this.p[l1 + k2 + 1] - d2) * d0;
+                    double d7 = (this.p[i2 + k2 + 1] - d3) * d0;
+                    double d8 = (this.p[j2 + k2 + 1] - d4) * d0;
+
+                    for (int l2 = 0; l2 < 8; ++l2) {
+                        double d9 = 0.25D;
+                        double d10 = d1;
+                        double d11 = d2;
+                        double d12 = (d3 - d1) * d9;
+                        double d13 = (d4 - d2) * d9;
+
+                        for (int i3 = 0; i3 < 4; ++i3) {
+                            double d14 = 0.25D;
+                            double d15 = (d11 - d10) * d14;
+                            double d16 = d10 - d15;
+
+                            for (int j3 = 0; j3 < 4; ++j3) {
+                                if ((d16 += d15) > 0.0D) {
+                                    chunksnapshot.a(k * 4 + i3, k2 * 8 + l2, j1 * 4 + j3, Blocks.STONE.getBlockData());
+                                } else if (k2 * 8 + l2 < this.r.q) {
+                                    chunksnapshot.a(k * 4 + i3, k2 * 8 + l2, j1 * 4 + j3, this.s.getBlockData());
+                                }
+                            }
+
+                            d10 += d12;
+                            d11 += d13;
+                        }
+
+                        d1 += d5;
+                        d2 += d6;
+                        d3 += d7;
+                        d4 += d8;
+                    }
+                }
+            }
+        }
+
+    }
+
+    public void a(int i, int j, ChunkSnapshot chunksnapshot, BiomeBase[] abiomebase) {
+        double d0 = 0.03125D;
+        Random h_hose = this.h;
+        this.t = this.l.a(this.t, (double) (i * 16), (double) (j * 16), 16, 16, d0 * 2.0D, d0 * 2.0D, 1.0D);
+
+        for (int k = 0; k < 16; ++k) {
+            for (int l = 0; l < 16; ++l) {
+                BiomeBase biomebase = abiomebase[l + k * 16];
+
+                //biomebase.a(this.m, this.h, chunksnapshot, i * 16 + k, j * 16 + l, this.t[l + k * 16]);
+                biomebase.a(this.m, h_hose, chunksnapshot, i * 16 + k, j * 16 + l, this.t[l + k * 16]);
+            }
+        }
+
+    }
+    
+    public Chunk getOrCreateChunk(int i, int j) {
+        //return getOrCreateChunk_hose(i, j);
+        SpigotWorldConfig.GetCreateChunkTask = new FutureTask(new GetCreateChunkPool(this, i, j));
+        SpigotWorldConfig.getcreatechunkatpool_executor.submit(SpigotWorldConfig.GetCreateChunkTask);
+        try {
+            return SpigotWorldConfig.GetCreateChunkTask.get();
+        } catch (InterruptedException ex) {
+            Logger.getLogger(ChunkProviderGenerate.class.getName()).log(Level.SEVERE, null, ex);
+        } catch (ExecutionException ex) {
+            Logger.getLogger(ChunkProviderGenerate.class.getName()).log(Level.SEVERE, null, ex);
+        }
+        return null;
+    }
+    
+    //try to prevent "Biome ID is out of bounds" issues
+    public Chunk getOrCreateChunk_hose(int i, int j) {
+        Random h_hose = this.h;
+        //this.h.setSeed((long) i * 341873128712L + (long) j * 132897987541L);
+        h_hose.setSeed((long) i * 341873128712L + (long) j * 132897987541L);
+        ChunkSnapshot chunksnapshot = new ChunkSnapshot();
+
+        this.a(i, j, chunksnapshot);
+        this.B = this.m.getWorldChunkManager().getBiomeBlock(this.B, i * 16, j * 16, 16, 16);
+        this.a(i, j, chunksnapshot, this.B);
+        if (this.r.r) {
+            this.u.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.z) {
+            this.z.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.w && this.n) {
+            this.x.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.v && this.n) {
+            this.w.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.u && this.n) {
+            this.v.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.x && this.n) {
+            this.y.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.y && this.n) {
+            this.A.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        Chunk chunk = new Chunk(this.m, chunksnapshot, i, j);
+        byte[] abyte = chunk.getBiomeIndex();
+
+        for (int k = 0; k < abyte.length; ++k) {
+            abyte[k] = (byte) this.B[k].id;
+        }
+
+        chunk.initLighting();
+        return chunk;
+    }
+
+    private void a(int i, int j, int k) {
+        this.g = this.b.a(this.g, i, k, 5, 5, (double) this.r.e, (double) this.r.f, (double) this.r.g);
+        float f = this.r.a;
+        float f1 = this.r.b;
+
+        this.d = this.k.a(this.d, i, j, k, 5, 33, 5, (double) (f / this.r.h), (double) (f1 / this.r.i), (double) (f / this.r.j));
+        this.e = this.i.a(this.e, i, j, k, 5, 33, 5, (double) f, (double) f1, (double) f);
+        this.f = this.j.a(this.f, i, j, k, 5, 33, 5, (double) f, (double) f1, (double) f);
+        boolean flag = false;
+        boolean flag1 = false;
+        int l = 0;
+        int i1 = 0;
+
+        for (int j1 = 0; j1 < 5; ++j1) {
+            for (int k1 = 0; k1 < 5; ++k1) {
+                float f2 = 0.0F;
+                float f3 = 0.0F;
+                float f4 = 0.0F;
+                byte b0 = 2;
+                BiomeBase biomebase = this.B[j1 + 2 + (k1 + 2) * 10];
+
+                for (int l1 = -b0; l1 <= b0; ++l1) {
+                    for (int i2 = -b0; i2 <= b0; ++i2) {
+                        BiomeBase biomebase1 = this.B[j1 + l1 + 2 + (k1 + i2 + 2) * 10];
+                        float f5 = this.r.n + biomebase1.an * this.r.m;
+                        float f6 = this.r.p + biomebase1.ao * this.r.o;
+
+                        if (this.o == WorldType.AMPLIFIED && f5 > 0.0F) {
+                            f5 = 1.0F + f5 * 2.0F;
+                            f6 = 1.0F + f6 * 4.0F;
+                        }
+
+                        float f7 = this.q[l1 + 2 + (i2 + 2) * 5] / (f5 + 2.0F);
+
+                        if (biomebase1.an > biomebase.an) {
+                            f7 /= 2.0F;
+                        }
+
+                        f2 += f6 * f7;
+                        f3 += f5 * f7;
+                        f4 += f7;
+                    }
+                }
+
+                f2 /= f4;
+                f3 /= f4;
+                f2 = f2 * 0.9F + 0.1F;
+                f3 = (f3 * 4.0F - 1.0F) / 8.0F;
+                double d0 = this.g[i1] / 8000.0D;
+
+                if (d0 < 0.0D) {
+                    d0 = -d0 * 0.3D;
+                }
+
+                d0 = d0 * 3.0D - 2.0D;
+                if (d0 < 0.0D) {
+                    d0 /= 2.0D;
+                    if (d0 < -1.0D) {
+                        d0 = -1.0D;
+                    }
+
+                    d0 /= 1.4D;
+                    d0 /= 2.0D;
+                } else {
+                    if (d0 > 1.0D) {
+                        d0 = 1.0D;
+                    }
+
+                    d0 /= 8.0D;
+                }
+
+                ++i1;
+                double d1 = (double) f3;
+                double d2 = (double) f2;
+
+                d1 += d0 * 0.2D;
+                d1 = d1 * (double) this.r.k / 8.0D;
+                double d3 = (double) this.r.k + d1 * 4.0D;
+
+                for (int j2 = 0; j2 < 33; ++j2) {
+                    double d4 = ((double) j2 - d3) * (double) this.r.l * 128.0D / 256.0D / d2;
+
+                    if (d4 < 0.0D) {
+                        d4 *= 4.0D;
+                    }
+
+                    double d5 = this.e[l] / (double) this.r.d;
+                    double d6 = this.f[l] / (double) this.r.c;
+                    double d7 = (this.d[l] / 10.0D + 1.0D) / 2.0D;
+                    double d8 = MathHelper.b(d5, d6, d7) - d4;
+
+                    if (j2 > 29) {
+                        double d9 = (double) ((float) (j2 - 29) / 3.0F);
+
+                        d8 = d8 * (1.0D - d9) + -10.0D * d9;
+                    }
+
+                    this.p[l] = d8;
+                    ++l;
+                }
+            }
+        }
+
+    }
+
+    public boolean isChunkLoaded(int i, int j) {
+        return true;
+    }
+   
+    public void getChunkAt(IChunkProvider ichunkprovider, int i, int j) {
+        //getChunkAt_hose(ichunkprovider, i, j);
+        SpigotWorldConfig.GetChunkATTask = new FutureTask(new GetChunkATPool(this, ichunkprovider, i, j));
+        SpigotWorldConfig.getchunkatpool_executor.submit(SpigotWorldConfig.GetChunkATTask);
+    }
+    
+    public void getChunkAt_hose(IChunkProvider ichunkprovider, int i, int j) {
+        BlockFalling.instaFall = true;
+        int k = i * 16;
+        int l = j * 16;
+        BlockPosition blockposition = new BlockPosition(k, 0, l);
+        BiomeBase biomebase = this.m.getBiome(blockposition.a(16, 0, 16));
+
+        Random h_hose = this.h;
+        h_hose.setSeed(this.m.getSeed());
+        
+        long i1 = h_hose.nextLong() / 2L * 2L + 1L;
+        long j1 = h_hose.nextLong() / 2L * 2L + 1L;
+
+        h_hose.setSeed((long) i * i1 + (long) j * j1 ^ this.m.getSeed());
+        boolean flag = false;
+        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
+
+        if (this.r.w && this.n) {
+            this.x.a(this.m, h_hose, chunkcoordintpair);
+        }
+
+        if (this.r.v && this.n) {
+            flag = this.w.a(this.m, h_hose, chunkcoordintpair);
+        }
+
+        if (this.r.u && this.n) {
+            this.v.a(this.m, h_hose, chunkcoordintpair);
+        }
+
+        if (this.r.x && this.n) {
+            this.y.a(this.m, h_hose, chunkcoordintpair);
+        }
+
+        if (this.r.y && this.n) {
+            this.A.a(this.m, h_hose, chunkcoordintpair);
+        }
+
+        int k1;
+        int l1;
+        int i2;
+
+        if (biomebase != BiomeBase.DESERT && biomebase != BiomeBase.DESERT_HILLS && this.r.A && !flag && h_hose.nextInt(this.r.B) == 0) {
+            k1 = h_hose.nextInt(16) + 8;
+            l1 = h_hose.nextInt(256);
+            i2 = h_hose.nextInt(16) + 8;
+            (new WorldGenLakes(Blocks.WATER)).generate(this.m, h_hose, blockposition.a(k1, l1, i2));
+        }
+
+        if (!flag && h_hose.nextInt(this.r.D / 10) == 0 && this.r.C) {
+            k1 = h_hose.nextInt(16) + 8;
+            l1 = h_hose.nextInt(h_hose.nextInt(248) + 8);
+            i2 = h_hose.nextInt(16) + 8;
+            if (l1 < this.m.F() || h_hose.nextInt(this.r.D / 8) == 0) {
+                (new WorldGenLakes(Blocks.LAVA)).generate(this.m, h_hose, blockposition.a(k1, l1, i2));
+            }
+        }
+
+        if (this.r.s) {
+            for (k1 = 0; k1 < this.r.t; ++k1) {
+                l1 = h_hose.nextInt(16) + 8;
+                i2 = h_hose.nextInt(256);
+                int j2 = h_hose.nextInt(16) + 8;
+
+                (new WorldGenDungeons()).generate(this.m, h_hose, blockposition.a(l1, i2, j2));
+            }
+        }
+
+        biomebase.a(this.m, h_hose, new BlockPosition(k, 0, l));
+        SpawnerCreature.a(this.m, biomebase, k + 8, l + 8, 16, 16, h_hose);
+        blockposition = blockposition.a(8, 0, 8);
+
+        for (k1 = 0; k1 < 16; ++k1) {
+            for (l1 = 0; l1 < 16; ++l1) {
+                BlockPosition blockposition1 = this.m.q(blockposition.a(k1, 0, l1));
+                BlockPosition blockposition2 = blockposition1.down();
+
+                if (this.m.v(blockposition2)) {
+                    this.m.setTypeAndData(blockposition2, Blocks.ICE.getBlockData(), 2);
+                }
+
+                if (this.m.f(blockposition1, true)) {
+                    this.m.setTypeAndData(blockposition1, Blocks.SNOW_LAYER.getBlockData(), 2);
+                }
+            }
+        }
+
+        BlockFalling.instaFall = false;
+        /*
+        this.h.setSeed(this.m.getSeed());
+        long i1 = this.h.nextLong() / 2L * 2L + 1L;
+        long j1 = this.h.nextLong() / 2L * 2L + 1L;
+
+        this.h.setSeed((long) i * i1 + (long) j * j1 ^ this.m.getSeed());
+        boolean flag = false;
+        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
+
+        if (this.r.w && this.n) {
+            this.x.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        if (this.r.v && this.n) {
+            flag = this.w.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        if (this.r.u && this.n) {
+            this.v.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        if (this.r.x && this.n) {
+            this.y.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        if (this.r.y && this.n) {
+            this.A.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        int k1;
+        int l1;
+        int i2;
+
+        if (biomebase != BiomeBase.DESERT && biomebase != BiomeBase.DESERT_HILLS && this.r.A && !flag && this.h.nextInt(this.r.B) == 0) {
+            k1 = this.h.nextInt(16) + 8;
+            l1 = this.h.nextInt(256);
+            i2 = this.h.nextInt(16) + 8;
+            (new WorldGenLakes(Blocks.WATER)).generate(this.m, this.h, blockposition.a(k1, l1, i2));
+        }
+
+        if (!flag && this.h.nextInt(this.r.D / 10) == 0 && this.r.C) {
+            k1 = this.h.nextInt(16) + 8;
+            l1 = this.h.nextInt(this.h.nextInt(248) + 8);
+            i2 = this.h.nextInt(16) + 8;
+            if (l1 < this.m.F() || this.h.nextInt(this.r.D / 8) == 0) {
+                (new WorldGenLakes(Blocks.LAVA)).generate(this.m, this.h, blockposition.a(k1, l1, i2));
+            }
+        }
+
+        if (this.r.s) {
+            for (k1 = 0; k1 < this.r.t; ++k1) {
+                l1 = this.h.nextInt(16) + 8;
+                i2 = this.h.nextInt(256);
+                int j2 = this.h.nextInt(16) + 8;
+
+                (new WorldGenDungeons()).generate(this.m, this.h, blockposition.a(l1, i2, j2));
+            }
+        }
+
+        biomebase.a(this.m, this.h, new BlockPosition(k, 0, l));
+        SpawnerCreature.a(this.m, biomebase, k + 8, l + 8, 16, 16, this.h);
+        blockposition = blockposition.a(8, 0, 8);
+
+        for (k1 = 0; k1 < 16; ++k1) {
+            for (l1 = 0; l1 < 16; ++l1) {
+                BlockPosition blockposition1 = this.m.q(blockposition.a(k1, 0, l1));
+                BlockPosition blockposition2 = blockposition1.down();
+
+                if (this.m.v(blockposition2)) {
+                    this.m.setTypeAndData(blockposition2, Blocks.ICE.getBlockData(), 2);
+                }
+
+                if (this.m.f(blockposition1, true)) {
+                    this.m.setTypeAndData(blockposition1, Blocks.SNOW_LAYER.getBlockData(), 2);
+                }
+            }
+        }
+
+        BlockFalling.instaFall = false;*/
+    }
+
+    public boolean a(IChunkProvider ichunkprovider, Chunk chunk, int i, int j) {
+        boolean flag = false;
+
+        if (this.r.y && this.n && chunk.w() < 3600L) {
+            flag |= this.A.a(this.m, this.h, new ChunkCoordIntPair(i, j));
+        }
+
+        return flag;
+    }
+
+    public boolean saveChunks(boolean flag, IProgressUpdate iprogressupdate) {
+        return true;
+    }
+
+    public void c() {}
+
+    public boolean unloadChunks() {
+        return false;
+    }
+
+    public boolean canSave() {
+        return true;
+    }
+
+    public String getName() {
+        return "RandomLevelSource";
+    }
+
+    public List<BiomeBase.BiomeMeta> getMobsFor(EnumCreatureType enumcreaturetype, BlockPosition blockposition) {
+        BiomeBase biomebase = this.m.getBiome(blockposition);
+
+        if (this.n) {
+            if (enumcreaturetype == EnumCreatureType.MONSTER && this.y.a(blockposition)) {
+                return this.y.b();
+            }
+
+            if (enumcreaturetype == EnumCreatureType.MONSTER && this.r.y && this.A.a(this.m, blockposition)) {
+                return this.A.b();
+            }
+        }
+
+        return biomebase.getMobs(enumcreaturetype);
+    }
+
+    public BlockPosition findNearestMapFeature(World world, String s, BlockPosition blockposition) {
+        return "Stronghold".equals(s) && this.v != null ? this.v.getNearestGeneratedFeature(world, blockposition) : null;
+    }
+
+    public int getLoadedChunks() {
+        return 0;
+    }
+
+    public void recreateStructures(Chunk chunk, int i, int j) {
+        if (this.r.w && this.n) {
+            this.x.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+        if (this.r.v && this.n) {
+            this.w.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+        if (this.r.u && this.n) {
+            this.v.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+        if (this.r.x && this.n) {
+            this.y.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+        if (this.r.y && this.n) {
+            this.A.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+    }
+
+    public Chunk getChunkAt(BlockPosition blockposition) {
+        return this.getOrCreateChunk(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderServer.java src/main/java/net/minecraft/server/ChunkProviderServer.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderServer.java	2016-02-26 15:27:08.093203344 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderServer.java	2016-03-16 23:43:29.270124843 +0800
@@ -1,37 +1,33 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Lists;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start
 import java.util.Random;
-import java.util.logging.Level;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.bukkit.Server;
 import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
 import org.bukkit.craftbukkit.util.LongHash;
-import org.bukkit.craftbukkit.util.LongHashSet;
-import org.bukkit.craftbukkit.util.LongObjectHashMap;
+import org.bukkit.event.Event;
 import org.bukkit.event.world.ChunkUnloadEvent;
 // CraftBukkit end
 
 public class ChunkProviderServer implements IChunkProvider {
 
     private static final Logger b = LogManager.getLogger();
-    public LongHashSet unloadQueue = new LongHashSet(); // CraftBukkit - LongHashSet
+    //public LongHashSet unloadQueue = new LongHashSet(); // CraftBukkit - LongHashSet
+    public ConcurrentHashMap<Long, Long> unloadQueue = new ConcurrentHashMap<Long, Long>(); // CraftBukkit
     public Chunk emptyChunk;
     public IChunkProvider chunkProvider;
     private IChunkLoader chunkLoader;
     public boolean forceChunkLoad = false; // CraftBukkit - true -> false
-    public LongObjectHashMap<Chunk> chunks = new LongObjectHashMap<Chunk>();
+    //public LongObjectHashMap<Chunk> chunks = new LongObjectHashMap<Chunk>();
+    public ConcurrentHashMap<Long, Chunk> chunks = new ConcurrentHashMap<Long, Chunk>();
     public WorldServer world;
 
     public ChunkProviderServer(WorldServer worldserver, IChunkLoader ichunkloader, IChunkProvider ichunkprovider) {
@@ -42,10 +38,13 @@
     }
 
     public boolean isChunkLoaded(int i, int j) {
+        //return this.chunks.containsKey(LongHash.toLong(i, j)); // CraftBukkit
+        //System.out.println(this.chunks.size()+","+this.chunks.values().size());
         return this.chunks.containsKey(LongHash.toLong(i, j)); // CraftBukkit
     }
 
     // CraftBukkit start - Change return type to Collection and return the values of our chunk map
+    //public java.util.Collection a() {
     public java.util.Collection a() {
         // return this.chunkList;
         return this.chunks.values();
@@ -53,12 +52,15 @@
     }
 
     public void queueUnload(int i, int j) {
+        long key = LongHash.toLong(i, j);
         if (this.world.worldProvider.e()) {
             if (!this.world.c(i, j)) {
                 // CraftBukkit start
-                this.unloadQueue.add(i, j);
+                //this.unloadQueue.add(i, j);
+                this.unloadQueue.put(key, key);
 
-                Chunk c = chunks.get(LongHash.toLong(i, j));
+                //Chunk c = chunks.get(LongHash.toLong(i, j));
+                Chunk c = chunks.get(key);
                 if (c != null) {
                     c.mustSave = true;
                 }
@@ -66,9 +68,11 @@
             }
         } else {
             // CraftBukkit start
-            this.unloadQueue.add(i, j);
+            //this.unloadQueue.add(i, j);
+            this.unloadQueue.put(key, key);
 
-            Chunk c = chunks.get(LongHash.toLong(i, j));
+            //Chunk c = chunks.get(LongHash.toLong(i, j));
+            Chunk c = chunks.get(key);
             if (c != null) {
                 c.mustSave = true;
             }
@@ -85,7 +89,7 @@
 
             this.queueUnload(chunk.locX, chunk.locZ);
         }
-
+        
     }
 
     // CraftBukkit start - Add async variant, provide compatibility
@@ -96,10 +100,14 @@
     public Chunk getChunkAt(int i, int j) {
         return getChunkAt(i, j, null);
     }
-
-    public Chunk getChunkAt(int i, int j, Runnable runnable) {
-        unloadQueue.remove(i, j);
-        Chunk chunk = chunks.get(LongHash.toLong(i, j));
+    
+    synchronized public Chunk getChunkAt(int i, int j, Runnable runnable) {
+    //public Chunk getChunkAt(int i, int j, Runnable runnable) {
+        long key = LongHash.toLong(i, j);
+        //unloadQueue.remove(i, j);
+        unloadQueue.remove(key);
+        //Chunk chunk = chunks.get(LongHash.toLong(i, j));
+        Chunk chunk = chunks.get(key);
         ChunkRegionLoader loader = null;
 
         if (this.chunkLoader instanceof ChunkRegionLoader) {
@@ -125,9 +133,13 @@
 
         return chunk;
     }
+    
     public Chunk originalGetChunkAt(int i, int j) {
-        this.unloadQueue.remove(i, j);
-        Chunk chunk = (Chunk) this.chunks.get(LongHash.toLong(i, j));
+        long key = LongHash.toLong(i, j);
+        //this.unloadQueue.remove(i, j);
+        this.unloadQueue.remove(key);
+        //Chunk chunk = (Chunk) this.chunks.get(LongHash.toLong(i, j));
+        Chunk chunk = (Chunk) this.chunks.get(key);
         boolean newChunk = false;
         // CraftBukkit end
 
@@ -152,7 +164,7 @@
                 }
                 newChunk = true; // CraftBukkit
             }
-
+            
             this.chunks.put(LongHash.toLong(i, j), chunk);
             
             chunk.addEntities();
@@ -165,7 +177,10 @@
                  * the World constructor. We can't reliably alter that, so we have
                  * no way of creating a CraftWorld/CraftServer at that point.
                  */
-                server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, newChunk));
+                //server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, newChunk));
+                Event ev = new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, newChunk);
+                ev.setAsynchronous();
+                server.getPluginManager().callEvent(ev);
             }
 
             // Update neighbor counts
@@ -190,8 +205,10 @@
         return chunk;
     }
 
+    //sync
     public Chunk getOrCreateChunk(int i, int j) {
         // CraftBukkit start
+        //Chunk chunk = (Chunk) this.chunks.get(LongHash.toLong(i, j));
         Chunk chunk = (Chunk) this.chunks.get(LongHash.toLong(i, j));
 
         chunk = chunk == null ? (!this.world.ad() && !this.forceChunkLoad ? this.emptyChunk : this.getChunkAt(i, j)) : chunk;
@@ -286,7 +303,10 @@
                     }
                 }
                 BlockSand.instaFall = false;
-                this.world.getServer().getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(chunk.bukkitChunk));
+                //this.world.getServer().getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(chunk.bukkitChunk));
+                Event ev = new org.bukkit.event.world.ChunkPopulateEvent(chunk.bukkitChunk);
+                ev.setAsynchronous();
+                this.world.getServer().getPluginManager().callEvent(ev);
                 // CraftBukkit end
                 
                 chunk.e();
@@ -344,11 +364,16 @@
             // CraftBukkit start
             Server server = this.world.getServer();
             for (int i = 0; i < 100 && !this.unloadQueue.isEmpty(); ++i) {
-                long chunkcoordinates = this.unloadQueue.popFirst();
+                //long chunkcoordinates = this.unloadQueue.popFirst();
+                long chunkcoordinates = this.unloadQueue.entrySet().iterator().next().getKey();
+                //remove after get it
+                this.unloadQueue.remove(chunkcoordinates);
                 Chunk chunk = this.chunks.get(chunkcoordinates);
                 if (chunk == null) continue;
 
                 ChunkUnloadEvent event = new ChunkUnloadEvent(chunk.bukkitChunk);
+                //set event async
+                event.setAsynchronous();
                 server.getPluginManager().callEvent(event);
                 if (!event.isCancelled()) {
 
@@ -356,9 +381,10 @@
                         chunk.removeEntities();
                         this.saveChunk(chunk);
                         this.saveChunkNOP(chunk);
+                        //this.chunks.remove(chunkcoordinates); // CraftBukkit
                         this.chunks.remove(chunkcoordinates); // CraftBukkit
                     }
-
+                    
                     // this.unloadQueue.remove(olong);
 
                     // Update neighbor counts
diff -Naur src_origin/main/java/net/minecraft/server/CommandSpreadPlayers.java src/main/java/net/minecraft/server/CommandSpreadPlayers.java
--- src_origin/main/java/net/minecraft/server/CommandSpreadPlayers.java	2016-02-26 15:27:08.290203362 +0800
+++ src/main/java/net/minecraft/server/CommandSpreadPlayers.java	2016-03-16 23:43:29.304124843 +0800
@@ -40,6 +40,7 @@
             double d4 = a(astring[i++], d3 + 1.0D);
             boolean flag = d(astring[i++]);
             ArrayList arraylist = Lists.newArrayList();
+            //List arraylist = Lists.newCopyOnWriteArrayList();
 
             while (i < astring.length) {
                 String s = astring[i++];
diff -Naur src_origin/main/java/net/minecraft/server/Container.java src/main/java/net/minecraft/server/Container.java
--- src_origin/main/java/net/minecraft/server/Container.java	2016-02-26 15:27:08.349203368 +0800
+++ src/main/java/net/minecraft/server/Container.java	2016-03-16 23:43:29.327124843 +0800
@@ -10,6 +10,8 @@
 // CraftBukkit start
 import java.util.HashMap;
 import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import org.bukkit.craftbukkit.inventory.CraftInventory;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.event.Event.Result;
@@ -22,12 +24,17 @@
 
     public List<ItemStack> b = Lists.newArrayList();
     public List<Slot> c = Lists.newArrayList();
+    /*public List<ItemStack> b = Lists.newCopyOnWriteArrayList();
+    public List<Slot> c = Lists.newCopyOnWriteArrayList();*/
     public int windowId;
     private int dragType = -1;
     private int g;
-    private final Set<Slot> h = Sets.newHashSet();
+    //private final Set<Slot> h = Sets.newHashSet();
+    private final Set<Slot> h = Sets.newConcurrentHashSet();
     protected List<ICrafting> listeners = Lists.newArrayList();
-    private Set<EntityHuman> i = Sets.newHashSet();
+    //protected List<ICrafting> listeners =Lists.newCopyOnWriteArrayList();
+    //private Set<EntityHuman> i = Sets.newHashSet();
+    private Set<EntityHuman> i = Sets.newConcurrentHashSet();
     private int tickCount; // Spigot
 
     // CraftBukkit start
@@ -63,7 +70,7 @@
 
     public List<ItemStack> a() {
         ArrayList arraylist = Lists.newArrayList();
-
+        
         for (int i = 0; i < this.c.size(); ++i) {
             arraylist.add(((Slot) this.c.get(i)).getItem());
         }
diff -Naur src_origin/main/java/net/minecraft/server/CraftingManager.java src/main/java/net/minecraft/server/CraftingManager.java
--- src_origin/main/java/net/minecraft/server/CraftingManager.java	2016-02-26 15:27:08.668203398 +0800
+++ src/main/java/net/minecraft/server/CraftingManager.java	2016-03-16 23:43:29.383124843 +0800
@@ -1,19 +1,19 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
-import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
 
 public class CraftingManager {
 
     private static final CraftingManager a = new CraftingManager();
+    //do not use "newCopyOnWriteArrayList"
     public List<IRecipe> recipes = Lists.newArrayList();
     // CraftBukkit start
     public IRecipe lastRecipe;
@@ -215,9 +215,11 @@
             }
         }
 
-        HashMap hashmap;
+        //HashMap hashmap;
+        ConcurrentHashMap hashmap;
 
-        for (hashmap = Maps.newHashMap(); i < aobject.length; i += 2) {
+        //for (hashmap = Maps.newHashMap(); i < aobject.length; i += 2) {
+        for (hashmap = new ConcurrentHashMap(); i < aobject.length; i += 2) {
             Character character = (Character) aobject[i];
             ItemStack itemstack1 = null;
 
diff -Naur src_origin/main/java/net/minecraft/server/CrashReport.java src/main/java/net/minecraft/server/CrashReport.java
--- src_origin/main/java/net/minecraft/server/CrashReport.java	2016-02-26 15:27:08.705203401 +0800
+++ src/main/java/net/minecraft/server/CrashReport.java	2016-03-16 23:43:29.389124843 +0800
@@ -12,6 +12,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.Callable;
+import java.util.concurrent.CopyOnWriteArrayList;
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.lang3.ArrayUtils;
 import org.apache.logging.log4j.LogManager;
@@ -23,7 +24,8 @@
     private final String b;
     private final Throwable c;
     private final CrashReportSystemDetails d = new CrashReportSystemDetails(this, "System Details");
-    private final List<CrashReportSystemDetails> e = Lists.newArrayList();
+    //private final List<CrashReportSystemDetails> e = Lists.newArrayList();
+    private final List<CrashReportSystemDetails> e = Lists.newCopyOnWriteArrayList();
     private File f;
     private boolean g = true;
     private StackTraceElement[] h = new StackTraceElement[0];
diff -Naur src_origin/main/java/net/minecraft/server/DedicatedServer.java src/main/java/net/minecraft/server/DedicatedServer.java
--- src_origin/main/java/net/minecraft/server/DedicatedServer.java	2016-02-26 15:27:08.757203406 +0800
+++ src/main/java/net/minecraft/server/DedicatedServer.java	2016-03-16 23:43:29.402124843 +0800
@@ -29,7 +29,8 @@
 public class DedicatedServer extends MinecraftServer implements IMinecraftServer {
 
     private static final Logger LOGGER = LogManager.getLogger();
-    private final List<ServerCommand> l = Collections.synchronizedList(Lists.<ServerCommand>newArrayList()); // CraftBukkit - fix decompile error
+    //private final List<ServerCommand> l = Collections.synchronizedList(Lists.<ServerCommand>newArrayList()); // CraftBukkit - fix decompile error
+    private final List<ServerCommand> l = Lists.newCopyOnWriteArrayList(); // CraftBukkit - fix decompile error
     private RemoteStatusListener m;
     private RemoteControlListener n;
     public PropertyManager propertyManager;
diff -Naur src_origin/main/java/net/minecraft/server/EntityFallingBlock.java src/main/java/net/minecraft/server/EntityFallingBlock.java
--- src_origin/main/java/net/minecraft/server/EntityFallingBlock.java	2016-02-26 15:27:09.384203465 +0800
+++ src/main/java/net/minecraft/server/EntityFallingBlock.java	2016-03-16 23:43:29.535124843 +0800
@@ -1,8 +1,8 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.List;
 
 import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
 
@@ -16,6 +16,8 @@
     private int fallHurtMax = 40;
     private float fallHurtAmount = 2.0F;
     public NBTTagCompound tileEntityData;
+    //add drop tag
+    protected boolean is_droped;
 
     public EntityFallingBlock(World world) {
         super(world);
@@ -115,7 +117,14 @@
                                     }
                                 }
                             } else if (this.dropItem && this.world.getGameRules().getBoolean("doEntityDrops")) {
-                                this.a(new ItemStack(block, 1, block.getDropData(this.block)), 0.0F);
+                                //casue sand dup
+                                //this.a(new ItemStack(block, 1, block.getDropData(this.block)), 0.0F);
+                                if (is_droped) {
+                                    //do nothing
+                                } else {
+                                    is_droped = true;
+                                    this.a(new ItemStack(block, 1, block.getDropData(this.block)), 0.0F);
+                                }
                             }
                         }
                     }
@@ -138,7 +147,8 @@
             int i = MathHelper.f(f - 1.0F);
 
             if (i > 0) {
-                ArrayList arraylist = Lists.newArrayList(this.world.getEntities(this, this.getBoundingBox()));
+                //ArrayList arraylist = Lists.newArrayList(this.world.getEntities(this, this.getBoundingBox()));
+                List arraylist = Lists.newCopyOnWriteArrayList(this.world.getEntities(this, this.getBoundingBox()));
                 boolean flag = block == Blocks.ANVIL;
                 DamageSource damagesource = flag ? DamageSource.ANVIL : DamageSource.FALLING_BLOCK;
                 Iterator iterator = arraylist.iterator();
diff -Naur src_origin/main/java/net/minecraft/server/EntityHuman.java src/main/java/net/minecraft/server/EntityHuman.java
--- src_origin/main/java/net/minecraft/server/EntityHuman.java	2016-02-26 15:27:09.563203482 +0800
+++ src/main/java/net/minecraft/server/EntityHuman.java	2016-03-16 23:43:29.593124843 +0800
@@ -430,15 +430,24 @@
             }
 
             List list = this.world.getEntities(this, axisalignedbb);
-
+            
             if (this.ae()) { // Spigot: Add this.ae() condition (second !this.isDead near bottom of EntityLiving)
+            Iterator it = list.iterator();
+            while (it.hasNext()) {
+                Entity entity = (Entity) it.next();
+
+                if (!entity.dead) {
+                    this.d(entity);
+                }
+            }
+            /*    
             for (int i = 0; i < list.size(); ++i) {
                 Entity entity = (Entity) list.get(i);
 
                 if (!entity.dead) {
                     this.d(entity);
                 }
-            }
+            }*/
             } // Spigot 
         }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityItem.java src/main/java/net/minecraft/server/EntityItem.java
--- src_origin/main/java/net/minecraft/server/EntityItem.java	2016-02-26 15:27:09.641203489 +0800
+++ src/main/java/net/minecraft/server/EntityItem.java	2016-03-16 23:43:29.614124843 +0800
@@ -81,10 +81,10 @@
                     this.motZ = (double) ((this.random.nextFloat() - this.random.nextFloat()) * 0.2F);
                     this.makeSound("random.fizz", 0.4F, 2.0F + this.random.nextFloat() * 0.4F);
                 }
-
-                if (!this.world.isClientSide) {
+                /*
+                if (!this.world.isClientSide && this.ak == false) {
                     this.w();
-                }
+                }*/
             }
 
             float f = 0.98F;
@@ -143,6 +143,7 @@
     }
     // Spigot end
 
+    //merge will cause dup through portal
     private void w() {
         // Spigot start
         double radius = world.spigotConfig.itemMerge;
@@ -375,9 +376,10 @@
 
     public void c(int i) {
         super.c(i);
-        if (!this.world.isClientSide) {
+        /*
+        if (!this.world.isClientSide && this.ak == false) {
             this.w();
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/Entity.java src/main/java/net/minecraft/server/Entity.java
--- src_origin/main/java/net/minecraft/server/Entity.java	2016-02-26 15:27:08.930203422 +0800
+++ src/main/java/net/minecraft/server/Entity.java	2016-03-16 23:43:29.446124843 +0800
@@ -122,6 +122,7 @@
     public final boolean defaultActivationState;
     public long activatedTick = Integer.MIN_VALUE;
     public boolean fromMobSpawner;
+    public boolean is_collidefence = false;
     public void inactiveTick() { }
     // Spigot end
 
@@ -263,12 +264,12 @@
             this.world.methodProfiler.a("portal");
             MinecraftServer minecraftserver = ((WorldServer) this.world).getMinecraftServer();
             int i = this.L();
-
             if (this.ak) {
                 if (true || minecraftserver.getAllowNether()) { // CraftBukkit
                     if (this.vehicle == null && this.al++ >= i) {
                         this.al = i;
                         this.portalCooldown = this.aq();
+
                         byte b0;
 
                         if (this.world.worldProvider.getDimension() == -1) {
@@ -291,9 +292,14 @@
                     this.al = 0;
                 }
             }
-
+            /*
             if (this.portalCooldown > 0) {
                 --this.portalCooldown;
+            }*/
+            if (this.portalCooldown > 0) {
+                --this.portalCooldown;
+            } else {
+                this.teleport_count = 0;
             }
 
             this.world.methodProfiler.b();
@@ -756,7 +762,12 @@
                     for (int k = blockposition.getZ(); k <= blockposition1.getZ(); ++k) {
                         BlockPosition blockposition2 = new BlockPosition(i, j, k);
                         IBlockData iblockdata = this.world.getType(blockposition2);
-
+                        //check fence
+                        if (iblockdata.getBlock() instanceof BlockFence) {
+                            this.is_collidefence = true;
+                        } else {
+                            this.is_collidefence = false;
+                        }
                         try {
                             iblockdata.getBlock().a(this.world, blockposition2, iblockdata, this);
                         } catch (Throwable throwable) {
@@ -1078,11 +1089,21 @@
                     d0 *= (double) (1.0F - this.U);
                     d1 *= (double) (1.0F - this.U);
                     if (this.passenger == null) {
-                        this.g(-d0, 0.0D, -d1);
+                        //this.g(-d0, 0.0D, -d1);
+                        if (this.is_collidefence) {
+                            this.g(-d0*3D, 0.0D, -d1*3D);
+                        } else {
+                            this.g(-d0, 0.0D, -d1);
+                        }
                     }
 
                     if (entity.passenger == null) {
-                        entity.g(d0, 0.0D, d1);
+                        if (this.is_collidefence) {
+                            entity.g(d0*3D, 0.0D, d1*3D);
+                        } else {
+                            entity.g(d0, 0.0D, d1);
+                        }
+                        //entity.g(d0, 0.0D, d1);
                     }
                 }
 
@@ -1539,8 +1560,9 @@
                 // CraftBukkit start
                 if ((this.bukkitEntity instanceof LivingEntity) && (this.vehicle.getBukkitEntity() instanceof Vehicle)) {
                     VehicleExitEvent event = new VehicleExitEvent((Vehicle) this.vehicle.getBukkitEntity(), (LivingEntity) this.bukkitEntity);
+                    //set to async
+                    event.setAsynchronous();
                     pluginManager.callEvent(event);
-
                     if (event.isCancelled() || vehicle != originalVehicle) {
                         return;
                     }
@@ -1559,6 +1581,8 @@
                 VehicleExitEvent exitEvent = null;
                 if (this.vehicle != null && this.vehicle.getBukkitEntity() instanceof Vehicle) {
                     exitEvent = new VehicleExitEvent((Vehicle) this.vehicle.getBukkitEntity(), (LivingEntity) this.bukkitEntity);
+                    //set to async
+                    exitEvent.setAsynchronous();
                     pluginManager.callEvent(exitEvent);
 
                     if (exitEvent.isCancelled() || this.vehicle != originalVehicle || (this.vehicle != null && this.vehicle.passenger != originalPassenger)) {
@@ -1567,6 +1591,8 @@
                 }
 
                 VehicleEnterEvent event = new VehicleEnterEvent((Vehicle) entity.getBukkitEntity(), this.bukkitEntity);
+                //set to async
+                event.setAsynchronous();
                 pluginManager.callEvent(event);
 
                 // If a plugin messes with the vehicle or the vehicle's passenger
@@ -1585,6 +1611,8 @@
             if ( entity.world.isChunkLoaded( (int) entity.locX >> 4, (int) entity.locZ >> 4, true ) )
             {
                 org.spigotmc.event.entity.EntityMountEvent event = new org.spigotmc.event.entity.EntityMountEvent( this.getBukkitEntity(), entity.getBukkitEntity() );
+                //set async
+                event.setAsynchronous();
                 pluginManager.callEvent( event );
                 if ( event.isCancelled() )
                 {
@@ -1891,7 +1919,8 @@
     }
 
     public void c(int i) {
-        if (!this.world.isClientSide && !this.dead) {
+        //fix dup
+        if (!this.world.isClientSide && !this.dead && this.teleport_count == 0) {
             this.world.methodProfiler.a("changeDimension");
             MinecraftServer minecraftserver = MinecraftServer.getServer();
             // CraftBukkit start - Move logic into new function "teleportToLocation"
@@ -1924,8 +1953,11 @@
         }
     }
 
+    int teleport_count = 0;
     public void teleportTo(Location exit, boolean portal) {
-        if (true) {
+        //if (true) {
+        if (true && teleport_count == 0) {
+            teleport_count = 1;
             WorldServer worldserver = ((CraftWorld) getBukkitEntity().getLocation().getWorld()).getHandle();
             WorldServer worldserver1 = ((CraftWorld) exit.getWorld()).getHandle();
             int i = worldserver1.dimension;
diff -Naur src_origin/main/java/net/minecraft/server/EntityLiving.java src/main/java/net/minecraft/server/EntityLiving.java
--- src_origin/main/java/net/minecraft/server/EntityLiving.java	2016-02-26 15:27:09.784203502 +0800
+++ src/main/java/net/minecraft/server/EntityLiving.java	2016-03-16 23:43:29.651124843 +0800
@@ -14,6 +14,8 @@
 import java.util.ArrayList;
 import com.google.common.base.Function;
 import com.google.common.collect.Lists;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.FutureTask;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Vehicle;
@@ -24,6 +26,9 @@
 // CraftBukkit end
 
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.hose.EntityAICollision_Pool;
+import org.hose.EntityTickRest_Pool;
+import org.spigotmc.SpigotWorldConfig;
 
 public abstract class EntityLiving extends Entity {
 
@@ -87,7 +92,8 @@
     // CraftBukkit start
     public int expToDrop;
     public int maxAirTicks = 300;
-    ArrayList<org.bukkit.inventory.ItemStack> drops = null;
+    //ArrayList<org.bukkit.inventory.ItemStack> drops = null;
+    List<org.bukkit.inventory.ItemStack> drops = null;
     // CraftBukkit end
     // Spigot start
     public void inactiveTick()
@@ -100,7 +106,7 @@
     public void G() {
         this.damageEntity(DamageSource.OUT_OF_WORLD, Float.MAX_VALUE);
     }
-
+    
     public EntityLiving(World world) {
         super(world);
         this.initAttributes();
@@ -461,7 +467,8 @@
 
     // CraftBukkit start
     private boolean isTickingEffects = false;
-    private List<Object> effectsToProcess = Lists.newArrayList();
+    //private List<Object> effectsToProcess = Lists.newArrayList();
+    private List<Object> effectsToProcess = Lists.newCopyOnWriteArrayList();
     // CraftBukkit end
 
     protected void bi() {
@@ -863,7 +870,8 @@
             }
 
             if (this.ba() && this.world.getGameRules().getBoolean("doMobLoot")) {
-                this.drops = new ArrayList<org.bukkit.inventory.ItemStack>(); // CraftBukkit - Setup drop capture
+                //this.drops = new ArrayList<org.bukkit.inventory.ItemStack>(); // CraftBukkit - Setup drop capture
+                this.drops = new CopyOnWriteArrayList<org.bukkit.inventory.ItemStack>(); // CraftBukkit - Setup drop capture
                 
                 this.dropDeathLoot(this.lastDamageByPlayerTime > 0, i);
                 this.dropEquipment(this.lastDamageByPlayerTime > 0, i);
@@ -1485,6 +1493,80 @@
 
         SpigotTimings.timerEntityBaseTick.stopTiming(); // Spigot
         this.m();
+        //EntityTickRest_hose();
+        SpigotWorldConfig.EntityTickRestTask = new FutureTask(new EntityTickRest_Pool(this));
+        SpigotWorldConfig.entitytickrestpool_executor.submit(SpigotWorldConfig.EntityTickRestTask);
+        /*
+        SpigotTimings.timerEntityTickRest.startTiming(); // Spigot
+        double d0 = this.locX - this.lastX;
+        double d1 = this.locZ - this.lastZ;
+        float f = (float) (d0 * d0 + d1 * d1);
+        float f1 = this.aI;
+        float f2 = 0.0F;
+
+        this.aR = this.aS;
+        float f3 = 0.0F;
+
+        if (f > 0.0025000002F) {
+            f3 = 1.0F;
+            f2 = (float) Math.sqrt((double) f) * 3.0F;
+            // CraftBukkit - Math -> TrigMath
+            f1 = (float) org.bukkit.craftbukkit.TrigMath.atan2(d1, d0) * 180.0F / 3.1415927F - 90.0F;
+        }
+
+        if (this.az > 0.0F) {
+            f1 = this.yaw;
+        }
+
+        if (!this.onGround) {
+            f3 = 0.0F;
+        }
+
+        this.aS += (f3 - this.aS) * 0.3F;
+        this.world.methodProfiler.a("headTurn");
+        f2 = this.h(f1, f2);
+        this.world.methodProfiler.b();
+        this.world.methodProfiler.a("rangeChecks");
+
+        while (this.yaw - this.lastYaw < -180.0F) {
+            this.lastYaw -= 360.0F;
+        }
+
+        while (this.yaw - this.lastYaw >= 180.0F) {
+            this.lastYaw += 360.0F;
+        }
+
+        while (this.aI - this.aJ < -180.0F) {
+            this.aJ -= 360.0F;
+        }
+
+        while (this.aI - this.aJ >= 180.0F) {
+            this.aJ += 360.0F;
+        }
+
+        while (this.pitch - this.lastPitch < -180.0F) {
+            this.lastPitch -= 360.0F;
+        }
+
+        while (this.pitch - this.lastPitch >= 180.0F) {
+            this.lastPitch += 360.0F;
+        }
+
+        while (this.aK - this.aL < -180.0F) {
+            this.aL -= 360.0F;
+        }
+
+        while (this.aK - this.aL >= 180.0F) {
+            this.aL += 360.0F;
+        }
+
+        this.world.methodProfiler.b();
+        this.aT += f2;
+        SpigotTimings.timerEntityTickRest.stopTiming(); // Spigot
+        */
+    }
+    
+    public void EntityTickRest_hose(){
         SpigotTimings.timerEntityTickRest.startTiming(); // Spigot
         double d0 = this.locX - this.lastX;
         double d1 = this.locZ - this.lastZ;
@@ -1655,14 +1737,27 @@
         this.world.methodProfiler.a("push");
         if (!this.world.isClientSide) {
             SpigotTimings.timerEntityAICollision.startTiming(); // Spigot
-            this.bL();
+            //this.bL();
+            if (!SpigotWorldConfig.Collision_list.contains(this.int_hash(this.getId()))){
+                SpigotWorldConfig.Collision_list.add(this.int_hash(this.getId()));
+                SpigotWorldConfig.EntityAICollisionTask = new FutureTask(new EntityAICollision_Pool(this));
+                SpigotWorldConfig.entityaicollisiontpool_executor.submit(SpigotWorldConfig.EntityAICollisionTask);
+            }
             SpigotTimings.timerEntityAICollision.stopTiming(); // Spigot
         }
-
         this.world.methodProfiler.b();
     }
-
+    
+    private int int_hash(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
+    
     protected void doTick() {}
+    
+    public void bL_hose(){
+        bL();
+    }
 
     protected void bL() {
         List list = this.world.a((Entity) this, this.getBoundingBox().grow(0.20000000298023224D, 0.0D, 0.20000000298023224D), Predicates.and(IEntitySelector.d, new Predicate() {
@@ -1698,6 +1793,8 @@
     }
 
     protected void s(Entity entity) {
+        //add fence detection
+        //BlockFence
         entity.collide(this);
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityMinecartAbstract.java src/main/java/net/minecraft/server/EntityMinecartAbstract.java
--- src_origin/main/java/net/minecraft/server/EntityMinecartAbstract.java	2016-02-26 15:27:09.793203503 +0800
+++ src/main/java/net/minecraft/server/EntityMinecartAbstract.java	2016-03-16 23:43:29.660124843 +0800
@@ -238,9 +238,14 @@
                     this.al = 0;
                 }
             }
-
+            /*
             if (this.portalCooldown > 0) {
                 --this.portalCooldown;
+            }*/
+            if (this.portalCooldown > 0) {
+                -- this.portalCooldown;
+            } else {
+                this.teleport_count = 0;
             }
 
             this.world.methodProfiler.b();
diff -Naur src_origin/main/java/net/minecraft/server/EntityPlayer.java src/main/java/net/minecraft/server/EntityPlayer.java
--- src_origin/main/java/net/minecraft/server/EntityPlayer.java	2016-02-26 15:27:09.996203522 +0800
+++ src/main/java/net/minecraft/server/EntityPlayer.java	2016-03-16 23:43:29.699124843 +0800
@@ -10,6 +10,7 @@
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -33,8 +34,11 @@
     public final PlayerInteractManager playerInteractManager;
     public double d;
     public double e;
-    public final List<ChunkCoordIntPair> chunkCoordIntPairQueue = Lists.newLinkedList();
-    public final List<Integer> removeQueue = Lists.newLinkedList();
+    //public final List<ChunkCoordIntPair> chunkCoordIntPairQueue = Lists.newLinkedList();
+    //casue negative array size
+    public final ConcurrentLinkedQueue<ChunkCoordIntPair> chunkCoordIntPairQueue = new ConcurrentLinkedQueue<ChunkCoordIntPair>();
+    //public final List<Integer> removeQueue = Lists.newLinkedList();
+    public final ConcurrentLinkedQueue<Integer> removeQueue = new ConcurrentLinkedQueue<Integer>();
     private final ServerStatisticManager bK;
     private float bL = Float.MIN_VALUE;
     private float bM = -1.0E8F;
@@ -217,9 +221,11 @@
         }
 
         if (!this.chunkCoordIntPairQueue.isEmpty()) {
-            ArrayList arraylist = Lists.newArrayList();
+            //ArrayList arraylist = Lists.newArrayList();
+            List arraylist = Lists.newCopyOnWriteArrayList();
             Iterator iterator1 = this.chunkCoordIntPairQueue.iterator();
-            ArrayList arraylist1 = Lists.newArrayList();
+            //ArrayList arraylist1 = Lists.newArrayList();
+            List arraylist1 = Lists.newCopyOnWriteArrayList();
 
             Chunk chunk;
 
@@ -894,11 +900,16 @@
     }
 
     public void copyTo(EntityHuman entityhuman, boolean flag) {
-        super.copyTo(entityhuman, flag);
-        this.lastSentExp = -1;
-        this.bM = -1.0F;
-        this.bN = -1;
-        this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
+        try {
+            super.copyTo(entityhuman, flag);
+            this.lastSentExp = -1;
+            this.bM = -1.0F;
+            this.bN = -1;
+            this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
+        } catch (Exception ex){
+            
+        }
+        
     }
 
     protected void a(MobEffect mobeffect) {
diff -Naur src_origin/main/java/net/minecraft/server/EntitySlice.java src/main/java/net/minecraft/server/EntitySlice.java
--- src_origin/main/java/net/minecraft/server/EntitySlice.java	2016-02-26 15:27:10.178203539 +0800
+++ src/main/java/net/minecraft/server/EntitySlice.java	2016-03-16 23:43:29.733124843 +0800
@@ -7,16 +7,19 @@
 import java.util.AbstractSet;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentMap;
 
 public class EntitySlice<T> extends AbstractSet<T> {
 
     private static final Set<Class<?>> a = Sets.newConcurrentHashSet(); // CraftBukkit
-    private final Map<Class<?>, List<T>> b = Maps.newHashMap();
+    //private final Map<Class<?>, List<T>> b = Maps.newHashMap();
+    private final ConcurrentMap<Class<?>, List<T>> b = Maps.newConcurrentMap();
+    
     private final Set<Class<?>> c = Sets.newIdentityHashSet();
     private final Class<T> d;
-    private final List<T> e = Lists.newArrayList();
+    //private final List<T> e = Lists.newArrayList();
+    private final List<T> e = Lists.newCopyOnWriteArrayList();
 
     public EntitySlice(Class<T> oclass) {
         this.d = oclass;
@@ -77,6 +80,7 @@
         List list = (List) this.b.get(oclass);
 
         if (list == null) {
+            //this.b.put(oclass, Lists.newArrayList(t0));
             this.b.put(oclass, Lists.newArrayList(t0));
         } else {
             list.add(t0);
diff -Naur src_origin/main/java/net/minecraft/server/EntityTrackerEntry.java src/main/java/net/minecraft/server/EntityTrackerEntry.java
--- src_origin/main/java/net/minecraft/server/EntityTrackerEntry.java	2016-02-26 15:27:10.392203559 +0800
+++ src/main/java/net/minecraft/server/EntityTrackerEntry.java	2016-03-16 23:43:29.778124843 +0800
@@ -1,10 +1,13 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Sets;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Iterator;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArraySet;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -39,7 +42,8 @@
     private boolean x;
     private boolean y;
     public boolean n;
-    public Set<EntityPlayer> trackedPlayers = Sets.newHashSet();
+    //public Set<EntityPlayer> trackedPlayers = Sets.newHashSet();
+    public Set<EntityPlayer> trackedPlayers = Collections.newSetFromMap(new ConcurrentHashMap<EntityPlayer, Boolean>());
 
     public EntityTrackerEntry(Entity entity, int i, int j, boolean flag) {
         this.tracker = entity;
@@ -424,9 +428,14 @@
     }
 
     public void scanPlayers(List<EntityHuman> list) {
+        Iterator it = list.iterator();
+        while(it.hasNext()){
+            this.updatePlayer((EntityPlayer) it.next());
+        }
+        /*
         for (int i = 0; i < list.size(); ++i) {
             this.updatePlayer((EntityPlayer) list.get(i));
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityTracker.java src/main/java/net/minecraft/server/EntityTracker.java
--- src_origin/main/java/net/minecraft/server/EntityTracker.java	2016-02-26 15:27:10.352203555 +0800
+++ src/main/java/net/minecraft/server/EntityTracker.java	2016-03-16 23:43:29.767124843 +0800
@@ -1,11 +1,11 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
-import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Set;
-import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArraySet;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -13,10 +13,18 @@
 
     private static final Logger a = LogManager.getLogger();
     private final WorldServer world;
-    private Set<EntityTrackerEntry> c = Sets.newHashSet();
-    public IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    //private Set<EntityTrackerEntry> c = Sets.newHashSet();
+    private Set<EntityTrackerEntry> c = new CopyOnWriteArraySet<EntityTrackerEntry>();
+    //public IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    public ConcurrentHashMap<Integer, EntityTrackerEntry> trackedEntities = new ConcurrentHashMap<Integer, EntityTrackerEntry>();
     private int e;
 
+    //for spigot
+    private int g(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
+    
     public EntityTracker(WorldServer worldserver) {
         this.world = worldserver;
         this.e = worldserver.getMinecraftServer().getPlayerList().d();
@@ -94,23 +102,40 @@
     }
 
     public void addEntity(Entity entity, int i, final int j, boolean flag) {
-        org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
-        i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
-        if (i > this.e) {
-            i = this.e;
-        }
-
-        try {
-            if (this.trackedEntities.b(entity.getId())) {
-                throw new IllegalStateException("Entity is already tracked!");
+        synchronized (this) {
+            org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
+            i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
+            if (i > this.e) {
+                i = this.e;
             }
 
-            EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, j, flag);
 
-            this.c.add(entitytrackerentry);
-            this.trackedEntities.a(entity.getId(), entitytrackerentry);
-            entitytrackerentry.scanPlayers(this.world.players);
-        } catch (Throwable throwable) {
+            //just track once
+            //if (this.trackedEntities.b(entity.getId())) {
+            if (this.trackedEntities.containsKey(this.g(entity.getId()))) {
+                //do nothing
+                //throw new IllegalStateException("Entity is already tracked!");
+                //throw new Exception();
+            } else {
+                EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, j, flag);
+
+                this.c.add(entitytrackerentry);
+                //key point causing error
+                //this.trackedEntities.a(entity.getId(), entitytrackerentry);
+                this.trackedEntities.put(this.g(entity.getId()), entitytrackerentry);
+
+                entitytrackerentry.scanPlayers(this.world.players);
+            }
+        }
+        /*
+        EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, j, flag);
+
+        this.c.add(entitytrackerentry);
+        //key point causing error
+        this.trackedEntities.a(entity.getId(), entitytrackerentry);
+        entitytrackerentry.scanPlayers(this.world.players);*/
+        
+        /*} catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
             CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity To Track");
 
@@ -141,7 +166,7 @@
             } catch (ReportedException reportedexception) {
                 EntityTracker.a.error("\"Silently\" catching entity tracking error.", reportedexception);
             }
-        }
+        }*/
 
     }
 
@@ -158,8 +183,11 @@
             }
         }
 
-        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
-
+        //EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
+        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.get(this.g(entity.getId()));
+        //remember to remove trackedEntities.
+        this.trackedEntities.remove(this.g(entity.getId()));
+        
         if (entitytrackerentry1 != null) {
             this.c.remove(entitytrackerentry1);
             entitytrackerentry1.a();
@@ -168,8 +196,11 @@
     }
 
     public void updatePlayers() {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         Iterator iterator = this.c.iterator();
+        //observe track list size
+        //System.out.println(this.c.size()+","+this.trackedEntities.size()+","+arraylist.size());
 
         while (iterator.hasNext()) {
             EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
@@ -211,7 +242,8 @@
     }
 
     public void a(Entity entity, Packet packet) {
-        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        //EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(this.g(entity.getId()));
 
         if (entitytrackerentry != null) {
             entitytrackerentry.broadcast(packet);
@@ -220,7 +252,8 @@
     }
 
     public void sendPacketToEntity(Entity entity, Packet packet) {
-        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        //EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(this.g(entity.getId()));
 
         if (entitytrackerentry != null) {
             entitytrackerentry.broadcastIncludingSelf(packet);
diff -Naur src_origin/main/java/net/minecraft/server/Explosion.java src/main/java/net/minecraft/server/Explosion.java
--- src_origin/main/java/net/minecraft/server/Explosion.java	2016-02-26 15:27:10.556203574 +0800
+++ src/main/java/net/minecraft/server/Explosion.java	2016-03-16 23:43:29.811124843 +0800
@@ -1,13 +1,13 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
 import java.util.Random;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.event.CraftEventFactory;
@@ -28,7 +28,9 @@
     public final Entity source;
     private final float size;
     private final List<BlockPosition> blocks = Lists.newArrayList();
-    private final Map<EntityHuman, Vec3D> k = Maps.newHashMap();
+    //private final List<BlockPosition> blocks = Lists.newCopyOnWriteArrayList();
+    //private final Map<EntityHuman, Vec3D> k = Maps.newHashMap();
+    private final ConcurrentHashMap<EntityHuman, Vec3D> k = new ConcurrentHashMap<EntityHuman, Vec3D>();
     public boolean wasCanceled = false; // CraftBukkit - add field
 
     public Explosion(World world, Entity entity, double d0, double d1, double d2, float f, boolean flag, boolean flag1) {
@@ -263,7 +265,8 @@
 
     }
 
-    public Map<EntityHuman, Vec3D> b() {
+    //public Map<EntityHuman, Vec3D> b() {
+    public ConcurrentMap<EntityHuman, Vec3D> b() {
         return this.k;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/GenLayerBiome.java src/main/java/net/minecraft/server/GenLayerBiome.java
--- src_origin/main/java/net/minecraft/server/GenLayerBiome.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayerBiome.java	2016-03-16 23:43:29.837124843 +0800
@@ -0,0 +1,78 @@
+package net.minecraft.server;
+
+public class GenLayerBiome extends GenLayer {
+
+    private BiomeBase[] c;
+    private BiomeBase[] d;
+    private BiomeBase[] e;
+    private BiomeBase[] f;
+    private final CustomWorldSettingsFinal g;
+
+    public GenLayerBiome(long i, GenLayer genlayer, WorldType worldtype, String s) {
+        super(i);
+        this.c = new BiomeBase[] { BiomeBase.DESERT, BiomeBase.DESERT, BiomeBase.DESERT, BiomeBase.SAVANNA, BiomeBase.SAVANNA, BiomeBase.PLAINS};
+        this.d = new BiomeBase[] { BiomeBase.FOREST, BiomeBase.ROOFED_FOREST, BiomeBase.EXTREME_HILLS, BiomeBase.PLAINS, BiomeBase.BIRCH_FOREST, BiomeBase.SWAMPLAND};
+        this.e = new BiomeBase[] { BiomeBase.FOREST, BiomeBase.EXTREME_HILLS, BiomeBase.TAIGA, BiomeBase.PLAINS};
+        this.f = new BiomeBase[] { BiomeBase.ICE_PLAINS, BiomeBase.ICE_PLAINS, BiomeBase.ICE_PLAINS, BiomeBase.COLD_TAIGA};
+        this.a = genlayer;
+        if (worldtype == WorldType.NORMAL_1_1) {
+            this.c = new BiomeBase[] { BiomeBase.DESERT, BiomeBase.FOREST, BiomeBase.EXTREME_HILLS, BiomeBase.SWAMPLAND, BiomeBase.PLAINS, BiomeBase.TAIGA};
+            this.g = null;
+        } else if (worldtype == WorldType.CUSTOMIZED) {
+            this.g = CustomWorldSettingsFinal.CustomWorldSettings.a(s).b();
+        } else {
+            this.g = null;
+        }
+
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        int[] aint = this.a.a(i, j, k, l);
+        int[] aint1 = IntCache.a(k * l);
+
+        for (int i1 = 0; i1 < l; ++i1) {
+            for (int j1 = 0; j1 < k; ++j1) {
+                this.a((long) (j1 + i), (long) (i1 + j));
+                int k1 = aint[j1 + i1 * k];
+                int l1 = (k1 & 3840) >> 8;
+
+                k1 &= -3841;
+                if (this.g != null && this.g.F >= 0) {
+                    aint1[j1 + i1 * k] = this.g.F;
+                } else if (b(k1)) {
+                    aint1[j1 + i1 * k] = k1;
+                } else if (k1 == BiomeBase.MUSHROOM_ISLAND.id) {
+                    aint1[j1 + i1 * k] = k1;
+                } else if (k1 == 1) {
+                    if (l1 > 0) {
+                        if (this.a(3) == 0) {
+                            aint1[j1 + i1 * k] = BiomeBase.MESA_PLATEAU.id;
+                        } else {
+                            aint1[j1 + i1 * k] = BiomeBase.MESA_PLATEAU_F.id;
+                        }
+                    } else {
+                        aint1[j1 + i1 * k] = this.c[this.a(this.c.length)].id;
+                    }
+                } else if (k1 == 2) {
+                    if (l1 > 0) {
+                        aint1[j1 + i1 * k] = BiomeBase.JUNGLE.id;
+                    } else {
+                        aint1[j1 + i1 * k] = this.d[this.a(this.d.length)].id;
+                    }
+                } else if (k1 == 3) {
+                    if (l1 > 0) {
+                        aint1[j1 + i1 * k] = BiomeBase.MEGA_TAIGA.id;
+                    } else {
+                        aint1[j1 + i1 * k] = this.e[this.a(this.e.length)].id;
+                    }
+                } else if (k1 == 4) {
+                    aint1[j1 + i1 * k] = this.f[this.a(this.f.length)].id;
+                } else {
+                    aint1[j1 + i1 * k] = BiomeBase.MUSHROOM_ISLAND.id;
+                }
+            }
+        }
+
+        return aint1;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/GenLayerCleaner.java src/main/java/net/minecraft/server/GenLayerCleaner.java
--- src_origin/main/java/net/minecraft/server/GenLayerCleaner.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayerCleaner.java	2016-03-16 23:43:29.841124843 +0800
@@ -0,0 +1,23 @@
+package net.minecraft.server;
+
+public class GenLayerCleaner extends GenLayer {
+
+    public GenLayerCleaner(long i, GenLayer genlayer) {
+        super(i);
+        this.a = genlayer;
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        int[] aint = this.a.a(i, j, k, l);
+        int[] aint1 = IntCache.a(k * l);
+
+        for (int i1 = 0; i1 < l; ++i1) {
+            for (int j1 = 0; j1 < k; ++j1) {
+                this.a((long) (j1 + i), (long) (i1 + j));
+                aint1[j1 + i1 * k] = aint[j1 + i1 * k] > 0 ? this.a(299999) + 2 : 0;
+            }
+        }
+
+        return aint1;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/GenLayerDeepOcean.java src/main/java/net/minecraft/server/GenLayerDeepOcean.java
--- src_origin/main/java/net/minecraft/server/GenLayerDeepOcean.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayerDeepOcean.java	2016-03-16 23:43:29.850124843 +0800
@@ -0,0 +1,53 @@
+package net.minecraft.server;
+
+public class GenLayerDeepOcean extends GenLayer {
+
+    public GenLayerDeepOcean(long i, GenLayer genlayer) {
+        super(i);
+        this.a = genlayer;
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        int i1 = i - 1;
+        int j1 = j - 1;
+        int k1 = k + 2;
+        int l1 = l + 2;
+        int[] aint = this.a.a(i1, j1, k1, l1);
+        int[] aint1 = IntCache.a(k * l);
+
+        for (int i2 = 0; i2 < l; ++i2) {
+            for (int j2 = 0; j2 < k; ++j2) {
+                int k2 = aint[j2 + 1 + (i2 + 1 - 1) * (k + 2)];
+                int l2 = aint[j2 + 1 + 1 + (i2 + 1) * (k + 2)];
+                int i3 = aint[j2 + 1 - 1 + (i2 + 1) * (k + 2)];
+                int j3 = aint[j2 + 1 + (i2 + 1 + 1) * (k + 2)];
+                int k3 = aint[j2 + 1 + (i2 + 1) * k1];
+                int l3 = 0;
+
+                if (k2 == 0) {
+                    ++l3;
+                }
+
+                if (l2 == 0) {
+                    ++l3;
+                }
+
+                if (i3 == 0) {
+                    ++l3;
+                }
+
+                if (j3 == 0) {
+                    ++l3;
+                }
+
+                if (k3 == 0 && l3 > 3) {
+                    aint1[j2 + i2 * k] = BiomeBase.DEEP_OCEAN.id;
+                } else {
+                    aint1[j2 + i2 * k] = k3;
+                }
+            }
+        }
+
+        return aint1;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/GenLayerDesert.java src/main/java/net/minecraft/server/GenLayerDesert.java
--- src_origin/main/java/net/minecraft/server/GenLayerDesert.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayerDesert.java	2016-03-16 23:43:29.850124843 +0800
@@ -0,0 +1,114 @@
+package net.minecraft.server;
+
+public class GenLayerDesert extends GenLayer {
+
+    public GenLayerDesert(long i, GenLayer genlayer) {
+        super(i);
+        this.a = genlayer;
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        int[] aint = this.a.a(i - 1, j - 1, k + 2, l + 2);
+        int[] aint1 = IntCache.a(k * l);
+
+        for (int i1 = 0; i1 < l; ++i1) {
+            for (int j1 = 0; j1 < k; ++j1) {
+                this.a((long) (j1 + i), (long) (i1 + j));
+                int k1 = aint[j1 + 1 + (i1 + 1) * (k + 2)];
+
+                if (!this.a(aint, aint1, j1, i1, k, k1, BiomeBase.EXTREME_HILLS.id, BiomeBase.SMALL_MOUNTAINS.id) && !this.b(aint, aint1, j1, i1, k, k1, BiomeBase.MESA_PLATEAU_F.id, BiomeBase.MESA.id) && !this.b(aint, aint1, j1, i1, k, k1, BiomeBase.MESA_PLATEAU.id, BiomeBase.MESA.id) && !this.b(aint, aint1, j1, i1, k, k1, BiomeBase.MEGA_TAIGA.id, BiomeBase.TAIGA.id)) {
+                    int l1;
+                    int i2;
+                    int j2;
+                    int k2;
+
+                    if (k1 == BiomeBase.DESERT.id) {
+                        l1 = aint[j1 + 1 + (i1 + 1 - 1) * (k + 2)];
+                        i2 = aint[j1 + 1 + 1 + (i1 + 1) * (k + 2)];
+                        j2 = aint[j1 + 1 - 1 + (i1 + 1) * (k + 2)];
+                        k2 = aint[j1 + 1 + (i1 + 1 + 1) * (k + 2)];
+                        if (l1 != BiomeBase.ICE_PLAINS.id && i2 != BiomeBase.ICE_PLAINS.id && j2 != BiomeBase.ICE_PLAINS.id && k2 != BiomeBase.ICE_PLAINS.id) {
+                            aint1[j1 + i1 * k] = k1;
+                        } else {
+                            aint1[j1 + i1 * k] = BiomeBase.EXTREME_HILLS_PLUS.id;
+                        }
+                    } else if (k1 == BiomeBase.SWAMPLAND.id) {
+                        l1 = aint[j1 + 1 + (i1 + 1 - 1) * (k + 2)];
+                        i2 = aint[j1 + 1 + 1 + (i1 + 1) * (k + 2)];
+                        j2 = aint[j1 + 1 - 1 + (i1 + 1) * (k + 2)];
+                        k2 = aint[j1 + 1 + (i1 + 1 + 1) * (k + 2)];
+                        if (l1 != BiomeBase.DESERT.id && i2 != BiomeBase.DESERT.id && j2 != BiomeBase.DESERT.id && k2 != BiomeBase.DESERT.id && l1 != BiomeBase.COLD_TAIGA.id && i2 != BiomeBase.COLD_TAIGA.id && j2 != BiomeBase.COLD_TAIGA.id && k2 != BiomeBase.COLD_TAIGA.id && l1 != BiomeBase.ICE_PLAINS.id && i2 != BiomeBase.ICE_PLAINS.id && j2 != BiomeBase.ICE_PLAINS.id && k2 != BiomeBase.ICE_PLAINS.id) {
+                            if (l1 != BiomeBase.JUNGLE.id && k2 != BiomeBase.JUNGLE.id && i2 != BiomeBase.JUNGLE.id && j2 != BiomeBase.JUNGLE.id) {
+                                aint1[j1 + i1 * k] = k1;
+                            } else {
+                                aint1[j1 + i1 * k] = BiomeBase.JUNGLE_EDGE.id;
+                            }
+                        } else {
+                            aint1[j1 + i1 * k] = BiomeBase.PLAINS.id;
+                        }
+                    } else {
+                        aint1[j1 + i1 * k] = k1;
+                    }
+                }
+            }
+        }
+
+        return aint1;
+    }
+
+    private boolean a(int[] aint, int[] aint1, int i, int j, int k, int l, int i1, int j1) {
+        if (!a(l, i1)) {
+            return false;
+        } else {
+            int k1 = aint[i + 1 + (j + 1 - 1) * (k + 2)];
+            int l1 = aint[i + 1 + 1 + (j + 1) * (k + 2)];
+            int i2 = aint[i + 1 - 1 + (j + 1) * (k + 2)];
+            int j2 = aint[i + 1 + (j + 1 + 1) * (k + 2)];
+
+            if (this.b(k1, i1) && this.b(l1, i1) && this.b(i2, i1) && this.b(j2, i1)) {
+                aint1[i + j * k] = l;
+            } else {
+                aint1[i + j * k] = j1;
+            }
+
+            return true;
+        }
+    }
+
+    private boolean b(int[] aint, int[] aint1, int i, int j, int k, int l, int i1, int j1) {
+        if (l != i1) {
+            return false;
+        } else {
+            int k1 = aint[i + 1 + (j + 1 - 1) * (k + 2)];
+            int l1 = aint[i + 1 + 1 + (j + 1) * (k + 2)];
+            int i2 = aint[i + 1 - 1 + (j + 1) * (k + 2)];
+            int j2 = aint[i + 1 + (j + 1 + 1) * (k + 2)];
+
+            if (a(k1, i1) && a(l1, i1) && a(i2, i1) && a(j2, i1)) {
+                aint1[i + j * k] = l;
+            } else {
+                aint1[i + j * k] = j1;
+            }
+
+            return true;
+        }
+    }
+
+    private boolean b(int i, int j) {
+        if (a(i, j)) {
+            return true;
+        } else {
+            BiomeBase biomebase = BiomeBase.getBiome(i);
+            BiomeBase biomebase1 = BiomeBase.getBiome(j);
+
+            if (biomebase != null && biomebase1 != null) {
+                BiomeBase.EnumTemperature biomebase_enumtemperature = biomebase.m();
+                BiomeBase.EnumTemperature biomebase_enumtemperature1 = biomebase1.m();
+
+                return biomebase_enumtemperature == biomebase_enumtemperature1 || biomebase_enumtemperature == BiomeBase.EnumTemperature.MEDIUM || biomebase_enumtemperature1 == BiomeBase.EnumTemperature.MEDIUM;
+            } else {
+                return false;
+            }
+        }
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/GenLayerIcePlains.java src/main/java/net/minecraft/server/GenLayerIcePlains.java
--- src_origin/main/java/net/minecraft/server/GenLayerIcePlains.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayerIcePlains.java	2016-03-16 23:43:29.853124843 +0800
@@ -0,0 +1,36 @@
+package net.minecraft.server;
+
+public class GenLayerIcePlains extends GenLayer {
+
+    public GenLayerIcePlains(long i, GenLayer genlayer) {
+        super(i);
+        this.a = genlayer;
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        int i1 = i - 1;
+        int j1 = j - 1;
+        int k1 = k + 2;
+        int l1 = l + 2;
+        int[] aint = this.a.a(i1, j1, k1, l1);
+        int[] aint1 = IntCache.a(k * l);
+
+        for (int i2 = 0; i2 < l; ++i2) {
+            for (int j2 = 0; j2 < k; ++j2) {
+                int k2 = aint[j2 + 1 + (i2 + 1 - 1) * (k + 2)];
+                int l2 = aint[j2 + 1 + 1 + (i2 + 1) * (k + 2)];
+                int i3 = aint[j2 + 1 - 1 + (i2 + 1) * (k + 2)];
+                int j3 = aint[j2 + 1 + (i2 + 1 + 1) * (k + 2)];
+                int k3 = aint[j2 + 1 + (i2 + 1) * k1];
+
+                aint1[j2 + i2 * k] = k3;
+                this.a((long) (j2 + i), (long) (i2 + j));
+                if (k3 == 0 && k2 == 0 && l2 == 0 && i3 == 0 && j3 == 0 && this.a(2) == 0) {
+                    aint1[j2 + i2 * k] = 1;
+                }
+            }
+        }
+
+        return aint1;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/GenLayerIsland.java src/main/java/net/minecraft/server/GenLayerIsland.java
--- src_origin/main/java/net/minecraft/server/GenLayerIsland.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayerIsland.java	2016-03-16 23:43:29.861124843 +0800
@@ -0,0 +1,72 @@
+package net.minecraft.server;
+
+public class GenLayerIsland extends GenLayer {
+
+    public GenLayerIsland(long i, GenLayer genlayer) {
+        super(i);
+        this.a = genlayer;
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        int i1 = i - 1;
+        int j1 = j - 1;
+        int k1 = k + 2;
+        int l1 = l + 2;
+        int[] aint = this.a.a(i1, j1, k1, l1);
+        int[] aint1 = IntCache.a(k * l);
+
+        for (int i2 = 0; i2 < l; ++i2) {
+            for (int j2 = 0; j2 < k; ++j2) {
+                int k2 = aint[j2 + 0 + (i2 + 0) * k1];
+                int l2 = aint[j2 + 2 + (i2 + 0) * k1];
+                int i3 = aint[j2 + 0 + (i2 + 2) * k1];
+                int j3 = aint[j2 + 2 + (i2 + 2) * k1];
+                int k3 = aint[j2 + 1 + (i2 + 1) * k1];
+
+                this.a((long) (j2 + i), (long) (i2 + j));
+                if (k3 == 0 && (k2 != 0 || l2 != 0 || i3 != 0 || j3 != 0)) {
+                    int l3 = 1;
+                    int i4 = 1;
+
+                    if (k2 != 0 && this.a(l3++) == 0) {
+                        i4 = k2;
+                    }
+
+                    if (l2 != 0 && this.a(l3++) == 0) {
+                        i4 = l2;
+                    }
+
+                    if (i3 != 0 && this.a(l3++) == 0) {
+                        i4 = i3;
+                    }
+
+                    if (j3 != 0 && this.a(l3++) == 0) {
+                        i4 = j3;
+                    }
+
+                    if (this.a(3) == 0) {
+                        aint1[j2 + i2 * k] = i4;
+                    } else if (i4 == 4) {
+                        aint1[j2 + i2 * k] = 4;
+                    } else {
+                        aint1[j2 + i2 * k] = 0;
+                    }
+                } else if (k3 > 0 && (k2 == 0 || l2 == 0 || i3 == 0 || j3 == 0)) {
+                    if (this.a(5) == 0) {
+                        if (k3 == 4) {
+                            aint1[j2 + i2 * k] = 4;
+                        } else {
+                            aint1[j2 + i2 * k] = 0;
+                        }
+                    } else {
+                        aint1[j2 + i2 * k] = k3;
+                    }
+                } else {
+                    aint1[j2 + i2 * k] = k3;
+                }
+            }
+        }
+
+        return aint1;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/GenLayer.java src/main/java/net/minecraft/server/GenLayer.java
--- src_origin/main/java/net/minecraft/server/GenLayer.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayer.java	2016-03-16 23:43:29.834124843 +0800
@@ -0,0 +1,184 @@
+package net.minecraft.server;
+
+import java.util.concurrent.Callable;
+
+public abstract class GenLayer {
+
+    private long c;
+    protected GenLayer a;
+    private long d;
+    protected long b;
+
+    public static GenLayer[] a(long i, WorldType worldtype, String s) {
+        LayerIsland layerisland = new LayerIsland(1L);
+        GenLayerZoomFuzzy genlayerzoomfuzzy = new GenLayerZoomFuzzy(2000L, layerisland);
+        GenLayerIsland genlayerisland = new GenLayerIsland(1L, genlayerzoomfuzzy);
+        GenLayerZoom genlayerzoom = new GenLayerZoom(2001L, genlayerisland);
+
+        genlayerisland = new GenLayerIsland(2L, genlayerzoom);
+        genlayerisland = new GenLayerIsland(50L, genlayerisland);
+        genlayerisland = new GenLayerIsland(70L, genlayerisland);
+        GenLayerIcePlains genlayericeplains = new GenLayerIcePlains(2L, genlayerisland);
+        GenLayerTopSoil genlayertopsoil = new GenLayerTopSoil(2L, genlayericeplains);
+
+        genlayerisland = new GenLayerIsland(3L, genlayertopsoil);
+        GenLayerSpecial genlayerspecial = new GenLayerSpecial(2L, genlayerisland, GenLayerSpecial.EnumGenLayerSpecial.COOL_WARM);
+
+        genlayerspecial = new GenLayerSpecial(2L, genlayerspecial, GenLayerSpecial.EnumGenLayerSpecial.HEAT_ICE);
+        genlayerspecial = new GenLayerSpecial(3L, genlayerspecial, GenLayerSpecial.EnumGenLayerSpecial.SPECIAL);
+        genlayerzoom = new GenLayerZoom(2002L, genlayerspecial);
+        genlayerzoom = new GenLayerZoom(2003L, genlayerzoom);
+        genlayerisland = new GenLayerIsland(4L, genlayerzoom);
+        GenLayerMushroomIsland genlayermushroomisland = new GenLayerMushroomIsland(5L, genlayerisland);
+        GenLayerDeepOcean genlayerdeepocean = new GenLayerDeepOcean(4L, genlayermushroomisland);
+        GenLayer genlayer = GenLayerZoom.b(1000L, genlayerdeepocean, 0);
+        CustomWorldSettingsFinal customworldsettingsfinal = null;
+        int j = 4;
+        int k = j;
+
+        if (worldtype == WorldType.CUSTOMIZED && s.length() > 0) {
+            customworldsettingsfinal = CustomWorldSettingsFinal.CustomWorldSettings.a(s).b();
+            j = customworldsettingsfinal.G;
+            k = customworldsettingsfinal.H;
+        }
+
+        if (worldtype == WorldType.LARGE_BIOMES) {
+            j = 6;
+        }
+
+        GenLayer genlayer1 = GenLayerZoom.b(1000L, genlayer, 0);
+        GenLayerCleaner genlayercleaner = new GenLayerCleaner(100L, genlayer1);
+        GenLayerBiome genlayerbiome = new GenLayerBiome(200L, genlayer, worldtype, s);
+        GenLayer genlayer2 = GenLayerZoom.b(1000L, genlayerbiome, 2);
+        GenLayerDesert genlayerdesert = new GenLayerDesert(1000L, genlayer2);
+        GenLayer genlayer3 = GenLayerZoom.b(1000L, genlayercleaner, 2);
+        GenLayerRegionHills genlayerregionhills = new GenLayerRegionHills(1000L, genlayerdesert, genlayer3);
+
+        genlayer1 = GenLayerZoom.b(1000L, genlayercleaner, 2);
+        genlayer1 = GenLayerZoom.b(1000L, genlayer1, k);
+        GenLayerRiver genlayerriver = new GenLayerRiver(1L, genlayer1);
+        GenLayerSmooth genlayersmooth = new GenLayerSmooth(1000L, genlayerriver);
+        Object object = new GenLayerPlains(1001L, genlayerregionhills);
+
+        for (int l = 0; l < j; ++l) {
+            object = new GenLayerZoom((long) (1000 + l), (GenLayer) object);
+            if (l == 0) {
+                object = new GenLayerIsland(3L, (GenLayer) object);
+            }
+
+            if (l == 1 || j == 1) {
+                object = new GenLayerMushroomShore(1000L, (GenLayer) object);
+            }
+        }
+
+        GenLayerSmooth genlayersmooth1 = new GenLayerSmooth(1000L, (GenLayer) object);
+        GenLayerRiverMix genlayerrivermix = new GenLayerRiverMix(100L, genlayersmooth1, genlayersmooth);
+        GenLayerZoomVoronoi genlayerzoomvoronoi = new GenLayerZoomVoronoi(10L, genlayerrivermix);
+
+        genlayerrivermix.a(i);
+        genlayerzoomvoronoi.a(i);
+        return new GenLayer[] { genlayerrivermix, genlayerzoomvoronoi, genlayerrivermix};
+    }
+
+    public GenLayer(long i) {
+        this.b = i;
+        this.b *= this.b * 6364136223846793005L + 1442695040888963407L;
+        this.b += i;
+        this.b *= this.b * 6364136223846793005L + 1442695040888963407L;
+        this.b += i;
+        this.b *= this.b * 6364136223846793005L + 1442695040888963407L;
+        this.b += i;
+    }
+
+    public void a(long i) {
+        this.c = i;
+        if (this.a != null) {
+            this.a.a(i);
+        }
+
+        this.c *= this.c * 6364136223846793005L + 1442695040888963407L;
+        this.c += this.b;
+        this.c *= this.c * 6364136223846793005L + 1442695040888963407L;
+        this.c += this.b;
+        this.c *= this.c * 6364136223846793005L + 1442695040888963407L;
+        this.c += this.b;
+    }
+
+    public void a(long i, long j) {
+        this.d = this.c;
+        this.d *= this.d * 6364136223846793005L + 1442695040888963407L;
+        this.d += i;
+        this.d *= this.d * 6364136223846793005L + 1442695040888963407L;
+        this.d += j;
+        this.d *= this.d * 6364136223846793005L + 1442695040888963407L;
+        this.d += i;
+        this.d *= this.d * 6364136223846793005L + 1442695040888963407L;
+        this.d += j;
+    }
+
+    protected int a(int i) {
+        int j = (int) ((this.d >> 24) % (long) i);
+
+        if (j < 0) {
+            j += i;
+        }
+
+        this.d *= this.d * 6364136223846793005L + 1442695040888963407L;
+        this.d += this.c;
+        return j;
+    }
+
+    public abstract int[] a(int i, int j, int k, int l);
+
+    protected static boolean a(int i, int j) {
+        if (i == j) {
+            return true;
+        } else if (i != BiomeBase.MESA_PLATEAU_F.id && i != BiomeBase.MESA_PLATEAU.id) {
+            final BiomeBase biomebase = BiomeBase.getBiome(i);
+            final BiomeBase biomebase1 = BiomeBase.getBiome(j);
+
+            try {
+                return biomebase != null && biomebase1 != null ? biomebase.a(biomebase1) : false;
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Comparing biomes");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Biomes being compared");
+
+                crashreportsystemdetails.a("Biome A ID", (Object) Integer.valueOf(i));
+                crashreportsystemdetails.a("Biome B ID", (Object) Integer.valueOf(j));
+                crashreportsystemdetails.a("Biome A", new Callable() {
+                    public String a() throws Exception {
+                        return String.valueOf(biomebase);
+                    }
+
+                    public Object call() throws Exception {
+                        return this.a();
+                    }
+                });
+                crashreportsystemdetails.a("Biome B", new Callable() {
+                    public String a() throws Exception {
+                        return String.valueOf(biomebase);
+                    }
+
+                    public Object call() throws Exception {
+                        return this.a();
+                    }
+                });
+                throw new ReportedException(crashreport);
+            }
+        } else {
+            return j == BiomeBase.MESA_PLATEAU_F.id || j == BiomeBase.MESA_PLATEAU.id;
+        }
+    }
+
+    protected static boolean b(int i) {
+        return i == BiomeBase.OCEAN.id || i == BiomeBase.DEEP_OCEAN.id || i == BiomeBase.FROZEN_OCEAN.id;
+    }
+
+    protected int a(int... aint) {
+        return aint[this.a(aint.length)];
+    }
+
+    protected int b(int i, int j, int k, int l) {
+        return j == k && k == l ? j : (i == j && i == k ? i : (i == j && i == l ? i : (i == k && i == l ? i : (i == j && k != l ? i : (i == k && j != l ? i : (i == l && j != k ? i : (j == k && i != l ? j : (j == l && i != k ? j : (k == l && i != j ? k : this.a(new int[] { i, j, k, l}))))))))));
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/GenLayerMushroomIsland.java src/main/java/net/minecraft/server/GenLayerMushroomIsland.java
--- src_origin/main/java/net/minecraft/server/GenLayerMushroomIsland.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayerMushroomIsland.java	2016-03-16 23:43:29.861124843 +0800
@@ -0,0 +1,37 @@
+package net.minecraft.server;
+
+public class GenLayerMushroomIsland extends GenLayer {
+
+    public GenLayerMushroomIsland(long i, GenLayer genlayer) {
+        super(i);
+        this.a = genlayer;
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        int i1 = i - 1;
+        int j1 = j - 1;
+        int k1 = k + 2;
+        int l1 = l + 2;
+        int[] aint = this.a.a(i1, j1, k1, l1);
+        int[] aint1 = IntCache.a(k * l);
+
+        for (int i2 = 0; i2 < l; ++i2) {
+            for (int j2 = 0; j2 < k; ++j2) {
+                int k2 = aint[j2 + 0 + (i2 + 0) * k1];
+                int l2 = aint[j2 + 2 + (i2 + 0) * k1];
+                int i3 = aint[j2 + 0 + (i2 + 2) * k1];
+                int j3 = aint[j2 + 2 + (i2 + 2) * k1];
+                int k3 = aint[j2 + 1 + (i2 + 1) * k1];
+
+                this.a((long) (j2 + i), (long) (i2 + j));
+                if (k3 == 0 && k2 == 0 && l2 == 0 && i3 == 0 && j3 == 0 && this.a(100) == 0) {
+                    aint1[j2 + i2 * k] = BiomeBase.MUSHROOM_ISLAND.id;
+                } else {
+                    aint1[j2 + i2 * k] = k3;
+                }
+            }
+        }
+
+        return aint1;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/GenLayerMushroomShore.java src/main/java/net/minecraft/server/GenLayerMushroomShore.java
--- src_origin/main/java/net/minecraft/server/GenLayerMushroomShore.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayerMushroomShore.java	2016-03-16 23:43:29.870124843 +0800
@@ -0,0 +1,114 @@
+package net.minecraft.server;
+
+public class GenLayerMushroomShore extends GenLayer {
+
+    public GenLayerMushroomShore(long i, GenLayer genlayer) {
+        super(i);
+        this.a = genlayer;
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        int[] aint = this.a.a(i - 1, j - 1, k + 2, l + 2);
+        int[] aint1 = IntCache.a(k * l);
+
+        for (int i1 = 0; i1 < l; ++i1) {
+            for (int j1 = 0; j1 < k; ++j1) {
+                this.a((long) (j1 + i), (long) (i1 + j));
+                int k1 = aint[j1 + 1 + (i1 + 1) * (k + 2)];
+                BiomeBase biomebase = BiomeBase.getBiome(k1);
+                int l1;
+                int i2;
+                int j2;
+                int k2;
+
+                if (k1 == BiomeBase.MUSHROOM_ISLAND.id) {
+                    l1 = aint[j1 + 1 + (i1 + 1 - 1) * (k + 2)];
+                    i2 = aint[j1 + 1 + 1 + (i1 + 1) * (k + 2)];
+                    j2 = aint[j1 + 1 - 1 + (i1 + 1) * (k + 2)];
+                    k2 = aint[j1 + 1 + (i1 + 1 + 1) * (k + 2)];
+                    if (l1 != BiomeBase.OCEAN.id && i2 != BiomeBase.OCEAN.id && j2 != BiomeBase.OCEAN.id && k2 != BiomeBase.OCEAN.id) {
+                        aint1[j1 + i1 * k] = k1;
+                    } else {
+                        aint1[j1 + i1 * k] = BiomeBase.MUSHROOM_SHORE.id;
+                    }
+                } else if (biomebase != null && biomebase.l() == BiomeJungle.class) {
+                    l1 = aint[j1 + 1 + (i1 + 1 - 1) * (k + 2)];
+                    i2 = aint[j1 + 1 + 1 + (i1 + 1) * (k + 2)];
+                    j2 = aint[j1 + 1 - 1 + (i1 + 1) * (k + 2)];
+                    k2 = aint[j1 + 1 + (i1 + 1 + 1) * (k + 2)];
+                    if (this.c(l1) && this.c(i2) && this.c(j2) && this.c(k2)) {
+                        if (!b(l1) && !b(i2) && !b(j2) && !b(k2)) {
+                            aint1[j1 + i1 * k] = k1;
+                        } else {
+                            aint1[j1 + i1 * k] = BiomeBase.BEACH.id;
+                        }
+                    } else {
+                        aint1[j1 + i1 * k] = BiomeBase.JUNGLE_EDGE.id;
+                    }
+                } else if (k1 != BiomeBase.EXTREME_HILLS.id && k1 != BiomeBase.EXTREME_HILLS_PLUS.id && k1 != BiomeBase.SMALL_MOUNTAINS.id) {
+                    if (biomebase != null && biomebase.j()) {
+                        this.a(aint, aint1, j1, i1, k, k1, BiomeBase.COLD_BEACH.id);
+                    } else if (k1 != BiomeBase.MESA.id && k1 != BiomeBase.MESA_PLATEAU_F.id) {
+                        if (k1 != BiomeBase.OCEAN.id && k1 != BiomeBase.DEEP_OCEAN.id && k1 != BiomeBase.RIVER.id && k1 != BiomeBase.SWAMPLAND.id) {
+                            l1 = aint[j1 + 1 + (i1 + 1 - 1) * (k + 2)];
+                            i2 = aint[j1 + 1 + 1 + (i1 + 1) * (k + 2)];
+                            j2 = aint[j1 + 1 - 1 + (i1 + 1) * (k + 2)];
+                            k2 = aint[j1 + 1 + (i1 + 1 + 1) * (k + 2)];
+                            if (!b(l1) && !b(i2) && !b(j2) && !b(k2)) {
+                                aint1[j1 + i1 * k] = k1;
+                            } else {
+                                aint1[j1 + i1 * k] = BiomeBase.BEACH.id;
+                            }
+                        } else {
+                            aint1[j1 + i1 * k] = k1;
+                        }
+                    } else {
+                        l1 = aint[j1 + 1 + (i1 + 1 - 1) * (k + 2)];
+                        i2 = aint[j1 + 1 + 1 + (i1 + 1) * (k + 2)];
+                        j2 = aint[j1 + 1 - 1 + (i1 + 1) * (k + 2)];
+                        k2 = aint[j1 + 1 + (i1 + 1 + 1) * (k + 2)];
+                        if (!b(l1) && !b(i2) && !b(j2) && !b(k2)) {
+                            if (this.d(l1) && this.d(i2) && this.d(j2) && this.d(k2)) {
+                                aint1[j1 + i1 * k] = k1;
+                            } else {
+                                aint1[j1 + i1 * k] = BiomeBase.DESERT.id;
+                            }
+                        } else {
+                            aint1[j1 + i1 * k] = k1;
+                        }
+                    }
+                } else {
+                    this.a(aint, aint1, j1, i1, k, k1, BiomeBase.STONE_BEACH.id);
+                }
+            }
+        }
+
+        return aint1;
+    }
+
+    private void a(int[] aint, int[] aint1, int i, int j, int k, int l, int i1) {
+        if (b(l)) {
+            aint1[i + j * k] = l;
+        } else {
+            int j1 = aint[i + 1 + (j + 1 - 1) * (k + 2)];
+            int k1 = aint[i + 1 + 1 + (j + 1) * (k + 2)];
+            int l1 = aint[i + 1 - 1 + (j + 1) * (k + 2)];
+            int i2 = aint[i + 1 + (j + 1 + 1) * (k + 2)];
+
+            if (!b(j1) && !b(k1) && !b(l1) && !b(i2)) {
+                aint1[i + j * k] = l;
+            } else {
+                aint1[i + j * k] = i1;
+            }
+
+        }
+    }
+
+    private boolean c(int i) {
+        return BiomeBase.getBiome(i) != null && BiomeBase.getBiome(i).l() == BiomeJungle.class ? true : i == BiomeBase.JUNGLE_EDGE.id || i == BiomeBase.JUNGLE.id || i == BiomeBase.JUNGLE_HILLS.id || i == BiomeBase.FOREST.id || i == BiomeBase.TAIGA.id || b(i);
+    }
+
+    private boolean d(int i) {
+        return BiomeBase.getBiome(i) instanceof BiomeMesa;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/GenLayerPlains.java src/main/java/net/minecraft/server/GenLayerPlains.java
--- src_origin/main/java/net/minecraft/server/GenLayerPlains.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayerPlains.java	2016-03-16 23:43:29.877124843 +0800
@@ -0,0 +1,33 @@
+package net.minecraft.server;
+
+public class GenLayerPlains extends GenLayer {
+
+    public GenLayerPlains(long i, GenLayer genlayer) {
+        super(i);
+        this.a = genlayer;
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        int[] aint = this.a.a(i - 1, j - 1, k + 2, l + 2);
+        int[] aint1 = IntCache.a(k * l);
+
+        for (int i1 = 0; i1 < l; ++i1) {
+            for (int j1 = 0; j1 < k; ++j1) {
+                this.a((long) (j1 + i), (long) (i1 + j));
+                int k1 = aint[j1 + 1 + (i1 + 1) * (k + 2)];
+
+                if (this.a(57) == 0) {
+                    if (k1 == BiomeBase.PLAINS.id) {
+                        aint1[j1 + i1 * k] = BiomeBase.PLAINS.id + 128;
+                    } else {
+                        aint1[j1 + i1 * k] = k1;
+                    }
+                } else {
+                    aint1[j1 + i1 * k] = k1;
+                }
+            }
+        }
+
+        return aint1;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/GenLayerRegionHills.java src/main/java/net/minecraft/server/GenLayerRegionHills.java
--- src_origin/main/java/net/minecraft/server/GenLayerRegionHills.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayerRegionHills.java	2016-03-16 23:43:29.878124843 +0800
@@ -0,0 +1,131 @@
+package net.minecraft.server;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public class GenLayerRegionHills extends GenLayer {
+
+    private static final Logger c = LogManager.getLogger();
+    private GenLayer d;
+
+    public GenLayerRegionHills(long i, GenLayer genlayer, GenLayer genlayer1) {
+        super(i);
+        this.a = genlayer;
+        this.d = genlayer1;
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        int[] aint = this.a.a(i - 1, j - 1, k + 2, l + 2);
+        int[] aint1 = this.d.a(i - 1, j - 1, k + 2, l + 2);
+        int[] aint2 = IntCache.a(k * l);
+
+        for (int i1 = 0; i1 < l; ++i1) {
+            for (int j1 = 0; j1 < k; ++j1) {
+                this.a((long) (j1 + i), (long) (i1 + j));
+                int k1 = aint[j1 + 1 + (i1 + 1) * (k + 2)];
+                int l1 = aint1[j1 + 1 + (i1 + 1) * (k + 2)];
+                boolean flag = (l1 - 2) % 29 == 0;
+
+                if (k1 > 255) {
+                    GenLayerRegionHills.c.debug("old! " + k1);
+                }
+
+                if (k1 != 0 && l1 >= 2 && (l1 - 2) % 29 == 1 && k1 < 128) {
+                    if (BiomeBase.getBiome(k1 + 128) != null) {
+                        aint2[j1 + i1 * k] = k1 + 128;
+                    } else {
+                        aint2[j1 + i1 * k] = k1;
+                    }
+                } else if (this.a(3) != 0 && !flag) {
+                    aint2[j1 + i1 * k] = k1;
+                } else {
+                    int i2 = k1;
+                    int j2;
+
+                    if (k1 == BiomeBase.DESERT.id) {
+                        i2 = BiomeBase.DESERT_HILLS.id;
+                    } else if (k1 == BiomeBase.FOREST.id) {
+                        i2 = BiomeBase.FOREST_HILLS.id;
+                    } else if (k1 == BiomeBase.BIRCH_FOREST.id) {
+                        i2 = BiomeBase.BIRCH_FOREST_HILLS.id;
+                    } else if (k1 == BiomeBase.ROOFED_FOREST.id) {
+                        i2 = BiomeBase.PLAINS.id;
+                    } else if (k1 == BiomeBase.TAIGA.id) {
+                        i2 = BiomeBase.TAIGA_HILLS.id;
+                    } else if (k1 == BiomeBase.MEGA_TAIGA.id) {
+                        i2 = BiomeBase.MEGA_TAIGA_HILLS.id;
+                    } else if (k1 == BiomeBase.COLD_TAIGA.id) {
+                        i2 = BiomeBase.COLD_TAIGA_HILLS.id;
+                    } else if (k1 == BiomeBase.PLAINS.id) {
+                        if (this.a(3) == 0) {
+                            i2 = BiomeBase.FOREST_HILLS.id;
+                        } else {
+                            i2 = BiomeBase.FOREST.id;
+                        }
+                    } else if (k1 == BiomeBase.ICE_PLAINS.id) {
+                        i2 = BiomeBase.ICE_MOUNTAINS.id;
+                    } else if (k1 == BiomeBase.JUNGLE.id) {
+                        i2 = BiomeBase.JUNGLE_HILLS.id;
+                    } else if (k1 == BiomeBase.OCEAN.id) {
+                        i2 = BiomeBase.DEEP_OCEAN.id;
+                    } else if (k1 == BiomeBase.EXTREME_HILLS.id) {
+                        i2 = BiomeBase.EXTREME_HILLS_PLUS.id;
+                    } else if (k1 == BiomeBase.SAVANNA.id) {
+                        i2 = BiomeBase.SAVANNA_PLATEAU.id;
+                    } else if (a(k1, BiomeBase.MESA_PLATEAU_F.id)) {
+                        i2 = BiomeBase.MESA.id;
+                    } else if (k1 == BiomeBase.DEEP_OCEAN.id && this.a(3) == 0) {
+                        j2 = this.a(2);
+                        if (j2 == 0) {
+                            i2 = BiomeBase.PLAINS.id;
+                        } else {
+                            i2 = BiomeBase.FOREST.id;
+                        }
+                    }
+
+                    if (flag && i2 != k1) {
+                        if (BiomeBase.getBiome(i2 + 128) != null) {
+                            i2 += 128;
+                        } else {
+                            i2 = k1;
+                        }
+                    }
+
+                    if (i2 == k1) {
+                        aint2[j1 + i1 * k] = k1;
+                    } else {
+                        j2 = aint[j1 + 1 + (i1 + 1 - 1) * (k + 2)];
+                        int k2 = aint[j1 + 1 + 1 + (i1 + 1) * (k + 2)];
+                        int l2 = aint[j1 + 1 - 1 + (i1 + 1) * (k + 2)];
+                        int i3 = aint[j1 + 1 + (i1 + 1 + 1) * (k + 2)];
+                        int j3 = 0;
+
+                        if (a(j2, k1)) {
+                            ++j3;
+                        }
+
+                        if (a(k2, k1)) {
+                            ++j3;
+                        }
+
+                        if (a(l2, k1)) {
+                            ++j3;
+                        }
+
+                        if (a(i3, k1)) {
+                            ++j3;
+                        }
+
+                        if (j3 >= 3) {
+                            aint2[j1 + i1 * k] = i2;
+                        } else {
+                            aint2[j1 + i1 * k] = k1;
+                        }
+                    }
+                }
+            }
+        }
+
+        return aint2;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/GenLayerRiver.java src/main/java/net/minecraft/server/GenLayerRiver.java
--- src_origin/main/java/net/minecraft/server/GenLayerRiver.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayerRiver.java	2016-03-16 23:43:29.881124843 +0800
@@ -0,0 +1,40 @@
+package net.minecraft.server;
+
+public class GenLayerRiver extends GenLayer {
+
+    public GenLayerRiver(long i, GenLayer genlayer) {
+        super(i);
+        super.a = genlayer;
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        int i1 = i - 1;
+        int j1 = j - 1;
+        int k1 = k + 2;
+        int l1 = l + 2;
+        int[] aint = this.a.a(i1, j1, k1, l1);
+        int[] aint1 = IntCache.a(k * l);
+
+        for (int i2 = 0; i2 < l; ++i2) {
+            for (int j2 = 0; j2 < k; ++j2) {
+                int k2 = this.c(aint[j2 + 0 + (i2 + 1) * k1]);
+                int l2 = this.c(aint[j2 + 2 + (i2 + 1) * k1]);
+                int i3 = this.c(aint[j2 + 1 + (i2 + 0) * k1]);
+                int j3 = this.c(aint[j2 + 1 + (i2 + 2) * k1]);
+                int k3 = this.c(aint[j2 + 1 + (i2 + 1) * k1]);
+
+                if (k3 == k2 && k3 == i3 && k3 == l2 && k3 == j3) {
+                    aint1[j2 + i2 * k] = -1;
+                } else {
+                    aint1[j2 + i2 * k] = BiomeBase.RIVER.id;
+                }
+            }
+        }
+
+        return aint1;
+    }
+
+    private int c(int i) {
+        return i >= 2 ? 2 + (i & 1) : i;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/GenLayerRiverMix.java src/main/java/net/minecraft/server/GenLayerRiverMix.java
--- src_origin/main/java/net/minecraft/server/GenLayerRiverMix.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayerRiverMix.java	2016-03-16 23:43:29.881124843 +0800
@@ -0,0 +1,45 @@
+package net.minecraft.server;
+
+public class GenLayerRiverMix extends GenLayer {
+
+    private GenLayer c;
+    private GenLayer d;
+
+    public GenLayerRiverMix(long i, GenLayer genlayer, GenLayer genlayer1) {
+        super(i);
+        this.c = genlayer;
+        this.d = genlayer1;
+    }
+
+    public void a(long i) {
+        this.c.a(i);
+        this.d.a(i);
+        super.a(i);
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        int[] aint = this.c.a(i, j, k, l);
+        int[] aint1 = this.d.a(i, j, k, l);
+        int[] aint2 = IntCache.a(k * l);
+
+        for (int i1 = 0; i1 < k * l; ++i1) {
+            if (aint[i1] != BiomeBase.OCEAN.id && aint[i1] != BiomeBase.DEEP_OCEAN.id) {
+                if (aint1[i1] == BiomeBase.RIVER.id) {
+                    if (aint[i1] == BiomeBase.ICE_PLAINS.id) {
+                        aint2[i1] = BiomeBase.FROZEN_RIVER.id;
+                    } else if (aint[i1] != BiomeBase.MUSHROOM_ISLAND.id && aint[i1] != BiomeBase.MUSHROOM_SHORE.id) {
+                        aint2[i1] = aint1[i1] & 255;
+                    } else {
+                        aint2[i1] = BiomeBase.MUSHROOM_SHORE.id;
+                    }
+                } else {
+                    aint2[i1] = aint[i1];
+                }
+            } else {
+                aint2[i1] = aint[i1];
+            }
+        }
+
+        return aint2;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/GenLayerSmooth.java src/main/java/net/minecraft/server/GenLayerSmooth.java
--- src_origin/main/java/net/minecraft/server/GenLayerSmooth.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayerSmooth.java	2016-03-16 23:43:29.889124843 +0800
@@ -0,0 +1,49 @@
+package net.minecraft.server;
+
+public class GenLayerSmooth extends GenLayer {
+
+    public GenLayerSmooth(long i, GenLayer genlayer) {
+        super(i);
+        super.a = genlayer;
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        int i1 = i - 1;
+        int j1 = j - 1;
+        int k1 = k + 2;
+        int l1 = l + 2;
+        int[] aint = this.a.a(i1, j1, k1, l1);
+        int[] aint1 = IntCache.a(k * l);
+
+        for (int i2 = 0; i2 < l; ++i2) {
+            for (int j2 = 0; j2 < k; ++j2) {
+                int k2 = aint[j2 + 0 + (i2 + 1) * k1];
+                int l2 = aint[j2 + 2 + (i2 + 1) * k1];
+                int i3 = aint[j2 + 1 + (i2 + 0) * k1];
+                int j3 = aint[j2 + 1 + (i2 + 2) * k1];
+                int k3 = aint[j2 + 1 + (i2 + 1) * k1];
+
+                if (k2 == l2 && i3 == j3) {
+                    this.a((long) (j2 + i), (long) (i2 + j));
+                    if (this.a(2) == 0) {
+                        k3 = k2;
+                    } else {
+                        k3 = i3;
+                    }
+                } else {
+                    if (k2 == l2) {
+                        k3 = k2;
+                    }
+
+                    if (i3 == j3) {
+                        k3 = i3;
+                    }
+                }
+
+                aint1[j2 + i2 * k] = k3;
+            }
+        }
+
+        return aint1;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/GenLayerSpecial.java src/main/java/net/minecraft/server/GenLayerSpecial.java
--- src_origin/main/java/net/minecraft/server/GenLayerSpecial.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayerSpecial.java	2016-03-16 23:43:29.894124843 +0800
@@ -0,0 +1,144 @@
+package net.minecraft.server;
+
+public class GenLayerSpecial extends GenLayer {
+
+    private final GenLayerSpecial.EnumGenLayerSpecial c;
+
+    public GenLayerSpecial(long i, GenLayer genlayer, GenLayerSpecial.EnumGenLayerSpecial genlayerspecial_enumgenlayerspecial) {
+        super(i);
+        this.a = genlayer;
+        this.c = genlayerspecial_enumgenlayerspecial;
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        switch (GenLayerSpecial.SyntheticClass_1.a[this.c.ordinal()]) {
+        case 1:
+        default:
+            return this.c(i, j, k, l);
+
+        case 2:
+            return this.d(i, j, k, l);
+
+        case 3:
+            return this.e(i, j, k, l);
+        }
+    }
+
+    private int[] c(int i, int j, int k, int l) {
+        int i1 = i - 1;
+        int j1 = j - 1;
+        int k1 = 1 + k + 1;
+        int l1 = 1 + l + 1;
+        int[] aint = this.a.a(i1, j1, k1, l1);
+        int[] aint1 = IntCache.a(k * l);
+
+        for (int i2 = 0; i2 < l; ++i2) {
+            for (int j2 = 0; j2 < k; ++j2) {
+                this.a((long) (j2 + i), (long) (i2 + j));
+                int k2 = aint[j2 + 1 + (i2 + 1) * k1];
+
+                if (k2 == 1) {
+                    int l2 = aint[j2 + 1 + (i2 + 1 - 1) * k1];
+                    int i3 = aint[j2 + 1 + 1 + (i2 + 1) * k1];
+                    int j3 = aint[j2 + 1 - 1 + (i2 + 1) * k1];
+                    int k3 = aint[j2 + 1 + (i2 + 1 + 1) * k1];
+                    boolean flag = l2 == 3 || i3 == 3 || j3 == 3 || k3 == 3;
+                    boolean flag1 = l2 == 4 || i3 == 4 || j3 == 4 || k3 == 4;
+
+                    if (flag || flag1) {
+                        k2 = 2;
+                    }
+                }
+
+                aint1[j2 + i2 * k] = k2;
+            }
+        }
+
+        return aint1;
+    }
+
+    private int[] d(int i, int j, int k, int l) {
+        int i1 = i - 1;
+        int j1 = j - 1;
+        int k1 = 1 + k + 1;
+        int l1 = 1 + l + 1;
+        int[] aint = this.a.a(i1, j1, k1, l1);
+        int[] aint1 = IntCache.a(k * l);
+
+        for (int i2 = 0; i2 < l; ++i2) {
+            for (int j2 = 0; j2 < k; ++j2) {
+                int k2 = aint[j2 + 1 + (i2 + 1) * k1];
+
+                if (k2 == 4) {
+                    int l2 = aint[j2 + 1 + (i2 + 1 - 1) * k1];
+                    int i3 = aint[j2 + 1 + 1 + (i2 + 1) * k1];
+                    int j3 = aint[j2 + 1 - 1 + (i2 + 1) * k1];
+                    int k3 = aint[j2 + 1 + (i2 + 1 + 1) * k1];
+                    boolean flag = l2 == 2 || i3 == 2 || j3 == 2 || k3 == 2;
+                    boolean flag1 = l2 == 1 || i3 == 1 || j3 == 1 || k3 == 1;
+
+                    if (flag1 || flag) {
+                        k2 = 3;
+                    }
+                }
+
+                aint1[j2 + i2 * k] = k2;
+            }
+        }
+
+        return aint1;
+    }
+
+    private int[] e(int i, int j, int k, int l) {
+        int[] aint = this.a.a(i, j, k, l);
+        int[] aint1 = IntCache.a(k * l);
+
+        for (int i1 = 0; i1 < l; ++i1) {
+            for (int j1 = 0; j1 < k; ++j1) {
+                this.a((long) (j1 + i), (long) (i1 + j));
+                int k1 = aint[j1 + i1 * k];
+
+                if (k1 != 0 && this.a(13) == 0) {
+                    k1 |= 1 + this.a(15) << 8 & 3840;
+                }
+
+                aint1[j1 + i1 * k] = k1;
+            }
+        }
+
+        return aint1;
+    }
+
+    static class SyntheticClass_1 {
+
+        static final int[] a = new int[GenLayerSpecial.EnumGenLayerSpecial.values().length];
+
+        static {
+            try {
+                GenLayerSpecial.SyntheticClass_1.a[GenLayerSpecial.EnumGenLayerSpecial.COOL_WARM.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror) {
+                ;
+            }
+
+            try {
+                GenLayerSpecial.SyntheticClass_1.a[GenLayerSpecial.EnumGenLayerSpecial.HEAT_ICE.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror1) {
+                ;
+            }
+
+            try {
+                GenLayerSpecial.SyntheticClass_1.a[GenLayerSpecial.EnumGenLayerSpecial.SPECIAL.ordinal()] = 3;
+            } catch (NoSuchFieldError nosuchfielderror2) {
+                ;
+            }
+
+        }
+    }
+
+    public static enum EnumGenLayerSpecial {
+
+        COOL_WARM, HEAT_ICE, SPECIAL;
+
+        private EnumGenLayerSpecial() {}
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/GenLayerTopSoil.java src/main/java/net/minecraft/server/GenLayerTopSoil.java
--- src_origin/main/java/net/minecraft/server/GenLayerTopSoil.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayerTopSoil.java	2016-03-16 23:43:29.897124843 +0800
@@ -0,0 +1,44 @@
+package net.minecraft.server;
+
+public class GenLayerTopSoil extends GenLayer {
+
+    public GenLayerTopSoil(long i, GenLayer genlayer) {
+        super(i);
+        this.a = genlayer;
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        int i1 = i - 1;
+        int j1 = j - 1;
+        int k1 = k + 2;
+        int l1 = l + 2;
+        int[] aint = this.a.a(i1, j1, k1, l1);
+        int[] aint1 = IntCache.a(k * l);
+
+        for (int i2 = 0; i2 < l; ++i2) {
+            for (int j2 = 0; j2 < k; ++j2) {
+                int k2 = aint[j2 + 1 + (i2 + 1) * k1];
+
+                this.a((long) (j2 + i), (long) (i2 + j));
+                if (k2 == 0) {
+                    aint1[j2 + i2 * k] = 0;
+                } else {
+                    int l2 = this.a(6);
+                    byte b0;
+
+                    if (l2 == 0) {
+                        b0 = 4;
+                    } else if (l2 <= 1) {
+                        b0 = 3;
+                    } else {
+                        b0 = 1;
+                    }
+
+                    aint1[j2 + i2 * k] = b0;
+                }
+            }
+        }
+
+        return aint1;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/GenLayerZoomFuzzy.java src/main/java/net/minecraft/server/GenLayerZoomFuzzy.java
--- src_origin/main/java/net/minecraft/server/GenLayerZoomFuzzy.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayerZoomFuzzy.java	2016-03-16 23:43:29.905124843 +0800
@@ -0,0 +1,12 @@
+package net.minecraft.server;
+
+public class GenLayerZoomFuzzy extends GenLayerZoom {
+
+    public GenLayerZoomFuzzy(long i, GenLayer genlayer) {
+        super(i, genlayer);
+    }
+
+    protected int b(int i, int j, int k, int l) {
+        return this.a(new int[] { i, j, k, l});
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/GenLayerZoom.java src/main/java/net/minecraft/server/GenLayerZoom.java
--- src_origin/main/java/net/minecraft/server/GenLayerZoom.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayerZoom.java	2016-03-16 23:43:29.905124843 +0800
@@ -0,0 +1,59 @@
+package net.minecraft.server;
+
+public class GenLayerZoom extends GenLayer {
+
+    public GenLayerZoom(long i, GenLayer genlayer) {
+        super(i);
+        super.a = genlayer;
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        int i1 = i >> 1;
+        int j1 = j >> 1;
+        int k1 = (k >> 1) + 2;
+        int l1 = (l >> 1) + 2;
+        int[] aint = this.a.a(i1, j1, k1, l1);
+        int i2 = k1 - 1 << 1;
+        int j2 = l1 - 1 << 1;
+        int[] aint1 = IntCache.a(i2 * j2);
+
+        int k2;
+
+        for (int l2 = 0; l2 < l1 - 1; ++l2) {
+            k2 = (l2 << 1) * i2;
+            int i3 = 0;
+            int j3 = aint[i3 + 0 + (l2 + 0) * k1];
+
+            for (int k3 = aint[i3 + 0 + (l2 + 1) * k1]; i3 < k1 - 1; ++i3) {
+                this.a((long) (i3 + i1 << 1), (long) (l2 + j1 << 1));
+                int l3 = aint[i3 + 1 + (l2 + 0) * k1];
+                int i4 = aint[i3 + 1 + (l2 + 1) * k1];
+
+                aint1[k2] = j3;
+                aint1[k2++ + i2] = this.a(new int[] { j3, k3});
+                aint1[k2] = this.a(new int[] { j3, l3});
+                aint1[k2++ + i2] = this.b(j3, l3, k3, i4);
+                j3 = l3;
+                k3 = i4;
+            }
+        }
+
+        int[] aint2 = IntCache.a(k * l);
+
+        for (k2 = 0; k2 < l; ++k2) {
+            System.arraycopy(aint1, (k2 + (j & 1)) * i2 + (i & 1), aint2, k2 * k, k);
+        }
+
+        return aint2;
+    }
+
+    public static GenLayer b(long i, GenLayer genlayer, int j) {
+        Object object = genlayer;
+
+        for (int k = 0; k < j; ++k) {
+            object = new GenLayerZoom(i + (long) k, (GenLayer) object);
+        }
+
+        return (GenLayer) object;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/GenLayerZoomVoronoi.java src/main/java/net/minecraft/server/GenLayerZoomVoronoi.java
--- src_origin/main/java/net/minecraft/server/GenLayerZoomVoronoi.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/GenLayerZoomVoronoi.java	2016-03-16 23:43:29.909124843 +0800
@@ -0,0 +1,83 @@
+package net.minecraft.server;
+
+public class GenLayerZoomVoronoi extends GenLayer {
+
+    public GenLayerZoomVoronoi(long i, GenLayer genlayer) {
+        super(i);
+        super.a = genlayer;
+    }
+
+    public int[] a(int i, int j, int k, int l) {
+        i -= 2;
+        j -= 2;
+        int i1 = i >> 2;
+        int j1 = j >> 2;
+        int k1 = (k >> 2) + 2;
+        int l1 = (l >> 2) + 2;
+        int[] aint = this.a.a(i1, j1, k1, l1);
+        int i2 = k1 - 1 << 2;
+        int j2 = l1 - 1 << 2;
+        int[] aint1 = IntCache.a(i2 * j2);
+
+        int k2;
+
+        for (int l2 = 0; l2 < l1 - 1; ++l2) {
+            k2 = 0;
+            int i3 = aint[k2 + 0 + (l2 + 0) * k1];
+
+            for (int j3 = aint[k2 + 0 + (l2 + 1) * k1]; k2 < k1 - 1; ++k2) {
+                double d0 = 3.6D;
+
+                this.a((long) (k2 + i1 << 2), (long) (l2 + j1 << 2));
+                double d1 = ((double) this.a(1024) / 1024.0D - 0.5D) * 3.6D;
+                double d2 = ((double) this.a(1024) / 1024.0D - 0.5D) * 3.6D;
+
+                this.a((long) (k2 + i1 + 1 << 2), (long) (l2 + j1 << 2));
+                double d3 = ((double) this.a(1024) / 1024.0D - 0.5D) * 3.6D + 4.0D;
+                double d4 = ((double) this.a(1024) / 1024.0D - 0.5D) * 3.6D;
+
+                this.a((long) (k2 + i1 << 2), (long) (l2 + j1 + 1 << 2));
+                double d5 = ((double) this.a(1024) / 1024.0D - 0.5D) * 3.6D;
+                double d6 = ((double) this.a(1024) / 1024.0D - 0.5D) * 3.6D + 4.0D;
+
+                this.a((long) (k2 + i1 + 1 << 2), (long) (l2 + j1 + 1 << 2));
+                double d7 = ((double) this.a(1024) / 1024.0D - 0.5D) * 3.6D + 4.0D;
+                double d8 = ((double) this.a(1024) / 1024.0D - 0.5D) * 3.6D + 4.0D;
+                int k3 = aint[k2 + 1 + (l2 + 0) * k1] & 255;
+                int l3 = aint[k2 + 1 + (l2 + 1) * k1] & 255;
+
+                for (int i4 = 0; i4 < 4; ++i4) {
+                    int j4 = ((l2 << 2) + i4) * i2 + (k2 << 2);
+
+                    for (int k4 = 0; k4 < 4; ++k4) {
+                        double d9 = ((double) i4 - d2) * ((double) i4 - d2) + ((double) k4 - d1) * ((double) k4 - d1);
+                        double d10 = ((double) i4 - d4) * ((double) i4 - d4) + ((double) k4 - d3) * ((double) k4 - d3);
+                        double d11 = ((double) i4 - d6) * ((double) i4 - d6) + ((double) k4 - d5) * ((double) k4 - d5);
+                        double d12 = ((double) i4 - d8) * ((double) i4 - d8) + ((double) k4 - d7) * ((double) k4 - d7);
+
+                        if (d9 < d10 && d9 < d11 && d9 < d12) {
+                            aint1[j4++] = i3;
+                        } else if (d10 < d9 && d10 < d11 && d10 < d12) {
+                            aint1[j4++] = k3;
+                        } else if (d11 < d9 && d11 < d10 && d11 < d12) {
+                            aint1[j4++] = j3;
+                        } else {
+                            aint1[j4++] = l3;
+                        }
+                    }
+                }
+
+                i3 = k3;
+                j3 = l3;
+            }
+        }
+
+        int[] aint2 = IntCache.a(k * l);
+
+        for (k2 = 0; k2 < l; ++k2) {
+            System.arraycopy(aint1, (k2 + (j & 3)) * i2 + (i & 3), aint2, k2 * k, k);
+        }
+
+        return aint2;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/HandshakeListener.java src/main/java/net/minecraft/server/HandshakeListener.java
--- src_origin/main/java/net/minecraft/server/HandshakeListener.java	2016-02-26 15:27:10.687203587 +0800
+++ src/main/java/net/minecraft/server/HandshakeListener.java	2016-03-16 23:43:29.918124843 +0800
@@ -2,14 +2,15 @@
 
 // CraftBukkit start
 import java.net.InetAddress;
-import java.util.HashMap;
+import java.util.concurrent.ConcurrentHashMap;
 // CraftBukkit end
 
 public class HandshakeListener implements PacketHandshakingInListener {
 
     private static final com.google.gson.Gson gson = new com.google.gson.Gson(); // Spigot
     // CraftBukkit start - add fields
-    private static final HashMap<InetAddress, Long> throttleTracker = new HashMap<InetAddress, Long>();
+    //private static final HashMap<InetAddress, Long> throttleTracker = new HashMap<InetAddress, Long>();
+    private static final ConcurrentHashMap<InetAddress, Long> throttleTracker = new ConcurrentHashMap<InetAddress, Long>();
     private static int throttleCounter = 0;
     // CraftBukkit end
 
diff -Naur src_origin/main/java/net/minecraft/server/IntCache.java src/main/java/net/minecraft/server/IntCache.java
--- src_origin/main/java/net/minecraft/server/IntCache.java	2016-02-26 15:27:10.750203593 +0800
+++ src/main/java/net/minecraft/server/IntCache.java	2016-03-16 23:43:29.925124843 +0800
@@ -10,7 +10,7 @@
     private static List<int[]> c = Lists.newArrayList();
     private static List<int[]> d = Lists.newArrayList();
     private static List<int[]> e = Lists.newArrayList();
-
+    
     public static synchronized int[] a(int i) {
         int[] aint;
 
diff -Naur src_origin/main/java/net/minecraft/server/ItemStack.java src/main/java/net/minecraft/server/ItemStack.java
--- src_origin/main/java/net/minecraft/server/ItemStack.java	2016-02-26 15:27:11.336203647 +0800
+++ src/main/java/net/minecraft/server/ItemStack.java	2016-03-16 23:43:30.042124843 +0800
@@ -8,6 +8,9 @@
 // CraftBukkit start
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 import org.bukkit.Location;
 import org.bukkit.TreeType;
@@ -120,12 +123,15 @@
         this.count = count;
         this.setData(data);
         world.captureBlockStates = false;
-        if (flag && world.captureTreeGeneration && world.capturedBlockStates.size() > 0) {
+        //if (flag && world.captureTreeGeneration && world.capturedBlockStates.size() > 0) {
+        if (flag && world.captureTreeGeneration && !world.capturedBlockStates.isEmpty()) {
             world.captureTreeGeneration = false;
             Location location = new Location(world.getWorld(), blockposition.getX(), blockposition.getY(), blockposition.getZ());
             TreeType treeType = BlockSapling.treeType;
             BlockSapling.treeType = null;
-            List<BlockState> blocks = (List<BlockState>) world.capturedBlockStates.clone();
+            //List<BlockState> blocks = (List<BlockState>) world.capturedBlockStates.clone();
+            Queue<BlockState> blocks = new ConcurrentLinkedQueue<BlockState>();
+            blocks.addAll(world.capturedBlockStates);
             world.capturedBlockStates.clear();
             StructureGrowEvent event = null;
             if (treeType != null) {
@@ -150,12 +156,19 @@
 
         if (flag) {
             org.bukkit.event.block.BlockPlaceEvent placeEvent = null;
-            List<BlockState> blocks = (List<BlockState>) world.capturedBlockStates.clone();
+            //List<BlockState> blocks = (List<BlockState>) world.capturedBlockStates.clone();
+            Queue<BlockState> blocks = new ConcurrentLinkedQueue<BlockState>();
+            blocks.addAll(world.capturedBlockStates);
+            BlockState first_block = null;
+            if (blocks.iterator().hasNext()){
+                first_block = blocks.iterator().next();
+            }
             world.capturedBlockStates.clear();
             if (blocks.size() > 1) {
                 placeEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callBlockMultiPlaceEvent(world, entityhuman, blocks, blockposition.getX(), blockposition.getY(), blockposition.getZ());
             } else if (blocks.size() == 1) {
-                placeEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPlaceEvent(world, entityhuman, blocks.get(0), blockposition.getX(), blockposition.getY(), blockposition.getZ());
+                //placeEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPlaceEvent(world, entityhuman, blocks.get(0), blockposition.getX(), blockposition.getY(), blockposition.getZ());
+                placeEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPlaceEvent(world, entityhuman, first_block, blockposition.getX(), blockposition.getY(), blockposition.getZ());
             }
 
             if (placeEvent != null && (placeEvent.isCancelled() || !placeEvent.canBuild())) {
diff -Naur src_origin/main/java/net/minecraft/server/JsonList.java src/main/java/net/minecraft/server/JsonList.java
--- src_origin/main/java/net/minecraft/server/JsonList.java	2016-02-26 15:27:11.423203656 +0800
+++ src/main/java/net/minecraft/server/JsonList.java	2016-03-16 23:43:30.057124843 +0800
@@ -25,6 +25,8 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -34,7 +36,8 @@
     protected static final Logger a = LogManager.getLogger();
     protected final Gson b;
     private final File c;
-    private final Map<String, V> d = Maps.newHashMap();
+    //private final Map<String, V> d = Maps.newHashMap();
+    private final ConcurrentMap<String, V> d = new ConcurrentHashMap<String, V>();
     private boolean e = true;
     private static final ParameterizedType f = new ParameterizedType() {
         public Type[] getActualTypeArguments() {
@@ -145,6 +148,7 @@
         return new JsonListEntry((Object) null, jsonobject);
     }
 
+    //do not change it
     protected Map<String, V> e() {
         return this.d;
     }
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2016-02-26 15:27:11.493203662 +0800
+++ src/main/java/net/minecraft/server/MinecraftServer.java	2016-03-16 23:43:30.076124844 +0800
@@ -2,7 +2,6 @@
 
 import com.google.common.base.Charsets;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.ListenableFutureTask;
@@ -17,7 +16,6 @@
 import java.awt.GraphicsEnvironment;
 import java.awt.image.BufferedImage;
 import java.io.File;
-import java.io.IOException;
 import java.net.Proxy;
 import java.security.KeyPair;
 import java.text.SimpleDateFormat;
@@ -40,12 +38,16 @@
 
 // CraftBukkit start
 import java.io.IOException;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 import jline.console.ConsoleReader;
 import joptsimple.OptionSet;
 
 import org.bukkit.craftbukkit.Main;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.bukkit.event.Event;
+import org.hose.ChunkGenPool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class MinecraftServer implements Runnable, ICommandListener, IAsyncTaskHandler, IMojangStatistics {
@@ -56,7 +58,8 @@
     public Convertable convertable;
     private final MojangStatisticsGenerator n = new MojangStatisticsGenerator("server", this, az());
     public File universe;
-    private final List<IUpdatePlayerListBox> p = Lists.newArrayList();
+    //private final List<IUpdatePlayerListBox> p = Lists.newArrayList();
+    private final List<IUpdatePlayerListBox> p = Lists.newCopyOnWriteArrayList();
     protected final ICommandHandler b;
     public final MethodProfiler methodProfiler = new MethodProfiler();
     private ServerConnection q; // Spigot
@@ -105,7 +108,8 @@
     private long ab = az();
 
     // CraftBukkit start
-    public List<WorldServer> worlds = new ArrayList<WorldServer>();
+    //public List<WorldServer> worlds = new ArrayList<WorldServer>();
+    public List<WorldServer> worlds = new CopyOnWriteArrayList<WorldServer>();
     public org.bukkit.craftbukkit.CraftServer server;
     public OptionSet options;
     public org.bukkit.command.ConsoleCommandSender console;
@@ -366,7 +370,10 @@
                     }
 
                     ++i;
-                    worldserver.chunkProviderServer.getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    //chunk loader
+                    //worldserver.chunkProviderServer.getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    SpigotWorldConfig.ChunkGenTask = new FutureTask(new ChunkGenPool(worldserver, blockposition, k, l));
+                    SpigotWorldConfig.chunkgenpool_executor.submit(SpigotWorldConfig.ChunkGenTask);
                 }
             }
         }
@@ -519,7 +526,7 @@
         return ( avg * exp ) + ( tps * ( 1 - exp ) );
     }
     // Spigot End
- 
+     
     public void run() {
         try {
             if (this.init()) {
@@ -642,7 +649,7 @@
     protected void A() throws ExceptionWorldConflict { // CraftBukkit - added throws
         SpigotTimings.serverTickTimer.startTiming(); // Spigot
         long i = System.nanoTime();
-
+        
         ++this.ticks;
         if (this.T) {
             this.T = false;
@@ -710,10 +717,15 @@
 
         // Spigot start
         FutureTask<?> entry;
-        int count = this.j.size();
+        /*int count = this.j.size();
         while (count-- > 0 && (entry = this.j.poll()) != null) {
             SystemUtils.a(entry, MinecraftServer.LOGGER);
-         }
+        }*/
+        //int count = this.j.size();
+        Iterator it = this.j.iterator();
+        while (it.hasNext() && (entry = this.j.poll()) != null) {
+            SystemUtils.a(entry, MinecraftServer.LOGGER);
+        }
         // Spigot end
 
         this.methodProfiler.c("levels");
@@ -820,9 +832,14 @@
         this.methodProfiler.c("tickables");
 
         SpigotTimings.tickablesTimer.startTiming(); // Spigot
+        Iterator it1 = this.p.iterator();
+        while (it1.hasNext()) {
+            ((IUpdatePlayerListBox) it1.next()).c();
+        }
+        /*
         for (i = 0; i < this.p.size(); ++i) {
             ((IUpdatePlayerListBox) this.p.get(i)).c();
-        }
+        }*/
         SpigotTimings.tickablesTimer.stopTiming(); // Spigot
 
         this.methodProfiler.b();
@@ -1023,7 +1040,8 @@
     }
 
     public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        //return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "HOSE"; // HOSE -> Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1105,7 +1123,8 @@
     }
 
     public String getName() {
-        return "Server";
+        //return "Server";
+        return org.bukkit.ChatColor.GREEN+"Server";
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
diff -Naur src_origin/main/java/net/minecraft/server/PacketPlayOutMapChunk.java src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
--- src_origin/main/java/net/minecraft/server/PacketPlayOutMapChunk.java	2016-02-26 15:27:12.026203712 +0800
+++ src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java	2016-03-16 23:43:30.169124844 +0800
@@ -4,6 +4,9 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.List;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
 
@@ -55,7 +58,8 @@
     public static PacketPlayOutMapChunk.ChunkMap a(Chunk chunk, boolean flag, boolean flag1, int i) {
         ChunkSection[] achunksection = chunk.getSections();
         PacketPlayOutMapChunk.ChunkMap packetplayoutmapchunk_chunkmap = new PacketPlayOutMapChunk.ChunkMap();
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        Queue arraylist = new ConcurrentLinkedQueue();
 
         int j;
 
diff -Naur src_origin/main/java/net/minecraft/server/PacketStatusListener.java src/main/java/net/minecraft/server/PacketStatusListener.java
--- src_origin/main/java/net/minecraft/server/PacketStatusListener.java	2016-02-26 15:27:12.107203720 +0800
+++ src/main/java/net/minecraft/server/PacketStatusListener.java	2016-03-16 23:43:30.186124844 +0800
@@ -4,7 +4,9 @@
 import com.mojang.authlib.GameProfile;
 import io.netty.channel.ChannelFutureListener;
 import java.net.InetSocketAddress;
+import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.List;
 
 import org.bukkit.craftbukkit.util.CraftIconCache;
 import org.bukkit.entity.Player;
@@ -98,9 +100,12 @@
         }
 
         ServerListPingEvent event = new ServerListPingEvent();
+        //set async
+        event.setAsynchronous();
         this.minecraftServer.server.getPluginManager().callEvent(event);
 
-        java.util.List<GameProfile> profiles = new java.util.ArrayList<GameProfile>(players.length);
+        //java.util.List<GameProfile> profiles = new java.util.ArrayList<GameProfile>(players.length);
+        List<GameProfile> profiles = new ArrayList<GameProfile>(players.length);
         for (Object player : players) {
             if (player != null) {
                 profiles.add(((EntityPlayer) player).getProfile());
diff -Naur src_origin/main/java/net/minecraft/server/PathfinderGoalBreed.java src/main/java/net/minecraft/server/PathfinderGoalBreed.java
--- src_origin/main/java/net/minecraft/server/PathfinderGoalBreed.java	2016-02-26 15:27:12.166203725 +0800
+++ src/main/java/net/minecraft/server/PathfinderGoalBreed.java	2016-03-16 23:43:30.197124844 +0800
@@ -3,6 +3,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
+import org.spigotmc.SpigotWorldConfig;
 
 public class PathfinderGoalBreed extends PathfinderGoal {
 
diff -Naur src_origin/main/java/net/minecraft/server/PersistentCollection.java src/main/java/net/minecraft/server/PersistentCollection.java
--- src_origin/main/java/net/minecraft/server/PersistentCollection.java	2016-02-26 15:27:12.587203764 +0800
+++ src/main/java/net/minecraft/server/PersistentCollection.java	2016-03-16 23:43:30.262124844 +0800
@@ -1,7 +1,6 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 import java.io.DataInputStream;
 import java.io.DataOutput;
 import java.io.DataOutputStream;
@@ -12,14 +11,17 @@
 import java.io.OutputStream;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 public class PersistentCollection {
 
     private IDataManager b;
-    protected Map<String, PersistentBase> a = Maps.newHashMap();
+    //protected Map<String, PersistentBase> a = Maps.newHashMap();
+    protected ConcurrentMap<String, PersistentBase> a = new ConcurrentHashMap<String, PersistentBase>();
     public List<PersistentBase> c = Lists.newArrayList(); // Spigot
-    private Map<String, Short> d = Maps.newHashMap();
+    //private Map<String, Short> d = Maps.newHashMap();
+    private ConcurrentMap<String, Short> d = new ConcurrentHashMap<String, Short>();
 
     public PersistentCollection(IDataManager idatamanager) {
         this.b = idatamanager;
diff -Naur src_origin/main/java/net/minecraft/server/PersistentVillage.java src/main/java/net/minecraft/server/PersistentVillage.java
--- src_origin/main/java/net/minecraft/server/PersistentVillage.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/PersistentVillage.java	2016-03-16 23:43:30.270124844 +0800
@@ -0,0 +1,271 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+
+public class PersistentVillage extends PersistentBase {
+
+    private World world;
+    /*private final List<BlockPosition> c = Lists.newArrayList();
+    private final List<VillageDoor> d = Lists.newArrayList();
+    private final List<Village> villages = Lists.newArrayList();*/
+    private final List<BlockPosition> c = Lists.newCopyOnWriteArrayList();
+    private final List<VillageDoor> d = Lists.newCopyOnWriteArrayList();
+    private final Queue<Village> villages = new ConcurrentLinkedQueue();
+    private int time;
+
+    public PersistentVillage(String s) {
+        super(s);
+    }
+
+    public PersistentVillage(World world) {
+        super(a(world.worldProvider));
+        this.world = world;
+        this.c();
+    }
+
+    public void a(World world) {
+        this.world = world;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(world);
+        }
+
+    }
+
+    public void a(BlockPosition blockposition) {
+        if (this.c.size() <= 64) {
+            if (!this.e(blockposition)) {
+                this.c.add(blockposition);
+            }
+
+        }
+    }
+
+    public void tick() {
+        ++this.time;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(this.time);
+        }
+
+        this.e();
+        this.f();
+        this.g();
+        if (this.time % 400 == 0) {
+            this.c();
+        }
+
+    }
+
+    private void e() {
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            if (village.g()) {
+                iterator.remove();
+                this.c();
+            }
+        }
+
+    }
+
+    //public List<Village> getVillages() {
+    public Queue<Village> getVillages() {
+        return this.villages;
+    }
+
+    public Village getClosestVillage(BlockPosition blockposition, int i) {
+        Village village = null;
+        double d0 = 3.4028234663852886E38D;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village1 = (Village) iterator.next();
+            double d1 = village1.a().i(blockposition);
+
+            if (d1 < d0) {
+                float f = (float) (i + village1.b());
+
+                if (d1 <= (double) (f * f)) {
+                    village = village1;
+                    d0 = d1;
+                }
+            }
+        }
+
+        return village;
+    }
+
+    private void f() {
+        if (!this.c.isEmpty()) {
+            this.b((BlockPosition) this.c.remove(0));
+        }
+    }
+
+    private void g() {
+        for (int i = 0; i < this.d.size(); ++i) {
+            VillageDoor villagedoor = (VillageDoor) this.d.get(i);
+            Village village = this.getClosestVillage(villagedoor.d(), 32);
+
+            if (village == null) {
+                village = new Village(this.world);
+                this.villages.add(village);
+                this.c();
+            }
+
+            village.a(villagedoor);
+        }
+
+        this.d.clear();
+    }
+
+    private void b(BlockPosition blockposition) {
+        byte b0 = 16;
+        byte b1 = 4;
+        byte b2 = 16;
+
+        for (int i = -b0; i < b0; ++i) {
+            for (int j = -b1; j < b1; ++j) {
+                for (int k = -b2; k < b2; ++k) {
+                    BlockPosition blockposition1 = blockposition.a(i, j, k);
+
+                    if (this.f(blockposition1)) {
+                        VillageDoor villagedoor = this.c(blockposition1);
+
+                        if (villagedoor == null) {
+                            this.d(blockposition1);
+                        } else {
+                            villagedoor.a(this.time);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    private VillageDoor c(BlockPosition blockposition) {
+        Iterator iterator = this.d.iterator();
+
+        VillageDoor villagedoor;
+
+        do {
+            if (!iterator.hasNext()) {
+                iterator = this.villages.iterator();
+
+                VillageDoor villagedoor1;
+
+                do {
+                    if (!iterator.hasNext()) {
+                        return null;
+                    }
+
+                    Village village = (Village) iterator.next();
+
+                    villagedoor1 = village.e(blockposition);
+                } while (villagedoor1 == null);
+
+                return villagedoor1;
+            }
+
+            villagedoor = (VillageDoor) iterator.next();
+        } while (villagedoor.d().getX() != blockposition.getX() || villagedoor.d().getZ() != blockposition.getZ() || Math.abs(villagedoor.d().getY() - blockposition.getY()) > 1);
+
+        return villagedoor;
+    }
+
+    private void d(BlockPosition blockposition) {
+        EnumDirection enumdirection = BlockDoor.h(this.world, blockposition);
+        EnumDirection enumdirection1 = enumdirection.opposite();
+        int i = this.a(blockposition, enumdirection, 5);
+        int j = this.a(blockposition, enumdirection1, i + 1);
+
+        if (i != j) {
+            this.d.add(new VillageDoor(blockposition, i < j ? enumdirection : enumdirection1, this.time));
+        }
+
+    }
+
+    private int a(BlockPosition blockposition, EnumDirection enumdirection, int i) {
+        int j = 0;
+
+        for (int k = 1; k <= 5; ++k) {
+            if (this.world.i(blockposition.shift(enumdirection, k))) {
+                ++j;
+                if (j >= i) {
+                    return j;
+                }
+            }
+        }
+
+        return j;
+    }
+
+    private boolean e(BlockPosition blockposition) {
+        Iterator iterator = this.c.iterator();
+
+        BlockPosition blockposition1;
+
+        do {
+            if (!iterator.hasNext()) {
+                return false;
+            }
+
+            blockposition1 = (BlockPosition) iterator.next();
+        } while (!blockposition1.equals(blockposition));
+
+        return true;
+    }
+
+    private boolean f(BlockPosition blockposition) {
+        Block block = this.world.getType(blockposition).getBlock();
+
+        return block instanceof BlockDoor ? block.getMaterial() == Material.WOOD : false;
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        this.time = nbttagcompound.getInt("Tick");
+        NBTTagList nbttaglist = nbttagcompound.getList("Villages", 10);
+
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound1 = nbttaglist.get(i);
+            Village village = new Village();
+
+            village.a(nbttagcompound1);
+            this.villages.add(village);
+        }
+
+    }
+
+    public void b(NBTTagCompound nbttagcompound) {
+        nbttagcompound.setInt("Tick", this.time);
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+            village.b(nbttagcompound1);
+            nbttaglist.add(nbttagcompound1);
+        }
+
+        nbttagcompound.set("Villages", nbttaglist);
+    }
+
+    public static String a(WorldProvider worldprovider) {
+        return "villages" + worldprovider.getSuffix();
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/PistonExtendsChecker.java src/main/java/net/minecraft/server/PistonExtendsChecker.java
--- src_origin/main/java/net/minecraft/server/PistonExtendsChecker.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/PistonExtendsChecker.java	2016-03-16 23:43:30.274124844 +0800
@@ -0,0 +1,196 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+public class PistonExtendsChecker {
+
+    private final World a;
+    private final BlockPosition b;
+    private final BlockPosition c;
+    private final EnumDirection d;
+    
+    /*private final List<BlockPosition> e = Lists.newArrayList();
+    private final List<BlockPosition> f = Lists.newArrayList();*/
+    private final List<BlockPosition> e = Lists.newCopyOnWriteArrayList();
+    private final List<BlockPosition> f = Lists.newCopyOnWriteArrayList();
+    
+
+    public PistonExtendsChecker(World world, BlockPosition blockposition, EnumDirection enumdirection, boolean flag) {
+        this.a = world;
+        this.b = blockposition;
+        if (flag) {
+            this.d = enumdirection;
+            this.c = blockposition.shift(enumdirection);
+        } else {
+            this.d = enumdirection.opposite();
+            this.c = blockposition.shift(enumdirection, 2);
+        }
+
+    }
+
+    public boolean a() {
+        this.e.clear();
+        this.f.clear();
+        Block block = this.a.getType(this.c).getBlock();
+
+        if (!BlockPiston.a(block, this.a, this.c, this.d, false)) {
+            if (block.k() != 1) {
+                return false;
+            } else {
+                this.f.add(this.c);
+                return true;
+            }
+        } else if (!this.a(this.c)) {
+            return false;
+        } else {
+            /*
+            Iterator it = this.e.iterator();
+            while (it.hasNext()){
+                BlockPosition blockposition = (BlockPosition) it.next();
+
+                if (this.a.getType(blockposition).getBlock() == Blocks.SLIME && !this.b(blockposition)) {
+                    return false;
+                }
+            }*/
+            
+            for (int i = 0; i < this.e.size(); ++i) {
+                BlockPosition blockposition = (BlockPosition) this.e.get(i);
+
+                if (this.a.getType(blockposition).getBlock() == Blocks.SLIME && !this.b(blockposition)) {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+    }
+
+    private boolean a(BlockPosition blockposition) {
+        Block block = this.a.getType(blockposition).getBlock();
+
+        if (block.getMaterial() == Material.AIR) {
+            return true;
+        } else if (!BlockPiston.a(block, this.a, blockposition, this.d, false)) {
+            return true;
+        } else if (blockposition.equals(this.b)) {
+            return true;
+        } else if (this.e.contains(blockposition)) {
+            return true;
+        } else {
+            int i = 1;
+
+            if (i + this.e.size() > 12) {
+                return false;
+            } else {
+                while (block == Blocks.SLIME) {
+                    BlockPosition blockposition1 = blockposition.shift(this.d.opposite(), i);
+
+                    block = this.a.getType(blockposition1).getBlock();
+                    if (block.getMaterial() == Material.AIR || !BlockPiston.a(block, this.a, blockposition1, this.d, false) || blockposition1.equals(this.b)) {
+                        break;
+                    }
+
+                    ++i;
+                    if (i + this.e.size() > 12) {
+                        return false;
+                    }
+                }
+
+                int j = 0;
+
+                int k;
+
+                for (k = i - 1; k >= 0; --k) {
+                    this.e.add(blockposition.shift(this.d.opposite(), k));
+                    ++j;
+                }
+
+                k = 1;
+
+                while (true) {
+                    BlockPosition blockposition2 = blockposition.shift(this.d, k);
+                    int l = this.e.indexOf(blockposition2);
+
+                    if (l > -1) {
+                        this.a(j, l);
+
+                        for (int i1 = 0; i1 <= l + j; ++i1) {
+                            BlockPosition blockposition3 = (BlockPosition) this.e.get(i1);
+
+                            if (this.a.getType(blockposition3).getBlock() == Blocks.SLIME && !this.b(blockposition3)) {
+                                return false;
+                            }
+                        }
+
+                        return true;
+                    }
+
+                    block = this.a.getType(blockposition2).getBlock();
+                    if (block.getMaterial() == Material.AIR) {
+                        return true;
+                    }
+
+                    if (!BlockPiston.a(block, this.a, blockposition2, this.d, true) || blockposition2.equals(this.b)) {
+                        return false;
+                    }
+
+                    if (block.k() == 1) {
+                        this.f.add(blockposition2);
+                        return true;
+                    }
+
+                    if (this.e.size() >= 12) {
+                        return false;
+                    }
+
+                    this.e.add(blockposition2);
+                    ++j;
+                    ++k;
+                }
+            }
+        }
+    }
+
+    private void a(int i, int j) {
+        ArrayList arraylist = Lists.newArrayList();
+        ArrayList arraylist1 = Lists.newArrayList();
+        ArrayList arraylist2 = Lists.newArrayList();
+
+        arraylist.addAll(this.e.subList(0, j));
+        arraylist1.addAll(this.e.subList(this.e.size() - i, this.e.size()));
+        arraylist2.addAll(this.e.subList(j, this.e.size() - i));
+        this.e.clear();
+        this.e.addAll(arraylist);
+        this.e.addAll(arraylist1);
+        this.e.addAll(arraylist2);
+    }
+
+    private boolean b(BlockPosition blockposition) {
+        EnumDirection[] aenumdirection = EnumDirection.values();
+        int i = aenumdirection.length;
+
+        for (int j = 0; j < i; ++j) {
+            EnumDirection enumdirection = aenumdirection[j];
+
+            if (enumdirection.k() != this.d.k() && !this.a(blockposition.shift(enumdirection))) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    public List<BlockPosition> getMovedBlocks() {
+    //public CopyOnWriteArrayList<BlockPosition> getMovedBlocks() {
+        return this.e;
+    }
+
+    public List<BlockPosition> getBrokenBlocks() {
+    //public CopyOnWriteArrayList<BlockPosition> getBrokenBlocks() {
+        return this.f;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/PlayerChunkMap.java src/main/java/net/minecraft/server/PlayerChunkMap.java
--- src_origin/main/java/net/minecraft/server/PlayerChunkMap.java	2016-02-26 15:27:12.591203765 +0800
+++ src/main/java/net/minecraft/server/PlayerChunkMap.java	2016-03-16 23:43:30.281124844 +0800
@@ -1,7 +1,7 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import java.util.ArrayList;
+import com.google.common.collect.Maps;
 import java.util.Iterator;
 import java.util.List;
 import org.apache.logging.log4j.LogManager;
@@ -13,14 +13,18 @@
 import java.util.LinkedList;
 import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
 import java.util.HashMap;
+import java.util.concurrent.ConcurrentHashMap;
+import org.bukkit.craftbukkit.util.LongHash;
 // CraftBukkit end
 
 public class PlayerChunkMap {
 
     private static final Logger a = LogManager.getLogger();
     private final WorldServer world;
-    private final List<EntityPlayer> managedPlayers = Lists.newArrayList();
-    private final LongHashMap<PlayerChunkMap.PlayerChunk> d = new LongHashMap();
+    //private final List<EntityPlayer> managedPlayers = Lists.newArrayList();
+    private final List<EntityPlayer> managedPlayers = Lists.newCopyOnWriteArrayList();
+    //private final LongHashMap<PlayerChunkMap.PlayerChunk> d = new LongHashMap();
+    private final ConcurrentHashMap<Long, PlayerChunkMap.PlayerChunk> d = new ConcurrentHashMap();
     private final Queue<PlayerChunkMap.PlayerChunk> e = new java.util.concurrent.ConcurrentLinkedQueue<PlayerChunkMap.PlayerChunk>(); // CraftBukkit ArrayList -> ConcurrentLinkedQueue
     private final Queue<PlayerChunkMap.PlayerChunk> f = new java.util.concurrent.ConcurrentLinkedQueue<PlayerChunkMap.PlayerChunk>(); // CraftBukkit ArrayList -> ConcurrentLinkedQueue
     private int g;
@@ -28,6 +32,10 @@
     private final int[][] i = new int[][] { { 1, 0}, { 0, 1}, { -1, 0}, { 0, -1}};
     private boolean wasNotEmpty; // CraftBukkit - add field
 
+    private int g(long i) {
+        return MathHelper.f((int) (i ^ i >>> 32));
+    }
+    
     public PlayerChunkMap(WorldServer worldserver, int viewDistance /* Spigot */) {
         this.world = worldserver;
         this.a(viewDistance); // Spigot
@@ -68,6 +76,7 @@
             WorldProvider worldprovider = this.world.worldProvider;
 
             if (!worldprovider.e()) {
+                //async this
                 this.world.chunkProviderServer.b();
             }
             // CraftBukkit start
@@ -80,14 +89,18 @@
     }
 
     public boolean a(int i, int j) {
-        long k = (long) i + 2147483647L | (long) j + 2147483647L << 32;
-
-        return this.d.getEntry(k) != null;
+        //long k = (long) i + 2147483647L | (long) j + 2147483647L << 32;
+        long k = LongHash.toLong(i, j);
+        //return this.d.getEntry(k) != null;
+        return this.d.get(k) != null;
     }
 
+    //public PlayerChunkMap.PlayerChunk a(int i, int j, boolean flag) {
     private PlayerChunkMap.PlayerChunk a(int i, int j, boolean flag) {
-        long k = (long) i + 2147483647L | (long) j + 2147483647L << 32;
-        PlayerChunkMap.PlayerChunk playerchunkmap_playerchunk = (PlayerChunkMap.PlayerChunk) this.d.getEntry(k);
+        //long k = (long) i + 2147483647L | (long) j + 2147483647L << 32;
+        long k = LongHash.toLong(i, j);
+        //PlayerChunkMap.PlayerChunk playerchunkmap_playerchunk = (PlayerChunkMap.PlayerChunk) this.d.getEntry(k);
+        PlayerChunkMap.PlayerChunk playerchunkmap_playerchunk = (PlayerChunkMap.PlayerChunk) this.d.get(k);
 
         if (playerchunkmap_playerchunk == null && flag) {
             playerchunkmap_playerchunk = new PlayerChunkMap.PlayerChunk(i, j);
@@ -146,7 +159,8 @@
     }
 
     public void b(EntityPlayer entityplayer) {
-        ArrayList arraylist = Lists.newArrayList(entityplayer.chunkCoordIntPairQueue);
+        //ArrayList arraylist = Lists.newArrayList(entityplayer.chunkCoordIntPairQueue);
+        List arraylist = Lists.newCopyOnWriteArrayList(entityplayer.chunkCoordIntPairQueue);
         int i = 0;
         int j = this.g;
         int k = (int) entityplayer.locX >> 4;
@@ -178,7 +192,7 @@
         }
 
         i %= 4;
-
+        
         for (k1 = 0; k1 < j * 2; ++k1) {
             i1 += this.i[i][0];
             j1 += this.i[i][1];
@@ -256,9 +270,11 @@
                     this.a(pair.x, pair.z, true).a(entityplayer);
                 }
 
+                /*
                 if (j1 > 1 || j1 < -1 || k1 > 1 || k1 < -1) {
+                    //Collections.sort(entityplayer.chunkCoordIntPairQueue, new ChunkCoordComparator(entityplayer));
                     Collections.sort(entityplayer.chunkCoordIntPairQueue, new ChunkCoordComparator(entityplayer));
-                }
+                }*/
                 // CraftBukkit end
             }
         }
@@ -274,7 +290,8 @@
         i = MathHelper.clamp(i, 3, 32);
         if (i != this.g) {
             int j = i - this.g;
-            ArrayList arraylist = Lists.newArrayList(this.managedPlayers);
+            //ArrayList arraylist = Lists.newArrayList(this.managedPlayers);
+            List arraylist = Lists.newCopyOnWriteArrayList(this.managedPlayers);
             Iterator iterator = arraylist.iterator();
 
             while (iterator.hasNext()) {
@@ -313,10 +330,12 @@
         return i * 16 - 16;
     }
 
-    class PlayerChunk {
+    public class PlayerChunk {
 
-        private final List<EntityPlayer> b = Lists.newArrayList();
-        private final ChunkCoordIntPair location;
+        //private final List<EntityPlayer> b = Lists.newArrayList();
+        private final List<EntityPlayer> b = Lists.newCopyOnWriteArrayList();
+        //private final ChunkCoordIntPair location;
+        public final ChunkCoordIntPair location;
         private short[] dirtyBlocks = new short[64];
         private int dirtyCount;
         private int f;
@@ -375,7 +394,9 @@
 
                     if (this.b.isEmpty()) {
                         ChunkIOExecutor.dropQueuedChunkLoad(PlayerChunkMap.this.a(), this.location.x, this.location.z, this.loadedRunnable);
-                        long i = (long) this.location.x + 2147483647L | (long) this.location.z + 2147483647L << 32;
+                        //long i = (long) this.location.x + 2147483647L | (long) this.location.z + 2147483647L << 32;
+                        long i = LongHash.toLong((int)this.location.x, (int)this.location.z);
+                        //PlayerChunkMap.this.d.remove(i);
                         PlayerChunkMap.this.d.remove(i);
                         PlayerChunkMap.this.f.remove(this);
                     }
@@ -393,9 +414,10 @@
                 this.b.remove(entityplayer);
                 entityplayer.chunkCoordIntPairQueue.remove(this.location);
                 if (this.b.isEmpty()) {
-                    long i = (long) this.location.x + 2147483647L | (long) this.location.z + 2147483647L << 32;
-
+                    //long i = (long) this.location.x + 2147483647L | (long) this.location.z + 2147483647L << 32;
+                    long i = LongHash.toLong((int)this.location.x, (int)this.location.z);
                     this.a(chunk);
+                    //PlayerChunkMap.this.d.remove(i);
                     PlayerChunkMap.this.d.remove(i);
                     PlayerChunkMap.this.f.remove(this);
                     if (this.dirtyCount > 0) {
diff -Naur src_origin/main/java/net/minecraft/server/PlayerConnection.java src/main/java/net/minecraft/server/PlayerConnection.java
--- src_origin/main/java/net/minecraft/server/PlayerConnection.java	2016-02-26 15:27:12.653203771 +0800
+++ src/main/java/net/minecraft/server/PlayerConnection.java	2016-03-16 23:43:30.304124844 +0800
@@ -3,7 +3,6 @@
 import com.google.common.collect.Lists;
 import com.google.common.primitives.Doubles;
 import com.google.common.primitives.Floats;
-import com.google.common.util.concurrent.Futures;
 import io.netty.buffer.Unpooled;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
@@ -23,6 +22,7 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.HashSet;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
@@ -80,12 +80,19 @@
     private static final AtomicIntegerFieldUpdater chatSpamField = AtomicIntegerFieldUpdater.newUpdater(PlayerConnection.class, "chatThrottle");
     // CraftBukkit end
     private int m;
-    private IntHashMap<Short> n = new IntHashMap();
+    //private IntHashMap<Short> n = new IntHashMap();
+    private ConcurrentHashMap<Integer, Short> n = new ConcurrentHashMap();
     private double o;
     private double p;
     private double q;
     private boolean checkMovement = true;
     private boolean processedDisconnect; // CraftBukkit - added
+    
+    //for spigot
+    private int g(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
 
     public PlayerConnection(MinecraftServer minecraftserver, NetworkManager networkmanager, EntityPlayer entityplayer) {
         this.minecraftServer = minecraftserver;
@@ -267,6 +274,8 @@
                     if (true) { // Spigot - don't skip any move events
                         Location oldTo = to.clone();
                         PlayerMoveEvent event = new PlayerMoveEvent(player, from, to);
+                        //set async
+                        event.setAsynchronous();
                         this.server.getPluginManager().callEvent(event);
 
                         // If the event is cancelled we move the player back to their old location.
@@ -1700,7 +1709,8 @@
                     this.player.broadcastCarriedItem();
                     this.player.g = false;
                 } else {
-                    this.n.a(this.player.activeContainer.windowId, Short.valueOf(packetplayinwindowclick.d()));
+                    //this.n.a(this.player.activeContainer.windowId, Short.valueOf(packetplayinwindowclick.d()));
+                    this.n.put(this.g(this.player.activeContainer.windowId), Short.valueOf(packetplayinwindowclick.d()));
                     this.player.playerConnection.sendPacket(new PacketPlayOutTransaction(packetplayinwindowclick.a(), packetplayinwindowclick.d(), false));
                     this.player.activeContainer.a(this.player, false);
                     ArrayList arraylist1 = Lists.newArrayList();
@@ -1818,7 +1828,8 @@
     public void a(PacketPlayInTransaction packetplayintransaction) {
         if (this.player.dead) return; // CraftBukkit
         PlayerConnectionUtils.ensureMainThread(packetplayintransaction, this, this.player.u());
-        Short oshort = (Short) this.n.get(this.player.activeContainer.windowId);
+        //Short oshort = (Short) this.n.get(this.player.activeContainer.windowId);
+        Short oshort = this.n.get(this.g(this.player.activeContainer.windowId));
 
         if (oshort != null && packetplayintransaction.b() == oshort.shortValue() && this.player.activeContainer.windowId == packetplayintransaction.a() && !this.player.activeContainer.c(this.player) && !this.player.isSpectator()) {
             this.player.activeContainer.a(this.player, true);
diff -Naur src_origin/main/java/net/minecraft/server/PlayerInventory.java src/main/java/net/minecraft/server/PlayerInventory.java
--- src_origin/main/java/net/minecraft/server/PlayerInventory.java	2016-02-26 15:27:12.713203776 +0800
+++ src/main/java/net/minecraft/server/PlayerInventory.java	2016-03-16 23:43:30.320124844 +0800
@@ -20,6 +20,7 @@
 
     // CraftBukkit start - add fields and methods
     public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
+    //public Queue<HumanEntity> transaction = new ConcurrentLinkedQueue<HumanEntity>();
     private int maxStack = MAX_STACK;
 
     public ItemStack[] getContents() {
@@ -40,6 +41,8 @@
 
     public List<HumanEntity> getViewers() {
         return transaction;
+        /*List re_list = new ArrayList(transaction);
+        return re_list;*/
     }
 
     public org.bukkit.inventory.InventoryHolder getOwner() {
diff -Naur src_origin/main/java/net/minecraft/server/PlayerList.java src/main/java/net/minecraft/server/PlayerList.java
--- src_origin/main/java/net/minecraft/server/PlayerList.java	2016-02-26 15:27:12.726203777 +0800
+++ src/main/java/net/minecraft/server/PlayerList.java	2016-03-16 23:43:30.328124844 +0800
@@ -1,7 +1,6 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import com.mojang.authlib.GameProfile;
 import io.netty.buffer.Unpooled;
@@ -15,6 +14,8 @@
 import java.util.List;
 import java.util.Map;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -48,13 +49,16 @@
     private static final Logger f = LogManager.getLogger();
     private static final SimpleDateFormat g = new SimpleDateFormat("yyyy-MM-dd \'at\' HH:mm:ss z");
     private final MinecraftServer server;
-    public final List<EntityPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
-    private final Map<UUID, EntityPlayer> j = Maps.newHashMap();
+    //public final List<EntityPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
+    public final List<EntityPlayer> players = Lists.newCopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
+    //private final Map<UUID, EntityPlayer> j = Maps.newHashMap();
+    private final ConcurrentHashMap<UUID, EntityPlayer> j = new ConcurrentHashMap<UUID, EntityPlayer>();
     private final GameProfileBanList k;
     private final IpBanList l;
     private final OpList operators;
     private final WhiteList whitelist;
-    private final Map<UUID, ServerStatisticManager> o;
+    //private final Map<UUID, ServerStatisticManager> o;
+    private final ConcurrentMap<UUID, ServerStatisticManager> o;
     public IPlayerFileData playerFileData;
     private boolean hasWhitelist;
     protected int maxPlayers;
@@ -77,7 +81,8 @@
         this.l = new IpBanList(PlayerList.b);
         this.operators = new OpList(PlayerList.c);
         this.whitelist = new WhiteList(PlayerList.d);
-        this.o = Maps.newHashMap();
+        //this.o = Maps.newHashMap();
+        this.o = new ConcurrentHashMap<UUID, ServerStatisticManager>();
         this.server = minecraftserver;
         this.k.a(false);
         this.l.a(false);
@@ -951,6 +956,7 @@
     public String b(boolean flag) {
         String s = "";
         ArrayList arraylist = Lists.newArrayList(this.players);
+        //List arraylist = Lists.newCopyOnWriteArrayList(this.players);
 
         for (int i = 0; i < arraylist.size(); ++i) {
             if (i > 0) {
@@ -1134,6 +1140,7 @@
 
     public List<EntityPlayer> b(String s) {
         ArrayList arraylist = Lists.newArrayList();
+        //List arraylist = Lists.newCopyOnWriteArrayList();
         Iterator iterator = this.players.iterator();
 
         while (iterator.hasNext()) {
diff -Naur src_origin/main/java/net/minecraft/server/PortalTravelAgent.java src/main/java/net/minecraft/server/PortalTravelAgent.java
--- src_origin/main/java/net/minecraft/server/PortalTravelAgent.java	2016-02-26 15:27:12.766203781 +0800
+++ src/main/java/net/minecraft/server/PortalTravelAgent.java	2016-03-16 23:43:30.333124844 +0800
@@ -1,9 +1,9 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Lists;
 import java.util.Iterator;
-import java.util.List;
+import java.util.Queue;
 import java.util.Random;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 // CraftBukkit start
 import org.bukkit.Location;
@@ -16,7 +16,8 @@
     private final WorldServer a;
     private final Random b;
     private final LongHashMap<PortalTravelAgent.ChunkCoordinatesPortal> c = new LongHashMap();
-    private final List<Long> d = Lists.newArrayList();
+    //private final List<Long> d = Lists.newArrayList();
+    private final Queue<Long> d = new ConcurrentLinkedQueue<Long>();
 
     public PortalTravelAgent(WorldServer worldserver) {
         this.a = worldserver;
diff -Naur src_origin/main/java/net/minecraft/server/RecipesFurnace.java src/main/java/net/minecraft/server/RecipesFurnace.java
--- src_origin/main/java/net/minecraft/server/RecipesFurnace.java	2016-02-26 15:27:12.987203802 +0800
+++ src/main/java/net/minecraft/server/RecipesFurnace.java	2016-03-16 23:43:30.370124844 +0800
@@ -1,16 +1,20 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Maps;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 public class RecipesFurnace {
 
     private static final RecipesFurnace a = new RecipesFurnace();
-    public Map<ItemStack, ItemStack> recipes = Maps.newHashMap();
+    /*public Map<ItemStack, ItemStack> recipes = Maps.newHashMap();
     private Map<ItemStack, Float> c = Maps.newHashMap();
-    public Map customRecipes = Maps.newHashMap(); // CraftBukkit - add field
+    public Map customRecipes = Maps.newHashMap(); // CraftBukkit - add field*/
+    public ConcurrentMap<ItemStack, ItemStack> recipes = new ConcurrentHashMap<ItemStack, ItemStack>();
+    private ConcurrentMap<ItemStack, Float> c = new ConcurrentHashMap<ItemStack, Float>();
+    public ConcurrentMap customRecipes = new ConcurrentHashMap();
 
     public static RecipesFurnace getInstance() {
         return RecipesFurnace.a;
diff -Naur src_origin/main/java/net/minecraft/server/RegionFileCache.java src/main/java/net/minecraft/server/RegionFileCache.java
--- src_origin/main/java/net/minecraft/server/RegionFileCache.java	2016-02-26 15:27:13.038203807 +0800
+++ src/main/java/net/minecraft/server/RegionFileCache.java	2016-03-16 23:43:30.373124844 +0800
@@ -1,16 +1,17 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Maps;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.util.Iterator;
-import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 public class RegionFileCache {
 
-    public static final Map<File, RegionFile> a = Maps.newHashMap(); // Spigot - private -> public
+    //public static final Map<File, RegionFile> a = Maps.newHashMap(); // Spigot - private -> public
+    public static final ConcurrentMap<File, RegionFile> a = new ConcurrentHashMap<File, RegionFile>(); // Spigot - private -> public
 
     public static synchronized RegionFile a(File file, int i, int j) {
         File file1 = new File(file, "region");
diff -Naur src_origin/main/java/net/minecraft/server/ScoreboardServer.java src/main/java/net/minecraft/server/ScoreboardServer.java
--- src_origin/main/java/net/minecraft/server/ScoreboardServer.java	2016-02-26 15:27:13.079203810 +0800
+++ src/main/java/net/minecraft/server/ScoreboardServer.java	2016-03-16 23:43:30.391124844 +0800
@@ -7,11 +7,13 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
 
 public class ScoreboardServer extends Scoreboard {
 
     private final MinecraftServer a;
-    private final Set<ScoreboardObjective> b = Sets.newHashSet();
+    //private final Set<ScoreboardObjective> b = Sets.newHashSet();
+    private final Set<ScoreboardObjective> b = new CopyOnWriteArraySet<ScoreboardObjective>();
     private PersistentScoreboard c;
 
     public ScoreboardServer(MinecraftServer minecraftserver) {
diff -Naur src_origin/main/java/net/minecraft/server/ServerConnection.java src/main/java/net/minecraft/server/ServerConnection.java
--- src_origin/main/java/net/minecraft/server/ServerConnection.java	2016-02-26 15:27:13.131203815 +0800
+++ src/main/java/net/minecraft/server/ServerConnection.java	2016-03-16 23:43:30.402124844 +0800
@@ -23,7 +23,9 @@
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -61,6 +63,8 @@
     public volatile boolean d;
     private final List<ChannelFuture> g = Collections.synchronizedList(Lists.<ChannelFuture>newArrayList());
     private final List<NetworkManager> h = Collections.synchronizedList(Lists.<NetworkManager>newArrayList());
+    /*private final List<ChannelFuture> g = Lists.<ChannelFuture>newCopyOnWriteArrayList();
+    private final Queue<NetworkManager> h = new ConcurrentLinkedQueue<NetworkManager>();*/
 
     public ServerConnection(MinecraftServer minecraftserver) {
         this.f = minecraftserver;
diff -Naur src_origin/main/java/net/minecraft/server/ServerStatisticManager.java src/main/java/net/minecraft/server/ServerStatisticManager.java
--- src_origin/main/java/net/minecraft/server/ServerStatisticManager.java	2016-02-26 15:27:13.135203816 +0800
+++ src/main/java/net/minecraft/server/ServerStatisticManager.java	2016-03-16 23:43:30.405124844 +0800
@@ -15,6 +15,7 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.Map.Entry;
+import java.util.concurrent.CopyOnWriteArraySet;
 import org.apache.commons.io.FileUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -24,7 +25,8 @@
     private static final Logger b = LogManager.getLogger();
     private final MinecraftServer c;
     private final File d;
-    private final Set<Statistic> e = Sets.newHashSet();
+    //private final Set<Statistic> e = Sets.newHashSet();
+    private final Set<Statistic> e = new CopyOnWriteArraySet<Statistic>();
     private int f = -300;
     private boolean g = false;
 
diff -Naur src_origin/main/java/net/minecraft/server/SpawnerCreature.java src/main/java/net/minecraft/server/SpawnerCreature.java
--- src_origin/main/java/net/minecraft/server/SpawnerCreature.java	2016-02-26 15:27:13.289203830 +0800
+++ src/main/java/net/minecraft/server/SpawnerCreature.java	2016-03-16 23:43:30.426124844 +0800
@@ -1,21 +1,23 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Sets;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
-import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.FutureTask;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.util.LongHash;
-import org.bukkit.craftbukkit.util.LongHashSet;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
+import org.hose.SpawnerCreature_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public final class SpawnerCreature {
 
     private static final int a = (int) Math.pow(17.0D, 2.0D);
-    private final LongHashSet b = new LongHashSet(); // CraftBukkit
+    //private final LongHashSet b = new LongHashSet(); // CraftBukkit
+    private ConcurrentHashMap<Long, Long> b = new ConcurrentHashMap<Long, Long>(); // CraftBukkit
 
     public SpawnerCreature() {}
 
@@ -23,13 +25,15 @@
     private int getEntityCount(WorldServer server, Class oClass)
     {
         int i = 0;
-        Iterator<Long> it = this.b.iterator();
+        //Iterator<Long> it = this.b.iterator();
+        Iterator<Long> it = this.b.keySet().iterator();
         while ( it.hasNext() )
         {
             Long coord = it.next();
             int x = LongHash.msw( coord );
             int z = LongHash.lsw( coord );
-            if ( !server.chunkProviderServer.unloadQueue.contains( coord ) && server.isChunkLoaded( x, z, true ) )
+            //if ( !server.chunkProviderServer.unloadQueue.contains( coord ) && server.isChunkLoaded( x, z, true ) )
+            if ( !server.chunkProviderServer.unloadQueue.containsKey( coord ) && server.isChunkLoaded( x, z, true ) )
             {
                 i += server.getChunkAt( x, z ).entityCount.get( oClass );
             }
@@ -37,7 +41,22 @@
         return i;
     }
     // Spigot end
-
+    /*
+    public int a(WorldServer worldserver, boolean flag, boolean flag1, boolean flag2) {
+        //return a_hose(worldserver, flag, flag1, flag2);
+        SpigotWorldConfig.SpawnerCreatureTask = new FutureTask(new SpawnerCreature_Pool(this, worldserver, flag, flag1, flag2));
+        SpigotWorldConfig.spawncreaturepool_executor.submit(SpigotWorldConfig.SpawnerCreatureTask);
+        try {
+            return SpigotWorldConfig.SpawnerCreatureTask.get();
+        } catch (InterruptedException ex) {
+            Logger.getLogger(SpawnerCreature.class.getName()).log(Level.SEVERE, null, ex);
+        } catch (ExecutionException ex) {
+            Logger.getLogger(SpawnerCreature.class.getName()).log(Level.SEVERE, null, ex);
+        }
+        return 0;
+    }*/
+    
+    //callable
     public int a(WorldServer worldserver, boolean flag, boolean flag1, boolean flag2) {
         if (!flag && !flag1) {
             return 0;
@@ -47,8 +66,9 @@
             Iterator iterator = worldserver.players.iterator();
 
             int j;
-            int k;
-
+            //int k;
+            int k = 0;
+            //long st01 = System.nanoTime();
             while (iterator.hasNext()) {
                 EntityHuman entityhuman = (EntityHuman) iterator.next();
 
@@ -70,10 +90,12 @@
                             // ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i1 + l, k + j);
 
                             long chunkCoords = LongHash.toLong(i1 + l, k + j);
-                            if (!this.b.contains(chunkCoords)) {
+                            //if (!this.b.contains(chunkCoords)) {
+                            if (!this.b.containsKey(chunkCoords)) {
                                 ++i;
                                 if (!flag3 && worldserver.getWorldBorder().isInBounds(i1 + l, k + j)) {
-                                    this.b.add(chunkCoords);
+                                    //this.b.add(chunkCoords);
+                                    this.b.put(chunkCoords, chunkCoords);
                                 }
                             }
                             // CraftBukkit end
@@ -81,17 +103,26 @@
                     }
                 }
             }
-
+            /*long et01 = System.nanoTime();
+            System.out.println("01: "+(et01-st01)+"ns");*/
+            
             int j1 = 0;
             BlockPosition blockposition = worldserver.getSpawn();
             EnumCreatureType[] aenumcreaturetype = EnumCreatureType.values();
 
             j = aenumcreaturetype.length;
 
+            //long st02 = System.nanoTime();
             for (int k1 = 0; k1 < j; ++k1) {
+                //create callable evry type
+                //j1 = spawn_calc_hose(aenumcreaturetype, blockposition, i, j1, k, k1, worldserver, flag, flag1, flag2);
+                SpigotWorldConfig.SpawnerCreatureTask = new FutureTask(new SpawnerCreature_Pool(this, aenumcreaturetype, blockposition, i, j1, k, k1, worldserver, flag, flag1, flag2));
+                SpigotWorldConfig.spawncreaturepool_executor.submit(SpigotWorldConfig.SpawnerCreatureTask);
+                
+                /*
                 EnumCreatureType enumcreaturetype = aenumcreaturetype[k1];
 
-               // CraftBukkit start - Use per-world spawn limits
+                // CraftBukkit start - Use per-world spawn limits
                 int limit = enumcreaturetype.b();
                 switch (enumcreaturetype) {
                     case MONSTER:
@@ -111,111 +142,244 @@
                 if (limit == 0) {
                     continue;
                 }
-				int mobcnt = 0; // Spigot
+                int mobcnt = 0; // Spigot
                 // CraftBukkit end
 
                 if ((!enumcreaturetype.d() || flag1) && (enumcreaturetype.d() || flag) && (!enumcreaturetype.e() || flag2)) {
-                    k = worldserver.a(enumcreaturetype.a());
-                    int l1 = limit * i / a; // CraftBukkit - use per-world limits
+                k = worldserver.a(enumcreaturetype.a());
+                int l1 = limit * i / a; // CraftBukkit - use per-world limits
+
+                if ((mobcnt = getEntityCount(worldserver, enumcreaturetype.a())) <= limit * i / 256) {
+                //Iterator iterator1 = this.b.iterator();
+                Iterator iterator1 = this.b.keySet().iterator();
+
+                int moblimit = (limit * i / 256) - mobcnt + 1; // Spigot - up to 1 more than limit
+                label115:
+                while (iterator1.hasNext() && (moblimit > 0)) { // Spigot - while more allowed
+                // CraftBukkit start = use LongHash and LongObjectHashMap
+                long key = ((Long) iterator1.next()).longValue();
+                BlockPosition blockposition1 = getRandomPosition(worldserver, LongHash.msw(key), LongHash.lsw(key));
+                // CraftBukkit
+                int i2 = blockposition1.getX();
+                int j2 = blockposition1.getY();
+                int k2 = blockposition1.getZ();
+                Block block = worldserver.getType(blockposition1).getBlock();
+
+                if (!block.isOccluding()) {
+                int l2 = 0;
+                int i3 = 0;
+
+                while (i3 < 3) {
+                int j3 = i2;
+                int k3 = j2;
+                int l3 = k2;
+                byte b1 = 6;
+                BiomeBase.BiomeMeta biomebase_biomemeta = null;
+                GroupDataEntity groupdataentity = null;
+                int i4 = 0;
+
+                while (true) {
+                if (i4 < 4) {
+                label108: {
+                j3 += worldserver.random.nextInt(b1) - worldserver.random.nextInt(b1);
+                k3 += worldserver.random.nextInt(1) - worldserver.random.nextInt(1);
+                l3 += worldserver.random.nextInt(b1) - worldserver.random.nextInt(b1);
+                BlockPosition blockposition2 = new BlockPosition(j3, k3, l3);
+                float f = (float) j3 + 0.5F;
+                float f1 = (float) l3 + 0.5F;
+
+                if (!worldserver.isPlayerNearby((double) f, (double) k3, (double) f1, 24.0D) && blockposition.c((double) f, (double) k3, (double) f1) >= 576.0D) {
+                    if (biomebase_biomemeta == null) {
+                        biomebase_biomemeta = worldserver.a(enumcreaturetype, blockposition2);
+                    if (biomebase_biomemeta == null) {
+                        break label108;
+                    }
+                }
 
-                    if ((mobcnt = getEntityCount(worldserver, enumcreaturetype.a())) <= limit * i / 256) {
-                        Iterator iterator1 = this.b.iterator();
+                if (worldserver.a(enumcreaturetype, biomebase_biomemeta, blockposition2) && a(EntityPositionTypes.a(biomebase_biomemeta.b), worldserver, blockposition2)) {
+                EntityInsentient entityinsentient;
 
-                        int moblimit = (limit * i / 256) - mobcnt + 1; // Spigot - up to 1 more than limit
-                        label115:
-                        while (iterator1.hasNext() && (moblimit > 0)) { // Spigot - while more allowed
-                            // CraftBukkit start = use LongHash and LongObjectHashMap
-                            long key = ((Long) iterator1.next()).longValue();
-                            BlockPosition blockposition1 = getRandomPosition(worldserver, LongHash.msw(key), LongHash.lsw(key));
-                            // CraftBukkit
-                            int i2 = blockposition1.getX();
-                            int j2 = blockposition1.getY();
-                            int k2 = blockposition1.getZ();
-                            Block block = worldserver.getType(blockposition1).getBlock();
-
-                            if (!block.isOccluding()) {
-                                int l2 = 0;
-                                int i3 = 0;
-
-                                while (i3 < 3) {
-                                    int j3 = i2;
-                                    int k3 = j2;
-                                    int l3 = k2;
-                                    byte b1 = 6;
-                                    BiomeBase.BiomeMeta biomebase_biomemeta = null;
-                                    GroupDataEntity groupdataentity = null;
-                                    int i4 = 0;
-
-                                    while (true) {
-                                        if (i4 < 4) {
-                                            label108: {
-                                                j3 += worldserver.random.nextInt(b1) - worldserver.random.nextInt(b1);
-                                                k3 += worldserver.random.nextInt(1) - worldserver.random.nextInt(1);
-                                                l3 += worldserver.random.nextInt(b1) - worldserver.random.nextInt(b1);
-                                                BlockPosition blockposition2 = new BlockPosition(j3, k3, l3);
-                                                float f = (float) j3 + 0.5F;
-                                                float f1 = (float) l3 + 0.5F;
-
-                                                if (!worldserver.isPlayerNearby((double) f, (double) k3, (double) f1, 24.0D) && blockposition.c((double) f, (double) k3, (double) f1) >= 576.0D) {
-                                                    if (biomebase_biomemeta == null) {
-                                                        biomebase_biomemeta = worldserver.a(enumcreaturetype, blockposition2);
-                                                        if (biomebase_biomemeta == null) {
-                                                            break label108;
-                                                        }
-                                                    }
+                try {
+                entityinsentient = (EntityInsentient) biomebase_biomemeta.b.getConstructor(new Class[] { World.class}).newInstance(new Object[] { worldserver});
+                } catch (Exception exception) {
+                exception.printStackTrace();
+                return j1;
+                }
+
+                entityinsentient.setPositionRotation((double) f, (double) k3, (double) f1, worldserver.random.nextFloat() * 360.0F, 0.0F);
+                if (entityinsentient.bR() && entityinsentient.canSpawn()) {
+                groupdataentity = entityinsentient.prepare(worldserver.E(new BlockPosition(entityinsentient)), groupdataentity);
+                if (entityinsentient.canSpawn()) {
+                ++l2;
+                worldserver.addEntity(entityinsentient, SpawnReason.NATURAL); // CraftBukkit - Added a reason for spawning this creature
+                //SpigotWorldConfig.SpawnerCreatureTask = new FutureTask(new SpawnerCreature_Pool(worldserver, entityinsentient));
+                //SpigotWorldConfig.spawncreaturepool_executor.submit(SpigotWorldConfig.SpawnerCreatureTask);
+                }
+
+                // Spigot start
+                if ( --moblimit <= 0 )
+                {
+                // If we're past limit, stop spawn
+                continue label115;
+                }
+                // Spigot end
+                if (l2 >= entityinsentient.bV()) {
+                continue label115;
+                }
+                }
+
+                j1 += l2;
+                }
+                }
+
+                ++i4;
+                continue;
+                }
+                }
+
+                ++i3;
+                break;
+                }
+                }
+                }
+                }
+                }
+                }*/
+            }
+            /*long et02 = System.nanoTime();
+            System.out.println("02: "+(et02-st02)+"ns");
+            System.out.println("j1: "+j1);*/
+            return j1;
+        }
+    }
+    
+    public int spawn_calc_hose(EnumCreatureType[] aenumcreaturetype, BlockPosition blockposition, int i, int j1, int k, int k1, WorldServer worldserver, boolean flag, boolean flag1, boolean flag2){
+        EnumCreatureType enumcreaturetype = aenumcreaturetype[k1];
+
+        // CraftBukkit start - Use per-world spawn limits
+        int limit = enumcreaturetype.b();
+        switch (enumcreaturetype) {
+            case MONSTER:
+                limit = worldserver.getWorld().getMonsterSpawnLimit();
+                break;
+            case CREATURE:
+                limit = worldserver.getWorld().getAnimalSpawnLimit();
+                break;
+            case WATER_CREATURE:
+                limit = worldserver.getWorld().getWaterAnimalSpawnLimit();
+                break;
+            case AMBIENT:
+                limit = worldserver.getWorld().getAmbientSpawnLimit();
+                break;
+        }
 
-                                                    if (worldserver.a(enumcreaturetype, biomebase_biomemeta, blockposition2) && a(EntityPositionTypes.a(biomebase_biomemeta.b), worldserver, blockposition2)) {
-                                                        EntityInsentient entityinsentient;
+        if (limit == 0) {
+            return 0;
+        }
+                        int mobcnt = 0; // Spigot
+        // CraftBukkit end
 
-                                                        try {
-                                                            entityinsentient = (EntityInsentient) biomebase_biomemeta.b.getConstructor(new Class[] { World.class}).newInstance(new Object[] { worldserver});
-                                                        } catch (Exception exception) {
-                                                            exception.printStackTrace();
-                                                            return j1;
-                                                        }
-
-                                                        entityinsentient.setPositionRotation((double) f, (double) k3, (double) f1, worldserver.random.nextFloat() * 360.0F, 0.0F);
-                                                        if (entityinsentient.bR() && entityinsentient.canSpawn()) {
-                                                            groupdataentity = entityinsentient.prepare(worldserver.E(new BlockPosition(entityinsentient)), groupdataentity);
-                                                            if (entityinsentient.canSpawn()) {
-                                                                ++l2;
-                                                                worldserver.addEntity(entityinsentient, SpawnReason.NATURAL); // CraftBukkit - Added a reason for spawning this creature
-                                                            }
-
-                                                            // Spigot start
-                                                            if ( --moblimit <= 0 )
-                                                            {
-                                                                // If we're past limit, stop spawn
-                                                                continue label115;
-                                                            }
-                                                            // Spigot end
-                                                            if (l2 >= entityinsentient.bV()) {
-                                                                continue label115;
-                                                            }
-                                                        }
+        if ((!enumcreaturetype.d() || flag1) && (enumcreaturetype.d() || flag) && (!enumcreaturetype.e() || flag2)) {
+            k = worldserver.a(enumcreaturetype.a());
+            int l1 = limit * i / a; // CraftBukkit - use per-world limits
+
+            if ((mobcnt = getEntityCount(worldserver, enumcreaturetype.a())) <= limit * i / 256) {
+                //Iterator iterator1 = this.b.iterator();
+                Iterator iterator1 = this.b.keySet().iterator();
+
+                int moblimit = (limit * i / 256) - mobcnt + 1; // Spigot - up to 1 more than limit
+                label115:
+                while (iterator1.hasNext() && (moblimit > 0)) { // Spigot - while more allowed
+                    // CraftBukkit start = use LongHash and LongObjectHashMap
+                    long key = ((Long) iterator1.next()).longValue();
+                    BlockPosition blockposition1 = getRandomPosition(worldserver, LongHash.msw(key), LongHash.lsw(key));
+                    // CraftBukkit
+                    int i2 = blockposition1.getX();
+                    int j2 = blockposition1.getY();
+                    int k2 = blockposition1.getZ();
+                    Block block = worldserver.getType(blockposition1).getBlock();
+
+                    if (!block.isOccluding()) {
+                        int l2 = 0;
+                        int i3 = 0;
+
+                        while (i3 < 3) {
+                            int j3 = i2;
+                            int k3 = j2;
+                            int l3 = k2;
+                            byte b1 = 6;
+                            BiomeBase.BiomeMeta biomebase_biomemeta = null;
+                            GroupDataEntity groupdataentity = null;
+                            int i4 = 0;
+
+                            while (true) {
+                                if (i4 < 4) {
+                                    label108: {
+                                        j3 += worldserver.random.nextInt(b1) - worldserver.random.nextInt(b1);
+                                        k3 += worldserver.random.nextInt(1) - worldserver.random.nextInt(1);
+                                        l3 += worldserver.random.nextInt(b1) - worldserver.random.nextInt(b1);
+                                        BlockPosition blockposition2 = new BlockPosition(j3, k3, l3);
+                                        float f = (float) j3 + 0.5F;
+                                        float f1 = (float) l3 + 0.5F;
+
+                                        if (!worldserver.isPlayerNearby((double) f, (double) k3, (double) f1, 24.0D) && blockposition.c((double) f, (double) k3, (double) f1) >= 576.0D) {
+                                            if (biomebase_biomemeta == null) {
+                                                biomebase_biomemeta = worldserver.a(enumcreaturetype, blockposition2);
+                                                if (biomebase_biomemeta == null) {
+                                                    break label108;
+                                                }
+                                            }
+
+                                            if (worldserver.a(enumcreaturetype, biomebase_biomemeta, blockposition2) && a(EntityPositionTypes.a(biomebase_biomemeta.b), worldserver, blockposition2)) {
+                                                EntityInsentient entityinsentient;
 
-                                                        j1 += l2;
+                                                try {
+                                                    entityinsentient = (EntityInsentient) biomebase_biomemeta.b.getConstructor(new Class[] { World.class}).newInstance(new Object[] { worldserver});
+                                                } catch (Exception exception) {
+                                                    exception.printStackTrace();
+                                                    return j1;
+                                                }
+
+                                                entityinsentient.setPositionRotation((double) f, (double) k3, (double) f1, worldserver.random.nextFloat() * 360.0F, 0.0F);
+                                                if (entityinsentient.bR() && entityinsentient.canSpawn()) {
+                                                    groupdataentity = entityinsentient.prepare(worldserver.E(new BlockPosition(entityinsentient)), groupdataentity);
+                                                    if (entityinsentient.canSpawn()) {
+                                                        ++l2;
+                                                        worldserver.addEntity(entityinsentient, SpawnReason.NATURAL); // CraftBukkit - Added a reason for spawning this creature
+                                                    }
+
+                                                    // Spigot start
+                                                    if ( --moblimit <= 0 )
+                                                    {
+                                                        // If we're past limit, stop spawn
+                                                        continue label115;
+                                                    }
+                                                    // Spigot end
+                                                    if (l2 >= entityinsentient.bV()) {
+                                                        continue label115;
                                                     }
                                                 }
 
-                                                ++i4;
-                                                continue;
+                                                j1 += l2;
                                             }
                                         }
 
-                                        ++i3;
-                                        break;
+                                        ++i4;
+                                        continue;
                                     }
                                 }
+
+                                ++i3;
+                                break;
                             }
                         }
                     }
                 }
             }
-
-            return j1;
         }
+        return j1;
     }
+    
 
     protected static BlockPosition getRandomPosition(World world, int i, int j) {
         Chunk chunk = world.getChunkAt(i, j);
diff -Naur src_origin/main/java/net/minecraft/server/StructureGenerator.java src/main/java/net/minecraft/server/StructureGenerator.java
--- src_origin/main/java/net/minecraft/server/StructureGenerator.java	2016-02-26 15:27:13.339203835 +0800
+++ src/main/java/net/minecraft/server/StructureGenerator.java	2016-03-16 23:43:30.438124844 +0800
@@ -1,16 +1,17 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Maps;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
 import java.util.Random;
 import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 public abstract class StructureGenerator extends WorldGenBase {
 
     private PersistentStructure d;
-    protected Map<Long, StructureStart> e = Maps.newHashMap();
+    //protected Map<Long, StructureStart> e = Maps.newHashMap(); //casue concurrent problem
+    protected ConcurrentMap<Long, StructureStart> e = new ConcurrentHashMap<Long, StructureStart>();
 
     public StructureGenerator() {}
 
diff -Naur src_origin/main/java/net/minecraft/server/TileEntityBeacon.java src/main/java/net/minecraft/server/TileEntityBeacon.java
--- src_origin/main/java/net/minecraft/server/TileEntityBeacon.java	2016-02-26 15:27:13.400203841 +0800
+++ src/main/java/net/minecraft/server/TileEntityBeacon.java	2016-03-16 23:43:30.454124844 +0800
@@ -1,9 +1,13 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
@@ -13,7 +17,8 @@
 public class TileEntityBeacon extends TileEntityContainer implements IUpdatePlayerListBox, IInventory {
 
     public static final MobEffectList[][] a = new MobEffectList[][] { { MobEffectList.FASTER_MOVEMENT, MobEffectList.FASTER_DIG}, { MobEffectList.RESISTANCE, MobEffectList.JUMP}, { MobEffectList.INCREASE_DAMAGE}, { MobEffectList.REGENERATION}};
-    private final List<TileEntityBeacon.BeaconColorTracker> f = Lists.newArrayList();
+    //private final List<TileEntityBeacon.BeaconColorTracker> f = Lists.newArrayList();
+    private final Queue<TileEntityBeacon.BeaconColorTracker> f = new ConcurrentLinkedQueue();
     private boolean i;
     private int j = -1;
     private int k;
@@ -22,6 +27,7 @@
     private String n;
     // CraftBukkit start - add fields and methods
     public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
+    //public Queue<HumanEntity> transaction = new ConcurrentLinkedQueue<HumanEntity>();
     private int maxStack = MAX_STACK;
 
     public ItemStack[] getContents() {
@@ -38,6 +44,8 @@
 
     public List<HumanEntity> getViewers() {
         return transaction;
+        /*List re_list = new ArrayList(transaction);
+        return re_list;*/
     }
 
     public void setMaxStackSize(int size) {
diff -Naur src_origin/main/java/net/minecraft/server/TileEntityBrewingStand.java src/main/java/net/minecraft/server/TileEntityBrewingStand.java
--- src_origin/main/java/net/minecraft/server/TileEntityBrewingStand.java	2016-02-26 15:27:13.432203844 +0800
+++ src/main/java/net/minecraft/server/TileEntityBrewingStand.java	2016-03-16 23:43:30.460124844 +0800
@@ -1,7 +1,11 @@
 package net.minecraft.server;
 
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
@@ -24,6 +28,7 @@
 
     // CraftBukkit start - add fields and methods
     public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
+    //public Queue<HumanEntity> transaction = new ConcurrentLinkedQueue<HumanEntity>();
     private int maxStack = 64;
 
     public void onOpen(CraftHumanEntity who) {
@@ -36,6 +41,8 @@
 
     public List<HumanEntity> getViewers() {
         return transaction;
+        /*List re_list = new ArrayList(transaction);
+        return re_list;*/
     }
 
     public ItemStack[] getContents() {
diff -Naur src_origin/main/java/net/minecraft/server/TileEntityChest.java src/main/java/net/minecraft/server/TileEntityChest.java
--- src_origin/main/java/net/minecraft/server/TileEntityChest.java	2016-02-26 15:27:13.445203845 +0800
+++ src/main/java/net/minecraft/server/TileEntityChest.java	2016-03-16 23:43:30.457124844 +0800
@@ -2,6 +2,7 @@
 
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
@@ -27,6 +28,7 @@
 
     // CraftBukkit start - add fields and methods
     public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
+    //public List<HumanEntity> transaction = new CopyOnWriteArrayList<HumanEntity>();
     private int maxStack = MAX_STACK;
 
     public ItemStack[] getContents() {
diff -Naur src_origin/main/java/net/minecraft/server/TileEntityFurnace.java src/main/java/net/minecraft/server/TileEntityFurnace.java
--- src_origin/main/java/net/minecraft/server/TileEntityFurnace.java	2016-02-26 15:27:13.533203853 +0800
+++ src/main/java/net/minecraft/server/TileEntityFurnace.java	2016-03-16 23:43:30.472124844 +0800
@@ -2,6 +2,8 @@
 
 // CraftBukkit start
 import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+import org.apache.logging.log4j.LogManager;
 
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.entity.HumanEntity;
@@ -26,6 +28,7 @@
     private int lastTick = MinecraftServer.currentTick;
     private int maxStack = MAX_STACK;
     public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
+    //public List<HumanEntity> transaction = new CopyOnWriteArrayList<HumanEntity>();
 
     public ItemStack[] getContents() {
         return this.items;
@@ -178,7 +181,7 @@
     public void c() {
         boolean flag = (this.w() == Blocks.LIT_FURNACE); // CraftBukkit - SPIGOT-844 - Check if furnace block is lit using the block instead of burn time // PAIL: Rename
         boolean flag1 = false;
-
+        
         // CraftBukkit start - Use wall time instead of ticks for cooking
         int elapsedTicks = MinecraftServer.currentTick - this.lastTick;
         this.lastTick = MinecraftServer.currentTick;
@@ -213,7 +216,7 @@
 
                     FurnaceBurnEvent furnaceBurnEvent = new FurnaceBurnEvent(this.world.getWorld().getBlockAt(position.getX(), position.getY(), position.getZ()), fuel, fuelTime(this.items[1]));
                     this.world.getServer().getPluginManager().callEvent(furnaceBurnEvent);
-
+                    
                     if (furnaceBurnEvent.isCancelled()) {
                         return;
                     }
@@ -248,7 +251,7 @@
                 }
                 */
             }
-
+            
             if (flag != this.isBurning()) {
                 flag1 = true;
                 BlockFurnace.a(this.isBurning(), this.world, this.position);
@@ -259,7 +262,7 @@
         if (flag1) {
             this.update();
         }
-
+        
     }
 
     public int a(ItemStack itemstack) {
@@ -273,7 +276,13 @@
             ItemStack itemstack = RecipesFurnace.getInstance().getResult(this.items[0]);
 
             // CraftBukkit - consider resultant count instead of current count
-            return itemstack == null ? false : (this.items[2] == null ? true : (!this.items[2].doMaterialsMatch(itemstack) ? false : (this.items[2].count + itemstack.count <= this.getMaxStackSize() && this.items[2].count < this.items[2].getMaxStackSize() ? true : this.items[2].count + itemstack.count <= itemstack.getMaxStackSize())));
+            //return itemstack == null ? false : (this.items[2] == null ? true : (!this.items[2].doMaterialsMatch(itemstack) ? false : (this.items[2].count + itemstack.count <= this.getMaxStackSize() && this.items[2].count < this.items[2].getMaxStackSize() ? true : this.items[2].count + itemstack.count <= itemstack.getMaxStackSize())));
+            try {
+                return itemstack == null ? false : (this.items[2] == null ? true : (!this.items[2].doMaterialsMatch(itemstack) ? false : (this.items[2].count + itemstack.count <= this.getMaxStackSize() && this.items[2].count < this.items[2].getMaxStackSize() ? true : this.items[2].count + itemstack.count <= itemstack.getMaxStackSize())));
+            } catch (Exception ex) {
+                LogManager.getLogger().warn("Something is wrong in TileEntityFurnace with canBurn(). "+ex);
+                return false;//prevent null error
+            }
         }
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/TileEntityHopper.java src/main/java/net/minecraft/server/TileEntityHopper.java
--- src_origin/main/java/net/minecraft/server/TileEntityHopper.java	2016-02-26 15:27:13.566203856 +0800
+++ src/main/java/net/minecraft/server/TileEntityHopper.java	2016-03-16 23:43:30.478124844 +0800
@@ -1,7 +1,10 @@
 package net.minecraft.server;
 
+import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+import org.apache.commons.lang.ArrayUtils;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
@@ -20,6 +23,7 @@
 
     // CraftBukkit start - add fields and methods
     public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
+    //public List<HumanEntity> transaction = new CopyOnWriteArrayList<HumanEntity>();
     private int maxStack = MAX_STACK;
 
     public ItemStack[] getContents() {
@@ -263,6 +267,8 @@
                         }
 
                         InventoryMoveItemEvent event = new InventoryMoveItemEvent(this.getOwner().getInventory(), oitemstack.clone(), destinationInventory, true);
+                        //set async
+                        event.setAsynchronous();
                         this.getWorld().getServer().getPluginManager().callEvent(event);
                         if (event.isCancelled()) {
                             this.setItem(i, itemstack);
@@ -441,7 +447,13 @@
             return false;
         } else {
             // CraftBukkit start
-            InventoryPickupItemEvent event = new InventoryPickupItemEvent(iinventory.getOwner().getInventory(), (org.bukkit.entity.Item) entityitem.getBukkitEntity());
+            //check which is null
+            Inventory inventory = iinventory.getOwner().getInventory();
+            org.bukkit.entity.Item item = (org.bukkit.entity.Item) entityitem.getBukkitEntity();
+            InventoryPickupItemEvent event = new InventoryPickupItemEvent(inventory, item);
+            //InventoryPickupItemEvent event = new InventoryPickupItemEvent(iinventory.getOwner().getInventory(), (org.bukkit.entity.Item) entityitem.getBukkitEntity());
+            //set async
+            event.setAsynchronous();
             entityitem.world.getServer().getPluginManager().callEvent(event);
             if (event.isCancelled()) {
                 return false;
@@ -621,9 +633,11 @@
     }
 
     public void l() {
+        Arrays.fill(this.items, null);
+        /*
         for (int i = 0; i < this.items.length; ++i) {
             this.items[i] = null;
-        }
+        }*/
 
     }
 }
diff -Naur src_origin/main/java/net/minecraft/server/TileEntity.java src/main/java/net/minecraft/server/TileEntity.java
--- src_origin/main/java/net/minecraft/server/TileEntity.java	2016-02-26 15:27:13.351203836 +0800
+++ src/main/java/net/minecraft/server/TileEntity.java	2016-03-16 23:43:30.450124844 +0800
@@ -1,8 +1,8 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Maps;
 import java.util.Map;
 import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -13,8 +13,10 @@
 
     public CustomTimingsHandler tickTimer = org.bukkit.craftbukkit.SpigotTimings.getTileEntityTimings(this); // Spigot
     private static final Logger a = LogManager.getLogger();
-    private static Map<String, Class<? extends TileEntity>> f = Maps.newHashMap();
-    private static Map<Class<? extends TileEntity>, String> g = Maps.newHashMap();
+    /*private static Map<String, Class<? extends TileEntity>> f = Maps.newHashMap();
+    private static Map<Class<? extends TileEntity>, String> g = Maps.newHashMap();*/
+    private static Map<String, Class<? extends TileEntity>> f = new ConcurrentHashMap<String, Class<? extends TileEntity>>();
+    private static Map<Class<? extends TileEntity>, String> g = new ConcurrentHashMap<Class<? extends TileEntity>, String>();
     protected World world;
     protected BlockPosition position;
     protected boolean d;
@@ -113,7 +115,7 @@
         return this.position;
     }
 
-    public Block w() {
+    synchronized public Block w() {
         if (this.e == null) {
             this.e = this.world.getType(this.position).getBlock();
         }
diff -Naur src_origin/main/java/net/minecraft/server/TileEntityPiston.java src/main/java/net/minecraft/server/TileEntityPiston.java
--- src_origin/main/java/net/minecraft/server/TileEntityPiston.java	2016-02-26 15:27:13.607203860 +0800
+++ src/main/java/net/minecraft/server/TileEntityPiston.java	2016-03-16 23:43:30.498124844 +0800
@@ -12,7 +12,8 @@
     private boolean h;
     private float i;
     private float j;
-    private List<Entity> k = Lists.newArrayList();
+    //private List<Entity> k = Lists.newArrayList();
+    private List<Entity> k = Lists.newCopyOnWriteArrayList();
 
     public TileEntityPiston() {}
 
diff -Naur src_origin/main/java/net/minecraft/server/UserCache.java src/main/java/net/minecraft/server/UserCache.java
--- src_origin/main/java/net/minecraft/server/UserCache.java	2016-02-26 15:27:13.676203866 +0800
+++ src/main/java/net/minecraft/server/UserCache.java	2016-03-16 23:43:30.508124844 +0800
@@ -35,13 +35,17 @@
 import java.util.Locale;
 import java.util.Map;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 import org.apache.commons.io.IOUtils;
 
 public class UserCache {
 
     public static final SimpleDateFormat a = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
-    private final Map<String, UserCache.UserCacheEntry> c = Maps.newHashMap();
-    private final Map<UUID, UserCache.UserCacheEntry> d = Maps.newHashMap();
+    /*private final Map<String, UserCache.UserCacheEntry> c = Maps.newHashMap();
+    private final Map<UUID, UserCache.UserCacheEntry> d = Maps.newHashMap();*/
+    private final Map<String, UserCache.UserCacheEntry> c = new ConcurrentHashMap<String, UserCache.UserCacheEntry>();
+    private final Map<UUID, UserCache.UserCacheEntry> d = new ConcurrentHashMap<UUID, UserCache.UserCacheEntry>();
     private final java.util.Deque<GameProfile> e = new java.util.concurrent.LinkedBlockingDeque<GameProfile>(); // CraftBukkit
     private final MinecraftServer f;
     protected final Gson b;
@@ -155,6 +159,7 @@
 
     public String[] a() {
         ArrayList arraylist = Lists.newArrayList(this.c.keySet());
+        //List arraylist = Lists.newCopyOnWriteArrayList(this.c.keySet());
 
         return (String[]) arraylist.toArray(new String[arraylist.size()]);
     }
diff -Naur src_origin/main/java/net/minecraft/server/WorldBorder.java src/main/java/net/minecraft/server/WorldBorder.java
--- src_origin/main/java/net/minecraft/server/WorldBorder.java	2016-02-26 15:27:13.784203876 +0800
+++ src/main/java/net/minecraft/server/WorldBorder.java	2016-03-16 23:43:30.541124844 +0800
@@ -7,6 +7,7 @@
 public class WorldBorder {
 
     private final List<IWorldBorderListener> a = Lists.newArrayList();
+    //private final List<IWorldBorderListener> a = Lists.newCopyOnWriteArrayList();
     private double b = 0.0D;
     private double c = 0.0D;
     private double d = 6.0E7D;
@@ -186,6 +187,7 @@
 
     protected List<IWorldBorderListener> k() {
         return Lists.newArrayList(this.a);
+        //return Lists.newCopyOnWriteArrayList(this.a);
     }
 
     public void a(IWorldBorderListener iworldborderlistener) {
diff -Naur src_origin/main/java/net/minecraft/server/WorldGenBase.java src/main/java/net/minecraft/server/WorldGenBase.java
--- src_origin/main/java/net/minecraft/server/WorldGenBase.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/WorldGenBase.java	2016-03-16 23:43:30.557124844 +0800
@@ -0,0 +1,34 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class WorldGenBase {
+
+    protected int a = 8;
+    protected Random b = new Random();
+    protected World c;
+
+    public WorldGenBase() {}
+
+    public void a(IChunkProvider ichunkprovider, World world, int i, int j, ChunkSnapshot chunksnapshot) {
+        int k = this.a;
+
+        this.c = world;
+        this.b.setSeed(world.getSeed());
+        long l = this.b.nextLong();
+        long i1 = this.b.nextLong();
+
+        for (int j1 = i - k; j1 <= i + k; ++j1) {
+            for (int k1 = j - k; k1 <= j + k; ++k1) {
+                long l1 = (long) j1 * l;
+                long i2 = (long) k1 * i1;
+
+                this.b.setSeed(l1 ^ i2 ^ world.getSeed());
+                this.a(world, j1, k1, i, j, chunksnapshot);
+            }
+        }
+
+    }
+
+    protected void a(World world, int i, int j, int k, int l, ChunkSnapshot chunksnapshot) {}
+}
diff -Naur src_origin/main/java/net/minecraft/server/WorldGenLargeFeature.java src/main/java/net/minecraft/server/WorldGenLargeFeature.java
--- src_origin/main/java/net/minecraft/server/WorldGenLargeFeature.java	2016-02-26 15:27:13.882203886 +0800
+++ src/main/java/net/minecraft/server/WorldGenLargeFeature.java	2016-03-16 23:43:30.570124844 +0800
@@ -17,6 +17,7 @@
 
     public WorldGenLargeFeature() {
         this.f = Lists.newArrayList();
+        //this.f = Lists.newCopyOnWriteArrayList();
         this.g = 32;
         this.h = 8;
         this.f.add(new BiomeBase.BiomeMeta(EntityWitch.class, 1, 1, 1));
diff -Naur src_origin/main/java/net/minecraft/server/WorldGenStronghold.java src/main/java/net/minecraft/server/WorldGenStronghold.java
--- src_origin/main/java/net/minecraft/server/WorldGenStronghold.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/WorldGenStronghold.java	2016-03-16 23:43:30.590124844 +0800
@@ -0,0 +1,153 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Random;
+import java.util.Map.Entry;
+
+public class WorldGenStronghold extends StructureGenerator {
+
+    private List<BiomeBase> d;
+    private boolean f;
+    private ChunkCoordIntPair[] g;
+    private double h;
+    private int i;
+
+    public WorldGenStronghold() {
+        this.g = new ChunkCoordIntPair[3];
+        this.h = 32.0D;
+        this.i = 3;
+        this.d = Lists.newArrayList();
+        BiomeBase[] abiomebase = BiomeBase.getBiomes();
+        int i = abiomebase.length;
+
+        for (int j = 0; j < i; ++j) {
+            BiomeBase biomebase = abiomebase[j];
+
+            if (biomebase != null && biomebase.an > 0.0F) {
+                this.d.add(biomebase);
+            }
+        }
+
+    }
+
+    public WorldGenStronghold(Map<String, String> map) {
+        this();
+        Iterator iterator = map.entrySet().iterator();
+
+        while (iterator.hasNext()) {
+            Entry entry = (Entry) iterator.next();
+
+            if (((String) entry.getKey()).equals("distance")) {
+                this.h = MathHelper.a((String) entry.getValue(), this.h, 1.0D);
+            } else if (((String) entry.getKey()).equals("count")) {
+                this.g = new ChunkCoordIntPair[MathHelper.a((String) entry.getValue(), this.g.length, 1)];
+            } else if (((String) entry.getKey()).equals("spread")) {
+                this.i = MathHelper.a((String) entry.getValue(), this.i, 1);
+            }
+        }
+
+    }
+
+    public String a() {
+        return "Stronghold";
+    }
+
+    protected boolean a(int i, int j) {
+        if (!this.f) {
+            Random random = new Random();
+
+            random.setSeed(this.c.getSeed());
+            double d0 = random.nextDouble() * 3.141592653589793D * 2.0D;
+            int k = 1;
+
+            for (int l = 0; l < this.g.length; ++l) {
+                double d1 = (1.25D * (double) k + random.nextDouble()) * this.h * (double) k;
+                int i1 = (int) Math.round(Math.cos(d0) * d1);
+                int j1 = (int) Math.round(Math.sin(d0) * d1);
+                BlockPosition blockposition = this.c.getWorldChunkManager().a((i1 << 4) + 8, (j1 << 4) + 8, 112, this.d, random);
+
+                if (blockposition != null) {
+                    i1 = blockposition.getX() >> 4;
+                    j1 = blockposition.getZ() >> 4;
+                }
+
+                this.g[l] = new ChunkCoordIntPair(i1, j1);
+                d0 += 6.283185307179586D * (double) k / (double) this.i;
+                if (l == this.i) {
+                    k += 2 + random.nextInt(5);
+                    this.i += 1 + random.nextInt(2);
+                }
+            }
+
+            this.f = true;
+        }
+
+        ChunkCoordIntPair[] achunkcoordintpair = this.g;
+        int k1 = achunkcoordintpair.length;
+
+        for (int l1 = 0; l1 < k1; ++l1) {
+            ChunkCoordIntPair chunkcoordintpair = achunkcoordintpair[l1];
+
+            if (i == chunkcoordintpair.x && j == chunkcoordintpair.z) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+
+    protected List<BlockPosition> z_() {
+        ArrayList arraylist = Lists.newArrayList();
+        ChunkCoordIntPair[] achunkcoordintpair = this.g;
+        int i = achunkcoordintpair.length;
+
+        for (int j = 0; j < i; ++j) {
+            ChunkCoordIntPair chunkcoordintpair = achunkcoordintpair[j];
+
+            if (chunkcoordintpair != null) {
+                arraylist.add(chunkcoordintpair.a(64));
+            }
+        }
+
+        return arraylist;
+    }
+
+    protected StructureStart b(int i, int j) {
+        WorldGenStronghold.WorldGenStronghold2Start worldgenstronghold_worldgenstronghold2start;
+
+        for (worldgenstronghold_worldgenstronghold2start = new WorldGenStronghold.WorldGenStronghold2Start(this.c, this.b, i, j); worldgenstronghold_worldgenstronghold2start.b().isEmpty() || ((WorldGenStrongholdPieces.WorldGenStrongholdStart) worldgenstronghold_worldgenstronghold2start.b().get(0)).b == null; worldgenstronghold_worldgenstronghold2start = new WorldGenStronghold.WorldGenStronghold2Start(this.c, this.b, i, j)) {
+            ;
+        }
+
+        return worldgenstronghold_worldgenstronghold2start;
+    }
+
+    public static class WorldGenStronghold2Start extends StructureStart {
+
+        public WorldGenStronghold2Start() {}
+
+        public WorldGenStronghold2Start(World world, Random random, int i, int j) {
+            super(i, j);
+            WorldGenStrongholdPieces.b();
+            WorldGenStrongholdPieces.WorldGenStrongholdStart worldgenstrongholdpieces_worldgenstrongholdstart = new WorldGenStrongholdPieces.WorldGenStrongholdStart(0, random, (i << 4) + 2, (j << 4) + 2);
+
+            this.a.add(worldgenstrongholdpieces_worldgenstrongholdstart);
+            worldgenstrongholdpieces_worldgenstrongholdstart.a((StructurePiece) worldgenstrongholdpieces_worldgenstrongholdstart, (List) this.a, random);
+            List list = worldgenstrongholdpieces_worldgenstrongholdstart.c;
+
+            while (!list.isEmpty()) {
+                int k = random.nextInt(list.size());
+                StructurePiece structurepiece = (StructurePiece) list.remove(k);
+
+                structurepiece.a((StructurePiece) worldgenstrongholdpieces_worldgenstrongholdstart, (List) this.a, random);
+            }
+
+            this.c();
+            this.a(world, random, 10);
+        }
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/WorldGenVillagePieces.java src/main/java/net/minecraft/server/WorldGenVillagePieces.java
--- src_origin/main/java/net/minecraft/server/WorldGenVillagePieces.java	2016-02-26 15:27:14.039203900 +0800
+++ src/main/java/net/minecraft/server/WorldGenVillagePieces.java	2016-03-16 23:43:30.613124844 +0800
@@ -2,9 +2,13 @@
 
 import com.google.common.collect.Lists;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.Random;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 public class WorldGenVillagePieces {
 
@@ -25,8 +29,9 @@
     }
 
     public static List<WorldGenVillagePieces.WorldGenVillagePieceWeight> a(Random random, int i) {
-        ArrayList arraylist = Lists.newArrayList();
-
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Collections.synchronizedList(Lists.newArrayList());
+        
         arraylist.add(new WorldGenVillagePieces.WorldGenVillagePieceWeight(WorldGenVillagePieces.WorldGenVillageHouse.class, 4, MathHelper.nextInt(random, 2 + i, 4 + i * 2)));
         arraylist.add(new WorldGenVillagePieces.WorldGenVillagePieceWeight(WorldGenVillagePieces.WorldGenVillageTemple.class, 20, MathHelper.nextInt(random, 0 + i, 1 + i)));
         arraylist.add(new WorldGenVillagePieces.WorldGenVillagePieceWeight(WorldGenVillagePieces.WorldGenVillageLibrary.class, 20, MathHelper.nextInt(random, 0 + i, 2 + i)));
diff -Naur src_origin/main/java/net/minecraft/server/World.java src/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2016-02-26 15:27:13.782203876 +0800
+++ src/main/java/net/minecraft/server/World.java	2016-03-16 23:43:30.539124844 +0800
@@ -2,25 +2,27 @@
 
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
+import io.netty.util.internal.ConcurrentSet;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
-import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.Callable;
 
 // CraftBukkit start
-import com.google.common.collect.Maps;
-import java.util.Map;
-
+import java.util.Queue;
+import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.FutureTask;
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.craftbukkit.util.LongHashSet;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
 import org.bukkit.generator.ChunkGenerator;
 import org.bukkit.craftbukkit.CraftServer;
@@ -29,8 +31,9 @@
 import org.bukkit.event.block.BlockCanBuildEvent;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
-import org.bukkit.event.weather.WeatherChangeEvent;
-import org.bukkit.event.weather.ThunderChangeEvent;
+import org.hose.AddParticlePool;
+import org.hose.EntityTick_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class World implements IBlockAccess {
@@ -38,39 +41,52 @@
     private int a = 63;
     protected boolean e;
     // Spigot start - guard entity list from removals
-    public final List<Entity> entityList = new java.util.ArrayList<Entity>()
+    //public final List<Entity> entityList = new java.util.ArrayList<Entity>()
+    public final List<Entity> entityList = new CopyOnWriteArrayList<Entity>();
+    //public final CopyOnWriteArrayList<Entity> entityList = new CopyOnWriteArrayList<Entity>()
+    /*
+    public final List<Entity> entityList = new CopyOnWriteArrayList<Entity>()
     {
         @Override
         public Entity remove(int index)
         {
-            guard();
+            //guard();
             return super.remove( index );
         }
 
         @Override
         public boolean remove(Object o)
         {
-            guard();
+            //guard();
             return super.remove( o );
         }
-
-        private void guard()
-        {
-            if ( guardEntityList )
-            {
-                throw new java.util.ConcurrentModificationException();
-            }
-        }
-    };
+        
+        
+        //private void guard()
+        //{
+        //    if ( guardEntityList )
+        //    {
+        //        throw new java.util.ConcurrentModificationException();
+        //    }
+        //}
+    };*/
     // Spigot end
-    protected final List<Entity> g = Lists.newArrayList();
+    /*protected final List<Entity> g = Lists.newArrayList();
     public final List<TileEntity> h = Lists.newArrayList();
     public final List<TileEntity> tileEntityList = Lists.newArrayList();
     private final List<TileEntity> b = Lists.newArrayList();
     private final List<TileEntity> c = Lists.newArrayList();
     public final List<EntityHuman> players = Lists.newArrayList();
-    public final List<Entity> k = Lists.newArrayList();
-    protected final IntHashMap<Entity> entitiesById = new IntHashMap();
+    public final List<Entity> k = Lists.newArrayList();*/
+    protected final Queue<Entity> g = new ConcurrentLinkedQueue();
+    public final List<TileEntity> h = Lists.newCopyOnWriteArrayList();
+    public final List<TileEntity> tileEntityList = Lists.newCopyOnWriteArrayList();
+    private final Queue<TileEntity> b = new ConcurrentLinkedQueue<TileEntity>();
+    private final List<TileEntity> c = Lists.newCopyOnWriteArrayList();
+    public final List<EntityHuman> players = Lists.newCopyOnWriteArrayList();
+    public final List<Entity> k = Lists.newCopyOnWriteArrayList();
+    //protected final IntHashMap<Entity> entitiesById = new IntHashMap();
+    protected final ConcurrentHashMap<Integer, Entity> entitiesById = new ConcurrentHashMap();
     private long d = 16777215L;
     private int I;
     protected int m = (new Random()).nextInt();
@@ -82,8 +98,10 @@
     private int J;
     public final Random random = new Random();
     public WorldProvider worldProvider; // CraftBukkit - remove final
-    protected List<IWorldAccess> u = Lists.newArrayList();
-    protected IChunkProvider chunkProvider;
+    //protected List<IWorldAccess> u = Lists.newArrayList();
+    protected Queue<IWorldAccess> u = new ConcurrentLinkedQueue<IWorldAccess>();
+    //protected IChunkProvider chunkProvider;
+    public IChunkProvider chunkProvider;
     protected final IDataManager dataManager;
     public WorldData worldData; // CraftBukkit - public
     protected boolean isLoading;
@@ -110,7 +128,8 @@
 
     public boolean captureBlockStates = false;
     public boolean captureTreeGeneration = false;
-    public ArrayList<BlockState> capturedBlockStates= new ArrayList<BlockState>(){
+    //public ArrayList<BlockState> capturedBlockStates= new ArrayList<BlockState>(){
+    public Queue<BlockState> capturedBlockStates= new ConcurrentLinkedQueue<BlockState>(){
         @Override
         public boolean add( BlockState blockState ) {
             Iterator<BlockState> blockStateIterator = this.iterator();
@@ -141,6 +160,12 @@
     private org.spigotmc.TickLimiter tileLimiter;
     private int tileTickPosition;
 
+    //for spigot
+    private int g(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
+    
     public static long chunkToKey(int x, int z)
     {
         long k = ( ( ( (long) x ) & 0xFFFF0000L ) << 16 ) | ( ( ( (long) x ) & 0x0000FFFFL ) << 0 );
@@ -172,6 +197,7 @@
     }
 
     public Chunk getChunkIfLoaded(int x, int z) {
+        //System.out.println(((ChunkProviderServer) this.chunkProvider).chunks.size()+","+((ChunkProviderServer) this.chunkProvider).unloadQueue.size());
         return ((ChunkProviderServer) this.chunkProvider).getChunkIfLoaded(x, z);
     }
 
@@ -225,7 +251,7 @@
 
             public void c(WorldBorder worldborder, double d0) {}
         }); 
-        this.getServer().addWorld(this.world); 
+        this.getServer().addWorld(this.world);
         // CraftBukkit end
         timings = new SpigotTimings.WorldTimingsHandler(this); // Spigot - code below can generate new world and access timings 
         this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
@@ -476,9 +502,14 @@
     }
 
     public void notify(BlockPosition blockposition) {
+        Iterator it = this.u.iterator();
+        while (it.hasNext()){
+            ((IWorldAccess) it.next()).a(blockposition);
+        }
+        /*
         for (int i = 0; i < this.u.size(); ++i) {
             ((IWorldAccess) this.u.get(i)).a(blockposition);
-        }
+        }*/
 
     }
 
@@ -517,9 +548,14 @@
     }
 
     public void b(int i, int j, int k, int l, int i1, int j1) {
+        Iterator it = this.u.iterator();
+        while (it.hasNext()){
+            ((IWorldAccess) it.next()).a(i, j, k, l, i1, j1);
+        }
+        /*
         for (int k1 = 0; k1 < this.u.size(); ++k1) {
             ((IWorldAccess) this.u.get(k1)).a(i, j, k, l, i1, j1);
-        }
+        }*/
 
     }
 
@@ -569,6 +605,7 @@
                 CraftWorld world = ((WorldServer) this).getWorld();
                 if (world != null) {
                     BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), CraftMagicNumbers.getId(block));
+                    event.setAsynchronous();
                     this.getServer().getPluginManager().callEvent(event);
 
                     if (event.isCancelled()) {
@@ -576,7 +613,14 @@
                     }
                 }
                 // CraftBukkit end
-                iblockdata.getBlock().doPhysics(this, blockposition, iblockdata, block);
+                //iblockdata.getBlock().doPhysics(this, blockposition, iblockdata, block);
+                if (!SpigotWorldConfig.BlockＮextＴick_list.contains(iblockdata.hashCode())){
+                    //add to list
+                    SpigotWorldConfig.BlockＮextＴick_list.add(iblockdata.hashCode());
+                    iblockdata.getBlock().doPhysics(this, blockposition, iblockdata, block);
+                } else {
+                    iblockdata.getBlock().doPhysics(this, blockposition, iblockdata, block);
+                }
             } catch (StackOverflowError stackoverflowerror) { // Spigot Start
                 haveWeSilencedAPhysicsCrash = true;
                 blockLocation = blockposition.getX() + ", " + blockposition.getY() + ", " + blockposition.getZ(); // Spigot End
@@ -749,9 +793,15 @@
     }
 
     public void n(BlockPosition blockposition) {
+        Iterator it = this.u.iterator();
+        while (it.hasNext()) {
+            ((IWorldAccess) it.next()).b(blockposition);
+        }
+        /*
+            
         for (int i = 0; i < this.u.size(); ++i) {
             ((IWorldAccess) this.u.get(i)).b(blockposition);
-        }
+        }*/
 
     }
 
@@ -768,12 +818,14 @@
     public IBlockData getType(BlockPosition blockposition, boolean useCaptured) {
         // CraftBukkit start - tree generation
         if (captureTreeGeneration && useCaptured) {
-    // Spigot end
-            Iterator<BlockState> it = capturedBlockStates.iterator();
-            while (it.hasNext()) {
-                BlockState previous = it.next();
-                if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
-                    return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
+        // Spigot end
+            synchronized (this.capturedBlockStates){
+                Iterator<BlockState> it = this.capturedBlockStates.iterator();
+                while (it.hasNext()) {
+                    BlockState previous = it.next();
+                    if (previous.getX() == blockposition.getX() && previous.getY() == blockposition.getY() && previous.getZ() == blockposition.getZ()) {
+                        return CraftMagicNumbers.getBlock(previous.getTypeId()).fromLegacyData(previous.getRawData());
+                    }
                 }
             }
         }
@@ -937,43 +989,72 @@
     }
 
     public void makeSound(Entity entity, String s, float f, float f1) {
+        Iterator it = this.u.iterator();
+        while (it.hasNext()) {
+            ((IWorldAccess) it.next()).a(s, entity.locX, entity.locY, entity.locZ, f, f1);
+        }
+        /*
         for (int i = 0; i < this.u.size(); ++i) {
             ((IWorldAccess) this.u.get(i)).a(s, entity.locX, entity.locY, entity.locZ, f, f1);
-        }
+        }*/
 
     }
 
     public void a(EntityHuman entityhuman, String s, float f, float f1) {
+        Iterator it = this.u.iterator();
+        while (it.hasNext()) {
+            ((IWorldAccess) it.next()).a(entityhuman, s, entityhuman.locX, entityhuman.locY, entityhuman.locZ, f, f1);
+        }
+        /*
         for (int i = 0; i < this.u.size(); ++i) {
             ((IWorldAccess) this.u.get(i)).a(entityhuman, s, entityhuman.locX, entityhuman.locY, entityhuman.locZ, f, f1);
-        }
+        }*/
 
     }
 
     public void makeSound(double d0, double d1, double d2, String s, float f, float f1) {
+        Iterator it = this.u.iterator();
+        while (it.hasNext()) {
+            ((IWorldAccess) it.next()).a(s, d0, d1, d2, f, f1);
+        }
+        
+        /*
         for (int i = 0; i < this.u.size(); ++i) {
             ((IWorldAccess) this.u.get(i)).a(s, d0, d1, d2, f, f1);
-        }
+        }*/
 
     }
 
     public void a(double d0, double d1, double d2, String s, float f, float f1, boolean flag) {}
 
     public void a(BlockPosition blockposition, String s) {
+        Iterator it = this.u.iterator();
+        while (it.hasNext()) {
+            ((IWorldAccess) it.next()).a(s, blockposition);
+        }
+        /*
         for (int i = 0; i < this.u.size(); ++i) {
             ((IWorldAccess) this.u.get(i)).a(s, blockposition);
-        }
+        }*/
 
     }
 
     public void addParticle(EnumParticle enumparticle, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
-        this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        //this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        SpigotWorldConfig.AddParticleTask = new FutureTask(new AddParticlePool(this, enumparticle, d0, d1, d2, d3, d4, d5, aint));
+        SpigotWorldConfig.addparticlepool_executor.submit(SpigotWorldConfig.AddParticleTask);
     }
 
-    private void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
+    public void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
+    //private void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
+        Iterator it = this.u.iterator();
+        while (it.hasNext()) {
+            ((IWorldAccess) it.next()).a(i, flag, d0, d1, d2, d3, d4, d5, aint);
+        }
+        /*
         for (int j = 0; j < this.u.size(); ++j) {
             ((IWorldAccess) this.u.get(j)).a(i, flag, d0, d1, d2, d3, d4, d5, aint);
-        }
+        }*/
 
     }
 
@@ -1062,17 +1143,25 @@
     }
 
     protected void a(Entity entity) {
-        for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).a(entity);
+        Iterator it = this.u.iterator();
+        while (it.hasNext()){
+            ((IWorldAccess) it.next()).a(entity);
         }
+        /*for (int i = 0; i < this.u.size(); ++i) {
+            ((IWorldAccess) this.u.get(i)).a(entity);
+        }*/
 
         entity.valid = true; // CraftBukkit
     }
 
     protected void b(Entity entity) {
-        for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).b(entity);
+        Iterator it = this.u.iterator();
+        while (it.hasNext()){
+            ((IWorldAccess) it.next()).b(entity);
         }
+        /*for (int i = 0; i < this.u.size(); ++i) {
+            ((IWorldAccess) this.u.get(i)).b(entity);
+        }*/
 
         entity.valid = false; // CraftBukkit
     }
@@ -1120,13 +1209,13 @@
             this.everyoneSleeping();
         }
 
-        if (!guardEntityList) { // Spigot - It will get removed after the tick if we are ticking
+        //if (!guardEntityList) { // Spigot - It will get removed after the tick if we are ticking
         int i = entity.ae;
         int j = entity.ag;
 
         if (entity.ad && this.isChunkLoaded(i, j, true)) {
             this.getChunkAt(i, j).b(entity);
-        }
+        //}
 
         // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
         int index = this.entityList.indexOf(entity);
@@ -1147,6 +1236,7 @@
 
     public List<AxisAlignedBB> getCubes(Entity entity, AxisAlignedBB axisalignedbb) {
         ArrayList arraylist = Lists.newArrayList();
+        //List arraylist = Lists.newCopyOnWriteArrayList();
         int i = MathHelper.floor(axisalignedbb.a);
         int j = MathHelper.floor(axisalignedbb.d + 1.0D);
         int k = MathHelper.floor(axisalignedbb.b);
@@ -1254,6 +1344,7 @@
 
     public List<AxisAlignedBB> a(AxisAlignedBB axisalignedbb) {
         ArrayList arraylist = Lists.newArrayList();
+        //List arraylist = Lists.newCopyOnWriteArrayList();
         int i = MathHelper.floor(axisalignedbb.a);
         int j = MathHelper.floor(axisalignedbb.d + 1.0D);
         int k = MathHelper.floor(axisalignedbb.b);
@@ -1337,11 +1428,11 @@
     public void a(BlockPosition blockposition, Block block, int i, int j) {}
 
     public void b(BlockPosition blockposition, Block block, int i, int j) {}
-
+    
     public void tickEntities() {
         this.methodProfiler.a("entities");
         this.methodProfiler.a("global");
-
+        //System.out.println(this.players.size()+","+this.entitiesById.size());
         int i;
         Entity entity;
         CrashReport crashreport;
@@ -1381,6 +1472,17 @@
         int j;
         int k;
 
+        Iterator itg = this.g.iterator();
+        while (itg.hasNext()){
+            entity = (Entity) itg.next();
+            j = entity.ae;
+            k = entity.ag;
+            if (entity.ad && this.isChunkLoaded(j, k, true)) {
+                this.getChunkAt(j, k).b(entity);
+            }
+            this.b(entity);
+        }
+        /*
         for (i = 0; i < this.g.size(); ++i) {
             entity = (Entity) this.g.get(i);
             j = entity.ae;
@@ -1392,14 +1494,15 @@
 
         for (i = 0; i < this.g.size(); ++i) {
             this.b((Entity) this.g.get(i));
-        }
+        }*/
 
         this.g.clear();
         this.methodProfiler.c("regular");
-
+        //observe
+        //System.out.println(this.chunkTickList.size()+","+this.entitiesById.size());
         org.spigotmc.ActivationRange.activateEntities(this); // Spigot
         timings.entityTick.startTiming(); // Spigot
-        guardEntityList = true; // Spigot
+        //guardEntityList = true; // Spigot
         // CraftBukkit start - Use field for loop variable
         int entitiesThisCycle = 0;
         if (tickPosition < 0) tickPosition = 0;
@@ -1422,7 +1525,12 @@
             if (!entity.dead) {
                 try {
                     SpigotTimings.tickEntityTimer.startTiming(); // Spigot
-                    this.g(entity);
+                    //this.g(entity);
+                    if (!SpigotWorldConfig.EntityTick_list.contains(this.g(entity.getId()))){
+                        SpigotWorldConfig.EntityTick_list.add(this.g(entity.getId()));
+                        SpigotWorldConfig.EntityTickTask = new FutureTask(new EntityTick_Pool(this, entity));
+                        SpigotWorldConfig.entitytick_pool_executor.submit(SpigotWorldConfig.EntityTickTask);
+                    }
                     SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
                 } catch (Throwable throwable1) {
                     crashreport = CrashReport.a(throwable1, "Ticking entity");
@@ -1449,7 +1557,7 @@
 
             this.methodProfiler.b();
         }
-        guardEntityList = false; // Spigot
+        //guardEntityList = false; // Spigot
 
         timings.entityTick.stopTiming(); // Spigot
         this.methodProfiler.c("blockEntities");
@@ -1485,7 +1593,17 @@
                 if (this.isLoaded(blockposition) && this.N.a(blockposition)) {
                     try {
                         tileentity.tickTimer.startTiming(); // Spigot
+                        //tile tick
+                        //check object type
                         ((IUpdatePlayerListBox) tileentity).c();
+                        /*
+                        //must be proofed
+                        if (tileentity instanceof TileEntityBeacon) {
+                            SpigotWorldConfig.TileTickTask = new FutureTask(new TileTick_Pool(tileentity));
+                            SpigotWorldConfig.tiletickpool_executor.submit(SpigotWorldConfig.TileTickTask);
+                        } else {
+                            ((IUpdatePlayerListBox) tileentity).c();
+                        }*/
                     } catch (Throwable throwable2) {
                         CrashReport crashreport1 = CrashReport.a(throwable2, "Ticking block entity");
                         CrashReportSystemDetails crashreportsystemdetails1 = crashreport1.a("Block entity being ticked");
@@ -1510,7 +1628,6 @@
                 }
             }
         }
-
         timings.tileEntityTick.stopTiming(); // Spigot
         timings.tileEntityPending.startTiming(); // Spigot
         this.M = false;
@@ -1524,8 +1641,9 @@
 
         this.methodProfiler.c("pendingBlockEntities");
         if (!this.b.isEmpty()) {
-            for (int l = 0; l < this.b.size(); ++l) {
-                TileEntity tileentity1 = (TileEntity) this.b.get(l);
+            Iterator it = this.b.iterator();
+            while (it.hasNext()){
+                TileEntity tileentity1 = (TileEntity) it.next();
 
                 if (!tileentity1.x()) {
                     /* CraftBukkit start - Order matters, moved down
@@ -1533,7 +1651,7 @@
                         this.a(tileentity1);
                     }
                     // CraftBukkit end */
-
+                    
                     if (this.isLoaded(tileentity1.getPosition())) {
                         this.getChunkAtWorldCoords(tileentity1.getPosition()).a(tileentity1.getPosition(), tileentity1);
                     }
@@ -1541,6 +1659,24 @@
                     this.notify(tileentity1.getPosition());
                 }
             }
+            /*
+            for (int l = 0; l < this.b.size(); ++l) {
+                TileEntity tileentity1 = (TileEntity) this.b.get(l);
+
+                if (!tileentity1.x()) {*/
+                    /* CraftBukkit start - Order matters, moved down
+                    if (!this.h.contains(tileentity1)) {
+                        this.a(tileentity1);
+                    }
+                    // CraftBukkit end */
+                    /*
+                    if (this.isLoaded(tileentity1.getPosition())) {
+                        this.getChunkAtWorldCoords(tileentity1.getPosition()).a(tileentity1.getPosition(), tileentity1);
+                    }
+
+                    this.notify(tileentity1.getPosition());
+                }
+            }*/
 
             this.b.clear();
         }
@@ -1912,7 +2048,8 @@
         }
     }
 
-    public Map<BlockPosition, TileEntity> capturedTileEntities = Maps.newHashMap();
+    //public Map<BlockPosition, TileEntity> capturedTileEntities = Maps.newHashMap();
+    public ConcurrentMap<BlockPosition, TileEntity> capturedTileEntities = new ConcurrentHashMap<BlockPosition, TileEntity>();
 
     public TileEntity getTileEntity(BlockPosition blockposition) {
         if (!this.isValidLocation(blockposition)) {
@@ -1929,13 +2066,26 @@
             TileEntity tileentity1;
 
             if (this.M) {
+                Iterator it = this.b.iterator();
+                while (it.hasNext()){
+                    tileentity1 = (TileEntity) it.next();
+                    try {
+                        if (!tileentity1.x() && tileentity1.getPosition().equals(blockposition)) {
+                            tileentity = tileentity1;
+                            break;
+                        }
+                    } catch(Exception ex){
+                        System.out.println(ex+" this.b error");
+                    }
+                }
+                /*
                 for (i = 0; i < this.b.size(); ++i) {
                     tileentity1 = (TileEntity) this.b.get(i);
                     if (!tileentity1.x() && tileentity1.getPosition().equals(blockposition)) {
                         tileentity = tileentity1;
                         break;
                     }
-                }
+                }*/
             }
 
             if (tileentity == null) {
@@ -1943,13 +2093,22 @@
             }
 
             if (tileentity == null) {
+                Iterator it = this.b.iterator();
+                while (it.hasNext()){
+                    tileentity1 = (TileEntity) it.next();
+                    if (!tileentity1.x() && tileentity1.getPosition().equals(blockposition)) {
+                        tileentity = tileentity1;
+                        break;
+                    }
+                }
+                /*
                 for (i = 0; i < this.b.size(); ++i) {
                     tileentity1 = (TileEntity) this.b.get(i);
                     if (!tileentity1.x() && tileentity1.getPosition().equals(blockposition)) {
                         tileentity = tileentity1;
                         break;
                     }
-                }
+                }*/
             }
 
             return tileentity;
@@ -2171,8 +2330,10 @@
 
             // Spigot start - Always update the chunk the player is on
             long key = chunkToKey( j, k );
-            int existingPlayers = Math.max( 0, chunkTickList.get( key ) ); // filter out -1
-            chunkTickList.put( key, (short) ( existingPlayers + 1 ) );
+            synchronized (this.chunkTickList) {
+                int existingPlayers = Math.max( 0, chunkTickList.get( key ) ); // filter out -1
+                chunkTickList.put( key, (short) ( existingPlayers + 1 ) );
+            }
 
             // Check and see if we update the chunks surrounding the player this tick
             for ( int chunk = 0; chunk < chunksPerPlayer; chunk++ )
@@ -2180,9 +2341,11 @@
                 int dx = ( random.nextBoolean() ? 1 : -1 ) * random.nextInt( randRange );
                 int dz = ( random.nextBoolean() ? 1 : -1 ) * random.nextInt( randRange );
                 long hash = chunkToKey( dx + j, dz + k );
-                if ( !chunkTickList.contains( hash ) && this.chunkProvider.isChunkLoaded(dx + j, dz + k ) )
-                {
-                    chunkTickList.put( hash, (short) -1 ); // no players
+                synchronized (this.chunkTickList) {
+                    if ( !chunkTickList.contains( hash ) && this.chunkProvider.isChunkLoaded(dx + j, dz + k ) )
+                    {
+                        chunkTickList.put( hash, (short) -1 ); // no players
+                    }
                 }
             }
         }
@@ -2501,10 +2664,12 @@
 
     public List<Entity> getEntities(Entity entity, AxisAlignedBB axisalignedbb) {
         return this.a(entity, axisalignedbb, IEntitySelector.d);
+        //List l = new ArrayList(q);
     }
 
     public List<Entity> a(Entity entity, AxisAlignedBB axisalignedbb, Predicate<? super Entity> predicate) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        Queue arraylist = new ConcurrentLinkedQueue();
         int i = MathHelper.floor((axisalignedbb.a - 2.0D) / 16.0D);
         int j = MathHelper.floor((axisalignedbb.d + 2.0D) / 16.0D);
         int k = MathHelper.floor((axisalignedbb.c - 2.0D) / 16.0D);
@@ -2517,8 +2682,9 @@
                 }
             }
         }
-
-        return arraylist;
+        List re_list = new ArrayList(arraylist);
+        //return arraylist;
+        return re_list;
     }
 
     public <T extends Entity> List<T> a(Class<? extends T> oclass, Predicate<? super T> predicate) {
@@ -2560,7 +2726,8 @@
         int j = MathHelper.floor((axisalignedbb.d + 2.0D) / 16.0D);
         int k = MathHelper.floor((axisalignedbb.c - 2.0D) / 16.0D);
         int l = MathHelper.floor((axisalignedbb.f + 2.0D) / 16.0D);
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        Queue arraylist = new ConcurrentLinkedQueue();
 
         for (int i1 = i; i1 <= j; ++i1) {
             for (int j1 = k; j1 <= l; ++j1) {
@@ -2569,8 +2736,9 @@
                 }
             }
         }
-
-        return arraylist;
+        List re_list = new ArrayList(arraylist);
+        //return arraylist;
+        return re_list;
     }
 
     public <T extends Entity> T a(Class<? extends T> oclass, AxisAlignedBB axisalignedbb, T t0) {
@@ -2595,7 +2763,8 @@
     }
 
     public Entity a(int i) {
-        return (Entity) this.entitiesById.get(i);
+        //return (Entity) this.entitiesById.get(i);
+        return (Entity) this.entitiesById.get(this.g(i));
     }
 
     public void b(BlockPosition blockposition, TileEntity tileentity) {
@@ -2618,14 +2787,14 @@
                     continue;
                 }
             }
-            
+
             if (oclass.isAssignableFrom(entity.getClass())) {
             // if ((!(entity instanceof EntityInsentient) || !((EntityInsentient) entity).isPersistent()) && oclass.isAssignableFrom(entity.getClass())) {
                 // CraftBukkit end
                 ++i;
             }
         }
-
+        
         return i;
     }
 
@@ -2945,9 +3114,14 @@
     }
 
     public void a(int i, BlockPosition blockposition, int j) {
+        Iterator it = this.u.iterator();
+        while (it.hasNext()) {
+            ((IWorldAccess) it.next()).a(i, blockposition, j);
+        }
+        /*
         for (int k = 0; k < this.u.size(); ++k) {
             ((IWorldAccess) this.u.get(k)).a(i, blockposition, j);
-        }
+        }*/
 
     }
 
@@ -2957,9 +3131,14 @@
 
     public void a(EntityHuman entityhuman, int i, BlockPosition blockposition, int j) {
         try {
+            Iterator it = this.u.iterator();
+            while (it.hasNext()) {
+                ((IWorldAccess) it.next()).a(entityhuman, i, blockposition, j);
+            }
+            /*
             for (int k = 0; k < this.u.size(); ++k) {
                 ((IWorldAccess) this.u.get(k)).a(entityhuman, i, blockposition, j);
-            }
+            }*/
 
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.a(throwable, "Playing level event");
@@ -3025,11 +3204,18 @@
     }
 
     public void c(int i, BlockPosition blockposition, int j) {
+        Iterator it = this.u.iterator();
+            while (it.hasNext()) {
+                IWorldAccess iworldaccess = (IWorldAccess) it.next();
+
+                iworldaccess.b(i, blockposition, j);
+            }
+        /*
         for (int k = 0; k < this.u.size(); ++k) {
             IWorldAccess iworldaccess = (IWorldAccess) this.u.get(k);
 
             iworldaccess.b(i, blockposition, j);
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/WorldMap.java src/main/java/net/minecraft/server/WorldMap.java
--- src_origin/main/java/net/minecraft/server/WorldMap.java	2016-02-26 15:27:14.088203905 +0800
+++ src/main/java/net/minecraft/server/WorldMap.java	2016-03-16 23:43:30.632124844 +0800
@@ -1,14 +1,16 @@
 package net.minecraft.server;
 
 import com.google.common.base.Charsets;
-import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import java.util.Iterator;
-import java.util.List;
 import java.util.Map;
+import java.util.Queue;
 
 // CraftBukkit start
 import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ConcurrentMap;
 
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
@@ -22,8 +24,10 @@
     public byte map;
     public byte scale;
     public byte[] colors = new byte[16384];
-    public List<WorldMap.WorldMapHumanTracker> g = Lists.newArrayList();
-    public Map<EntityHuman, WorldMap.WorldMapHumanTracker> i = Maps.newHashMap(); // Spigot
+    //public List<WorldMap.WorldMapHumanTracker> g = Lists.newArrayList();
+    public Queue<WorldMap.WorldMapHumanTracker> g = new ConcurrentLinkedQueue<WorldMap.WorldMapHumanTracker>();
+    //public Map<EntityHuman, WorldMap.WorldMapHumanTracker> i = Maps.newHashMap(); // Spigot
+    public Map<EntityHuman, WorldMap.WorldMapHumanTracker> i = new ConcurrentHashMap<EntityHuman, WorldMap.WorldMapHumanTracker>(); // Spigot
     public Map<UUID, MapIcon> decorations = Maps.newLinkedHashMap(); // Spigot
 
     // CraftBukkit start
@@ -148,6 +152,20 @@
             this.decorations.remove(entityhuman.getUniqueID()); // Spigot
         }
 
+        Iterator it = this.g.iterator();
+        while (it.hasNext()){
+            WorldMap.WorldMapHumanTracker worldmap_worldmaphumantracker1 = (WorldMap.WorldMapHumanTracker) it.next();
+
+            if (!worldmap_worldmaphumantracker1.trackee.dead && (worldmap_worldmaphumantracker1.trackee.inventory.c(itemstack) || itemstack.y())) {
+                if (!itemstack.y() && worldmap_worldmaphumantracker1.trackee.dimension == this.map) {
+                    this.a(0, worldmap_worldmaphumantracker1.trackee.world, worldmap_worldmaphumantracker1.trackee.getUniqueID(), worldmap_worldmaphumantracker1.trackee.locX, worldmap_worldmaphumantracker1.trackee.locZ, (double) worldmap_worldmaphumantracker1.trackee.yaw); // Spigot
+                }
+            } else {
+                this.i.remove(worldmap_worldmaphumantracker1.trackee);
+                this.g.remove(worldmap_worldmaphumantracker1);
+            }
+        }
+        /*
         for (int i = 0; i < this.g.size(); ++i) {
             WorldMap.WorldMapHumanTracker worldmap_worldmaphumantracker1 = (WorldMap.WorldMapHumanTracker) this.g.get(i);
 
@@ -159,7 +177,7 @@
                 this.i.remove(worldmap_worldmaphumantracker1.trackee);
                 this.g.remove(worldmap_worldmaphumantracker1);
             }
-        }
+        }*/
 
         if (itemstack.y()) {
             EntityItemFrame entityitemframe = itemstack.z();
diff -Naur src_origin/main/java/net/minecraft/server/WorldServer.java src/main/java/net/minecraft/server/WorldServer.java
--- src_origin/main/java/net/minecraft/server/WorldServer.java	2016-02-26 15:27:14.144203910 +0800
+++ src/main/java/net/minecraft/server/WorldServer.java	2016-03-16 23:43:30.652124844 +0800
@@ -2,31 +2,30 @@
 
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
-import java.util.Set;
-import java.util.TreeSet;
 import java.util.UUID;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start
 import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.logging.Level;
 
 import org.bukkit.WeatherType;
 import org.bukkit.block.BlockState;
-import org.bukkit.craftbukkit.util.LongHash;
 import org.bukkit.craftbukkit.util.HashTreeSet;
+import org.bukkit.craftbukkit.util.LongHash;
 
 import org.bukkit.event.block.BlockFormEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public class WorldServer extends World implements IAsyncTaskHandler {
@@ -37,7 +36,8 @@
     private final PlayerChunkMap manager;
     // private final Set<NextTickListEntry> L = Sets.newHashSet(); // PAIL: Rename nextTickListHash
     private final HashTreeSet<NextTickListEntry> M = new HashTreeSet<NextTickListEntry>(); // CraftBukkit - HashTreeSet // PAIL: Rename nextTickList
-    private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
+    //private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
+    private final Map<UUID, Entity> entitiesByUUID = new ConcurrentHashMap<UUID, Entity>();
     public ChunkProviderServer chunkProviderServer;
     public boolean savingDisabled;
     private boolean O;
@@ -48,8 +48,9 @@
     private WorldServer.BlockActionDataList[] S = new WorldServer.BlockActionDataList[] { new WorldServer.BlockActionDataList(null), new WorldServer.BlockActionDataList(null)};
     private int T;
     private static final List<StructurePieceTreasure> U = Lists.newArrayList(new StructurePieceTreasure[] { new StructurePieceTreasure(Items.STICK, 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.PLANKS), 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG), 0, 1, 3, 10), new StructurePieceTreasure(Items.STONE_AXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_AXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.STONE_PICKAXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_PICKAXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.APPLE, 0, 2, 3, 5), new StructurePieceTreasure(Items.BREAD, 0, 2, 3, 3), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG2), 0, 1, 3, 10)});
-    private List<NextTickListEntry> V = Lists.newArrayList();
-
+    //private List<NextTickListEntry> V = Lists.newArrayList();
+    private Queue<NextTickListEntry> V = new ConcurrentLinkedQueue<NextTickListEntry>();
+    
     // CraftBukkit start
     public final int dimension;
 
@@ -370,18 +371,21 @@
         }
     }
 
+    //tick block
     protected void h() {
         super.h();
         if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
             // Spigot start
-           gnu.trove.iterator.TLongShortIterator iterator = this.chunkTickList.iterator();
+            synchronized (this.chunkTickList) {
+                gnu.trove.iterator.TLongShortIterator iterator = this.chunkTickList.iterator();
 
-            while (iterator.hasNext()) {
-                iterator.advance();
-                long chunkCoord = iterator.key();
+                while (iterator.hasNext()) {
+                    iterator.advance();
+                    long chunkCoord = iterator.key();
 
-                this.getChunkAt(World.keyToX( chunkCoord ), World.keyToZ( chunkCoord )).b(false);
-                // Spigot end
+                    this.getChunkAt(World.keyToX( chunkCoord ), World.keyToZ( chunkCoord )).b(false);
+                    // Spigot end
+                }
             }
 
         } else {
@@ -394,117 +398,124 @@
             //    int k = chunkcoordintpair1.x * 16;
             //    int l = chunkcoordintpair1.z * 16;
             // Spigot start
-            for (gnu.trove.iterator.TLongShortIterator iter = chunkTickList.iterator(); iter.hasNext(); )
-            {
-                iter.advance();
-                long chunkCoord = iter.key();
-                int chunkX = World.keyToX( chunkCoord );
-                int chunkZ = World.keyToZ( chunkCoord );
-                // If unloaded, or in procedd of being unloaded, drop it
-                if ( ( !this.chunkProvider.isChunkLoaded( chunkX, chunkZ ) ) || ( this.chunkProviderServer.unloadQueue.contains( chunkX, chunkZ ) ) )
+            synchronized (this.chunkTickList) {
+                //for (gnu.trove.iterator.TLongShortIterator iter = chunkTickList.iterator(); iter.hasNext(); )
+                gnu.trove.iterator.TLongShortIterator iter = this.chunkTickList.iterator();
+                while (iter.hasNext())
                 {
-                    iter.remove();
-                    continue;
-                }
-                // Spigot end
-                // ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) iterator.next();
-                int k = chunkX * 16;
-                int l = chunkZ * 16;
-
-                this.methodProfiler.a("getChunk");
-                Chunk chunk = this.getChunkAt(chunkX, chunkZ);
-                // CraftBukkit end
-
-                this.a(k, l, chunk);
-                this.methodProfiler.c("tickChunk");
-                chunk.b(false);
-                this.methodProfiler.c("thunder");
-                int i1;
-                BlockPosition blockposition;
-
-                if (this.random.nextInt(100000) == 0 && this.S() && this.R()) {
-                    this.m = this.m * 3 + 1013904223;
-                    i1 = this.m >> 2;
-                    blockposition = this.a(new BlockPosition(k + (i1 & 15), 0, l + (i1 >> 8 & 15)));
-                    if (this.isRainingAt(blockposition)) {
-                        this.strikeLightning(new EntityLightning(this, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ()));
+                    iter.advance();
+                    long chunkCoord = iter.key();
+                    int chunkX = World.keyToX( chunkCoord );
+                    int chunkZ = World.keyToZ( chunkCoord );
+                    long key = LongHash.toLong(chunkX, chunkZ);
+                    // If unloaded, or in procedd of being unloaded, drop it
+                    //if ( ( !this.chunkProvider.isChunkLoaded( chunkX, chunkZ ) ) || ( this.chunkProviderServer.unloadQueue.contains( chunkX, chunkZ ) ) )
+                    if ( ( !this.chunkProvider.isChunkLoaded( chunkX, chunkZ ) ) || ( this.chunkProviderServer.unloadQueue.containsKey(key) ) )
+                    {
+                        iter.remove();
+                        continue;
                     }
-                }
+                    // Spigot end
+                    // ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) iterator.next();
+                    int k = chunkX * 16;
+                    int l = chunkZ * 16;
 
-                this.methodProfiler.c("iceandsnow");
-                if (this.random.nextInt(16) == 0) {
-                    this.m = this.m * 3 + 1013904223;
-                    i1 = this.m >> 2;
-                    blockposition = this.q(new BlockPosition(k + (i1 & 15), 0, l + (i1 >> 8 & 15)));
-                    BlockPosition blockposition1 = blockposition.down();
-
-                    if (this.w(blockposition1)) {
-                        // CraftBukkit start
-                        BlockState blockState = this.getWorld().getBlockAt(blockposition1.getX(), blockposition1.getY(), blockposition1.getZ()).getState();
-                        blockState.setTypeId(Block.getId(Blocks.ICE));
-
-                        BlockFormEvent iceBlockForm = new BlockFormEvent(blockState.getBlock(), blockState);
-                        this.getServer().getPluginManager().callEvent(iceBlockForm);
-                        if (!iceBlockForm.isCancelled()) {
-                            blockState.update(true);
+                    this.methodProfiler.a("getChunk");
+                    Chunk chunk = this.getChunkAt(chunkX, chunkZ);
+                    // CraftBukkit end
+
+                    this.a(k, l, chunk);
+                    this.methodProfiler.c("tickChunk");
+                    chunk.b(false);
+                    this.methodProfiler.c("thunder");
+                    int i1;
+                    BlockPosition blockposition;
+
+                    if (this.random.nextInt(100000) == 0 && this.S() && this.R()) {
+                        this.m = this.m * 3 + 1013904223;
+                        i1 = this.m >> 2;
+                        blockposition = this.a(new BlockPosition(k + (i1 & 15), 0, l + (i1 >> 8 & 15)));
+                        if (this.isRainingAt(blockposition)) {
+                            this.strikeLightning(new EntityLightning(this, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ()));
                         }
-                        // CraftBukkit end
                     }
 
-                    if (this.S() && this.f(blockposition, true)) {
-                        // CraftBukkit start
-                        BlockState blockState = this.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()).getState();
-                        blockState.setTypeId(Block.getId(Blocks.SNOW_LAYER));
-
-                        BlockFormEvent snow = new BlockFormEvent(blockState.getBlock(), blockState);
-                        this.getServer().getPluginManager().callEvent(snow);
-                        if (!snow.isCancelled()) {
-                            blockState.update(true);
+                    this.methodProfiler.c("iceandsnow");
+                    if (this.random.nextInt(16) == 0) {
+                        this.m = this.m * 3 + 1013904223;
+                        i1 = this.m >> 2;
+                        blockposition = this.q(new BlockPosition(k + (i1 & 15), 0, l + (i1 >> 8 & 15)));
+                        BlockPosition blockposition1 = blockposition.down();
+
+                        if (this.w(blockposition1)) {
+                            // CraftBukkit start
+                            BlockState blockState = this.getWorld().getBlockAt(blockposition1.getX(), blockposition1.getY(), blockposition1.getZ()).getState();
+                            blockState.setTypeId(Block.getId(Blocks.ICE));
+
+                            BlockFormEvent iceBlockForm = new BlockFormEvent(blockState.getBlock(), blockState);
+                            this.getServer().getPluginManager().callEvent(iceBlockForm);
+                            if (!iceBlockForm.isCancelled()) {
+                                blockState.update(true);
+                            }
+                            // CraftBukkit end
                         }
-                        // CraftBukkit end
-                    }
 
-                    if (this.S() && this.getBiome(blockposition1).e()) {
-                        this.getType(blockposition1).getBlock().k(this, blockposition1);
+                        if (this.S() && this.f(blockposition, true)) {
+                            // CraftBukkit start
+                            BlockState blockState = this.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()).getState();
+                            blockState.setTypeId(Block.getId(Blocks.SNOW_LAYER));
+
+                            BlockFormEvent snow = new BlockFormEvent(blockState.getBlock(), blockState);
+                            this.getServer().getPluginManager().callEvent(snow);
+                            if (!snow.isCancelled()) {
+                                blockState.update(true);
+                            }
+                            // CraftBukkit end
+                        }
+
+                        if (this.S() && this.getBiome(blockposition1).e()) {
+                            this.getType(blockposition1).getBlock().k(this, blockposition1);
+                        }
                     }
-                }
 
-                this.methodProfiler.c("tickBlocks");
-                i1 = this.getGameRules().c("randomTickSpeed");
-                if (i1 > 0) {
-                    ChunkSection[] achunksection = chunk.getSections();
-                    int j1 = achunksection.length;
-
-                    for (int k1 = 0; k1 < j1; ++k1) {
-                        ChunkSection chunksection = achunksection[k1];
-
-                        if (chunksection != null && chunksection.shouldTick()) {
-                            for (int l1 = 0; l1 < i1; ++l1) {
-                                this.m = this.m * 3 + 1013904223;
-                                int i2 = this.m >> 2;
-                                int j2 = i2 & 15;
-                                int k2 = i2 >> 8 & 15;
-                                int l2 = i2 >> 16 & 15;
-
-                                ++j;
-                                IBlockData iblockdata = chunksection.getType(j2, l2, k2);
-                                Block block = iblockdata.getBlock();
-
-                                if (block.isTicking()) {
-                                    ++i;
-                                    block.a((World) this, new BlockPosition(j2 + k, l2 + chunksection.getYPosition(), k2 + l), iblockdata, this.random);
+                    this.methodProfiler.c("tickBlocks");
+                    i1 = this.getGameRules().c("randomTickSpeed");
+                    if (i1 > 0) {
+                        ChunkSection[] achunksection = chunk.getSections();
+                        int j1 = achunksection.length;
+
+                        for (int k1 = 0; k1 < j1; ++k1) {
+                            ChunkSection chunksection = achunksection[k1];
+
+                            if (chunksection != null && chunksection.shouldTick()) {
+                                for (int l1 = 0; l1 < i1; ++l1) {
+                                    this.m = this.m * 3 + 1013904223;
+                                    int i2 = this.m >> 2;
+                                    int j2 = i2 & 15;
+                                    int k2 = i2 >> 8 & 15;
+                                    int l2 = i2 >> 16 & 15;
+
+                                    ++j;
+                                    IBlockData iblockdata = chunksection.getType(j2, l2, k2);
+                                    Block block = iblockdata.getBlock();
+
+                                    if (block.isTicking()) {
+                                        ++i;
+                                        block.a((World) this, new BlockPosition(j2 + k, l2 + chunksection.getYPosition(), k2 + l), iblockdata, this.random);
+                                    }
                                 }
                             }
                         }
                     }
                 }
             }
-
         }
         // Spigot Start
         if ( spigotConfig.clearChunksOnTick )
-        {
-            chunkTickList.clear();
+        {   
+            synchronized (this.chunkTickList) {
+                chunkTickList.clear();
+            }
         }
         // Spigot End
     }
@@ -546,7 +557,17 @@
                     IBlockData iblockdata = this.getType(nextticklistentry.a);
 
                     if (iblockdata.getBlock().getMaterial() != Material.AIR && iblockdata.getBlock() == nextticklistentry.a()) {
-                        iblockdata.getBlock().b((World) this, nextticklistentry.a, iblockdata, this.random);
+                        //iblockdata.getBlock().b((World) this, nextticklistentry.a, iblockdata, this.random);
+                        if (iblockdata.getBlock() instanceof BlockTripwire || iblockdata.getBlock() instanceof BlockPressurePlateAbstract){
+                            if (!SpigotWorldConfig.BlockＮextＴick_list.contains(iblockdata.hashCode())){
+                                //add to list
+                                SpigotWorldConfig.BlockＮextＴick_list.add(iblockdata.hashCode());
+                            } else {
+                                iblockdata.getBlock().b((World) this, nextticklistentry.a, iblockdata, this.random);
+                            }
+                        } else {
+                            iblockdata.getBlock().b((World) this, nextticklistentry.a, iblockdata, this.random);
+                        }
                     }
                 }
 
@@ -602,6 +623,7 @@
         this.emptyTime = 0;
     }
 
+    //tick pending
     public boolean a(boolean flag) {
         if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
             return false;
@@ -611,12 +633,12 @@
             if (false) { // CraftBukkit
                 throw new IllegalStateException("TickNextTick list out of synch");
             } else {
-                if (i > 1000) {
+                if (i > 3000) {//1000
                     // CraftBukkit start - If the server has too much to process over time, try to alleviate that
-                    if (i > 20 * 1000) {
+                    if (i > 20 * 3000) {//1000
                         i = i / 20;
                     } else {
-                        i = 1000;
+                        i = 3000;//1000
                     }
                     // CraftBukkit end
                 }
@@ -624,9 +646,9 @@
                 this.methodProfiler.a("cleaning");
 
                 NextTickListEntry nextticklistentry;
-
-                for (int j = 0; j < i; ++j) {
-                    nextticklistentry = (NextTickListEntry) this.M.first();
+                Iterator it = this.M.iterator();
+                while (it.hasNext()){
+                    nextticklistentry = (NextTickListEntry) it.next();
                     if (!flag && nextticklistentry.b > this.worldData.getTime()) {
                         break;
                     }
@@ -635,6 +657,23 @@
                     this.M.remove(nextticklistentry);
                     this.V.add(nextticklistentry);
                 }
+                /*
+                for (int j = 0; j < i; ++j) {
+                    try {
+                        nextticklistentry = (NextTickListEntry) this.M.first();
+                        if (!flag && nextticklistentry.b > this.worldData.getTime()) {
+                            break;
+                        }
+
+                        // CraftBukkit - use M, PAIL: Rename nextTickList
+                        this.M.remove(nextticklistentry);
+                        this.V.add(nextticklistentry);
+                    } catch (Exception ex){
+                        LogManager.getLogger().warn(this.M.size()+":"+ex);
+                        
+                        break;
+                    }
+                }*/
 
                 this.methodProfiler.b();
                 this.methodProfiler.a("ticking");
@@ -682,7 +721,8 @@
     }
 
     public List<NextTickListEntry> a(StructureBoundingBox structureboundingbox, boolean flag) {
-        ArrayList arraylist = null;
+        //ArrayList arraylist = null;
+        List arraylist = null;
 
         for (int i = 0; i < 2; ++i) {
             Iterator iterator;
@@ -704,7 +744,8 @@
                     }
 
                     if (arraylist == null) {
-                        arraylist = Lists.newArrayList();
+                        //arraylist = Lists.newArrayList();
+                        arraylist = Lists.newCopyOnWriteArrayList();
                     }
 
                     arraylist.add(nextticklistentry);
@@ -759,7 +800,8 @@
     }
 
     public List<TileEntity> getTileEntities(int i, int j, int k, int l, int i1, int j1) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
 
         // CraftBukkit start - Get tile entities from chunks instead of world
         for (int chunkX = (i >> 4); chunkX <= ((l - 1) >> 4); chunkX++) {
@@ -929,13 +971,16 @@
             // CraftBukkit - ArrayList -> Collection
             Collection arraylist = this.chunkProviderServer.a();
             Iterator iterator = arraylist.iterator();
+            try {
+                while (iterator.hasNext()) {
+                    Chunk chunk = (Chunk) iterator.next();
 
-            while (iterator.hasNext()) {
-                Chunk chunk = (Chunk) iterator.next();
-
-                if (chunk != null && !this.manager.a(chunk.locX, chunk.locZ)) {
-                    this.chunkProviderServer.queueUnload(chunk.locX, chunk.locZ);
+                    if (chunk != null && !this.manager.a(chunk.locX, chunk.locZ)) {
+                        this.chunkProviderServer.queueUnload(chunk.locX, chunk.locZ);
+                    }
                 }
+            } catch (Exception exception) {
+                LogManager.getLogger().error("Couldn\'t save chunk", exception);
             }
 
         }
@@ -966,15 +1011,23 @@
         // CraftBukkit end
     }
 
+    //for spigot
+    private int g(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
+    
     protected void a(Entity entity) {
         super.a(entity);
-        this.entitiesById.a(entity.getId(), entity);
+        //this.entitiesById.a(entity.getId(), entity);
+        this.entitiesById.put(this.g(entity.getId()), entity);
         this.entitiesByUUID.put(entity.getUniqueID(), entity);
         Entity[] aentity = entity.aB();
 
         if (aentity != null) {
             for (int i = 0; i < aentity.length; ++i) {
-                this.entitiesById.a(aentity[i].getId(), aentity[i]);
+                //this.entitiesById.a(aentity[i].getId(), aentity[i]);
+                this.entitiesById.put(this.g(aentity[i].getId()), aentity[i]);
             }
         }
 
@@ -982,13 +1035,18 @@
 
     protected void b(Entity entity) {
         super.b(entity);
-        this.entitiesById.d(entity.getId());
+        //this.entitiesById.d(entity.getId());
+        //remove it
+        //this.entitiesById.get(this.g(entity.getId()));
+        this.entitiesById.remove(this.g(entity.getId()));
         this.entitiesByUUID.remove(entity.getUniqueID());
         Entity[] aentity = entity.aB();
 
         if (aentity != null) {
             for (int i = 0; i < aentity.length; ++i) {
-                this.entitiesById.d(aentity[i].getId());
+                //this.entitiesById.d(aentity[i].getId());
+                //this.entitiesById.get(this.g(aentity[i].getId()));
+                this.entitiesById.remove(this.g(aentity[i].getId()));
             }
         }
 
@@ -1195,6 +1253,7 @@
     }
 
     static class BlockActionDataList extends ArrayList<BlockActionData> {
+    //static class BlockActionDataList extends CopyOnWriteArrayList<BlockActionData> {
 
         private BlockActionDataList() {}
 
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
--- src_origin/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java	2016-02-26 15:27:16.164204099 +0800
+++ src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java	2016-03-16 23:43:31.374124845 +0800
@@ -10,10 +10,7 @@
 import org.bukkit.craftbukkit.util.LongHash;
 
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import net.minecraft.server.Entity;
-import net.minecraft.server.EntitySlice;
+import org.bukkit.event.Event;
 
 class ChunkIOProvider implements AsynchronousExecutor.CallBackProvider<QueuedChunk, Chunk, Runnable, RuntimeException> {
     private final AtomicInteger threadNumber = new AtomicInteger(1);
@@ -56,7 +53,10 @@
 
         Server server = queuedChunk.provider.world.getServer();
         if (server != null) {
-            server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, false));
+            Event ev = new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, false);
+            //server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, false));
+            ev.setAsynchronous();
+            server.getPluginManager().callEvent(ev);
         }
 
         // Update neighbor counts
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java src/main/java/org/bukkit/craftbukkit/CraftWorld.java
--- src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-02-26 15:27:14.770203969 +0800
+++ src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-03-16 23:43:30.930124844 +0800
@@ -11,6 +11,7 @@
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 import net.minecraft.server.*;
 
@@ -45,8 +46,6 @@
 import org.bukkit.entity.minecart.SpawnerMinecart;
 import org.bukkit.entity.minecart.StorageMinecart;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
-import org.bukkit.event.weather.ThunderChangeEvent;
-import org.bukkit.event.weather.WeatherChangeEvent;
 import org.bukkit.event.world.SpawnChangeEvent;
 import org.bukkit.generator.BlockPopulator;
 import org.bukkit.generator.ChunkGenerator;
@@ -64,7 +63,8 @@
     private Environment environment;
     private final CraftServer server = (CraftServer) Bukkit.getServer();
     private final ChunkGenerator generator;
-    private final List<BlockPopulator> populators = new ArrayList<BlockPopulator>();
+    //private final List<BlockPopulator> populators = new ArrayList<BlockPopulator>();
+    private final List<BlockPopulator> populators = new CopyOnWriteArrayList<BlockPopulator>();
     private final BlockMetadataStore blockMetadata = new BlockMetadataStore(this);
     private int monsterSpawn = -1;
     private int animalSpawn = -1;
@@ -194,8 +194,9 @@
             world.chunkProviderServer.saveChunk(chunk);
             world.chunkProviderServer.saveChunkNOP(chunk);
         }
-
-        world.chunkProviderServer.unloadQueue.remove(x, z);
+        long key = LongHash.toLong(x, z);
+        //world.chunkProviderServer.unloadQueue.remove(x, z);
+        world.chunkProviderServer.unloadQueue.remove(key);
         world.chunkProviderServer.chunks.remove(LongHash.toLong(x, z));
 
         return true;
@@ -203,8 +204,9 @@
 
     public boolean regenerateChunk(int x, int z) {
         unloadChunk(x, z, false, false);
-
-        world.chunkProviderServer.unloadQueue.remove(x, z);
+        long key = LongHash.toLong(x, z);
+        //world.chunkProviderServer.unloadQueue.remove(x, z);
+        world.chunkProviderServer.unloadQueue.remove(key);
 
         net.minecraft.server.Chunk chunk = null;
 
@@ -252,8 +254,9 @@
             // Use the default variant of loadChunk when generate == true.
             return world.chunkProviderServer.getChunkAt(x, z) != null;
         }
-
-        world.chunkProviderServer.unloadQueue.remove(x, z);
+        long key = LongHash.toLong(x, z);
+        //world.chunkProviderServer.unloadQueue.remove(x, z);
+        world.chunkProviderServer.unloadQueue.remove(key);
         net.minecraft.server.Chunk chunk = world.chunkProviderServer.chunks.get(LongHash.toLong(x, z));
 
         if (chunk == null) {
@@ -462,7 +465,10 @@
         world.captureBlockStates = false;
         world.captureTreeGeneration = false;
         if (grownTree) { // Copy block data to delegate
-            for (BlockState blockstate : world.capturedBlockStates) {
+            //for (BlockState blockstate : world.capturedBlockStates) {
+            Iterator it = world.capturedBlockStates.iterator();
+            while(it.hasNext()){
+                BlockState blockstate = (BlockState) it.next();
                 int x = blockstate.getX();
                 int y = blockstate.getY();
                 int z = blockstate.getZ();
@@ -1371,6 +1377,27 @@
         }
 
         ChunkProviderServer cps = world.chunkProviderServer;
+        Iterator it = cps.chunks.values().iterator();
+        net.minecraft.server.Chunk chunk;
+        while (it.hasNext()){
+            //net.minecraft.server.Chunk chunk = (net.minecraft.server.Chunk) it.next();
+            chunk = (net.minecraft.server.Chunk) it.next();
+            long key = LongHash.toLong(chunk.locX, chunk.locZ);
+            // If in use, skip it
+            if (isChunkInUse(chunk.locX, chunk.locZ)) {
+                continue;
+            }
+
+            // Already unloading?
+            //if (cps.unloadQueue.contains(chunk.locX, chunk.locZ)) {
+            if (cps.unloadQueue.containsKey(key)) {
+                continue;
+            }
+
+            // Add unload request
+            cps.queueUnload(chunk.locX, chunk.locZ);
+        }
+        /*
         for (net.minecraft.server.Chunk chunk : cps.chunks.values()) {
             // If in use, skip it
             if (isChunkInUse(chunk.locX, chunk.locZ)) {
@@ -1384,7 +1411,7 @@
 
             // Add unload request
             cps.queueUnload(chunk.locX, chunk.locZ);
-        }
+        }*/
     }
     // Spigot start
     private final Spigot spigot = new Spigot()
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java
--- src_origin/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java	2016-02-26 15:27:18.493204317 +0800
+++ src/main/java/org/bukkit/craftbukkit/entity/CraftPlayer.java	2016-03-16 23:43:31.836124845 +0800
@@ -867,6 +867,12 @@
             getHandle().spawnWorld = location.getWorld().getName();
         }
     }
+    
+    //for spigot
+    private int g(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
 
     @Override
     public void hidePlayer(Player player) {
@@ -879,7 +885,8 @@
         //remove this player from the hidden player's EntityTrackerEntry
         EntityTracker tracker = ((WorldServer) entity.world).tracker;
         EntityPlayer other = ((CraftPlayer) player).getHandle();
-        EntityTrackerEntry entry = (EntityTrackerEntry) tracker.trackedEntities.get(other.getId());
+        //EntityTrackerEntry entry = (EntityTrackerEntry) tracker.trackedEntities.get(other.getId());
+        EntityTrackerEntry entry = (EntityTrackerEntry) tracker.trackedEntities.get(this.g(other.getId()));
         if (entry != null) {
             entry.clear(getHandle());
         }
@@ -901,7 +908,8 @@
 
         getHandle().playerConnection.sendPacket(new PacketPlayOutPlayerInfo(PacketPlayOutPlayerInfo.EnumPlayerInfoAction.ADD_PLAYER, other));
 
-        EntityTrackerEntry entry = (EntityTrackerEntry) tracker.trackedEntities.get(other.getId());
+        //EntityTrackerEntry entry = (EntityTrackerEntry) tracker.trackedEntities.get(other.getId());
+        EntityTrackerEntry entry = (EntityTrackerEntry) tracker.trackedEntities.get(this.g(other.getId()));
         if (entry != null && !entry.trackedPlayers.contains(getHandle())) {
             entry.updatePlayer(getHandle());
         }
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
--- src_origin/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java	2016-02-26 15:27:19.207204384 +0800
+++ src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java	2016-03-16 23:43:32.079124845 +0800
@@ -8,6 +8,8 @@
 
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
+import java.util.Iterator;
+import java.util.Queue;
 
 import net.minecraft.server.*;
 
@@ -91,7 +93,8 @@
     /**
      * Block place methods
      */
-    public static BlockMultiPlaceEvent callBlockMultiPlaceEvent(World world, EntityHuman who, List<BlockState> blockStates, int clickedX, int clickedY, int clickedZ) {
+    //public static BlockMultiPlaceEvent callBlockMultiPlaceEvent(World world, EntityHuman who, List<BlockState> blockStates, int clickedX, int clickedY, int clickedZ) {
+    public static BlockMultiPlaceEvent callBlockMultiPlaceEvent(World world, EntityHuman who, Queue<BlockState> blockStates, int clickedX, int clickedY, int clickedZ) {
         CraftWorld craftWorld = world.getWorld();
         CraftServer craftServer = world.getServer();
         Player player = (who == null) ? null : (Player) who.getBukkitEntity();
@@ -99,14 +102,30 @@
         Block blockClicked = craftWorld.getBlockAt(clickedX, clickedY, clickedZ);
 
         boolean canBuild = true;
+        Iterator it = blockStates.iterator();
+        while (it.hasNext()){
+            BlockState bs = (BlockState) it.next();
+            if (!canBuild(craftWorld, player, bs.getX(), bs.getZ())) {
+                canBuild = false;
+                break;
+            }
+        }
+        /*
         for (int i = 0; i < blockStates.size(); i++) {
             if (!canBuild(craftWorld, player, blockStates.get(i).getX(), blockStates.get(i).getZ())) {
                 canBuild = false;
                 break;
             }
-        }
+        }*/
 
-        BlockMultiPlaceEvent event = new BlockMultiPlaceEvent(blockStates, blockClicked, player.getItemInHand(), player, canBuild);
+        //BlockMultiPlaceEvent event = new BlockMultiPlaceEvent(blockStates, blockClicked, player.getItemInHand(), player, canBuild);
+        BlockState first_stat = null;
+        if (blockStates.iterator().hasNext()){
+            first_stat = blockStates.iterator().next();
+        }
+        
+        BlockMultiPlaceEvent event = new BlockMultiPlaceEvent(blockStates, first_stat, first_stat.getBlock(), blockClicked, player.getItemInHand(), player, canBuild);
+        
         craftServer.getPluginManager().callEvent(event);
 
         return event;
@@ -961,6 +980,8 @@
                 event = new PlayerStatisticIncrementEvent(player, stat, current, current + incrementation, material);
             }
         }
+        //set async
+        event.setAsynchronous();
         entityHuman.world.getServer().getPluginManager().callEvent(event);
         return (Cancellable) event;
     }
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/generator/NormalChunkGenerator.java src/main/java/org/bukkit/craftbukkit/generator/NormalChunkGenerator.java
--- src_origin/main/java/org/bukkit/craftbukkit/generator/NormalChunkGenerator.java	2016-02-26 15:27:19.354204398 +0800
+++ src/main/java/org/bukkit/craftbukkit/generator/NormalChunkGenerator.java	2016-03-16 23:43:32.081124845 +0800
@@ -3,6 +3,7 @@
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Random;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 import net.minecraft.server.*;
 
@@ -28,7 +29,8 @@
 
     @Override
     public List<BlockPopulator> getDefaultPopulators(org.bukkit.World world) {
-        return new ArrayList<BlockPopulator>();
+        //return new ArrayList<BlockPopulator>();
+        return new CopyOnWriteArrayList<BlockPopulator>();
     }
 
     @Override
@@ -88,7 +90,7 @@
     }
 
     @Override
-    public void recreateStructures(Chunk chunk, int i, int i1) {
+    synchronized public void recreateStructures(Chunk chunk, int i, int i1) {
         provider.recreateStructures(chunk, i, i1);
     }
 
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
--- src_origin/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java	2016-02-26 15:27:20.478204503 +0800
+++ src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java	2016-03-16 23:43:32.375124846 +0800
@@ -42,6 +42,7 @@
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import net.minecraft.server.NBTCompressedStreamTools;
@@ -226,7 +227,8 @@
     private int repairCost;
     private int hideFlag;
 
-    private static final Set<String> HANDLED_TAGS = Sets.newHashSet();
+    //private static final Set<String> HANDLED_TAGS = Sets.newHashSet();
+    private static final Set<String> HANDLED_TAGS = new CopyOnWriteArraySet<String>();
 
     private final Map<String, NBTBase> unhandledTags = new HashMap<String, NBTBase>();
 
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/potion/CraftPotionBrewer.java src/main/java/org/bukkit/craftbukkit/potion/CraftPotionBrewer.java
--- src_origin/main/java/org/bukkit/craftbukkit/potion/CraftPotionBrewer.java	2016-02-26 15:27:21.354204585 +0800
+++ src/main/java/org/bukkit/craftbukkit/potion/CraftPotionBrewer.java	2016-03-16 23:43:32.593124846 +0800
@@ -3,7 +3,6 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
-import java.util.Map;
 
 import net.minecraft.server.MobEffect;
 
@@ -11,10 +10,12 @@
 import org.bukkit.potion.PotionBrewer;
 import org.bukkit.potion.PotionEffect;
 
-import com.google.common.collect.Maps;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 public class CraftPotionBrewer implements PotionBrewer {
-    private static final Map<Integer, Collection<PotionEffect>> cache = Maps.newHashMap();
+    //private static final Map<Integer, Collection<PotionEffect>> cache = Maps.newHashMap();
+    private static final ConcurrentMap<Integer, Collection<PotionEffect>> cache = new ConcurrentHashMap<Integer, Collection<PotionEffect>>();
 
     public Collection<PotionEffect> getEffectsFromDamage(int damage) {
         if (cache.containsKey(damage))
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java src/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java	2016-02-26 15:27:22.149204659 +0800
+++ src/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java	2016-03-16 23:43:32.928124846 +0800
@@ -5,7 +5,9 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Queue;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
@@ -74,7 +76,8 @@
         volatile int state = PENDING;
         final P parameter;
         T object;
-        final List<C> callbacks = new LinkedList<C>();
+        //final List<C> callbacks = new LinkedList<C>();
+        final Queue<C> callbacks = new ConcurrentLinkedQueue<C>();
         E t = null;
 
         Task(final P parameter) {
@@ -216,7 +219,8 @@
 
     final CallBackProvider<P, T, C, E> provider;
     final Queue<Task> finished = new ConcurrentLinkedQueue<Task>();
-    final Map<P, Task> tasks = new HashMap<P, Task>();
+    //final Map<P, Task> tasks = new HashMap<P, Task>();
+    final ConcurrentMap<P, Task> tasks = new ConcurrentHashMap<P, Task>();
     final ThreadPoolExecutor pool;
 
     /**
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/ForwardLogHandler.java src/main/java/org/bukkit/craftbukkit/util/ForwardLogHandler.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/ForwardLogHandler.java	2016-02-26 15:27:22.318204675 +0800
+++ src/main/java/org/bukkit/craftbukkit/util/ForwardLogHandler.java	2016-03-16 23:43:32.929124846 +0800
@@ -10,6 +10,7 @@
 import java.util.logging.LogRecord;
 
 public class ForwardLogHandler extends ConsoleHandler {
+    //private Map<String, Logger> cachedLoggers = new ConcurrentHashMap<String, Logger>();
     private Map<String, Logger> cachedLoggers = new ConcurrentHashMap<String, Logger>();
 
     private Logger getLogger(String name) {
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-02-26 15:27:22.350204678 +0800
+++ src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-03-16 23:43:32.933124846 +0800
@@ -1,15 +1,17 @@
 package org.bukkit.craftbukkit.util;
 
+import com.google.common.collect.Sets;
 import java.util.Collection;
-import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
-import java.util.TreeSet;
+import java.util.concurrent.ConcurrentSkipListSet;
 
 public class HashTreeSet<V> implements Set<V> {
 
-    private HashSet<V> hash = new HashSet<V>();
-    private TreeSet<V> tree = new TreeSet<V>();
+    //private HashSet<V> hash = new HashSet<V>();
+    private Set<V> hash = Sets.newConcurrentHashSet();
+    //private TreeSet<V> tree = new TreeSet<V>();
+    private ConcurrentSkipListSet<V> tree = new ConcurrentSkipListSet<V>();
 
     public HashTreeSet() {
 
@@ -112,6 +114,6 @@
 
     public V first() {
         return tree.first();
-    }
+   }
 
 }
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java src/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java	2016-02-26 15:27:22.480204690 +0800
+++ src/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java	1970-01-01 08:00:00.000000000 +0800
@@ -1,422 +0,0 @@
-package org.bukkit.craftbukkit.util;
-
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.Serializable;
-import java.util.AbstractCollection;
-import java.util.AbstractSet;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.ConcurrentModificationException;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.NoSuchElementException;
-import java.util.Set;
-
-@SuppressWarnings("unchecked")
-public class LongObjectHashMap<V> implements Cloneable, Serializable {
-    static final long serialVersionUID = 2841537710170573815L;
-
-    private static final long EMPTY_KEY = Long.MIN_VALUE;
-    private static final int  BUCKET_SIZE = 4096;
-
-    private transient long[][] keys;
-    private transient V[][]    values;
-    private transient int      modCount;
-    private transient int      size;
-
-    public LongObjectHashMap() {
-        initialize();
-    }
-
-    public LongObjectHashMap(Map<? extends Long, ? extends V> map) {
-        this();
-        putAll(map);
-    }
-
-    public int size() {
-        return size;
-    }
-
-    public boolean isEmpty() {
-        return size == 0;
-    }
-
-    public boolean containsKey(long key) {
-        return get(key) != null;
-    }
-
-    public boolean containsValue(V value) {
-        for (V val : values()) {
-            if (val == value || val.equals(value)) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    public V get(long key) {
-        int index = (int) (keyIndex(key) & (BUCKET_SIZE - 1));
-        long[] inner = keys[index];
-        if (inner == null) return null;
-
-        for (int i = 0; i < inner.length; i++) {
-            long innerKey = inner[i];
-            if (innerKey == EMPTY_KEY) {
-                return null;
-            } else if (innerKey == key) {
-                return values[index][i];
-            }
-        }
-
-        return null;
-    }
-
-    public V put(long key, V value) {
-        int index = (int) (keyIndex(key) & (BUCKET_SIZE - 1));
-        long[] innerKeys = keys[index];
-        V[] innerValues = values[index];
-        modCount++;
-
-        if (innerKeys == null) {
-            // need to make a new chain
-            keys[index] = innerKeys = new long[8];
-            Arrays.fill(innerKeys, EMPTY_KEY);
-            values[index] = innerValues = (V[]) new Object[8];
-            innerKeys[0] = key;
-            innerValues[0] = value;
-            size++;
-        } else {
-            int i;
-            for (i = 0; i < innerKeys.length; i++) {
-                // found an empty spot in the chain to put this
-                if (innerKeys[i] == EMPTY_KEY) {
-                    size++;
-                    innerKeys[i] = key;
-                    innerValues[i] = value;
-                    return null;
-                }
-
-                // found an existing entry in the chain with this key, replace it
-                if (innerKeys[i] == key) {
-                    V oldValue = innerValues[i];
-                    innerKeys[i] = key;
-                    innerValues[i] = value;
-                    return oldValue;
-                }
-            }
-
-            // chain is full, resize it and add our new entry
-            keys[index] = innerKeys = Arrays.copyOf(innerKeys, i << 1);
-            Arrays.fill(innerKeys, i, innerKeys.length, EMPTY_KEY);
-            values[index] = innerValues = Arrays.copyOf(innerValues, i << 1);
-            innerKeys[i] = key;
-            innerValues[i] = value;
-            size++;
-        }
-
-        return null;
-    }
-
-    public V remove(long key) {
-        int index = (int) (keyIndex(key) & (BUCKET_SIZE - 1));
-        long[] inner = keys[index];
-        if (inner == null) {
-            return null;
-        }
-
-        for (int i = 0; i < inner.length; i++) {
-            // hit the end of the chain, didn't find this entry
-            if (inner[i] == EMPTY_KEY) {
-                break;
-            }
-
-            if (inner[i] == key) {
-                V value = values[index][i];
-
-                for (i++; i < inner.length; i++) {
-                    if (inner[i] == EMPTY_KEY) {
-                        break;
-                    }
-
-                    inner[i - 1] = inner[i];
-                    values[index][i - 1] = values[index][i];
-                }
-
-                inner[i - 1] = EMPTY_KEY;
-                values[index][i - 1] = null;
-                size--;
-                modCount++;
-                return value;
-            }
-        }
-
-        return null;
-    }
-
-    public void putAll(Map<? extends Long, ? extends V> map) {
-        for (Map.Entry entry : map.entrySet()) {
-            put((Long) entry.getKey(), (V) entry.getValue());
-        }
-    }
-
-    public void clear() {
-        if (size == 0) {
-            return;
-        }
-
-        modCount++;
-        size = 0;
-        Arrays.fill(keys, null);
-        Arrays.fill(values, null);
-    }
-
-    public Set<Long> keySet() {
-        return new KeySet();
-    }
-
-    public Collection<V> values() {
-        return new ValueCollection();
-    }
-
-    /**
-     * Returns a Set of Entry objects for the HashMap. This is not how the internal
-     * implementation is laid out so this constructs the entire Set when called. For
-     * this reason it should be avoided if at all possible.
-     *
-     * @return Set of Entry objects
-     * @deprecated
-     */
-    @Deprecated
-    public Set<Map.Entry<Long, V>> entrySet() {
-        HashSet<Map.Entry<Long, V>> set = new HashSet<Map.Entry<Long, V>>();
-        for (long key : keySet()) {
-            set.add(new Entry(key, get(key)));
-        }
-
-        return set;
-    }
-
-    public Object clone() throws CloneNotSupportedException {
-        LongObjectHashMap clone = (LongObjectHashMap) super.clone();
-        // Make sure we clear any existing information from the clone
-        clone.clear();
-        // Make sure the clone is properly setup for new entries
-        clone.initialize();
-
-        // Iterate through the data normally to do a safe clone
-        for (long key : keySet()) {
-            final V value = get(key);
-            clone.put(key, value);
-        }
-
-        return clone;
-    }
-
-    private void initialize() {
-        keys = new long[BUCKET_SIZE][];
-        values = (V[][]) new Object[BUCKET_SIZE][];
-    }
-
-    private long keyIndex(long key) {
-        key ^= key >>> 33;
-        key *= 0xff51afd7ed558ccdL;
-        key ^= key >>> 33;
-        key *= 0xc4ceb9fe1a85ec53L;
-        key ^= key >>> 33;
-        return key;
-    }
-
-    private void writeObject(ObjectOutputStream outputStream) throws IOException {
-        outputStream.defaultWriteObject();
-
-        for (long key : keySet()) {
-            V value = get(key);
-            outputStream.writeLong(key);
-            outputStream.writeObject(value);
-        }
-
-        outputStream.writeLong(EMPTY_KEY);
-        outputStream.writeObject(null);
-    }
-
-    private void readObject(ObjectInputStream inputStream) throws ClassNotFoundException, IOException {
-        inputStream.defaultReadObject();
-        initialize();
-
-        while (true) {
-            long key = inputStream.readLong();
-            V value = (V) inputStream.readObject();
-            if (key == EMPTY_KEY && value == null) {
-                break;
-            }
-
-            put(key, value);
-        }
-    }
-
-
-    private class ValueIterator implements Iterator<V> {
-        private int count;
-        private int index;
-        private int innerIndex;
-        private int expectedModCount;
-        private long lastReturned = EMPTY_KEY;
-
-        long prevKey = EMPTY_KEY;
-        V prevValue;
-
-        ValueIterator() {
-            expectedModCount = LongObjectHashMap.this.modCount;
-        }
-
-        public boolean hasNext() {
-            return count < LongObjectHashMap.this.size;
-        }
-
-        public void remove() {
-            if (LongObjectHashMap.this.modCount != expectedModCount) {
-                throw new ConcurrentModificationException();
-            }
-
-            if (lastReturned == EMPTY_KEY) {
-                throw new IllegalStateException();
-            }
-
-            count--;
-            LongObjectHashMap.this.remove(lastReturned);
-            lastReturned = EMPTY_KEY;
-            expectedModCount = LongObjectHashMap.this.modCount;
-        }
-
-        public V next() {
-            if (LongObjectHashMap.this.modCount != expectedModCount) {
-                throw new ConcurrentModificationException();
-            }
-
-            if (!hasNext()) {
-                throw new NoSuchElementException();
-            }
-
-            long[][] keys = LongObjectHashMap.this.keys;
-            count++;
-
-            if (prevKey != EMPTY_KEY) {
-                innerIndex++;
-            }
-
-            for (; index < keys.length; index++) {
-                if (keys[index] != null) {
-                    for (; innerIndex < keys[index].length; innerIndex++) {
-                        long key = keys[index][innerIndex];
-                        V value = values[index][innerIndex];
-                        if (key == EMPTY_KEY) {
-                            break;
-                        }
-
-                        lastReturned = key;
-                        prevKey = key;
-                        prevValue = value;
-                        return prevValue;
-                    }
-                    innerIndex = 0;
-                }
-            }
-
-            throw new NoSuchElementException();
-        }
-    }
-
-    private class KeyIterator implements Iterator<Long> {
-        final ValueIterator iterator;
-
-        public KeyIterator() {
-            iterator = new ValueIterator();
-        }
-
-        public void remove() {
-            iterator.remove();
-        }
-
-        public boolean hasNext() {
-            return iterator.hasNext();
-        }
-
-        public Long next() {
-            iterator.next();
-            return iterator.prevKey;
-        }
-    }
-
-
-    private class KeySet extends AbstractSet<Long> {
-        public void clear() {
-            LongObjectHashMap.this.clear();
-        }
-
-        public int size() {
-            return LongObjectHashMap.this.size();
-        }
-
-        public boolean contains(Object key) {
-            return key instanceof Long && LongObjectHashMap.this.containsKey((Long) key);
-
-        }
-
-        public boolean remove(Object key) {
-            return LongObjectHashMap.this.remove((Long) key) != null;
-        }
-
-        public Iterator<Long> iterator() {
-            return new KeyIterator();
-        }
-    }
-
-
-    private class ValueCollection extends AbstractCollection<V> {
-        public void clear() {
-            LongObjectHashMap.this.clear();
-        }
-
-        public int size() {
-            return LongObjectHashMap.this.size();
-        }
-
-        public boolean contains(Object value) {
-            return LongObjectHashMap.this.containsValue((V) value);
-        }
-
-        public Iterator<V> iterator() {
-            return new ValueIterator();
-        }
-    }
-
-
-    private class Entry implements Map.Entry<Long, V> {
-        private final Long key;
-        private V value;
-
-        Entry(long k, V v) {
-            key = k;
-            value = v;
-        }
-
-        public Long getKey() {
-            return key;
-        }
-
-        public V getValue() {
-            return value;
-        }
-
-        public V setValue(V v) {
-            V old = value;
-            value = v;
-            put(key, v);
-            return old;
-        }
-    }
-}
diff -Naur src_origin/main/java/org/hose/AddParticlePool.java src/main/java/org/hose/AddParticlePool.java
--- src_origin/main/java/org/hose/AddParticlePool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/AddParticlePool.java	2016-03-16 23:43:28.310124842 +0800
@@ -0,0 +1,41 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.EnumParticle;
+import net.minecraft.server.World;
+/**
+ *
+ * @author softpak
+ */
+public class AddParticlePool implements Callable{
+    private World w;
+    private EnumParticle ep;
+    private int[] aint;
+    private double d0, d1, d2, d3, d4, d5;
+    
+    public AddParticlePool(World w, EnumParticle ep, double d0, double d1, double d2, double d3, double d4, double d5, int... aint){
+        this.w = w;
+        this.ep = ep;
+        this.aint = aint;
+        this.d0 = d0;
+        this.d1 = d1;
+        this.d2 = d2;
+        this.d3 = d3;
+        this.d4 = d4;
+        this.d5 = d5;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+        //this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        w.a(ep.c(), ep.e(), d0, d1, d2, d3, d4, d5, aint);
+        return null;
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/ChangeEntityThreadCommand.java src/main/java/org/hose/ChangeEntityThreadCommand.java
--- src_origin/main/java/org/hose/ChangeEntityThreadCommand.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChangeEntityThreadCommand.java	2016-03-16 23:43:28.305124842 +0800
@@ -0,0 +1,52 @@
+package org.hose;
+
+import com.google.common.base.Joiner;
+import net.minecraft.server.MinecraftServer;
+import com.google.common.collect.Iterables;
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.spigotmc.SpigotWorldConfig;
+
+public class ChangeEntityThreadCommand extends Command
+{
+
+    public ChangeEntityThreadCommand(String name)
+    {
+        super( name );
+        this.description = "Change the Entity thread number for the server";
+        this.usageMessage = "/ctp";
+        this.setPermission( "bukkit.command.ctp" );
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args)
+    {
+        if ( !testPermission( sender ) )
+        {
+            return true;
+        }
+        StringBuilder sb;
+        if (args.length > 0){//cahnge thread pool size
+            try {
+                SpigotWorldConfig.entitytick_pool_executor.setCorePoolSize(Integer.parseInt(args[0]));
+                SpigotWorldConfig.entitytick_pool_executor.setMaximumPoolSize(Integer.parseInt(args[0]));
+                sb = new StringBuilder( ChatColor.GOLD + "Entity thread pool size: "+ SpigotWorldConfig.entitytick_pool_executor.getCorePoolSize() );
+            } catch (Exception ex) {
+                sb = new StringBuilder( ChatColor.GOLD + "Something is wrong with setting entity thread pool size. ");
+            }
+        } else {
+            sb = new StringBuilder( ChatColor.GOLD + "Entity thread pool size: "+ SpigotWorldConfig.entitytick_pool_executor.getCorePoolSize() );
+        }
+        
+        sender.sendMessage( sb.toString() );
+        
+        return true;
+    }
+
+    private String format(double tps)
+    {
+        return ( ( tps > 18.0 ) ? ChatColor.GREEN : ( tps > 16.0 ) ? ChatColor.YELLOW : ChatColor.RED ).toString()
+                + ( ( tps > 20.0 ) ? "*" : "" ) + Math.min( Math.round( tps * 100.0 ) / 100.0, 20.0 );
+    }
+}
diff -Naur src_origin/main/java/org/hose/ChunkGenPool.java src/main/java/org/hose/ChunkGenPool.java
--- src_origin/main/java/org/hose/ChunkGenPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChunkGenPool.java	2016-03-16 23:43:28.309124842 +0800
@@ -0,0 +1,38 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.WorldServer;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkGenPool  implements Callable<Chunk>{
+    WorldServer worldserver;
+    BlockPosition blockposition;
+    
+    int k, l;
+    
+    public ChunkGenPool(WorldServer worldserver, BlockPosition blockposition, int k, int l) {
+        this.worldserver = worldserver;
+        this.blockposition = blockposition;
+        this.k = k;
+        this.l = l;
+    }
+
+    @Override
+    public Chunk call() throws Exception {
+        //worldserver.chunkProviderServer.getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+        return worldserver.chunkProviderServer.getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/EntityAICollision_Pool.java src/main/java/org/hose/EntityAICollision_Pool.java
--- src_origin/main/java/org/hose/EntityAICollision_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/EntityAICollision_Pool.java	2016-03-16 23:43:28.308124842 +0800
@@ -0,0 +1,35 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.EntityLiving;
+import org.spigotmc.SpigotWorldConfig;
+
+/**
+ *
+ * @author softpak
+ */
+public class EntityAICollision_Pool  implements Callable{
+    private EntityLiving el;
+    
+    public EntityAICollision_Pool(EntityLiving el) {
+        this.el = el;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        SpigotWorldConfig.Collision_list.remove(this.g(this.el.getId()));
+        this.el.bL_hose();
+        return null;
+    }
+    
+    private int g(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
+    
+}
diff -Naur src_origin/main/java/org/hose/EntityTick_Pool.java src/main/java/org/hose/EntityTick_Pool.java
--- src_origin/main/java/org/hose/EntityTick_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/EntityTick_Pool.java	2016-03-16 23:43:28.309124842 +0800
@@ -0,0 +1,38 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Entity;
+import net.minecraft.server.World;
+import org.spigotmc.SpigotWorldConfig;
+
+/**
+ *
+ * @author softpak
+ */
+public class EntityTick_Pool  implements Callable{
+    private Entity e;
+    private World w;
+
+    public EntityTick_Pool(World w, Entity e) {
+        this.e = e;
+        this.w = w;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        SpigotWorldConfig.EntityTick_list.remove(this.g(this.e.getId()));
+        this.w.g(this.e);
+        return null;
+    }
+    
+    private int g(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
+    
+}
diff -Naur src_origin/main/java/org/hose/EntityTickRest_Pool.java src/main/java/org/hose/EntityTickRest_Pool.java
--- src_origin/main/java/org/hose/EntityTickRest_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/EntityTickRest_Pool.java	2016-03-16 23:43:28.305124842 +0800
@@ -0,0 +1,30 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.EntityLiving;
+
+/**
+ *
+ * @author softpak
+ */
+public class EntityTickRest_Pool  implements Callable{
+    private EntityLiving el;
+    
+    public EntityTickRest_Pool(EntityLiving el) {
+        this.el = el;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        this.el.EntityTickRest_hose();
+        return null;
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/GetChunkATPool.java src/main/java/org/hose/GetChunkATPool.java
--- src_origin/main/java/org/hose/GetChunkATPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/GetChunkATPool.java	2016-03-16 23:43:28.309124842 +0800
@@ -0,0 +1,35 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.ChunkProviderGenerate;
+import net.minecraft.server.IChunkProvider;
+/**
+ *
+ * @author softpak
+ */
+public class GetChunkATPool implements Callable{
+    ChunkProviderGenerate cpg;
+    IChunkProvider ichunkprovider;
+    int i, j;
+    
+    public GetChunkATPool(ChunkProviderGenerate cpg, IChunkProvider ichunkprovider, int i, int j) {
+        this.cpg = cpg;
+        this.ichunkprovider = ichunkprovider;
+        this.i = i;
+        this.j = j;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        cpg.getChunkAt_hose(ichunkprovider, i, j);
+        return null;
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/GetCreateChunkPool.java src/main/java/org/hose/GetCreateChunkPool.java
--- src_origin/main/java/org/hose/GetCreateChunkPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/GetCreateChunkPool.java	2016-03-16 23:43:28.309124842 +0800
@@ -0,0 +1,32 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkProviderGenerate;
+/**
+ *
+ * @author softpak
+ */
+public class GetCreateChunkPool implements Callable<Chunk>{
+    ChunkProviderGenerate cpg;
+    int i, j;
+    
+    public GetCreateChunkPool(ChunkProviderGenerate cpg, int i, int j) {
+        this.cpg = cpg;
+        this.i = i;
+        this.j = j;
+    }
+
+    @Override
+    public Chunk call() throws Exception {
+        return cpg.getOrCreateChunk_hose(i, j);
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/SpawnerCreature_Pool.java src/main/java/org/hose/SpawnerCreature_Pool.java
--- src_origin/main/java/org/hose/SpawnerCreature_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/SpawnerCreature_Pool.java	2016-03-16 23:43:28.310124842 +0800
@@ -0,0 +1,47 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.EnumCreatureType;
+import net.minecraft.server.SpawnerCreature;
+import net.minecraft.server.WorldServer;
+
+/**
+ *
+ * @author softpak
+ */
+public class SpawnerCreature_Pool  implements Callable<Integer>{
+    SpawnerCreature sc;
+    boolean flag, flag1, flag2;
+    WorldServer worldserver;
+    EnumCreatureType[] aenumcreaturetype;
+    BlockPosition blockposition;
+    int i, j1, k, k1;
+
+    public SpawnerCreature_Pool(SpawnerCreature sc, EnumCreatureType[] aenumcreaturetype, BlockPosition blockposition, int i, int j1, int k, int k1, WorldServer worldserver, boolean flag, boolean flag1, boolean flag2) {
+        this.sc = sc;
+        this.flag = flag;
+        this.flag2 = flag1;
+        this.flag2 = flag2;
+        this.worldserver = worldserver;
+        this.aenumcreaturetype = aenumcreaturetype;
+        this.i = i;
+        this.k = k;
+        this.j1 = j1;
+        this.k1 = k1;
+        this.blockposition = blockposition;
+    }
+
+    @Override
+    public Integer call() throws Exception {
+        return sc.spawn_calc_hose(aenumcreaturetype, blockposition, i, j1, k, k1, worldserver, flag, flag1, flag2);
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/TileTick_Pool.java src/main/java/org/hose/TileTick_Pool.java
--- src_origin/main/java/org/hose/TileTick_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/TileTick_Pool.java	2016-03-16 23:43:28.310124842 +0800
@@ -0,0 +1,32 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.IUpdatePlayerListBox;
+import net.minecraft.server.TileEntity;
+
+/**
+ *
+ * @author softpak
+ */
+public class TileTick_Pool  implements Callable{
+    private TileEntity tileentity;
+
+    public TileTick_Pool(TileEntity tileentity) {
+        this.tileentity = tileentity;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        //((IUpdatePlayerListBox) tileentity).c();
+        ((IUpdatePlayerListBox) this.tileentity).c();
+        return null;
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/spigotmc/ActivationRange.java src/main/java/org/spigotmc/ActivationRange.java
--- src_origin/main/java/org/spigotmc/ActivationRange.java	2016-02-26 15:27:05.386203091 +0800
+++ src/main/java/org/spigotmc/ActivationRange.java	2016-03-16 23:43:28.483124842 +0800
@@ -1,8 +1,7 @@
 package org.spigotmc;
 
-import java.util.ArrayList;
 import java.util.List;
-import java.util.Set;
+import java.util.Queue;
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.Chunk;
 import net.minecraft.server.Entity;
@@ -21,7 +20,6 @@
 import net.minecraft.server.EntityMonster;
 import net.minecraft.server.EntityProjectile;
 import net.minecraft.server.EntitySheep;
-import net.minecraft.server.EntitySlice;
 import net.minecraft.server.EntitySlime;
 import net.minecraft.server.EntityTNTPrimed;
 import net.minecraft.server.EntityVillager;
@@ -31,7 +29,6 @@
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.World;
 import org.bukkit.craftbukkit.SpigotTimings;
-import org.bukkit.entity.Creeper;
 
 public class ActivationRange
 {
@@ -143,7 +140,8 @@
      */
     private static void activateChunkEntities(Chunk chunk)
     {
-        for ( List<Entity> slice : chunk.entitySlices )
+        //for ( List<Entity> slice : chunk.entitySlices )
+        for ( Queue<Entity> slice : chunk.entitySlices )
         {
             for ( Entity entity : slice )
             {
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2016-02-26 15:27:05.429203095 +0800
+++ src/main/java/org/spigotmc/AsyncCatcher.java	2016-03-16 23:43:28.485124842 +0800
@@ -5,7 +5,7 @@
 public class AsyncCatcher
 {
 
-    public static boolean enabled = true;
+    public static boolean enabled = false;
 
     public static void catchOp(String reason)
     {
diff -Naur src_origin/main/java/org/spigotmc/SpigotConfig.java src/main/java/org/spigotmc/SpigotConfig.java
--- src_origin/main/java/org/spigotmc/SpigotConfig.java	2016-02-26 15:27:05.584203109 +0800
+++ src/main/java/org/spigotmc/SpigotConfig.java	2016-03-16 23:43:28.510124842 +0800
@@ -26,6 +26,7 @@
 import org.bukkit.configuration.ConfigurationSection;
 import org.bukkit.configuration.InvalidConfigurationException;
 import org.bukkit.configuration.file.YamlConfiguration;
+import org.hose.ChangeEntityThreadCommand;
 
 public class SpigotConfig
 {
@@ -275,6 +276,11 @@
     {
         commands.put( "tps", new TicksPerSecondCommand( "tps" ) );
     }
+    
+    private static void ctpCommand()
+    {
+        commands.put( "ctp", new ChangeEntityThreadCommand( "ctp" ) );
+    }
 
     public static int playerSample;
     private static void playerSample()
diff -Naur src_origin/main/java/org/spigotmc/SpigotWorldConfig.java src/main/java/org/spigotmc/SpigotWorldConfig.java
--- src_origin/main/java/org/spigotmc/SpigotWorldConfig.java	2016-02-26 15:27:05.636203114 +0800
+++ src/main/java/org/spigotmc/SpigotWorldConfig.java	2016-03-16 23:43:28.532124842 +0800
@@ -1,13 +1,89 @@
 package org.spigotmc;
 
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
+import io.netty.util.internal.ConcurrentSet;
 import java.util.Arrays;
 import java.util.List;
+import java.util.Set;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import net.minecraft.server.Chunk;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
 public class SpigotWorldConfig
 {
+    static public final int cpu_core = Runtime.getRuntime().availableProcessors();
+    
+    static public Set<Integer> BlockＮextＴick_list = new ConcurrentSet();
+    static public Set<Integer> Collision_list = new ConcurrentSet();
+    static public Set<Integer> EntityTick_list = new ConcurrentSet();
+    
+    static public FutureTask AddParticleTask;
+    static public FutureTask EntityTickTask;
+    static public FutureTask<Chunk> ChunkGenTask;
+    static public FutureTask GetChunkATTask;
+    static public FutureTask<Chunk> GetCreateChunkTask;
+    static public FutureTask TileTickTask;
+    static public FutureTask<Integer> SpawnerCreatureTask;
+    static public FutureTask EntityTickRestTask;
+    static public FutureTask EntityAICollisionTask;
+        
+    static final ThreadFactory tfeacp = new ThreadFactoryBuilder().setNameFormat("EntityAICollision_Pool-%d").build();
+    static public final ExecutorService entityaicollisiontpool_executor = Executors.newFixedThreadPool(cpu_core, tfeacp);            
+            
+    static final ThreadFactory tfetrp = new ThreadFactoryBuilder().setNameFormat("EntityTickRest_Pool-%d").build();
+    static public final ExecutorService entitytickrestpool_executor = Executors.newFixedThreadPool(cpu_core, tfetrp);
+    
+    static final ThreadFactory tfttp = new ThreadFactoryBuilder().setNameFormat("TileTick_Pool-%d").build();
+    static public final ExecutorService tiletickpool_executor = Executors.newFixedThreadPool(cpu_core*10, tfttp);
+    
+    static final ThreadFactory tfgccp = new ThreadFactoryBuilder().setNameFormat("GetCreateChunkPool-%d").build();
+    static public final ExecutorService getcreatechunkatpool_executor = Executors.newFixedThreadPool(cpu_core*10, tfgccp);
+            
+    static final ThreadFactory tfgcap = new ThreadFactoryBuilder().setNameFormat("GetChunkATPool-%d").build();
+    static public final ExecutorService getchunkatpool_executor = Executors.newFixedThreadPool(cpu_core*10, tfgcap);
+    
+    static final ThreadFactory tfcgp = new ThreadFactoryBuilder().setNameFormat("ChunkGenPool-%d").build();
+    static public final ExecutorService chunkgenpool_executor = Executors.newFixedThreadPool(cpu_core*10, tfcgp);
+    
+    static final ThreadFactory tfapp = new ThreadFactoryBuilder().setNameFormat("AddParticlePool-%d").build();
+    static public final ExecutorService addparticlepool_executor = Executors.newFixedThreadPool(cpu_core, tfapp);
+    
+    static final ThreadFactory tfetp = new ThreadFactoryBuilder().setNameFormat("EntityTick_Pool-%d").build();
+    static public ThreadPoolExecutor entitytick_pool_executor;
 
+    static final ThreadFactory tfscp = new ThreadFactoryBuilder().setNameFormat("SpawnerCreature_Pool-%d").build();
+    static public ExecutorService spawncreaturepool_executor;
+    
+    public static int worldtickentitypool_core_multiple;
+    
+    public static int getthreadnumber(){
+        return cpu_core*worldtickentitypool_core_multiple;
+    }
+    
+    //static public BlockingQueue entitytick_queue = new LinkedBlockingQueue(5000000);//capacity 5M 
+    static public BlockingQueue entitytick_queue = new LinkedBlockingQueue();
+    //static public ThreadPoolExecutor executor;
+    
+    
+    private void wetp_core_multiple()
+    {
+        worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 4);
+        entitytick_pool_executor = new ThreadPoolExecutor(getthreadnumber(), getthreadnumber(), 1, TimeUnit.DAYS, entitytick_queue, tfetp);
+        spawncreaturepool_executor = Executors.newFixedThreadPool(getthreadnumber(), tfscp);
+        //executor = new ThreadPoolExecutor(getthreadnumber(), getthreadnumber(), 1, TimeUnit.DAYS, queue);
+        log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
+    }
+    
+    
+    
     private final String worldName;
     private final YamlConfiguration config;
     private boolean verbose;
