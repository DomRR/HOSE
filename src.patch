diff -Naur src_origin/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java src_new/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java
--- src_origin/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java	2016-02-26 15:27:07.267203267 +0800
+++ src_new/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java	2016-02-29 09:37:07.892490901 +0800
@@ -3,6 +3,7 @@
 import com.google.common.collect.Lists;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 public abstract class BlockMinecartTrackAbstract extends Block {
 
@@ -247,7 +248,8 @@
         private final BlockMinecartTrackAbstract d;
         private IBlockData e;
         private final boolean f;
-        private final List<BlockPosition> g = Lists.newArrayList();
+        //private final List<BlockPosition> g = Lists.newArrayList();
+        private final List<BlockPosition> g = Lists.newCopyOnWriteArrayList();
 
         public MinecartTrackLogic(World world, BlockPosition blockposition, IBlockData iblockdata) {
             this.b = world;
diff -Naur src_origin/main/java/net/minecraft/server/BlockRedstoneTorch.java src_new/main/java/net/minecraft/server/BlockRedstoneTorch.java
--- src_origin/main/java/net/minecraft/server/BlockRedstoneTorch.java	2016-02-26 15:27:07.667203304 +0800
+++ src_new/main/java/net/minecraft/server/BlockRedstoneTorch.java	2016-02-29 09:37:08.256490935 +0800
@@ -15,7 +15,8 @@
 
     private boolean a(World world, BlockPosition blockposition, boolean flag) {
         if (!BlockRedstoneTorch.b.containsKey(world)) {
-            BlockRedstoneTorch.b.put(world, Lists.<BlockRedstoneTorch.RedstoneUpdateInfo>newArrayList()); // CraftBukkit - fix decompile error
+            //BlockRedstoneTorch.b.put(world, Lists.<BlockRedstoneTorch.RedstoneUpdateInfo>newArrayList()); // CraftBukkit - fix decompile error
+            BlockRedstoneTorch.b.put(world, Lists.<BlockRedstoneTorch.RedstoneUpdateInfo>newCopyOnWriteArrayList()); // CraftBukkit - fix decompile error
         }
 
         List list = (List) BlockRedstoneTorch.b.get(world);
diff -Naur src_origin/main/java/net/minecraft/server/BlockRedstoneWire.java src_new/main/java/net/minecraft/server/BlockRedstoneWire.java
--- src_origin/main/java/net/minecraft/server/BlockRedstoneWire.java	2016-02-26 15:27:07.697203307 +0800
+++ src_new/main/java/net/minecraft/server/BlockRedstoneWire.java	2016-02-29 09:37:08.290490938 +0800
@@ -5,8 +5,10 @@
 import java.util.ArrayList;
 import java.util.EnumSet;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Random;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
 
 import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
 
@@ -18,7 +20,8 @@
     public static final BlockStateEnum<BlockRedstoneWire.EnumRedstoneWireConnection> WEST = BlockStateEnum.of("west", BlockRedstoneWire.EnumRedstoneWireConnection.class);
     public static final BlockStateInteger POWER = BlockStateInteger.of("power", 0, 15);
     private boolean Q = true;
-    private final Set<BlockPosition> R = Sets.newHashSet();
+    //private final Set<BlockPosition> R = Sets.newHashSet();
+    private final Set<BlockPosition> R = new CopyOnWriteArraySet<BlockPosition>();
 
     public BlockRedstoneWire() {
         super(Material.ORIENTABLE);
@@ -65,7 +68,8 @@
 
     private IBlockData e(World world, BlockPosition blockposition, IBlockData iblockdata) {
         iblockdata = this.a(world, blockposition, blockposition, iblockdata);
-        ArrayList arraylist = Lists.newArrayList(this.R);
+        //ArrayList arraylist = Lists.newArrayList(this.R);
+        List arraylist = Lists.newCopyOnWriteArrayList(this.R);
 
         this.R.clear();
         Iterator iterator = arraylist.iterator();
diff -Naur src_origin/main/java/net/minecraft/server/ChatBaseComponent.java src_new/main/java/net/minecraft/server/ChatBaseComponent.java
--- src_origin/main/java/net/minecraft/server/ChatBaseComponent.java	2016-02-26 15:27:08.023203337 +0800
+++ src_new/main/java/net/minecraft/server/ChatBaseComponent.java	2016-02-29 09:37:08.556490963 +0800
@@ -5,10 +5,12 @@
 import com.google.common.collect.Lists;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 public abstract class ChatBaseComponent implements IChatBaseComponent {
 
-    protected List<IChatBaseComponent> a = Lists.newArrayList();
+    //protected List<IChatBaseComponent> a = Lists.newArrayList();
+    protected List<IChatBaseComponent> a = Lists.newCopyOnWriteArrayList();
     private ChatModifier b;
 
     public ChatBaseComponent() {}
diff -Naur src_origin/main/java/net/minecraft/server/Chunk.java src_new/main/java/net/minecraft/server/Chunk.java
--- src_origin/main/java/net/minecraft/server/Chunk.java	2016-02-26 15:27:08.084203343 +0800
+++ src_new/main/java/net/minecraft/server/Chunk.java	2016-02-29 09:37:08.609490968 +0800
@@ -15,7 +15,12 @@
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists; // CraftBukkit
+import java.util.Queue;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.FutureTask;
 import org.bukkit.Bukkit; // CraftBukkit
+import org.hose.ChunkGenPool;
+import org.spigotmc.SpigotWorldConfig;
 
 public class Chunk {
 
@@ -80,14 +85,16 @@
         this.tileEntities = Maps.newHashMap();
         this.v = 4096;
         this.w = Queues.newConcurrentLinkedQueue();
-        this.entitySlices = (List[]) (new List[16]); // Spigot
+        //this.entitySlices = (List[]) (new List[16]); // Spigot
+        this.entitySlices = (List[]) (new CopyOnWriteArrayList[16]); // Spigot
         this.world = world;
         this.locX = i;
         this.locZ = j;
         this.heightMap = new int[256];
 
         for (int k = 0; k < this.entitySlices.length; ++k) {
-            this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            //this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[k] = Lists.newCopyOnWriteArrayList(); // Spigot
         }
 
         Arrays.fill(this.f, -999);
@@ -831,7 +838,8 @@
             // Spigot Start
             if ( tileentity instanceof IInventory )
             {
-                for ( org.bukkit.entity.HumanEntity h : Lists.<org.bukkit.entity.HumanEntity>newArrayList((List<org.bukkit.entity.HumanEntity>) ( (IInventory) tileentity ).getViewers() ) )
+                //for ( org.bukkit.entity.HumanEntity h : Lists.<org.bukkit.entity.HumanEntity>newArrayList((List<org.bukkit.entity.HumanEntity>) ( (IInventory) tileentity ).getViewers() ) )
+                for ( org.bukkit.entity.HumanEntity h : Lists.<org.bukkit.entity.HumanEntity>newCopyOnWriteArrayList((List<org.bukkit.entity.HumanEntity>) ( (IInventory) tileentity ).getViewers() ) )
                 {
                     if ( h instanceof org.bukkit.craftbukkit.entity.CraftHumanEntity )
                     {
@@ -846,14 +854,16 @@
 
         for (int i = 0; i < this.entitySlices.length; ++i) {
             // CraftBukkit start
-            List<Entity> newList = Lists.newArrayList(this.entitySlices[i]);
+            //List<Entity> newList = Lists.newArrayList(this.entitySlices[i]);
+            Queue<Entity> newList = new ConcurrentLinkedQueue<Entity>(this.entitySlices[i]);
             java.util.Iterator<Entity> iter = newList.iterator();
             while (iter.hasNext()) {
                 Entity entity = iter.next();
                 // Spigot Start
                 if ( entity instanceof IInventory )
                 {
-                    for ( org.bukkit.entity.HumanEntity h : Lists.<org.bukkit.entity.HumanEntity>newArrayList( (List<org.bukkit.entity.HumanEntity>) ( (IInventory) entity ).getViewers() ) )
+                    //for ( org.bukkit.entity.HumanEntity h : Lists.<org.bukkit.entity.HumanEntity>newArrayList( (List<org.bukkit.entity.HumanEntity>) ( (IInventory) entity ).getViewers() ) )
+                    for ( org.bukkit.entity.HumanEntity h : Lists.<org.bukkit.entity.HumanEntity>newCopyOnWriteArrayList( (List<org.bukkit.entity.HumanEntity>) ( (IInventory) entity ).getViewers() ) )
                     {
                         if ( h instanceof org.bukkit.craftbukkit.entity.CraftHumanEntity )
                         {
@@ -956,7 +966,7 @@
     public boolean isEmpty() {
         return false;
     }
-
+    
     public void loadNearby(IChunkProvider ichunkprovider, IChunkProvider ichunkprovider1, int i, int j) {
         world.timings.syncChunkLoadPostTimer.startTiming(); // Spigot
         boolean flag = ichunkprovider.isChunkLoaded(i, j - 1);
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderGenerate.java src_new/main/java/net/minecraft/server/ChunkProviderGenerate.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderGenerate.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/net/minecraft/server/ChunkProviderGenerate.java	2016-02-29 09:37:08.646490971 +0800
@@ -0,0 +1,499 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.FutureTask;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.hose.GetChunkATPool;
+import org.hose.GetCreateChunkPool;
+import org.spigotmc.SpigotWorldConfig;
+
+public class ChunkProviderGenerate implements IChunkProvider {
+
+    private Random h;
+    private NoiseGeneratorOctaves i;
+    private NoiseGeneratorOctaves j;
+    private NoiseGeneratorOctaves k;
+    private NoiseGenerator3 l;
+    public NoiseGeneratorOctaves a;
+    public NoiseGeneratorOctaves b;
+    public NoiseGeneratorOctaves c;
+    private World m;
+    private final boolean n;
+    private WorldType o;
+    private final double[] p;
+    private final float[] q;
+    private CustomWorldSettingsFinal r;
+    private Block s;
+    private double[] t;
+    private WorldGenBase u;
+    private WorldGenStronghold v;
+    private WorldGenVillage w;
+    private WorldGenMineshaft x;
+    private WorldGenLargeFeature y;
+    private WorldGenBase z;
+    private WorldGenMonument A;
+    private BiomeBase[] B;
+    double[] d;
+    double[] e;
+    double[] f;
+    double[] g;
+
+    public ChunkProviderGenerate(World world, long i, boolean flag, String s) {
+        this.s = Blocks.WATER;
+        this.t = new double[256];
+        this.u = new WorldGenCaves();
+        this.v = new WorldGenStronghold();
+        this.w = new WorldGenVillage();
+        this.x = new WorldGenMineshaft();
+        this.y = new WorldGenLargeFeature();
+        this.z = new WorldGenCanyon();
+        this.A = new WorldGenMonument();
+        this.m = world;
+        this.n = flag;
+        this.o = world.getWorldData().getType();
+        this.h = new Random(i);
+        this.i = new NoiseGeneratorOctaves(this.h, 16);
+        this.j = new NoiseGeneratorOctaves(this.h, 16);
+        this.k = new NoiseGeneratorOctaves(this.h, 8);
+        this.l = new NoiseGenerator3(this.h, 4);
+        this.a = new NoiseGeneratorOctaves(this.h, 10);
+        this.b = new NoiseGeneratorOctaves(this.h, 16);
+        this.c = new NoiseGeneratorOctaves(this.h, 8);
+        this.p = new double[825];
+        this.q = new float[25];
+
+        for (int j = -2; j <= 2; ++j) {
+            for (int k = -2; k <= 2; ++k) {
+                float f = 10.0F / MathHelper.c((float) (j * j + k * k) + 0.2F);
+
+                this.q[j + 2 + (k + 2) * 5] = f;
+            }
+        }
+
+        if (s != null) {
+            this.r = CustomWorldSettingsFinal.CustomWorldSettings.a(s).b();
+            this.s = this.r.E ? Blocks.LAVA : Blocks.WATER;
+            world.b(this.r.q);
+        }
+
+    }
+
+    public void a(int i, int j, ChunkSnapshot chunksnapshot) {
+        this.B = this.m.getWorldChunkManager().getBiomes(this.B, i * 4 - 2, j * 4 - 2, 10, 10);
+        this.a(i * 4, 0, j * 4);
+
+        for (int k = 0; k < 4; ++k) {
+            int l = k * 5;
+            int i1 = (k + 1) * 5;
+
+            for (int j1 = 0; j1 < 4; ++j1) {
+                int k1 = (l + j1) * 33;
+                int l1 = (l + j1 + 1) * 33;
+                int i2 = (i1 + j1) * 33;
+                int j2 = (i1 + j1 + 1) * 33;
+
+                for (int k2 = 0; k2 < 32; ++k2) {
+                    double d0 = 0.125D;
+                    double d1 = this.p[k1 + k2];
+                    double d2 = this.p[l1 + k2];
+                    double d3 = this.p[i2 + k2];
+                    double d4 = this.p[j2 + k2];
+                    double d5 = (this.p[k1 + k2 + 1] - d1) * d0;
+                    double d6 = (this.p[l1 + k2 + 1] - d2) * d0;
+                    double d7 = (this.p[i2 + k2 + 1] - d3) * d0;
+                    double d8 = (this.p[j2 + k2 + 1] - d4) * d0;
+
+                    for (int l2 = 0; l2 < 8; ++l2) {
+                        double d9 = 0.25D;
+                        double d10 = d1;
+                        double d11 = d2;
+                        double d12 = (d3 - d1) * d9;
+                        double d13 = (d4 - d2) * d9;
+
+                        for (int i3 = 0; i3 < 4; ++i3) {
+                            double d14 = 0.25D;
+                            double d15 = (d11 - d10) * d14;
+                            double d16 = d10 - d15;
+
+                            for (int j3 = 0; j3 < 4; ++j3) {
+                                if ((d16 += d15) > 0.0D) {
+                                    chunksnapshot.a(k * 4 + i3, k2 * 8 + l2, j1 * 4 + j3, Blocks.STONE.getBlockData());
+                                } else if (k2 * 8 + l2 < this.r.q) {
+                                    chunksnapshot.a(k * 4 + i3, k2 * 8 + l2, j1 * 4 + j3, this.s.getBlockData());
+                                }
+                            }
+
+                            d10 += d12;
+                            d11 += d13;
+                        }
+
+                        d1 += d5;
+                        d2 += d6;
+                        d3 += d7;
+                        d4 += d8;
+                    }
+                }
+            }
+        }
+
+    }
+
+    public void a(int i, int j, ChunkSnapshot chunksnapshot, BiomeBase[] abiomebase) {
+        double d0 = 0.03125D;
+
+        this.t = this.l.a(this.t, (double) (i * 16), (double) (j * 16), 16, 16, d0 * 2.0D, d0 * 2.0D, 1.0D);
+
+        for (int k = 0; k < 16; ++k) {
+            for (int l = 0; l < 16; ++l) {
+                BiomeBase biomebase = abiomebase[l + k * 16];
+
+                biomebase.a(this.m, this.h, chunksnapshot, i * 16 + k, j * 16 + l, this.t[l + k * 16]);
+            }
+        }
+
+    }
+    
+    public Chunk getOrCreateChunk(int i, int j) {
+        //return getOrCreateChunk_hose(i, j);
+        SpigotWorldConfig.GetCreateChunkTask = new FutureTask(new GetCreateChunkPool(this, i, j));
+        SpigotWorldConfig.getcreatechunkatpool_executor.submit(SpigotWorldConfig.GetCreateChunkTask);
+        try {
+            return SpigotWorldConfig.GetCreateChunkTask.get();
+        } catch (InterruptedException ex) {
+            Logger.getLogger(ChunkProviderGenerate.class.getName()).log(Level.SEVERE, null, ex);
+        } catch (ExecutionException ex) {
+            Logger.getLogger(ChunkProviderGenerate.class.getName()).log(Level.SEVERE, null, ex);
+        }
+        return null;
+    }
+    
+    public Chunk getOrCreateChunk_hose(int i, int j) {
+        this.h.setSeed((long) i * 341873128712L + (long) j * 132897987541L);
+        ChunkSnapshot chunksnapshot = new ChunkSnapshot();
+
+        this.a(i, j, chunksnapshot);
+        this.B = this.m.getWorldChunkManager().getBiomeBlock(this.B, i * 16, j * 16, 16, 16);
+        this.a(i, j, chunksnapshot, this.B);
+        if (this.r.r) {
+            this.u.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.z) {
+            this.z.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.w && this.n) {
+            this.x.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.v && this.n) {
+            this.w.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.u && this.n) {
+            this.v.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.x && this.n) {
+            this.y.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.y && this.n) {
+            this.A.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        Chunk chunk = new Chunk(this.m, chunksnapshot, i, j);
+        byte[] abyte = chunk.getBiomeIndex();
+
+        for (int k = 0; k < abyte.length; ++k) {
+            abyte[k] = (byte) this.B[k].id;
+        }
+
+        chunk.initLighting();
+        return chunk;
+    }
+
+    private void a(int i, int j, int k) {
+        this.g = this.b.a(this.g, i, k, 5, 5, (double) this.r.e, (double) this.r.f, (double) this.r.g);
+        float f = this.r.a;
+        float f1 = this.r.b;
+
+        this.d = this.k.a(this.d, i, j, k, 5, 33, 5, (double) (f / this.r.h), (double) (f1 / this.r.i), (double) (f / this.r.j));
+        this.e = this.i.a(this.e, i, j, k, 5, 33, 5, (double) f, (double) f1, (double) f);
+        this.f = this.j.a(this.f, i, j, k, 5, 33, 5, (double) f, (double) f1, (double) f);
+        boolean flag = false;
+        boolean flag1 = false;
+        int l = 0;
+        int i1 = 0;
+
+        for (int j1 = 0; j1 < 5; ++j1) {
+            for (int k1 = 0; k1 < 5; ++k1) {
+                float f2 = 0.0F;
+                float f3 = 0.0F;
+                float f4 = 0.0F;
+                byte b0 = 2;
+                BiomeBase biomebase = this.B[j1 + 2 + (k1 + 2) * 10];
+
+                for (int l1 = -b0; l1 <= b0; ++l1) {
+                    for (int i2 = -b0; i2 <= b0; ++i2) {
+                        BiomeBase biomebase1 = this.B[j1 + l1 + 2 + (k1 + i2 + 2) * 10];
+                        float f5 = this.r.n + biomebase1.an * this.r.m;
+                        float f6 = this.r.p + biomebase1.ao * this.r.o;
+
+                        if (this.o == WorldType.AMPLIFIED && f5 > 0.0F) {
+                            f5 = 1.0F + f5 * 2.0F;
+                            f6 = 1.0F + f6 * 4.0F;
+                        }
+
+                        float f7 = this.q[l1 + 2 + (i2 + 2) * 5] / (f5 + 2.0F);
+
+                        if (biomebase1.an > biomebase.an) {
+                            f7 /= 2.0F;
+                        }
+
+                        f2 += f6 * f7;
+                        f3 += f5 * f7;
+                        f4 += f7;
+                    }
+                }
+
+                f2 /= f4;
+                f3 /= f4;
+                f2 = f2 * 0.9F + 0.1F;
+                f3 = (f3 * 4.0F - 1.0F) / 8.0F;
+                double d0 = this.g[i1] / 8000.0D;
+
+                if (d0 < 0.0D) {
+                    d0 = -d0 * 0.3D;
+                }
+
+                d0 = d0 * 3.0D - 2.0D;
+                if (d0 < 0.0D) {
+                    d0 /= 2.0D;
+                    if (d0 < -1.0D) {
+                        d0 = -1.0D;
+                    }
+
+                    d0 /= 1.4D;
+                    d0 /= 2.0D;
+                } else {
+                    if (d0 > 1.0D) {
+                        d0 = 1.0D;
+                    }
+
+                    d0 /= 8.0D;
+                }
+
+                ++i1;
+                double d1 = (double) f3;
+                double d2 = (double) f2;
+
+                d1 += d0 * 0.2D;
+                d1 = d1 * (double) this.r.k / 8.0D;
+                double d3 = (double) this.r.k + d1 * 4.0D;
+
+                for (int j2 = 0; j2 < 33; ++j2) {
+                    double d4 = ((double) j2 - d3) * (double) this.r.l * 128.0D / 256.0D / d2;
+
+                    if (d4 < 0.0D) {
+                        d4 *= 4.0D;
+                    }
+
+                    double d5 = this.e[l] / (double) this.r.d;
+                    double d6 = this.f[l] / (double) this.r.c;
+                    double d7 = (this.d[l] / 10.0D + 1.0D) / 2.0D;
+                    double d8 = MathHelper.b(d5, d6, d7) - d4;
+
+                    if (j2 > 29) {
+                        double d9 = (double) ((float) (j2 - 29) / 3.0F);
+
+                        d8 = d8 * (1.0D - d9) + -10.0D * d9;
+                    }
+
+                    this.p[l] = d8;
+                    ++l;
+                }
+            }
+        }
+
+    }
+
+    public boolean isChunkLoaded(int i, int j) {
+        return true;
+    }
+   
+    public void getChunkAt(IChunkProvider ichunkprovider, int i, int j) {
+        //getChunkAt_hose(ichunkprovider, i, j);
+        SpigotWorldConfig.GetChunkATTask = new FutureTask(new GetChunkATPool(this, ichunkprovider, i, j));
+        SpigotWorldConfig.getchunkatpool_executor.submit(SpigotWorldConfig.GetChunkATTask);
+    }
+    
+    public void getChunkAt_hose(IChunkProvider ichunkprovider, int i, int j) {
+        BlockFalling.instaFall = true;
+        int k = i * 16;
+        int l = j * 16;
+        BlockPosition blockposition = new BlockPosition(k, 0, l);
+        BiomeBase biomebase = this.m.getBiome(blockposition.a(16, 0, 16));
+
+        this.h.setSeed(this.m.getSeed());
+        long i1 = this.h.nextLong() / 2L * 2L + 1L;
+        long j1 = this.h.nextLong() / 2L * 2L + 1L;
+
+        this.h.setSeed((long) i * i1 + (long) j * j1 ^ this.m.getSeed());
+        boolean flag = false;
+        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
+
+        if (this.r.w && this.n) {
+            this.x.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        if (this.r.v && this.n) {
+            flag = this.w.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        if (this.r.u && this.n) {
+            this.v.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        if (this.r.x && this.n) {
+            this.y.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        if (this.r.y && this.n) {
+            this.A.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        int k1;
+        int l1;
+        int i2;
+
+        if (biomebase != BiomeBase.DESERT && biomebase != BiomeBase.DESERT_HILLS && this.r.A && !flag && this.h.nextInt(this.r.B) == 0) {
+            k1 = this.h.nextInt(16) + 8;
+            l1 = this.h.nextInt(256);
+            i2 = this.h.nextInt(16) + 8;
+            (new WorldGenLakes(Blocks.WATER)).generate(this.m, this.h, blockposition.a(k1, l1, i2));
+        }
+
+        if (!flag && this.h.nextInt(this.r.D / 10) == 0 && this.r.C) {
+            k1 = this.h.nextInt(16) + 8;
+            l1 = this.h.nextInt(this.h.nextInt(248) + 8);
+            i2 = this.h.nextInt(16) + 8;
+            if (l1 < this.m.F() || this.h.nextInt(this.r.D / 8) == 0) {
+                (new WorldGenLakes(Blocks.LAVA)).generate(this.m, this.h, blockposition.a(k1, l1, i2));
+            }
+        }
+
+        if (this.r.s) {
+            for (k1 = 0; k1 < this.r.t; ++k1) {
+                l1 = this.h.nextInt(16) + 8;
+                i2 = this.h.nextInt(256);
+                int j2 = this.h.nextInt(16) + 8;
+
+                (new WorldGenDungeons()).generate(this.m, this.h, blockposition.a(l1, i2, j2));
+            }
+        }
+
+        biomebase.a(this.m, this.h, new BlockPosition(k, 0, l));
+        SpawnerCreature.a(this.m, biomebase, k + 8, l + 8, 16, 16, this.h);
+        blockposition = blockposition.a(8, 0, 8);
+
+        for (k1 = 0; k1 < 16; ++k1) {
+            for (l1 = 0; l1 < 16; ++l1) {
+                BlockPosition blockposition1 = this.m.q(blockposition.a(k1, 0, l1));
+                BlockPosition blockposition2 = blockposition1.down();
+
+                if (this.m.v(blockposition2)) {
+                    this.m.setTypeAndData(blockposition2, Blocks.ICE.getBlockData(), 2);
+                }
+
+                if (this.m.f(blockposition1, true)) {
+                    this.m.setTypeAndData(blockposition1, Blocks.SNOW_LAYER.getBlockData(), 2);
+                }
+            }
+        }
+
+        BlockFalling.instaFall = false;
+    }
+
+    public boolean a(IChunkProvider ichunkprovider, Chunk chunk, int i, int j) {
+        boolean flag = false;
+
+        if (this.r.y && this.n && chunk.w() < 3600L) {
+            flag |= this.A.a(this.m, this.h, new ChunkCoordIntPair(i, j));
+        }
+
+        return flag;
+    }
+
+    public boolean saveChunks(boolean flag, IProgressUpdate iprogressupdate) {
+        return true;
+    }
+
+    public void c() {}
+
+    public boolean unloadChunks() {
+        return false;
+    }
+
+    public boolean canSave() {
+        return true;
+    }
+
+    public String getName() {
+        return "RandomLevelSource";
+    }
+
+    public List<BiomeBase.BiomeMeta> getMobsFor(EnumCreatureType enumcreaturetype, BlockPosition blockposition) {
+        BiomeBase biomebase = this.m.getBiome(blockposition);
+
+        if (this.n) {
+            if (enumcreaturetype == EnumCreatureType.MONSTER && this.y.a(blockposition)) {
+                return this.y.b();
+            }
+
+            if (enumcreaturetype == EnumCreatureType.MONSTER && this.r.y && this.A.a(this.m, blockposition)) {
+                return this.A.b();
+            }
+        }
+
+        return biomebase.getMobs(enumcreaturetype);
+    }
+
+    public BlockPosition findNearestMapFeature(World world, String s, BlockPosition blockposition) {
+        return "Stronghold".equals(s) && this.v != null ? this.v.getNearestGeneratedFeature(world, blockposition) : null;
+    }
+
+    public int getLoadedChunks() {
+        return 0;
+    }
+
+    public void recreateStructures(Chunk chunk, int i, int j) {
+        if (this.r.w && this.n) {
+            this.x.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+        if (this.r.v && this.n) {
+            this.w.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+        if (this.r.u && this.n) {
+            this.v.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+        if (this.r.x && this.n) {
+            this.y.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+        if (this.r.y && this.n) {
+            this.A.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+    }
+
+    public Chunk getChunkAt(BlockPosition blockposition) {
+        return this.getOrCreateChunk(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderServer.java src_new/main/java/net/minecraft/server/ChunkProviderServer.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderServer.java	2016-02-26 15:27:08.093203344 +0800
+++ src_new/main/java/net/minecraft/server/ChunkProviderServer.java	2016-02-29 09:37:08.654490972 +0800
@@ -1,19 +1,13 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Lists;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start
 import java.util.Random;
-import java.util.logging.Level;
 
 import org.bukkit.Server;
 import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
@@ -46,6 +40,7 @@
     }
 
     // CraftBukkit start - Change return type to Collection and return the values of our chunk map
+    //public java.util.Collection a() {
     public java.util.Collection a() {
         // return this.chunkList;
         return this.chunks.values();
@@ -81,9 +76,13 @@
         Iterator iterator = this.chunks.values().iterator();
 
         while (iterator.hasNext()) {
-            Chunk chunk = (Chunk) iterator.next();
+            try {
+                Chunk chunk = (Chunk) iterator.next();
 
-            this.queueUnload(chunk.locX, chunk.locZ);
+                this.queueUnload(chunk.locX, chunk.locZ);
+            } catch (Exception exception) {
+                ChunkProviderServer.b.error("Couldn\'t b() chunk", exception);
+            }
         }
 
     }
@@ -96,8 +95,8 @@
     public Chunk getChunkAt(int i, int j) {
         return getChunkAt(i, j, null);
     }
-
-    public Chunk getChunkAt(int i, int j, Runnable runnable) {
+    
+    synchronized public Chunk getChunkAt(int i, int j, Runnable runnable) {
         unloadQueue.remove(i, j);
         Chunk chunk = chunks.get(LongHash.toLong(i, j));
         ChunkRegionLoader loader = null;
@@ -152,9 +151,9 @@
                 }
                 newChunk = true; // CraftBukkit
             }
-
-            this.chunks.put(LongHash.toLong(i, j), chunk);
-            
+            synchronized (this.chunks){
+                this.chunks.put(LongHash.toLong(i, j), chunk);
+            }
             chunk.addEntities();
             
             // CraftBukkit start
@@ -312,20 +311,27 @@
         // CraftBukkit start
         Iterator iterator = this.chunks.values().iterator();
         while (iterator.hasNext()) {
-            Chunk chunk = (Chunk) iterator.next();
-            // CraftBukkit end
+            try {
+                Chunk chunk = (Chunk) iterator.next();
+                // CraftBukkit end
 
-            if (flag) {
-                this.saveChunkNOP(chunk);
-            }
+                if (flag) {
+                    this.saveChunkNOP(chunk);
+                }
 
-            if (chunk.a(flag)) {
-                this.saveChunk(chunk);
-                chunk.f(false);
-                ++i;
-                if (i == 24 && !flag && false) { // Spigot
-                    return false;
+                if (chunk.a(flag)) {
+                    this.saveChunk(chunk);
+                    chunk.f(false);
+                    ++i;
+                    if (i == 24 && !flag && false) { // Spigot
+                        return false;
+                    }
                 }
+            } catch (Exception exception) {
+                ChunkProviderServer.b.warn("Couldn\'t save chunk", exception);
+                //create a new chunk map
+                //this.chunks = new LongObjectHashMap<Chunk>();
+                break;
             }
         }
 
@@ -351,14 +357,14 @@
                 ChunkUnloadEvent event = new ChunkUnloadEvent(chunk.bukkitChunk);
                 server.getPluginManager().callEvent(event);
                 if (!event.isCancelled()) {
-
-                    if (chunk != null) {
-                        chunk.removeEntities();
-                        this.saveChunk(chunk);
-                        this.saveChunkNOP(chunk);
-                        this.chunks.remove(chunkcoordinates); // CraftBukkit
+                    synchronized (this.chunks){
+                        if (chunk != null) {
+                            chunk.removeEntities();
+                            this.saveChunk(chunk);
+                            this.saveChunkNOP(chunk);
+                            this.chunks.remove(chunkcoordinates); // CraftBukkit
+                        }
                     }
-
                     // this.unloadQueue.remove(olong);
 
                     // Update neighbor counts
diff -Naur src_origin/main/java/net/minecraft/server/CommandSpreadPlayers.java src_new/main/java/net/minecraft/server/CommandSpreadPlayers.java
--- src_origin/main/java/net/minecraft/server/CommandSpreadPlayers.java	2016-02-26 15:27:08.290203362 +0800
+++ src_new/main/java/net/minecraft/server/CommandSpreadPlayers.java	2016-02-29 09:37:08.826490988 +0800
@@ -39,7 +39,8 @@
             double d3 = a(astring[i++], 0.0D);
             double d4 = a(astring[i++], d3 + 1.0D);
             boolean flag = d(astring[i++]);
-            ArrayList arraylist = Lists.newArrayList();
+            //ArrayList arraylist = Lists.newArrayList();
+            List arraylist = Lists.newCopyOnWriteArrayList();
 
             while (i < astring.length) {
                 String s = astring[i++];
diff -Naur src_origin/main/java/net/minecraft/server/Container.java src_new/main/java/net/minecraft/server/Container.java
--- src_origin/main/java/net/minecraft/server/Container.java	2016-02-26 15:27:08.349203368 +0800
+++ src_new/main/java/net/minecraft/server/Container.java	2016-02-29 09:37:08.872490992 +0800
@@ -10,6 +10,8 @@
 // CraftBukkit start
 import java.util.HashMap;
 import java.util.Map;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.CopyOnWriteArraySet;
 import org.bukkit.craftbukkit.inventory.CraftInventory;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
 import org.bukkit.event.Event.Result;
@@ -22,12 +24,17 @@
 
     public List<ItemStack> b = Lists.newArrayList();
     public List<Slot> c = Lists.newArrayList();
+    /*public List<ItemStack> b = Lists.newCopyOnWriteArrayList();
+    public List<Slot> c = Lists.newCopyOnWriteArrayList();*/
     public int windowId;
     private int dragType = -1;
     private int g;
     private final Set<Slot> h = Sets.newHashSet();
+    //private final Set<Slot> h = new CopyOnWriteArraySet<Slot>();
     protected List<ICrafting> listeners = Lists.newArrayList();
+    //protected List<ICrafting> listeners =Lists.newCopyOnWriteArrayList();
     private Set<EntityHuman> i = Sets.newHashSet();
+    //private Set<EntityHuman> i = new CopyOnWriteArraySet<EntityHuman>();
     private int tickCount; // Spigot
 
     // CraftBukkit start
@@ -63,6 +70,7 @@
 
     public List<ItemStack> a() {
         ArrayList arraylist = Lists.newArrayList();
+        //List arraylist = Lists.newCopyOnWriteArrayList();
 
         for (int i = 0; i < this.c.size(); ++i) {
             arraylist.add(((Slot) this.c.get(i)).getItem());
diff -Naur src_origin/main/java/net/minecraft/server/CraftingManager.java src_new/main/java/net/minecraft/server/CraftingManager.java
--- src_origin/main/java/net/minecraft/server/CraftingManager.java	2016-02-26 15:27:08.668203398 +0800
+++ src_new/main/java/net/minecraft/server/CraftingManager.java	2016-02-29 09:37:09.149491018 +0800
@@ -14,6 +14,7 @@
 public class CraftingManager {
 
     private static final CraftingManager a = new CraftingManager();
+    //do not use "newCopyOnWriteArrayList"
     public List<IRecipe> recipes = Lists.newArrayList();
     // CraftBukkit start
     public IRecipe lastRecipe;
diff -Naur src_origin/main/java/net/minecraft/server/CrashReport.java src_new/main/java/net/minecraft/server/CrashReport.java
--- src_origin/main/java/net/minecraft/server/CrashReport.java	2016-02-26 15:27:08.705203401 +0800
+++ src_new/main/java/net/minecraft/server/CrashReport.java	2016-02-29 09:37:09.177491021 +0800
@@ -12,6 +12,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.Callable;
+import java.util.concurrent.CopyOnWriteArrayList;
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.lang3.ArrayUtils;
 import org.apache.logging.log4j.LogManager;
@@ -23,7 +24,8 @@
     private final String b;
     private final Throwable c;
     private final CrashReportSystemDetails d = new CrashReportSystemDetails(this, "System Details");
-    private final List<CrashReportSystemDetails> e = Lists.newArrayList();
+    //private final List<CrashReportSystemDetails> e = Lists.newArrayList();
+    private final List<CrashReportSystemDetails> e = Lists.newCopyOnWriteArrayList();
     private File f;
     private boolean g = true;
     private StackTraceElement[] h = new StackTraceElement[0];
diff -Naur src_origin/main/java/net/minecraft/server/DataWatcher.java src_new/main/java/net/minecraft/server/DataWatcher.java
--- src_origin/main/java/net/minecraft/server/DataWatcher.java	2016-02-26 15:27:08.716203402 +0800
+++ src_new/main/java/net/minecraft/server/DataWatcher.java	2016-02-29 09:37:09.193491022 +0800
@@ -140,7 +140,8 @@
     }
 
     public List<DataWatcher.WatchableObject> b() {
-        ArrayList arraylist = null;
+        //ArrayList arraylist = null;
+        List arraylist = null;
 
         if (this.e) {
             this.f.readLock().lock();
@@ -152,7 +153,8 @@
                 if (datawatcher_watchableobject.d()) {
                     datawatcher_watchableobject.a(false);
                     if (arraylist == null) {
-                        arraylist = Lists.newArrayList();
+                        //arraylist = Lists.newArrayList();
+                        arraylist = Lists.newCopyOnWriteArrayList();
                     }
 
                    // Spigot start - copy ItemStacks to prevent ConcurrentModificationExceptions
@@ -192,7 +194,8 @@
     }
 
     public List<DataWatcher.WatchableObject> c() {
-        ArrayList arraylist = Lists.newArrayList(); // Spigot
+        //ArrayList arraylist = Lists.newArrayList(); // Spigot
+        List arraylist = Lists.newCopyOnWriteArrayList(); // Spigot
 
         this.f.readLock().lock();
 
@@ -267,11 +270,13 @@
     }
 
     public static List<DataWatcher.WatchableObject> b(PacketDataSerializer packetdataserializer) throws IOException {
-        ArrayList arraylist = null;
+        //ArrayList arraylist = null;
+        List arraylist = null;
 
         for (byte b0 = packetdataserializer.readByte(); b0 != 127; b0 = packetdataserializer.readByte()) {
             if (arraylist == null) {
-                arraylist = Lists.newArrayList();
+                //arraylist = Lists.newArrayList();
+                arraylist = Lists.newCopyOnWriteArrayList();
             }
 
             int i = (b0 & 224) >> 5;
diff -Naur src_origin/main/java/net/minecraft/server/DedicatedServer.java src_new/main/java/net/minecraft/server/DedicatedServer.java
--- src_origin/main/java/net/minecraft/server/DedicatedServer.java	2016-02-26 15:27:08.757203406 +0800
+++ src_new/main/java/net/minecraft/server/DedicatedServer.java	2016-02-29 09:37:09.229491026 +0800
@@ -29,7 +29,8 @@
 public class DedicatedServer extends MinecraftServer implements IMinecraftServer {
 
     private static final Logger LOGGER = LogManager.getLogger();
-    private final List<ServerCommand> l = Collections.synchronizedList(Lists.<ServerCommand>newArrayList()); // CraftBukkit - fix decompile error
+    //private final List<ServerCommand> l = Collections.synchronizedList(Lists.<ServerCommand>newArrayList()); // CraftBukkit - fix decompile error
+    private final List<ServerCommand> l = Lists.newCopyOnWriteArrayList(); // CraftBukkit - fix decompile error
     private RemoteStatusListener m;
     private RemoteControlListener n;
     public PropertyManager propertyManager;
diff -Naur src_origin/main/java/net/minecraft/server/EntityFallingBlock.java src_new/main/java/net/minecraft/server/EntityFallingBlock.java
--- src_origin/main/java/net/minecraft/server/EntityFallingBlock.java	2016-02-26 15:27:09.384203465 +0800
+++ src_new/main/java/net/minecraft/server/EntityFallingBlock.java	2016-02-29 09:37:09.765491076 +0800
@@ -3,6 +3,8 @@
 import com.google.common.collect.Lists;
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
 
@@ -138,7 +140,8 @@
             int i = MathHelper.f(f - 1.0F);
 
             if (i > 0) {
-                ArrayList arraylist = Lists.newArrayList(this.world.getEntities(this, this.getBoundingBox()));
+                //ArrayList arraylist = Lists.newArrayList(this.world.getEntities(this, this.getBoundingBox()));
+                List arraylist = Lists.newCopyOnWriteArrayList(this.world.getEntities(this, this.getBoundingBox()));
                 boolean flag = block == Blocks.ANVIL;
                 DamageSource damagesource = flag ? DamageSource.ANVIL : DamageSource.FALLING_BLOCK;
                 Iterator iterator = arraylist.iterator();
diff -Naur src_origin/main/java/net/minecraft/server/EntityItem.java src_new/main/java/net/minecraft/server/EntityItem.java
--- src_origin/main/java/net/minecraft/server/EntityItem.java	2016-02-26 15:27:09.641203489 +0800
+++ src_new/main/java/net/minecraft/server/EntityItem.java	2016-02-29 09:37:09.994491097 +0800
@@ -81,10 +81,10 @@
                     this.motZ = (double) ((this.random.nextFloat() - this.random.nextFloat()) * 0.2F);
                     this.makeSound("random.fizz", 0.4F, 2.0F + this.random.nextFloat() * 0.4F);
                 }
-
-                if (!this.world.isClientSide) {
+                /*
+                if (!this.world.isClientSide && this.ak == false) {
                     this.w();
-                }
+                }*/
             }
 
             float f = 0.98F;
@@ -143,6 +143,7 @@
     }
     // Spigot end
 
+    //merge will cause dup through portal
     private void w() {
         // Spigot start
         double radius = world.spigotConfig.itemMerge;
@@ -375,9 +376,10 @@
 
     public void c(int i) {
         super.c(i);
-        if (!this.world.isClientSide) {
+        /*
+        if (!this.world.isClientSide && this.ak == false) {
             this.w();
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/Entity.java src_new/main/java/net/minecraft/server/Entity.java
--- src_origin/main/java/net/minecraft/server/Entity.java	2016-02-26 15:27:08.930203422 +0800
+++ src_new/main/java/net/minecraft/server/Entity.java	2016-02-29 09:37:09.392491041 +0800
@@ -263,12 +263,12 @@
             this.world.methodProfiler.a("portal");
             MinecraftServer minecraftserver = ((WorldServer) this.world).getMinecraftServer();
             int i = this.L();
-
             if (this.ak) {
                 if (true || minecraftserver.getAllowNether()) { // CraftBukkit
                     if (this.vehicle == null && this.al++ >= i) {
                         this.al = i;
                         this.portalCooldown = this.aq();
+
                         byte b0;
 
                         if (this.world.worldProvider.getDimension() == -1) {
@@ -291,9 +291,14 @@
                     this.al = 0;
                 }
             }
-
+            /*
             if (this.portalCooldown > 0) {
                 --this.portalCooldown;
+            }*/
+            if (this.portalCooldown > 0) {
+                --this.portalCooldown;
+            } else {
+                this.teleport_count = 0;
             }
 
             this.world.methodProfiler.b();
@@ -1891,7 +1896,8 @@
     }
 
     public void c(int i) {
-        if (!this.world.isClientSide && !this.dead) {
+        //fix dup
+        if (!this.world.isClientSide && !this.dead && this.teleport_count == 0) {
             this.world.methodProfiler.a("changeDimension");
             MinecraftServer minecraftserver = MinecraftServer.getServer();
             // CraftBukkit start - Move logic into new function "teleportToLocation"
@@ -1924,8 +1930,11 @@
         }
     }
 
+    int teleport_count = 0;
     public void teleportTo(Location exit, boolean portal) {
-        if (true) {
+        //if (true) {
+        if (true && teleport_count == 0) {
+            teleport_count = 1;
             WorldServer worldserver = ((CraftWorld) getBukkitEntity().getLocation().getWorld()).getHandle();
             WorldServer worldserver1 = ((CraftWorld) exit.getWorld()).getHandle();
             int i = worldserver1.dimension;
diff -Naur src_origin/main/java/net/minecraft/server/EntityLiving.java src_new/main/java/net/minecraft/server/EntityLiving.java
--- src_origin/main/java/net/minecraft/server/EntityLiving.java	2016-02-26 15:27:09.784203502 +0800
+++ src_new/main/java/net/minecraft/server/EntityLiving.java	2016-02-29 09:37:10.096491107 +0800
@@ -14,6 +14,7 @@
 import java.util.ArrayList;
 import com.google.common.base.Function;
 import com.google.common.collect.Lists;
+import java.util.concurrent.CopyOnWriteArrayList;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Vehicle;
@@ -461,7 +462,8 @@
 
     // CraftBukkit start
     private boolean isTickingEffects = false;
-    private List<Object> effectsToProcess = Lists.newArrayList();
+    //private List<Object> effectsToProcess = Lists.newArrayList();
+    private List<Object> effectsToProcess = Lists.newCopyOnWriteArrayList();
     // CraftBukkit end
 
     protected void bi() {
diff -Naur src_origin/main/java/net/minecraft/server/EntityMinecartAbstract.java src_new/main/java/net/minecraft/server/EntityMinecartAbstract.java
--- src_origin/main/java/net/minecraft/server/EntityMinecartAbstract.java	2016-02-26 15:27:09.793203503 +0800
+++ src_new/main/java/net/minecraft/server/EntityMinecartAbstract.java	2016-02-29 09:37:10.126491110 +0800
@@ -238,9 +238,14 @@
                     this.al = 0;
                 }
             }
-
+            /*
             if (this.portalCooldown > 0) {
                 --this.portalCooldown;
+            }*/
+            if (this.portalCooldown > 0) {
+                -- this.portalCooldown;
+            } else {
+                this.teleport_count = 0;
             }
 
             this.world.methodProfiler.b();
diff -Naur src_origin/main/java/net/minecraft/server/EntityPlayer.java src_new/main/java/net/minecraft/server/EntityPlayer.java
--- src_origin/main/java/net/minecraft/server/EntityPlayer.java	2016-02-26 15:27:09.996203522 +0800
+++ src_new/main/java/net/minecraft/server/EntityPlayer.java	2016-02-29 09:37:10.296491126 +0800
@@ -10,6 +10,7 @@
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -33,7 +34,10 @@
     public final PlayerInteractManager playerInteractManager;
     public double d;
     public double e;
-    public final List<ChunkCoordIntPair> chunkCoordIntPairQueue = Lists.newLinkedList();
+    //public final List<ChunkCoordIntPair> chunkCoordIntPairQueue = Lists.newLinkedList();
+    //casue negative array size
+    public final ConcurrentLinkedQueue<ChunkCoordIntPair> chunkCoordIntPairQueue = new ConcurrentLinkedQueue<ChunkCoordIntPair>();
+    //public final List<Integer> removeQueue = Lists.newLinkedList();
     public final List<Integer> removeQueue = Lists.newLinkedList();
     private final ServerStatisticManager bK;
     private float bL = Float.MIN_VALUE;
@@ -217,9 +221,11 @@
         }
 
         if (!this.chunkCoordIntPairQueue.isEmpty()) {
-            ArrayList arraylist = Lists.newArrayList();
+            //ArrayList arraylist = Lists.newArrayList();
+            List arraylist = Lists.newCopyOnWriteArrayList();
             Iterator iterator1 = this.chunkCoordIntPairQueue.iterator();
-            ArrayList arraylist1 = Lists.newArrayList();
+            //ArrayList arraylist1 = Lists.newArrayList();
+            List arraylist1 = Lists.newCopyOnWriteArrayList();
 
             Chunk chunk;
 
@@ -894,11 +900,16 @@
     }
 
     public void copyTo(EntityHuman entityhuman, boolean flag) {
-        super.copyTo(entityhuman, flag);
-        this.lastSentExp = -1;
-        this.bM = -1.0F;
-        this.bN = -1;
-        this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
+        try {
+            super.copyTo(entityhuman, flag);
+            this.lastSentExp = -1;
+            this.bM = -1.0F;
+            this.bN = -1;
+            this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
+        } catch (Exception ex){
+            
+        }
+        
     }
 
     protected void a(MobEffect mobeffect) {
diff -Naur src_origin/main/java/net/minecraft/server/EntitySlice.java src_new/main/java/net/minecraft/server/EntitySlice.java
--- src_origin/main/java/net/minecraft/server/EntitySlice.java	2016-02-26 15:27:10.178203539 +0800
+++ src_new/main/java/net/minecraft/server/EntitySlice.java	2016-02-29 09:37:10.439491139 +0800
@@ -9,14 +9,19 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 public class EntitySlice<T> extends AbstractSet<T> {
 
     private static final Set<Class<?>> a = Sets.newConcurrentHashSet(); // CraftBukkit
-    private final Map<Class<?>, List<T>> b = Maps.newHashMap();
+    //private final Map<Class<?>, List<T>> b = Maps.newHashMap();
+    private final ConcurrentMap<Class<?>, List<T>> b = Maps.newConcurrentMap();
+    
     private final Set<Class<?>> c = Sets.newIdentityHashSet();
     private final Class<T> d;
-    private final List<T> e = Lists.newArrayList();
+    //private final List<T> e = Lists.newArrayList();
+    private final List<T> e = Lists.newCopyOnWriteArrayList();
 
     public EntitySlice(Class<T> oclass) {
         this.d = oclass;
@@ -77,6 +82,7 @@
         List list = (List) this.b.get(oclass);
 
         if (list == null) {
+            //this.b.put(oclass, Lists.newArrayList(t0));
             this.b.put(oclass, Lists.newArrayList(t0));
         } else {
             list.add(t0);
diff -Naur src_origin/main/java/net/minecraft/server/EntityTrackerEntry.java src_new/main/java/net/minecraft/server/EntityTrackerEntry.java
--- src_origin/main/java/net/minecraft/server/EntityTrackerEntry.java	2016-02-26 15:27:10.392203559 +0800
+++ src_new/main/java/net/minecraft/server/EntityTrackerEntry.java	2016-02-29 09:37:10.648491158 +0800
@@ -5,6 +5,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -39,7 +40,8 @@
     private boolean x;
     private boolean y;
     public boolean n;
-    public Set<EntityPlayer> trackedPlayers = Sets.newHashSet();
+    //public Set<EntityPlayer> trackedPlayers = Sets.newHashSet();
+    public Set<EntityPlayer> trackedPlayers = new CopyOnWriteArraySet<EntityPlayer>();
 
     public EntityTrackerEntry(Entity entity, int i, int j, boolean flag) {
         this.tracker = entity;
@@ -424,9 +426,14 @@
     }
 
     public void scanPlayers(List<EntityHuman> list) {
+        Iterator it = list.iterator();
+        while(it.hasNext()){
+            this.updatePlayer((EntityPlayer) it.next());
+        }
+        /*
         for (int i = 0; i < list.size(); ++i) {
             this.updatePlayer((EntityPlayer) list.get(i));
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityTracker.java src_new/main/java/net/minecraft/server/EntityTracker.java
--- src_origin/main/java/net/minecraft/server/EntityTracker.java	2016-02-26 15:27:10.352203555 +0800
+++ src_new/main/java/net/minecraft/server/EntityTracker.java	2016-02-29 09:37:10.609491155 +0800
@@ -1,11 +1,14 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Set;
-import java.util.concurrent.Callable;
+import java.util.concurrent.BlockingDeque;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArraySet;
+import java.util.concurrent.LinkedBlockingDeque;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -13,10 +16,18 @@
 
     private static final Logger a = LogManager.getLogger();
     private final WorldServer world;
-    private Set<EntityTrackerEntry> c = Sets.newHashSet();
-    public IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    //private Set<EntityTrackerEntry> c = Sets.newHashSet();
+    private Set<EntityTrackerEntry> c = new CopyOnWriteArraySet<EntityTrackerEntry>();
+    //public IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    public ConcurrentHashMap<Integer, EntityTrackerEntry> trackedEntities = new ConcurrentHashMap();
     private int e;
 
+    //for spigot
+    private int g(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
+    
     public EntityTracker(WorldServer worldserver) {
         this.world = worldserver;
         this.e = worldserver.getMinecraftServer().getPlayerList().d();
@@ -100,17 +111,32 @@
             i = this.e;
         }
 
-        try {
-            if (this.trackedEntities.b(entity.getId())) {
-                throw new IllegalStateException("Entity is already tracked!");
-            }
+        
+            //just track once
+            //if (this.trackedEntities.b(entity.getId())) {
+            if (this.trackedEntities.containsKey(this.g(entity.getId()))) {
+                //throw new IllegalStateException("Entity is already tracked!");
+                //throw new Exception();
+            } else {
+                EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, j, flag);
 
+                this.c.add(entitytrackerentry);
+                //key point causing error
+                //this.trackedEntities.a(entity.getId(), entitytrackerentry);
+                this.trackedEntities.put(this.g(entity.getId()), entitytrackerentry);
+                
+                entitytrackerentry.scanPlayers(this.world.players);
+            }
+            
+            /*
             EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, j, flag);
 
             this.c.add(entitytrackerentry);
+            //key point causing error
             this.trackedEntities.a(entity.getId(), entitytrackerentry);
-            entitytrackerentry.scanPlayers(this.world.players);
-        } catch (Throwable throwable) {
+            entitytrackerentry.scanPlayers(this.world.players);*/
+        
+        /*} catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
             CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity To Track");
 
@@ -141,7 +167,7 @@
             } catch (ReportedException reportedexception) {
                 EntityTracker.a.error("\"Silently\" catching entity tracking error.", reportedexception);
             }
-        }
+        }*/
 
     }
 
@@ -158,7 +184,8 @@
             }
         }
 
-        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
+        //EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
+        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.get(this.g(entity.getId()));
 
         if (entitytrackerentry1 != null) {
             this.c.remove(entitytrackerentry1);
@@ -168,7 +195,8 @@
     }
 
     public void updatePlayers() {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         Iterator iterator = this.c.iterator();
 
         while (iterator.hasNext()) {
@@ -211,7 +239,8 @@
     }
 
     public void a(Entity entity, Packet packet) {
-        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        //EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(this.g(entity.getId()));
 
         if (entitytrackerentry != null) {
             entitytrackerentry.broadcast(packet);
@@ -220,7 +249,8 @@
     }
 
     public void sendPacketToEntity(Entity entity, Packet packet) {
-        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        //EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(this.g(entity.getId()));
 
         if (entitytrackerentry != null) {
             entitytrackerentry.broadcastIncludingSelf(packet);
diff -Naur src_origin/main/java/net/minecraft/server/Explosion.java src_new/main/java/net/minecraft/server/Explosion.java
--- src_origin/main/java/net/minecraft/server/Explosion.java	2016-02-26 15:27:10.556203574 +0800
+++ src_new/main/java/net/minecraft/server/Explosion.java	2016-02-29 09:37:10.798491172 +0800
@@ -8,6 +8,7 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.event.CraftEventFactory;
@@ -27,7 +28,8 @@
     private final double posZ;
     public final Entity source;
     private final float size;
-    private final List<BlockPosition> blocks = Lists.newArrayList();
+    //private final List<BlockPosition> blocks = Lists.newArrayList();
+    private final List<BlockPosition> blocks = Lists.newCopyOnWriteArrayList();
     private final Map<EntityHuman, Vec3D> k = Maps.newHashMap();
     public boolean wasCanceled = false; // CraftBukkit - add field
 
@@ -166,7 +168,8 @@
             org.bukkit.entity.Entity explode = this.source == null ? null : this.source.getBukkitEntity();
             Location location = new Location(bworld, this.posX, this.posY, this.posZ);
 
-            List<org.bukkit.block.Block> blockList = Lists.newArrayList();
+            //List<org.bukkit.block.Block> blockList = Lists.newArrayList();
+            List<org.bukkit.block.Block> blockList = Lists.newCopyOnWriteArrayList();
             for (int i1 = this.blocks.size() - 1; i1 >= 0; i1--) {
                 BlockPosition cpos = (BlockPosition) this.blocks.get(i1);
                 org.bukkit.block.Block bblock = bworld.getBlockAt(cpos.getX(), cpos.getY(), cpos.getZ());
diff -Naur src_origin/main/java/net/minecraft/server/IntCache.java src_new/main/java/net/minecraft/server/IntCache.java
--- src_origin/main/java/net/minecraft/server/IntCache.java	2016-02-26 15:27:10.750203593 +0800
+++ src_new/main/java/net/minecraft/server/IntCache.java	2016-02-29 09:37:10.959491188 +0800
@@ -2,14 +2,19 @@
 
 import com.google.common.collect.Lists;
 import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 public class IntCache {
 
     private static int a = 256;
-    private static List<int[]> b = Lists.newArrayList();
+    /*private static List<int[]> b = Lists.newArrayList();
     private static List<int[]> c = Lists.newArrayList();
     private static List<int[]> d = Lists.newArrayList();
-    private static List<int[]> e = Lists.newArrayList();
+    private static List<int[]> e = Lists.newArrayList();*/
+    private static List<int[]> b = Lists.newCopyOnWriteArrayList();
+    private static List<int[]> c = Lists.newCopyOnWriteArrayList();
+    private static List<int[]> d = Lists.newCopyOnWriteArrayList();
+    private static List<int[]> e = Lists.newCopyOnWriteArrayList();
 
     public static synchronized int[] a(int i) {
         int[] aint;
diff -Naur src_origin/main/java/net/minecraft/server/InventorySubcontainer.java src_new/main/java/net/minecraft/server/InventorySubcontainer.java
--- src_origin/main/java/net/minecraft/server/InventorySubcontainer.java	2016-02-26 15:27:10.927203609 +0800
+++ src_new/main/java/net/minecraft/server/InventorySubcontainer.java	2016-02-29 09:37:11.116491202 +0800
@@ -5,6 +5,7 @@
 
 // CraftBukkit start
 import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.entity.HumanEntity;
 // CraftBukkit end
@@ -61,7 +62,8 @@
 
     public void a(IInventoryListener iinventorylistener) {
         if (this.d == null) {
-            this.d = Lists.newArrayList();
+            //this.d = Lists.newArrayList();
+            this.d = Lists.newCopyOnWriteArrayList();
         }
 
         this.d.add(iinventorylistener);
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src_new/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2016-02-26 15:27:11.493203662 +0800
+++ src_new/main/java/net/minecraft/server/MinecraftServer.java	2016-02-29 09:37:11.630491250 +0800
@@ -40,12 +40,15 @@
 
 // CraftBukkit start
 import java.io.IOException;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 import jline.console.ConsoleReader;
 import joptsimple.OptionSet;
 
 import org.bukkit.craftbukkit.Main;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.hose.ChunkGenPool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class MinecraftServer implements Runnable, ICommandListener, IAsyncTaskHandler, IMojangStatistics {
@@ -56,7 +59,8 @@
     public Convertable convertable;
     private final MojangStatisticsGenerator n = new MojangStatisticsGenerator("server", this, az());
     public File universe;
-    private final List<IUpdatePlayerListBox> p = Lists.newArrayList();
+    //private final List<IUpdatePlayerListBox> p = Lists.newArrayList();
+    private final List<IUpdatePlayerListBox> p = Lists.newCopyOnWriteArrayList();
     protected final ICommandHandler b;
     public final MethodProfiler methodProfiler = new MethodProfiler();
     private ServerConnection q; // Spigot
@@ -366,7 +370,10 @@
                     }
 
                     ++i;
-                    worldserver.chunkProviderServer.getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    //chunk loader
+                    //worldserver.chunkProviderServer.getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    SpigotWorldConfig.ChunkGenTask = new FutureTask(new ChunkGenPool(worldserver, blockposition, k, l));
+                    SpigotWorldConfig.chunkgenpool_executor.submit(SpigotWorldConfig.ChunkGenTask);
                 }
             }
         }
@@ -642,7 +649,7 @@
     protected void A() throws ExceptionWorldConflict { // CraftBukkit - added throws
         SpigotTimings.serverTickTimer.startTiming(); // Spigot
         long i = System.nanoTime();
-
+        
         ++this.ticks;
         if (this.T) {
             this.T = false;
@@ -710,10 +717,15 @@
 
         // Spigot start
         FutureTask<?> entry;
-        int count = this.j.size();
+        /*int count = this.j.size();
         while (count-- > 0 && (entry = this.j.poll()) != null) {
             SystemUtils.a(entry, MinecraftServer.LOGGER);
-         }
+        }*/
+        //int count = this.j.size();
+        Iterator it = this.j.iterator();
+        while (it.hasNext() && (entry = this.j.poll()) != null) {
+            SystemUtils.a(entry, MinecraftServer.LOGGER);
+        }
         // Spigot end
 
         this.methodProfiler.c("levels");
@@ -1023,7 +1035,8 @@
     }
 
     public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        //return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "HOSE"; // HOSE -> Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1105,7 +1118,8 @@
     }
 
     public String getName() {
-        return "Server";
+        //return "Server";
+        return org.bukkit.ChatColor.GREEN+"Server";
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
diff -Naur src_origin/main/java/net/minecraft/server/MobSpawnerAbstract.java src_new/main/java/net/minecraft/server/MobSpawnerAbstract.java
--- src_origin/main/java/net/minecraft/server/MobSpawnerAbstract.java	2016-02-26 15:27:11.553203668 +0800
+++ src_new/main/java/net/minecraft/server/MobSpawnerAbstract.java	2016-02-29 09:37:11.674491254 +0800
@@ -3,6 +3,7 @@
 import com.google.common.collect.Lists;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.event.CraftEventFactory;
@@ -14,7 +15,8 @@
 
     public int spawnDelay = 20;
     private String mobName = "Pig";
-    private final List<MobSpawnerAbstract.a> mobs = Lists.newArrayList();
+    //private final List<MobSpawnerAbstract.a> mobs = Lists.newArrayList();
+    private final List<MobSpawnerAbstract.a> mobs = Lists.newCopyOnWriteArrayList();
     private MobSpawnerAbstract.a spawnData;
     private double e;
     private double f;
diff -Naur src_origin/main/java/net/minecraft/server/NBTTagList.java src_new/main/java/net/minecraft/server/NBTTagList.java
--- src_origin/main/java/net/minecraft/server/NBTTagList.java	2016-02-26 15:27:11.700203681 +0800
+++ src_new/main/java/net/minecraft/server/NBTTagList.java	2016-02-29 09:37:11.796491266 +0800
@@ -6,13 +6,15 @@
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class NBTTagList extends NBTBase {
 
     private static final Logger b = LogManager.getLogger();
-    private List<NBTBase> list = Lists.newArrayList();
+    //private List<NBTBase> list = Lists.newArrayList();
+    private List<NBTBase> list = Lists.newCopyOnWriteArrayList();
     private byte type = 0;
 
     public NBTTagList() {}
diff -Naur src_origin/main/java/net/minecraft/server/PacketPlayOutMapChunk.java src_new/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
--- src_origin/main/java/net/minecraft/server/PacketPlayOutMapChunk.java	2016-02-26 15:27:12.026203712 +0800
+++ src_new/main/java/net/minecraft/server/PacketPlayOutMapChunk.java	2016-02-29 09:37:12.080491292 +0800
@@ -4,6 +4,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.List;
 
 public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
 
@@ -55,7 +56,8 @@
     public static PacketPlayOutMapChunk.ChunkMap a(Chunk chunk, boolean flag, boolean flag1, int i) {
         ChunkSection[] achunksection = chunk.getSections();
         PacketPlayOutMapChunk.ChunkMap packetplayoutmapchunk_chunkmap = new PacketPlayOutMapChunk.ChunkMap();
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
 
         int j;
 
diff -Naur src_origin/main/java/net/minecraft/server/PersistentCollection.java src_new/main/java/net/minecraft/server/PersistentCollection.java
--- src_origin/main/java/net/minecraft/server/PersistentCollection.java	2016-02-26 15:27:12.587203764 +0800
+++ src_new/main/java/net/minecraft/server/PersistentCollection.java	2016-02-29 09:37:12.496491331 +0800
@@ -18,7 +18,8 @@
 
     private IDataManager b;
     protected Map<String, PersistentBase> a = Maps.newHashMap();
-    public List<PersistentBase> c = Lists.newArrayList(); // Spigot
+    //public List<PersistentBase> c = Lists.newArrayList(); // Spigot
+    public List<PersistentBase> c = Lists.newCopyOnWriteArrayList(); // Spigot
     private Map<String, Short> d = Maps.newHashMap();
 
     public PersistentCollection(IDataManager idatamanager) {
diff -Naur src_origin/main/java/net/minecraft/server/PlayerChunkMap.java src_new/main/java/net/minecraft/server/PlayerChunkMap.java
--- src_origin/main/java/net/minecraft/server/PlayerChunkMap.java	2016-02-26 15:27:12.591203765 +0800
+++ src_new/main/java/net/minecraft/server/PlayerChunkMap.java	2016-02-29 09:37:12.536491335 +0800
@@ -1,7 +1,6 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import org.apache.logging.log4j.LogManager;
@@ -19,7 +18,8 @@
 
     private static final Logger a = LogManager.getLogger();
     private final WorldServer world;
-    private final List<EntityPlayer> managedPlayers = Lists.newArrayList();
+    //private final List<EntityPlayer> managedPlayers = Lists.newArrayList();
+    private final List<EntityPlayer> managedPlayers = Lists.newCopyOnWriteArrayList();
     private final LongHashMap<PlayerChunkMap.PlayerChunk> d = new LongHashMap();
     private final Queue<PlayerChunkMap.PlayerChunk> e = new java.util.concurrent.ConcurrentLinkedQueue<PlayerChunkMap.PlayerChunk>(); // CraftBukkit ArrayList -> ConcurrentLinkedQueue
     private final Queue<PlayerChunkMap.PlayerChunk> f = new java.util.concurrent.ConcurrentLinkedQueue<PlayerChunkMap.PlayerChunk>(); // CraftBukkit ArrayList -> ConcurrentLinkedQueue
@@ -85,7 +85,8 @@
         return this.d.getEntry(k) != null;
     }
 
-    private PlayerChunkMap.PlayerChunk a(int i, int j, boolean flag) {
+    public PlayerChunkMap.PlayerChunk a(int i, int j, boolean flag) {
+    //private PlayerChunkMap.PlayerChunk a(int i, int j, boolean flag) {
         long k = (long) i + 2147483647L | (long) j + 2147483647L << 32;
         PlayerChunkMap.PlayerChunk playerchunkmap_playerchunk = (PlayerChunkMap.PlayerChunk) this.d.getEntry(k);
 
@@ -146,7 +147,8 @@
     }
 
     public void b(EntityPlayer entityplayer) {
-        ArrayList arraylist = Lists.newArrayList(entityplayer.chunkCoordIntPairQueue);
+        //ArrayList arraylist = Lists.newArrayList(entityplayer.chunkCoordIntPairQueue);
+        List arraylist = Lists.newCopyOnWriteArrayList(entityplayer.chunkCoordIntPairQueue);
         int i = 0;
         int j = this.g;
         int k = (int) entityplayer.locX >> 4;
@@ -178,7 +180,7 @@
         }
 
         i %= 4;
-
+        
         for (k1 = 0; k1 < j * 2; ++k1) {
             i1 += this.i[i][0];
             j1 += this.i[i][1];
@@ -256,9 +258,11 @@
                     this.a(pair.x, pair.z, true).a(entityplayer);
                 }
 
+                /*
                 if (j1 > 1 || j1 < -1 || k1 > 1 || k1 < -1) {
+                    //Collections.sort(entityplayer.chunkCoordIntPairQueue, new ChunkCoordComparator(entityplayer));
                     Collections.sort(entityplayer.chunkCoordIntPairQueue, new ChunkCoordComparator(entityplayer));
-                }
+                }*/
                 // CraftBukkit end
             }
         }
@@ -274,7 +278,8 @@
         i = MathHelper.clamp(i, 3, 32);
         if (i != this.g) {
             int j = i - this.g;
-            ArrayList arraylist = Lists.newArrayList(this.managedPlayers);
+            //ArrayList arraylist = Lists.newArrayList(this.managedPlayers);
+            List arraylist = Lists.newCopyOnWriteArrayList(this.managedPlayers);
             Iterator iterator = arraylist.iterator();
 
             while (iterator.hasNext()) {
@@ -313,10 +318,12 @@
         return i * 16 - 16;
     }
 
-    class PlayerChunk {
+    public class PlayerChunk {
 
-        private final List<EntityPlayer> b = Lists.newArrayList();
-        private final ChunkCoordIntPair location;
+        //private final List<EntityPlayer> b = Lists.newArrayList();
+        private final List<EntityPlayer> b = Lists.newCopyOnWriteArrayList();
+        //private final ChunkCoordIntPair location;
+        public final ChunkCoordIntPair location;
         private short[] dirtyBlocks = new short[64];
         private int dirtyCount;
         private int f;
diff -Naur src_origin/main/java/net/minecraft/server/PlayerList.java src_new/main/java/net/minecraft/server/PlayerList.java
--- src_origin/main/java/net/minecraft/server/PlayerList.java	2016-02-26 15:27:12.726203777 +0800
+++ src_new/main/java/net/minecraft/server/PlayerList.java	2016-02-29 09:37:12.646491345 +0800
@@ -48,7 +48,8 @@
     private static final Logger f = LogManager.getLogger();
     private static final SimpleDateFormat g = new SimpleDateFormat("yyyy-MM-dd \'at\' HH:mm:ss z");
     private final MinecraftServer server;
-    public final List<EntityPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
+    //public final List<EntityPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
+    public final List<EntityPlayer> players = Lists.newCopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
     private final Map<UUID, EntityPlayer> j = Maps.newHashMap();
     private final GameProfileBanList k;
     private final IpBanList l;
@@ -950,7 +951,8 @@
 
     public String b(boolean flag) {
         String s = "";
-        ArrayList arraylist = Lists.newArrayList(this.players);
+        //ArrayList arraylist = Lists.newArrayList(this.players);
+        List arraylist = Lists.newCopyOnWriteArrayList(this.players);
 
         for (int i = 0; i < arraylist.size(); ++i) {
             if (i > 0) {
@@ -1133,7 +1135,8 @@
     }
 
     public List<EntityPlayer> b(String s) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         Iterator iterator = this.players.iterator();
 
         while (iterator.hasNext()) {
diff -Naur src_origin/main/java/net/minecraft/server/PortalTravelAgent.java src_new/main/java/net/minecraft/server/PortalTravelAgent.java
--- src_origin/main/java/net/minecraft/server/PortalTravelAgent.java	2016-02-26 15:27:12.766203781 +0800
+++ src_new/main/java/net/minecraft/server/PortalTravelAgent.java	2016-02-29 09:37:12.651491346 +0800
@@ -1,9 +1,9 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Lists;
 import java.util.Iterator;
-import java.util.List;
+import java.util.Queue;
 import java.util.Random;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 // CraftBukkit start
 import org.bukkit.Location;
@@ -16,7 +16,8 @@
     private final WorldServer a;
     private final Random b;
     private final LongHashMap<PortalTravelAgent.ChunkCoordinatesPortal> c = new LongHashMap();
-    private final List<Long> d = Lists.newArrayList();
+    //private final List<Long> d = Lists.newArrayList();
+    private final Queue<Long> d = new ConcurrentLinkedQueue<Long>();
 
     public PortalTravelAgent(WorldServer worldserver) {
         this.a = worldserver;
diff -Naur src_origin/main/java/net/minecraft/server/ScoreboardServer.java src_new/main/java/net/minecraft/server/ScoreboardServer.java
--- src_origin/main/java/net/minecraft/server/ScoreboardServer.java	2016-02-26 15:27:13.079203810 +0800
+++ src_new/main/java/net/minecraft/server/ScoreboardServer.java	2016-02-29 09:37:12.912491370 +0800
@@ -7,11 +7,13 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
 
 public class ScoreboardServer extends Scoreboard {
 
     private final MinecraftServer a;
-    private final Set<ScoreboardObjective> b = Sets.newHashSet();
+    //private final Set<ScoreboardObjective> b = Sets.newHashSet();
+    private final Set<ScoreboardObjective> b = new CopyOnWriteArraySet<ScoreboardObjective>();
     private PersistentScoreboard c;
 
     public ScoreboardServer(MinecraftServer minecraftserver) {
diff -Naur src_origin/main/java/net/minecraft/server/ServerConnection.java src_new/main/java/net/minecraft/server/ServerConnection.java
--- src_origin/main/java/net/minecraft/server/ServerConnection.java	2016-02-26 15:27:13.131203815 +0800
+++ src_new/main/java/net/minecraft/server/ServerConnection.java	2016-02-29 09:37:12.956491374 +0800
@@ -23,7 +23,9 @@
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -59,8 +61,10 @@
     };
     private final MinecraftServer f;
     public volatile boolean d;
-    private final List<ChannelFuture> g = Collections.synchronizedList(Lists.<ChannelFuture>newArrayList());
-    private final List<NetworkManager> h = Collections.synchronizedList(Lists.<NetworkManager>newArrayList());
+    /*private final List<ChannelFuture> g = Collections.synchronizedList(Lists.<ChannelFuture>newArrayList());
+    private final List<NetworkManager> h = Collections.synchronizedList(Lists.<NetworkManager>newArrayList());*/
+    private final List<ChannelFuture> g = Lists.<ChannelFuture>newCopyOnWriteArrayList();
+    private final Queue<NetworkManager> h = new ConcurrentLinkedQueue<NetworkManager>();
 
     public ServerConnection(MinecraftServer minecraftserver) {
         this.f = minecraftserver;
@@ -120,14 +124,15 @@
     }
 
     public void c() {
-        List list = this.h;
+        //List list = this.h;
+        //Queue list = this.h;
 
         synchronized (this.h) {
             // Spigot Start
             // This prevents players from 'gaming' the server, and strategically relogging to increase their position in the tick order
             if ( org.spigotmc.SpigotConfig.playerShuffle > 0 && MinecraftServer.currentTick % org.spigotmc.SpigotConfig.playerShuffle == 0 )
             {
-                Collections.shuffle( this.h );
+                Collections.shuffle( (List)this.h );
             }
             // Spigot End
             Iterator iterator = this.h.iterator();
diff -Naur src_origin/main/java/net/minecraft/server/ServerStatisticManager.java src_new/main/java/net/minecraft/server/ServerStatisticManager.java
--- src_origin/main/java/net/minecraft/server/ServerStatisticManager.java	2016-02-26 15:27:13.135203816 +0800
+++ src_new/main/java/net/minecraft/server/ServerStatisticManager.java	2016-02-29 09:37:13.000491379 +0800
@@ -15,6 +15,7 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.Map.Entry;
+import java.util.concurrent.CopyOnWriteArraySet;
 import org.apache.commons.io.FileUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -24,7 +25,8 @@
     private static final Logger b = LogManager.getLogger();
     private final MinecraftServer c;
     private final File d;
-    private final Set<Statistic> e = Sets.newHashSet();
+    //private final Set<Statistic> e = Sets.newHashSet();
+    private final Set<Statistic> e = new CopyOnWriteArraySet<Statistic>();
     private int f = -300;
     private boolean g = false;
 
diff -Naur src_origin/main/java/net/minecraft/server/StructurePiece.java src_new/main/java/net/minecraft/server/StructurePiece.java
--- src_origin/main/java/net/minecraft/server/StructurePiece.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/net/minecraft/server/StructurePiece.java	2016-02-29 09:37:13.172491395 +0800
@@ -0,0 +1,646 @@
+package net.minecraft.server;
+
+import java.util.Iterator;
+import java.util.List;
+import java.util.Random;
+
+public abstract class StructurePiece {
+
+    protected StructureBoundingBox l;
+    protected EnumDirection m;
+    protected int n;
+
+    public StructurePiece() {}
+
+    protected StructurePiece(int i) {
+        this.n = i;
+    }
+
+    public NBTTagCompound b() {
+        NBTTagCompound nbttagcompound = new NBTTagCompound();
+
+        nbttagcompound.setString("id", WorldGenFactory.a(this));
+        nbttagcompound.set("BB", this.l.g());
+        nbttagcompound.setInt("O", this.m == null ? -1 : this.m.b());
+        nbttagcompound.setInt("GD", this.n);
+        this.a(nbttagcompound);
+        return nbttagcompound;
+    }
+
+    protected abstract void a(NBTTagCompound nbttagcompound);
+
+    public void a(World world, NBTTagCompound nbttagcompound) {
+        if (nbttagcompound.hasKey("BB")) {
+            this.l = new StructureBoundingBox(nbttagcompound.getIntArray("BB"));
+        }
+
+        int i = nbttagcompound.getInt("O");
+
+        this.m = i == -1 ? null : EnumDirection.fromType2(i);
+        this.n = nbttagcompound.getInt("GD");
+        this.b(nbttagcompound);
+    }
+
+    protected abstract void b(NBTTagCompound nbttagcompound);
+
+    public void a(StructurePiece structurepiece, List<StructurePiece> list, Random random) {}
+
+    public abstract boolean a(World world, Random random, StructureBoundingBox structureboundingbox);
+
+    public StructureBoundingBox c() {
+        return this.l;
+    }
+
+    public int d() {
+        return this.n;
+    }
+
+    public static StructurePiece a(List<StructurePiece> list, StructureBoundingBox structureboundingbox) {
+        Iterator iterator = list.iterator();
+
+        StructurePiece structurepiece;
+
+        do {
+            if (!iterator.hasNext()) {
+                return null;
+            }
+
+            structurepiece = (StructurePiece) iterator.next();
+        } while (structurepiece.c() == null || !structurepiece.c().a(structureboundingbox));
+
+        return structurepiece;
+    }
+
+    public BlockPosition a() {
+        return new BlockPosition(this.l.f());
+    }
+
+    protected boolean a(World world, StructureBoundingBox structureboundingbox) {
+        int i = Math.max(this.l.a - 1, structureboundingbox.a);
+        int j = Math.max(this.l.b - 1, structureboundingbox.b);
+        int k = Math.max(this.l.c - 1, structureboundingbox.c);
+        int l = Math.min(this.l.d + 1, structureboundingbox.d);
+        int i1 = Math.min(this.l.e + 1, structureboundingbox.e);
+        int j1 = Math.min(this.l.f + 1, structureboundingbox.f);
+        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
+
+        int k1;
+        int l1;
+
+        for (k1 = i; k1 <= l; ++k1) {
+            for (l1 = k; l1 <= j1; ++l1) {
+                if (world.getType(blockposition_mutableblockposition.c(k1, j, l1)).getBlock().getMaterial().isLiquid()) {
+                    return true;
+                }
+
+                if (world.getType(blockposition_mutableblockposition.c(k1, i1, l1)).getBlock().getMaterial().isLiquid()) {
+                    return true;
+                }
+            }
+        }
+
+        for (k1 = i; k1 <= l; ++k1) {
+            for (l1 = j; l1 <= i1; ++l1) {
+                if (world.getType(blockposition_mutableblockposition.c(k1, l1, k)).getBlock().getMaterial().isLiquid()) {
+                    return true;
+                }
+
+                if (world.getType(blockposition_mutableblockposition.c(k1, l1, j1)).getBlock().getMaterial().isLiquid()) {
+                    return true;
+                }
+            }
+        }
+
+        for (k1 = k; k1 <= j1; ++k1) {
+            for (l1 = j; l1 <= i1; ++l1) {
+                if (world.getType(blockposition_mutableblockposition.c(i, l1, k1)).getBlock().getMaterial().isLiquid()) {
+                    return true;
+                }
+
+                if (world.getType(blockposition_mutableblockposition.c(l, l1, k1)).getBlock().getMaterial().isLiquid()) {
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    protected int a(int i, int j) {
+        if (this.m == null) {
+            return i;
+        } else {
+            switch (StructurePiece.SyntheticClass_1.a[this.m.ordinal()]) {
+            case 1:
+            case 2:
+                return this.l.a + i;
+
+            case 3:
+                return this.l.d - j;
+
+            case 4:
+                return this.l.a + j;
+
+            default:
+                return i;
+            }
+        }
+    }
+
+    protected int d(int i) {
+        return this.m == null ? i : i + this.l.b;
+    }
+
+    protected int b(int i, int j) {
+        if (this.m == null) {
+            return j;
+        } else {
+            switch (StructurePiece.SyntheticClass_1.a[this.m.ordinal()]) {
+            case 1:
+                return this.l.f - j;
+
+            case 2:
+                return this.l.c + j;
+
+            case 3:
+            case 4:
+                return this.l.c + i;
+
+            default:
+                return j;
+            }
+        }
+    }
+
+    protected int a(Block block, int i) {
+        if (block == Blocks.RAIL) {
+            if (this.m == EnumDirection.WEST || this.m == EnumDirection.EAST) {
+                if (i == 1) {
+                    return 0;
+                }
+
+                return 1;
+            }
+        } else if (block instanceof BlockDoor) {
+            if (this.m == EnumDirection.SOUTH) {
+                if (i == 0) {
+                    return 2;
+                }
+
+                if (i == 2) {
+                    return 0;
+                }
+            } else {
+                if (this.m == EnumDirection.WEST) {
+                    return i + 1 & 3;
+                }
+
+                if (this.m == EnumDirection.EAST) {
+                    return i + 3 & 3;
+                }
+            }
+        } else if (block != Blocks.STONE_STAIRS && block != Blocks.OAK_STAIRS && block != Blocks.NETHER_BRICK_STAIRS && block != Blocks.STONE_BRICK_STAIRS && block != Blocks.SANDSTONE_STAIRS) {
+            if (block == Blocks.LADDER) {
+                if (this.m == EnumDirection.SOUTH) {
+                    if (i == EnumDirection.NORTH.a()) {
+                        return EnumDirection.SOUTH.a();
+                    }
+
+                    if (i == EnumDirection.SOUTH.a()) {
+                        return EnumDirection.NORTH.a();
+                    }
+                } else if (this.m == EnumDirection.WEST) {
+                    if (i == EnumDirection.NORTH.a()) {
+                        return EnumDirection.WEST.a();
+                    }
+
+                    if (i == EnumDirection.SOUTH.a()) {
+                        return EnumDirection.EAST.a();
+                    }
+
+                    if (i == EnumDirection.WEST.a()) {
+                        return EnumDirection.NORTH.a();
+                    }
+
+                    if (i == EnumDirection.EAST.a()) {
+                        return EnumDirection.SOUTH.a();
+                    }
+                } else if (this.m == EnumDirection.EAST) {
+                    if (i == EnumDirection.NORTH.a()) {
+                        return EnumDirection.EAST.a();
+                    }
+
+                    if (i == EnumDirection.SOUTH.a()) {
+                        return EnumDirection.WEST.a();
+                    }
+
+                    if (i == EnumDirection.WEST.a()) {
+                        return EnumDirection.NORTH.a();
+                    }
+
+                    if (i == EnumDirection.EAST.a()) {
+                        return EnumDirection.SOUTH.a();
+                    }
+                }
+            } else if (block == Blocks.STONE_BUTTON) {
+                if (this.m == EnumDirection.SOUTH) {
+                    if (i == 3) {
+                        return 4;
+                    }
+
+                    if (i == 4) {
+                        return 3;
+                    }
+                } else if (this.m == EnumDirection.WEST) {
+                    if (i == 3) {
+                        return 1;
+                    }
+
+                    if (i == 4) {
+                        return 2;
+                    }
+
+                    if (i == 2) {
+                        return 3;
+                    }
+
+                    if (i == 1) {
+                        return 4;
+                    }
+                } else if (this.m == EnumDirection.EAST) {
+                    if (i == 3) {
+                        return 2;
+                    }
+
+                    if (i == 4) {
+                        return 1;
+                    }
+
+                    if (i == 2) {
+                        return 3;
+                    }
+
+                    if (i == 1) {
+                        return 4;
+                    }
+                }
+            } else if (block != Blocks.TRIPWIRE_HOOK && !(block instanceof BlockDirectional)) {
+                if (block == Blocks.PISTON || block == Blocks.STICKY_PISTON || block == Blocks.LEVER || block == Blocks.DISPENSER) {
+                    if (this.m == EnumDirection.SOUTH) {
+                        if (i == EnumDirection.NORTH.a() || i == EnumDirection.SOUTH.a()) {
+                            return EnumDirection.fromType1(i).opposite().a();
+                        }
+                    } else if (this.m == EnumDirection.WEST) {
+                        if (i == EnumDirection.NORTH.a()) {
+                            return EnumDirection.WEST.a();
+                        }
+
+                        if (i == EnumDirection.SOUTH.a()) {
+                            return EnumDirection.EAST.a();
+                        }
+
+                        if (i == EnumDirection.WEST.a()) {
+                            return EnumDirection.NORTH.a();
+                        }
+
+                        if (i == EnumDirection.EAST.a()) {
+                            return EnumDirection.SOUTH.a();
+                        }
+                    } else if (this.m == EnumDirection.EAST) {
+                        if (i == EnumDirection.NORTH.a()) {
+                            return EnumDirection.EAST.a();
+                        }
+
+                        if (i == EnumDirection.SOUTH.a()) {
+                            return EnumDirection.WEST.a();
+                        }
+
+                        if (i == EnumDirection.WEST.a()) {
+                            return EnumDirection.NORTH.a();
+                        }
+
+                        if (i == EnumDirection.EAST.a()) {
+                            return EnumDirection.SOUTH.a();
+                        }
+                    }
+                }
+            } else {
+                EnumDirection enumdirection = EnumDirection.fromType2(i);
+
+                if (this.m == EnumDirection.SOUTH) {
+                    if (enumdirection == EnumDirection.SOUTH || enumdirection == EnumDirection.NORTH) {
+                        return enumdirection.opposite().b();
+                    }
+                } else if (this.m == EnumDirection.WEST) {
+                    if (enumdirection == EnumDirection.NORTH) {
+                        return EnumDirection.WEST.b();
+                    }
+
+                    if (enumdirection == EnumDirection.SOUTH) {
+                        return EnumDirection.EAST.b();
+                    }
+
+                    if (enumdirection == EnumDirection.WEST) {
+                        return EnumDirection.NORTH.b();
+                    }
+
+                    if (enumdirection == EnumDirection.EAST) {
+                        return EnumDirection.SOUTH.b();
+                    }
+                } else if (this.m == EnumDirection.EAST) {
+                    if (enumdirection == EnumDirection.NORTH) {
+                        return EnumDirection.EAST.b();
+                    }
+
+                    if (enumdirection == EnumDirection.SOUTH) {
+                        return EnumDirection.WEST.b();
+                    }
+
+                    if (enumdirection == EnumDirection.WEST) {
+                        return EnumDirection.NORTH.b();
+                    }
+
+                    if (enumdirection == EnumDirection.EAST) {
+                        return EnumDirection.SOUTH.b();
+                    }
+                }
+            }
+        } else if (this.m == EnumDirection.SOUTH) {
+            if (i == 2) {
+                return 3;
+            }
+
+            if (i == 3) {
+                return 2;
+            }
+        } else if (this.m == EnumDirection.WEST) {
+            if (i == 0) {
+                return 2;
+            }
+
+            if (i == 1) {
+                return 3;
+            }
+
+            if (i == 2) {
+                return 0;
+            }
+
+            if (i == 3) {
+                return 1;
+            }
+        } else if (this.m == EnumDirection.EAST) {
+            if (i == 0) {
+                return 2;
+            }
+
+            if (i == 1) {
+                return 3;
+            }
+
+            if (i == 2) {
+                return 1;
+            }
+
+            if (i == 3) {
+                return 0;
+            }
+        }
+
+        return i;
+    }
+
+    protected void a(World world, IBlockData iblockdata, int i, int j, int k, StructureBoundingBox structureboundingbox) {
+        BlockPosition blockposition = new BlockPosition(this.a(i, k), this.d(j), this.b(i, k));
+
+        if (structureboundingbox.b((BaseBlockPosition) blockposition)) {
+            world.setTypeAndData(blockposition, iblockdata, 2);
+        }
+    }
+
+    protected IBlockData a(World world, int i, int j, int k, StructureBoundingBox structureboundingbox) {
+        int l = this.a(i, k);
+        int i1 = this.d(j);
+        int j1 = this.b(i, k);
+        BlockPosition blockposition = new BlockPosition(l, i1, j1);
+
+        return !structureboundingbox.b((BaseBlockPosition) blockposition) ? Blocks.AIR.getBlockData() : world.getType(blockposition);
+    }
+
+    protected void a(World world, StructureBoundingBox structureboundingbox, int i, int j, int k, int l, int i1, int j1) {
+        for (int k1 = j; k1 <= i1; ++k1) {
+            for (int l1 = i; l1 <= l; ++l1) {
+                for (int i2 = k; i2 <= j1; ++i2) {
+                    this.a(world, Blocks.AIR.getBlockData(), l1, k1, i2, structureboundingbox);
+                }
+            }
+        }
+
+    }
+
+    protected void a(World world, StructureBoundingBox structureboundingbox, int i, int j, int k, int l, int i1, int j1, IBlockData iblockdata, IBlockData iblockdata1, boolean flag) {
+        for (int k1 = j; k1 <= i1; ++k1) {
+            for (int l1 = i; l1 <= l; ++l1) {
+                for (int i2 = k; i2 <= j1; ++i2) {
+                    if (!flag || this.a(world, l1, k1, i2, structureboundingbox).getBlock().getMaterial() != Material.AIR) {
+                        if (k1 != j && k1 != i1 && l1 != i && l1 != l && i2 != k && i2 != j1) {
+                            this.a(world, iblockdata1, l1, k1, i2, structureboundingbox);
+                        } else {
+                            this.a(world, iblockdata, l1, k1, i2, structureboundingbox);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    protected void a(World world, StructureBoundingBox structureboundingbox, int i, int j, int k, int l, int i1, int j1, boolean flag, Random random, StructurePiece.StructurePieceBlockSelector structurepiece_structurepieceblockselector) {
+        for (int k1 = j; k1 <= i1; ++k1) {
+            for (int l1 = i; l1 <= l; ++l1) {
+                for (int i2 = k; i2 <= j1; ++i2) {
+                    if (!flag || this.a(world, l1, k1, i2, structureboundingbox).getBlock().getMaterial() != Material.AIR) {
+                        structurepiece_structurepieceblockselector.a(random, l1, k1, i2, k1 == j || k1 == i1 || l1 == i || l1 == l || i2 == k || i2 == j1);
+                        this.a(world, structurepiece_structurepieceblockselector.a(), l1, k1, i2, structureboundingbox);
+                    }
+                }
+            }
+        }
+
+    }
+
+    protected void a(World world, StructureBoundingBox structureboundingbox, Random random, float f, int i, int j, int k, int l, int i1, int j1, IBlockData iblockdata, IBlockData iblockdata1, boolean flag) {
+        for (int k1 = j; k1 <= i1; ++k1) {
+            for (int l1 = i; l1 <= l; ++l1) {
+                for (int i2 = k; i2 <= j1; ++i2) {
+                    if (random.nextFloat() <= f && (!flag || this.a(world, l1, k1, i2, structureboundingbox).getBlock().getMaterial() != Material.AIR)) {
+                        if (k1 != j && k1 != i1 && l1 != i && l1 != l && i2 != k && i2 != j1) {
+                            this.a(world, iblockdata1, l1, k1, i2, structureboundingbox);
+                        } else {
+                            this.a(world, iblockdata, l1, k1, i2, structureboundingbox);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    protected void a(World world, StructureBoundingBox structureboundingbox, Random random, float f, int i, int j, int k, IBlockData iblockdata) {
+        if (random.nextFloat() < f) {
+            this.a(world, iblockdata, i, j, k, structureboundingbox);
+        }
+
+    }
+
+    protected void a(World world, StructureBoundingBox structureboundingbox, int i, int j, int k, int l, int i1, int j1, IBlockData iblockdata, boolean flag) {
+        float f = (float) (l - i + 1);
+        float f1 = (float) (i1 - j + 1);
+        float f2 = (float) (j1 - k + 1);
+        float f3 = (float) i + f / 2.0F;
+        float f4 = (float) k + f2 / 2.0F;
+
+        for (int k1 = j; k1 <= i1; ++k1) {
+            float f5 = (float) (k1 - j) / f1;
+
+            for (int l1 = i; l1 <= l; ++l1) {
+                float f6 = ((float) l1 - f3) / (f * 0.5F);
+
+                for (int i2 = k; i2 <= j1; ++i2) {
+                    float f7 = ((float) i2 - f4) / (f2 * 0.5F);
+
+                    if (!flag || this.a(world, l1, k1, i2, structureboundingbox).getBlock().getMaterial() != Material.AIR) {
+                        float f8 = f6 * f6 + f5 * f5 + f7 * f7;
+
+                        if (f8 <= 1.05F) {
+                            this.a(world, iblockdata, l1, k1, i2, structureboundingbox);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    protected void b(World world, int i, int j, int k, StructureBoundingBox structureboundingbox) {
+        BlockPosition blockposition = new BlockPosition(this.a(i, k), this.d(j), this.b(i, k));
+
+        if (structureboundingbox.b((BaseBlockPosition) blockposition)) {
+            while (!world.isEmpty(blockposition) && blockposition.getY() < 255) {
+                world.setTypeAndData(blockposition, Blocks.AIR.getBlockData(), 2);
+                blockposition = blockposition.up();
+            }
+
+        }
+    }
+
+    protected void b(World world, IBlockData iblockdata, int i, int j, int k, StructureBoundingBox structureboundingbox) {
+        int l = this.a(i, k);
+        int i1 = this.d(j);
+        int j1 = this.b(i, k);
+
+        if (structureboundingbox.b((BaseBlockPosition) (new BlockPosition(l, i1, j1)))) {
+            while ((world.isEmpty(new BlockPosition(l, i1, j1)) || world.getType(new BlockPosition(l, i1, j1)).getBlock().getMaterial().isLiquid()) && i1 > 1) {
+                world.setTypeAndData(new BlockPosition(l, i1, j1), iblockdata, 2);
+                --i1;
+            }
+
+        }
+    }
+
+    protected boolean a(World world, StructureBoundingBox structureboundingbox, Random random, int i, int j, int k, List<StructurePieceTreasure> list, int l) {
+        BlockPosition blockposition = new BlockPosition(this.a(i, k), this.d(j), this.b(i, k));
+
+        if (structureboundingbox.b((BaseBlockPosition) blockposition) && world.getType(blockposition).getBlock() != Blocks.CHEST) {
+            IBlockData iblockdata = Blocks.CHEST.getBlockData();
+
+            world.setTypeAndData(blockposition, Blocks.CHEST.f(world, blockposition, iblockdata), 2);
+            TileEntity tileentity = world.getTileEntity(blockposition);
+
+            if (tileentity instanceof TileEntityChest) {
+                StructurePieceTreasure.a(random, list, (IInventory) ((TileEntityChest) tileentity), l);
+            }
+
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    protected boolean a(World world, StructureBoundingBox structureboundingbox, Random random, int i, int j, int k, int l, List<StructurePieceTreasure> list, int i1) {
+        BlockPosition blockposition = new BlockPosition(this.a(i, k), this.d(j), this.b(i, k));
+
+        if (structureboundingbox.b((BaseBlockPosition) blockposition) && world.getType(blockposition).getBlock() != Blocks.DISPENSER) {
+            world.setTypeAndData(blockposition, Blocks.DISPENSER.fromLegacyData(this.a(Blocks.DISPENSER, l)), 2);
+            TileEntity tileentity = world.getTileEntity(blockposition);
+
+            if (tileentity instanceof TileEntityDispenser) {
+                StructurePieceTreasure.a(random, list, (TileEntityDispenser) tileentity, i1);
+            }
+
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    protected void a(World world, StructureBoundingBox structureboundingbox, Random random, int i, int j, int k, EnumDirection enumdirection) {
+        BlockPosition blockposition = new BlockPosition(this.a(i, k), this.d(j), this.b(i, k));
+
+        if (structureboundingbox.b((BaseBlockPosition) blockposition)) {
+            ItemDoor.a(world, blockposition, enumdirection.f(), Blocks.WOODEN_DOOR);
+        }
+
+    }
+
+    public void a(int i, int j, int k) {
+        this.l.a(i, j, k);
+    }
+
+    static class SyntheticClass_1 {
+
+        static final int[] a = new int[EnumDirection.values().length];
+
+        static {
+            try {
+                StructurePiece.SyntheticClass_1.a[EnumDirection.NORTH.ordinal()] = 1;
+            } catch (NoSuchFieldError nosuchfielderror) {
+                ;
+            }
+
+            try {
+                StructurePiece.SyntheticClass_1.a[EnumDirection.SOUTH.ordinal()] = 2;
+            } catch (NoSuchFieldError nosuchfielderror1) {
+                ;
+            }
+
+            try {
+                StructurePiece.SyntheticClass_1.a[EnumDirection.WEST.ordinal()] = 3;
+            } catch (NoSuchFieldError nosuchfielderror2) {
+                ;
+            }
+
+            try {
+                StructurePiece.SyntheticClass_1.a[EnumDirection.EAST.ordinal()] = 4;
+            } catch (NoSuchFieldError nosuchfielderror3) {
+                ;
+            }
+
+        }
+    }
+
+    public abstract static class StructurePieceBlockSelector {
+
+        protected IBlockData a;
+
+        protected StructurePieceBlockSelector() {
+            this.a = Blocks.AIR.getBlockData();
+        }
+
+        public abstract void a(Random random, int i, int j, int k, boolean flag);
+
+        public IBlockData a() {
+            return this.a;
+        }
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/TileEntityBeacon.java src_new/main/java/net/minecraft/server/TileEntityBeacon.java
--- src_origin/main/java/net/minecraft/server/TileEntityBeacon.java	2016-02-26 15:27:13.400203841 +0800
+++ src_new/main/java/net/minecraft/server/TileEntityBeacon.java	2016-02-29 09:37:13.240491401 +0800
@@ -13,7 +13,8 @@
 public class TileEntityBeacon extends TileEntityContainer implements IUpdatePlayerListBox, IInventory {
 
     public static final MobEffectList[][] a = new MobEffectList[][] { { MobEffectList.FASTER_MOVEMENT, MobEffectList.FASTER_DIG}, { MobEffectList.RESISTANCE, MobEffectList.JUMP}, { MobEffectList.INCREASE_DAMAGE}, { MobEffectList.REGENERATION}};
-    private final List<TileEntityBeacon.BeaconColorTracker> f = Lists.newArrayList();
+    //private final List<TileEntityBeacon.BeaconColorTracker> f = Lists.newArrayList();
+    private final List<TileEntityBeacon.BeaconColorTracker> f = Lists.newCopyOnWriteArrayList();
     private boolean i;
     private int j = -1;
     private int k;
diff -Naur src_origin/main/java/net/minecraft/server/TileEntityPiston.java src_new/main/java/net/minecraft/server/TileEntityPiston.java
--- src_origin/main/java/net/minecraft/server/TileEntityPiston.java	2016-02-26 15:27:13.607203860 +0800
+++ src_new/main/java/net/minecraft/server/TileEntityPiston.java	2016-02-29 09:37:13.416491417 +0800
@@ -12,7 +12,8 @@
     private boolean h;
     private float i;
     private float j;
-    private List<Entity> k = Lists.newArrayList();
+    //private List<Entity> k = Lists.newArrayList();
+    private List<Entity> k = Lists.newCopyOnWriteArrayList();
 
     public TileEntityPiston() {}
 
diff -Naur src_origin/main/java/net/minecraft/server/UserCache.java src_new/main/java/net/minecraft/server/UserCache.java
--- src_origin/main/java/net/minecraft/server/UserCache.java	2016-02-26 15:27:13.676203866 +0800
+++ src_new/main/java/net/minecraft/server/UserCache.java	2016-02-29 09:37:13.473491423 +0800
@@ -155,6 +155,7 @@
 
     public String[] a() {
         ArrayList arraylist = Lists.newArrayList(this.c.keySet());
+        //List arraylist = Lists.newCopyOnWriteArrayList(this.c.keySet());
 
         return (String[]) arraylist.toArray(new String[arraylist.size()]);
     }
diff -Naur src_origin/main/java/net/minecraft/server/WorldBorder.java src_new/main/java/net/minecraft/server/WorldBorder.java
--- src_origin/main/java/net/minecraft/server/WorldBorder.java	2016-02-26 15:27:13.784203876 +0800
+++ src_new/main/java/net/minecraft/server/WorldBorder.java	2016-02-29 09:37:13.580491433 +0800
@@ -6,7 +6,8 @@
 
 public class WorldBorder {
 
-    private final List<IWorldBorderListener> a = Lists.newArrayList();
+    //private final List<IWorldBorderListener> a = Lists.newArrayList();
+    private final List<IWorldBorderListener> a = Lists.newCopyOnWriteArrayList();
     private double b = 0.0D;
     private double c = 0.0D;
     private double d = 6.0E7D;
@@ -185,7 +186,8 @@
     }
 
     protected List<IWorldBorderListener> k() {
-        return Lists.newArrayList(this.a);
+        //return Lists.newArrayList(this.a);
+        return Lists.newCopyOnWriteArrayList(this.a);
     }
 
     public void a(IWorldBorderListener iworldborderlistener) {
diff -Naur src_origin/main/java/net/minecraft/server/WorldGenBase.java src_new/main/java/net/minecraft/server/WorldGenBase.java
--- src_origin/main/java/net/minecraft/server/WorldGenBase.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/net/minecraft/server/WorldGenBase.java	2016-02-29 09:37:13.623491437 +0800
@@ -0,0 +1,34 @@
+package net.minecraft.server;
+
+import java.util.Random;
+
+public class WorldGenBase {
+
+    protected int a = 8;
+    protected Random b = new Random();
+    protected World c;
+
+    public WorldGenBase() {}
+
+    public void a(IChunkProvider ichunkprovider, World world, int i, int j, ChunkSnapshot chunksnapshot) {
+        int k = this.a;
+
+        this.c = world;
+        this.b.setSeed(world.getSeed());
+        long l = this.b.nextLong();
+        long i1 = this.b.nextLong();
+
+        for (int j1 = i - k; j1 <= i + k; ++j1) {
+            for (int k1 = j - k; k1 <= j + k; ++k1) {
+                long l1 = (long) j1 * l;
+                long i2 = (long) k1 * i1;
+
+                this.b.setSeed(l1 ^ i2 ^ world.getSeed());
+                this.a(world, j1, k1, i, j, chunksnapshot);
+            }
+        }
+
+    }
+
+    protected void a(World world, int i, int j, int k, int l, ChunkSnapshot chunksnapshot) {}
+}
diff -Naur src_origin/main/java/net/minecraft/server/WorldGenLargeFeature.java src_new/main/java/net/minecraft/server/WorldGenLargeFeature.java
--- src_origin/main/java/net/minecraft/server/WorldGenLargeFeature.java	2016-02-26 15:27:13.882203886 +0800
+++ src_new/main/java/net/minecraft/server/WorldGenLargeFeature.java	2016-02-29 09:37:13.707491445 +0800
@@ -16,7 +16,8 @@
     private int h;
 
     public WorldGenLargeFeature() {
-        this.f = Lists.newArrayList();
+        //this.f = Lists.newArrayList();
+        this.f = Lists.newCopyOnWriteArrayList();
         this.g = 32;
         this.h = 8;
         this.f.add(new BiomeBase.BiomeMeta(EntityWitch.class, 1, 1, 1));
diff -Naur src_origin/main/java/net/minecraft/server/WorldGenVillagePieces.java src_new/main/java/net/minecraft/server/WorldGenVillagePieces.java
--- src_origin/main/java/net/minecraft/server/WorldGenVillagePieces.java	2016-02-26 15:27:14.039203900 +0800
+++ src_new/main/java/net/minecraft/server/WorldGenVillagePieces.java	2016-02-29 09:37:13.828491456 +0800
@@ -2,9 +2,13 @@
 
 import com.google.common.collect.Lists;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.Random;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 public class WorldGenVillagePieces {
 
@@ -25,8 +29,9 @@
     }
 
     public static List<WorldGenVillagePieces.WorldGenVillagePieceWeight> a(Random random, int i) {
-        ArrayList arraylist = Lists.newArrayList();
-
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Collections.synchronizedList(Lists.newArrayList());
+        
         arraylist.add(new WorldGenVillagePieces.WorldGenVillagePieceWeight(WorldGenVillagePieces.WorldGenVillageHouse.class, 4, MathHelper.nextInt(random, 2 + i, 4 + i * 2)));
         arraylist.add(new WorldGenVillagePieces.WorldGenVillagePieceWeight(WorldGenVillagePieces.WorldGenVillageTemple.class, 20, MathHelper.nextInt(random, 0 + i, 1 + i)));
         arraylist.add(new WorldGenVillagePieces.WorldGenVillagePieceWeight(WorldGenVillagePieces.WorldGenVillageLibrary.class, 20, MathHelper.nextInt(random, 0 + i, 2 + i)));
diff -Naur src_origin/main/java/net/minecraft/server/World.java src_new/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2016-02-26 15:27:13.782203876 +0800
+++ src_new/main/java/net/minecraft/server/World.java	2016-02-29 09:37:13.568491432 +0800
@@ -15,7 +15,18 @@
 
 // CraftBukkit start
 import com.google.common.collect.Maps;
+import java.util.Collections;
 import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.BlockingDeque;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.LinkedBlockingDeque;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
@@ -29,8 +40,10 @@
 import org.bukkit.event.block.BlockCanBuildEvent;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
-import org.bukkit.event.weather.WeatherChangeEvent;
-import org.bukkit.event.weather.ThunderChangeEvent;
+import org.hose.AddParticlePool;
+import org.hose.ChunkGenPool;
+import org.hose.t_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class World implements IBlockAccess {
@@ -38,38 +51,49 @@
     private int a = 63;
     protected boolean e;
     // Spigot start - guard entity list from removals
-    public final List<Entity> entityList = new java.util.ArrayList<Entity>()
+    //public final List<Entity> entityList = new java.util.ArrayList<Entity>()
+    //public final CopyOnWriteArrayList<Entity> entityList = new CopyOnWriteArrayList<Entity>()
+    public final List<Entity> entityPortalList = new CopyOnWriteArrayList<Entity>();
+    public final List<Entity> entityList = new CopyOnWriteArrayList<Entity>()
     {
         @Override
         public Entity remove(int index)
         {
-            guard();
+            //guard();
             return super.remove( index );
         }
 
         @Override
         public boolean remove(Object o)
         {
-            guard();
+            //guard();
             return super.remove( o );
         }
-
+        
+        /*
         private void guard()
         {
             if ( guardEntityList )
             {
                 throw new java.util.ConcurrentModificationException();
             }
-        }
+        }*/
     };
     // Spigot end
-    protected final List<Entity> g = Lists.newArrayList();
+    /*protected final List<Entity> g = Lists.newArrayList();
     public final List<TileEntity> h = Lists.newArrayList();
     public final List<TileEntity> tileEntityList = Lists.newArrayList();
     private final List<TileEntity> b = Lists.newArrayList();
     private final List<TileEntity> c = Lists.newArrayList();
     public final List<EntityHuman> players = Lists.newArrayList();
-    public final List<Entity> k = Lists.newArrayList();
+    public final List<Entity> k = Lists.newArrayList();*/
+    protected final List<Entity> g = Lists.newCopyOnWriteArrayList();
+    public final List<TileEntity> h = Lists.newCopyOnWriteArrayList();
+    public final List<TileEntity> tileEntityList = Lists.newCopyOnWriteArrayList();
+    private final Queue<TileEntity> b = new ConcurrentLinkedQueue<TileEntity>();
+    private final List<TileEntity> c = Lists.newCopyOnWriteArrayList();
+    public final List<EntityHuman> players = Lists.newCopyOnWriteArrayList();
+    public final List<Entity> k = Lists.newCopyOnWriteArrayList();
     protected final IntHashMap<Entity> entitiesById = new IntHashMap();
     private long d = 16777215L;
     private int I;
@@ -82,8 +106,10 @@
     private int J;
     public final Random random = new Random();
     public WorldProvider worldProvider; // CraftBukkit - remove final
-    protected List<IWorldAccess> u = Lists.newArrayList();
-    protected IChunkProvider chunkProvider;
+    //protected List<IWorldAccess> u = Lists.newArrayList();
+    protected List<IWorldAccess> u = Lists.newCopyOnWriteArrayList();
+    //protected IChunkProvider chunkProvider;
+    public IChunkProvider chunkProvider;
     protected final IDataManager dataManager;
     public WorldData worldData; // CraftBukkit - public
     protected boolean isLoading;
@@ -353,6 +379,7 @@
 
     public Chunk getChunkAt(int i, int j) {
         return this.chunkProvider.getOrCreateChunk(i, j);
+
     }
 
     public boolean setTypeAndData(BlockPosition blockposition, IBlockData iblockdata, int i) {
@@ -967,10 +994,13 @@
     }
 
     public void addParticle(EnumParticle enumparticle, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
-        this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        //this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        SpigotWorldConfig.AddParticleTask = new FutureTask(new AddParticlePool(this, enumparticle, d0, d1, d2, d3, d4, d5, aint));
+        SpigotWorldConfig.addparticlepool_executor.submit(SpigotWorldConfig.AddParticleTask);
     }
 
-    private void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
+    public void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
+    //private void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
         for (int j = 0; j < this.u.size(); ++j) {
             ((IWorldAccess) this.u.get(j)).a(i, flag, d0, d1, d2, d3, d4, d5, aint);
         }
@@ -1062,17 +1092,25 @@
     }
 
     protected void a(Entity entity) {
-        for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).a(entity);
+        Iterator it = this.u.iterator();
+        while (it.hasNext()){
+            ((IWorldAccess) it.next()).a(entity);
         }
+        /*for (int i = 0; i < this.u.size(); ++i) {
+            ((IWorldAccess) this.u.get(i)).a(entity);
+        }*/
 
         entity.valid = true; // CraftBukkit
     }
 
     protected void b(Entity entity) {
-        for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).b(entity);
+        Iterator it = this.u.iterator();
+        while (it.hasNext()){
+            ((IWorldAccess) it.next()).b(entity);
         }
+        /*for (int i = 0; i < this.u.size(); ++i) {
+            ((IWorldAccess) this.u.get(i)).b(entity);
+        }*/
 
         entity.valid = false; // CraftBukkit
     }
@@ -1146,7 +1184,8 @@
     }
 
     public List<AxisAlignedBB> getCubes(Entity entity, AxisAlignedBB axisalignedbb) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         int i = MathHelper.floor(axisalignedbb.a);
         int j = MathHelper.floor(axisalignedbb.d + 1.0D);
         int k = MathHelper.floor(axisalignedbb.b);
@@ -1253,7 +1292,8 @@
     }
 
     public List<AxisAlignedBB> a(AxisAlignedBB axisalignedbb) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         int i = MathHelper.floor(axisalignedbb.a);
         int j = MathHelper.floor(axisalignedbb.d + 1.0D);
         int k = MathHelper.floor(axisalignedbb.b);
@@ -1422,7 +1462,9 @@
             if (!entity.dead) {
                 try {
                     SpigotTimings.tickEntityTimer.startTiming(); // Spigot
-                    this.g(entity);
+                    //this.g(entity);
+                    SpigotWorldConfig.t_Task = new FutureTask(new t_Pool(this,entity));
+                    SpigotWorldConfig.t_pool_executor.submit(SpigotWorldConfig.t_Task);
                     SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
                 } catch (Throwable throwable1) {
                     crashreport = CrashReport.a(throwable1, "Ticking entity");
@@ -1524,8 +1566,9 @@
 
         this.methodProfiler.c("pendingBlockEntities");
         if (!this.b.isEmpty()) {
-            for (int l = 0; l < this.b.size(); ++l) {
-                TileEntity tileentity1 = (TileEntity) this.b.get(l);
+            Iterator it = this.b.iterator();
+            while (it.hasNext()){
+                TileEntity tileentity1 = (TileEntity) it.next();
 
                 if (!tileentity1.x()) {
                     /* CraftBukkit start - Order matters, moved down
@@ -1533,7 +1576,7 @@
                         this.a(tileentity1);
                     }
                     // CraftBukkit end */
-
+                    
                     if (this.isLoaded(tileentity1.getPosition())) {
                         this.getChunkAtWorldCoords(tileentity1.getPosition()).a(tileentity1.getPosition(), tileentity1);
                     }
@@ -1541,6 +1584,24 @@
                     this.notify(tileentity1.getPosition());
                 }
             }
+            /*
+            for (int l = 0; l < this.b.size(); ++l) {
+                TileEntity tileentity1 = (TileEntity) this.b.get(l);
+
+                if (!tileentity1.x()) {*/
+                    /* CraftBukkit start - Order matters, moved down
+                    if (!this.h.contains(tileentity1)) {
+                        this.a(tileentity1);
+                    }
+                    // CraftBukkit end */
+                    /*
+                    if (this.isLoaded(tileentity1.getPosition())) {
+                        this.getChunkAtWorldCoords(tileentity1.getPosition()).a(tileentity1.getPosition(), tileentity1);
+                    }
+
+                    this.notify(tileentity1.getPosition());
+                }
+            }*/
 
             this.b.clear();
         }
@@ -1580,6 +1641,8 @@
 
     public void g(Entity entity) {
         this.entityJoinedWorld(entity, true);
+        /*SpigotWorldConfig.TickTask = new FutureTask(new Tick_Pool(this,entity));
+        SpigotWorldConfig.tickpool_executor.submit(SpigotWorldConfig.TickTask);*/
     }
 
     public void entityJoinedWorld(Entity entity, boolean flag) {
@@ -1929,13 +1992,26 @@
             TileEntity tileentity1;
 
             if (this.M) {
+                Iterator it = this.b.iterator();
+                while (it.hasNext()){
+                    tileentity1 = (TileEntity) it.next();
+                    try {
+                        if (!tileentity1.x() && tileentity1.getPosition().equals(blockposition)) {
+                            tileentity = tileentity1;
+                            break;
+                        }
+                    } catch(Exception ex){
+                        System.out.println(ex+" this.b error");
+                    }
+                }
+                /*
                 for (i = 0; i < this.b.size(); ++i) {
                     tileentity1 = (TileEntity) this.b.get(i);
                     if (!tileentity1.x() && tileentity1.getPosition().equals(blockposition)) {
                         tileentity = tileentity1;
                         break;
                     }
-                }
+                }*/
             }
 
             if (tileentity == null) {
@@ -1943,13 +2019,22 @@
             }
 
             if (tileentity == null) {
+                Iterator it = this.b.iterator();
+                while (it.hasNext()){
+                    tileentity1 = (TileEntity) it.next();
+                    if (!tileentity1.x() && tileentity1.getPosition().equals(blockposition)) {
+                        tileentity = tileentity1;
+                        break;
+                    }
+                }
+                /*
                 for (i = 0; i < this.b.size(); ++i) {
                     tileentity1 = (TileEntity) this.b.get(i);
                     if (!tileentity1.x() && tileentity1.getPosition().equals(blockposition)) {
                         tileentity = tileentity1;
                         break;
                     }
-                }
+                }*/
             }
 
             return tileentity;
@@ -2504,7 +2589,8 @@
     }
 
     public List<Entity> a(Entity entity, AxisAlignedBB axisalignedbb, Predicate<? super Entity> predicate) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         int i = MathHelper.floor((axisalignedbb.a - 2.0D) / 16.0D);
         int j = MathHelper.floor((axisalignedbb.d + 2.0D) / 16.0D);
         int k = MathHelper.floor((axisalignedbb.c - 2.0D) / 16.0D);
@@ -2522,7 +2608,8 @@
     }
 
     public <T extends Entity> List<T> a(Class<? extends T> oclass, Predicate<? super T> predicate) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         Iterator iterator = this.entityList.iterator();
 
         while (iterator.hasNext()) {
@@ -2537,7 +2624,8 @@
     }
 
     public <T extends Entity> List<T> b(Class<? extends T> oclass, Predicate<? super T> predicate) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         Iterator iterator = this.players.iterator();
 
         while (iterator.hasNext()) {
@@ -2560,7 +2648,8 @@
         int j = MathHelper.floor((axisalignedbb.d + 2.0D) / 16.0D);
         int k = MathHelper.floor((axisalignedbb.c - 2.0D) / 16.0D);
         int l = MathHelper.floor((axisalignedbb.f + 2.0D) / 16.0D);
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
 
         for (int i1 = i; i1 <= j; ++i1) {
             for (int j1 = k; j1 <= l; ++j1) {
@@ -2607,25 +2696,26 @@
 
     public int a(Class<?> oclass) {
         int i = 0;
-        Iterator iterator = this.entityList.iterator();
+        synchronized (this.entityList) {
+            Iterator iterator = this.entityList.iterator();
 
-        while (iterator.hasNext()) {
-            Entity entity = (Entity) iterator.next();
-            // CraftBukkit start - Split out persistent check, don't apply it to special persistent mobs
-            if (entity instanceof EntityInsentient) {
-                EntityInsentient entityinsentient = (EntityInsentient) entity;
-                if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
-                    continue;
+            while (iterator.hasNext()) {
+                Entity entity = (Entity) iterator.next();
+                // CraftBukkit start - Split out persistent check, don't apply it to special persistent mobs
+                if (entity instanceof EntityInsentient) {
+                    EntityInsentient entityinsentient = (EntityInsentient) entity;
+                    if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
+                        continue;
+                    }
+                }
+
+                if (oclass.isAssignableFrom(entity.getClass())) {
+                // if ((!(entity instanceof EntityInsentient) || !((EntityInsentient) entity).isPersistent()) && oclass.isAssignableFrom(entity.getClass())) {
+                    // CraftBukkit end
+                    ++i;
                 }
-            }
-            
-            if (oclass.isAssignableFrom(entity.getClass())) {
-            // if ((!(entity instanceof EntityInsentient) || !((EntityInsentient) entity).isPersistent()) && oclass.isAssignableFrom(entity.getClass())) {
-                // CraftBukkit end
-                ++i;
             }
         }
-
         return i;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/WorldMap.java src_new/main/java/net/minecraft/server/WorldMap.java
--- src_origin/main/java/net/minecraft/server/WorldMap.java	2016-02-26 15:27:14.088203905 +0800
+++ src_new/main/java/net/minecraft/server/WorldMap.java	2016-02-29 09:37:13.877491461 +0800
@@ -6,9 +6,11 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
 
 // CraftBukkit start
 import java.util.UUID;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
@@ -22,7 +24,8 @@
     public byte map;
     public byte scale;
     public byte[] colors = new byte[16384];
-    public List<WorldMap.WorldMapHumanTracker> g = Lists.newArrayList();
+    //public List<WorldMap.WorldMapHumanTracker> g = Lists.newArrayList();
+    public Queue<WorldMap.WorldMapHumanTracker> g = new ConcurrentLinkedQueue<WorldMap.WorldMapHumanTracker>();
     public Map<EntityHuman, WorldMap.WorldMapHumanTracker> i = Maps.newHashMap(); // Spigot
     public Map<UUID, MapIcon> decorations = Maps.newLinkedHashMap(); // Spigot
 
@@ -148,6 +151,20 @@
             this.decorations.remove(entityhuman.getUniqueID()); // Spigot
         }
 
+        Iterator it = this.g.iterator();
+        while (it.hasNext()){
+            WorldMap.WorldMapHumanTracker worldmap_worldmaphumantracker1 = (WorldMap.WorldMapHumanTracker) it.next();
+
+            if (!worldmap_worldmaphumantracker1.trackee.dead && (worldmap_worldmaphumantracker1.trackee.inventory.c(itemstack) || itemstack.y())) {
+                if (!itemstack.y() && worldmap_worldmaphumantracker1.trackee.dimension == this.map) {
+                    this.a(0, worldmap_worldmaphumantracker1.trackee.world, worldmap_worldmaphumantracker1.trackee.getUniqueID(), worldmap_worldmaphumantracker1.trackee.locX, worldmap_worldmaphumantracker1.trackee.locZ, (double) worldmap_worldmaphumantracker1.trackee.yaw); // Spigot
+                }
+            } else {
+                this.i.remove(worldmap_worldmaphumantracker1.trackee);
+                this.g.remove(worldmap_worldmaphumantracker1);
+            }
+        }
+        /*
         for (int i = 0; i < this.g.size(); ++i) {
             WorldMap.WorldMapHumanTracker worldmap_worldmaphumantracker1 = (WorldMap.WorldMapHumanTracker) this.g.get(i);
 
@@ -159,7 +176,7 @@
                 this.i.remove(worldmap_worldmaphumantracker1.trackee);
                 this.g.remove(worldmap_worldmaphumantracker1);
             }
-        }
+        }*/
 
         if (itemstack.y()) {
             EntityItemFrame entityitemframe = itemstack.z();
diff -Naur src_origin/main/java/net/minecraft/server/WorldServer.java src_new/main/java/net/minecraft/server/WorldServer.java
--- src_origin/main/java/net/minecraft/server/WorldServer.java	2016-02-26 15:27:14.144203910 +0800
+++ src_new/main/java/net/minecraft/server/WorldServer.java	2016-02-29 09:37:13.930491466 +0800
@@ -3,26 +3,23 @@
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
-import java.util.Set;
-import java.util.TreeSet;
 import java.util.UUID;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start
 import java.util.*;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.logging.Level;
 
 import org.bukkit.WeatherType;
 import org.bukkit.block.BlockState;
-import org.bukkit.craftbukkit.util.LongHash;
 import org.bukkit.craftbukkit.util.HashTreeSet;
 
 import org.bukkit.event.block.BlockFormEvent;
@@ -48,8 +45,9 @@
     private WorldServer.BlockActionDataList[] S = new WorldServer.BlockActionDataList[] { new WorldServer.BlockActionDataList(null), new WorldServer.BlockActionDataList(null)};
     private int T;
     private static final List<StructurePieceTreasure> U = Lists.newArrayList(new StructurePieceTreasure[] { new StructurePieceTreasure(Items.STICK, 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.PLANKS), 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG), 0, 1, 3, 10), new StructurePieceTreasure(Items.STONE_AXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_AXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.STONE_PICKAXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_PICKAXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.APPLE, 0, 2, 3, 5), new StructurePieceTreasure(Items.BREAD, 0, 2, 3, 3), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG2), 0, 1, 3, 10)});
-    private List<NextTickListEntry> V = Lists.newArrayList();
-
+    //private List<NextTickListEntry> V = Lists.newArrayList();
+    private Queue<NextTickListEntry> V = new ConcurrentLinkedQueue<NextTickListEntry>();
+    
     // CraftBukkit start
     public final int dimension;
 
@@ -624,9 +622,9 @@
                 this.methodProfiler.a("cleaning");
 
                 NextTickListEntry nextticklistentry;
-
-                for (int j = 0; j < i; ++j) {
-                    nextticklistentry = (NextTickListEntry) this.M.first();
+                Iterator it = this.M.iterator();
+                while (it.hasNext()){
+                    nextticklistentry = (NextTickListEntry) it.next();
                     if (!flag && nextticklistentry.b > this.worldData.getTime()) {
                         break;
                     }
@@ -635,6 +633,23 @@
                     this.M.remove(nextticklistentry);
                     this.V.add(nextticklistentry);
                 }
+                /*
+                for (int j = 0; j < i; ++j) {
+                    try {
+                        nextticklistentry = (NextTickListEntry) this.M.first();
+                        if (!flag && nextticklistentry.b > this.worldData.getTime()) {
+                            break;
+                        }
+
+                        // CraftBukkit - use M, PAIL: Rename nextTickList
+                        this.M.remove(nextticklistentry);
+                        this.V.add(nextticklistentry);
+                    } catch (Exception ex){
+                        LogManager.getLogger().warn(this.M.size()+":"+ex);
+                        
+                        break;
+                    }
+                }*/
 
                 this.methodProfiler.b();
                 this.methodProfiler.a("ticking");
@@ -682,7 +697,8 @@
     }
 
     public List<NextTickListEntry> a(StructureBoundingBox structureboundingbox, boolean flag) {
-        ArrayList arraylist = null;
+        //ArrayList arraylist = null;
+        List arraylist = null;
 
         for (int i = 0; i < 2; ++i) {
             Iterator iterator;
@@ -704,7 +720,8 @@
                     }
 
                     if (arraylist == null) {
-                        arraylist = Lists.newArrayList();
+                        //arraylist = Lists.newArrayList();
+                        arraylist = Lists.newCopyOnWriteArrayList();
                     }
 
                     arraylist.add(nextticklistentry);
@@ -759,7 +776,8 @@
     }
 
     public List<TileEntity> getTileEntities(int i, int j, int k, int l, int i1, int j1) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
 
         // CraftBukkit start - Get tile entities from chunks instead of world
         for (int chunkX = (i >> 4); chunkX <= ((l - 1) >> 4); chunkX++) {
@@ -929,13 +947,16 @@
             // CraftBukkit - ArrayList -> Collection
             Collection arraylist = this.chunkProviderServer.a();
             Iterator iterator = arraylist.iterator();
+            try {
+                while (iterator.hasNext()) {
+                    Chunk chunk = (Chunk) iterator.next();
 
-            while (iterator.hasNext()) {
-                Chunk chunk = (Chunk) iterator.next();
-
-                if (chunk != null && !this.manager.a(chunk.locX, chunk.locZ)) {
-                    this.chunkProviderServer.queueUnload(chunk.locX, chunk.locZ);
+                    if (chunk != null && !this.manager.a(chunk.locX, chunk.locZ)) {
+                        this.chunkProviderServer.queueUnload(chunk.locX, chunk.locZ);
+                    }
                 }
+            } catch (Exception exception) {
+                LogManager.getLogger().error("Couldn\'t save chunk", exception);
             }
 
         }
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java src_new/main/java/org/bukkit/craftbukkit/CraftWorld.java
--- src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-02-26 15:27:14.770203969 +0800
+++ src_new/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-02-29 09:37:14.479491517 +0800
@@ -1371,7 +1371,15 @@
         }
 
         ChunkProviderServer cps = world.chunkProviderServer;
-        for (net.minecraft.server.Chunk chunk : cps.chunks.values()) {
+        Iterator it = cps.chunks.values().iterator();
+        net.minecraft.server.Chunk chunk;
+        while (it.hasNext()){
+            try {
+                //net.minecraft.server.Chunk chunk = (net.minecraft.server.Chunk) it.next();
+                chunk = (net.minecraft.server.Chunk) it.next();
+            } catch (Exception ex){
+                break;
+            }
             // If in use, skip it
             if (isChunkInUse(chunk.locX, chunk.locZ)) {
                 continue;
@@ -1385,6 +1393,21 @@
             // Add unload request
             cps.queueUnload(chunk.locX, chunk.locZ);
         }
+        /*
+        for (net.minecraft.server.Chunk chunk : cps.chunks.values()) {
+            // If in use, skip it
+            if (isChunkInUse(chunk.locX, chunk.locZ)) {
+                continue;
+            }
+
+            // Already unloading?
+            if (cps.unloadQueue.contains(chunk.locX, chunk.locZ)) {
+                continue;
+            }
+
+            // Add unload request
+            cps.queueUnload(chunk.locX, chunk.locZ);
+        }*/
     }
     // Spigot start
     private final Spigot spigot = new Spigot()
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java src_new/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
--- src_origin/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java	2016-02-26 15:27:20.478204503 +0800
+++ src_new/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java	2016-02-29 09:37:19.379491975 +0800
@@ -42,6 +42,7 @@
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import net.minecraft.server.NBTCompressedStreamTools;
@@ -226,7 +227,8 @@
     private int repairCost;
     private int hideFlag;
 
-    private static final Set<String> HANDLED_TAGS = Sets.newHashSet();
+    //private static final Set<String> HANDLED_TAGS = Sets.newHashSet();
+    private static final Set<String> HANDLED_TAGS = new CopyOnWriteArraySet<String>();
 
     private final Map<String, NBTBase> unhandledTags = new HashMap<String, NBTBase>();
 
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java src_new/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-02-26 15:27:22.350204678 +0800
+++ src_new/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-02-29 09:37:21.112492138 +0800
@@ -1,15 +1,19 @@
 package org.bukkit.craftbukkit.util;
 
+import com.google.common.collect.Sets;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.TreeSet;
+import java.util.concurrent.ConcurrentSkipListSet;
 
 public class HashTreeSet<V> implements Set<V> {
 
-    private HashSet<V> hash = new HashSet<V>();
-    private TreeSet<V> tree = new TreeSet<V>();
+    //private HashSet<V> hash = new HashSet<V>();
+    private Set<V> hash = Sets.newConcurrentHashSet();
+    //private TreeSet<V> tree = new TreeSet<V>();
+    private ConcurrentSkipListSet<V> tree = new ConcurrentSkipListSet<V>();
 
     public HashTreeSet() {
 
@@ -112,6 +116,6 @@
 
     public V first() {
         return tree.first();
-    }
+   }
 
 }
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java src_new/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java	2016-02-26 15:27:22.480204690 +0800
+++ src_new/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java	2016-02-29 09:37:21.209492147 +0800
@@ -14,6 +14,7 @@
 import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.Set;
+import java.util.concurrent.ConcurrentMap;
 
 @SuppressWarnings("unchecked")
 public class LongObjectHashMap<V> implements Cloneable, Serializable {
@@ -31,7 +32,7 @@
         initialize();
     }
 
-    public LongObjectHashMap(Map<? extends Long, ? extends V> map) {
+    public LongObjectHashMap(ConcurrentMap<? extends Long, ? extends V> map) {
         this();
         putAll(map);
     }
@@ -75,7 +76,7 @@
         return null;
     }
 
-    public V put(long key, V value) {
+    synchronized public V put(long key, V value) {
         int index = (int) (keyIndex(key) & (BUCKET_SIZE - 1));
         long[] innerKeys = keys[index];
         V[] innerValues = values[index];
@@ -121,13 +122,13 @@
         return null;
     }
 
-    public V remove(long key) {
+    synchronized public V remove(long key) {
         int index = (int) (keyIndex(key) & (BUCKET_SIZE - 1));
         long[] inner = keys[index];
         if (inner == null) {
             return null;
         }
-
+        
         for (int i = 0; i < inner.length; i++) {
             // hit the end of the chain, didn't find this entry
             if (inner[i] == EMPTY_KEY) {
@@ -157,13 +158,19 @@
         return null;
     }
 
-    public void putAll(Map<? extends Long, ? extends V> map) {
-        for (Map.Entry entry : map.entrySet()) {
+    //public void putAll(Map<? extends Long, ? extends V> map) {
+    public void putAll(ConcurrentMap<? extends Long, ? extends V> map) {
+        Iterator it = map.entrySet().iterator();
+        while (it.hasNext()){
+            ConcurrentMap.Entry entry = (ConcurrentMap.Entry) it.next();
             put((Long) entry.getKey(), (V) entry.getValue());
         }
+        /*for (ConcurrentMap.Entry entry : map.entrySet()) {
+            put((Long) entry.getKey(), (V) entry.getValue());
+        }*/
     }
 
-    public void clear() {
+    synchronized public void clear() {
         if (size == 0) {
             return;
         }
@@ -191,8 +198,8 @@
      * @deprecated
      */
     @Deprecated
-    public Set<Map.Entry<Long, V>> entrySet() {
-        HashSet<Map.Entry<Long, V>> set = new HashSet<Map.Entry<Long, V>>();
+    public Set<ConcurrentMap.Entry<Long, V>> entrySet() {
+        HashSet<ConcurrentMap.Entry<Long, V>> set = new HashSet<Map.Entry<Long, V>>();
         for (long key : keySet()) {
             set.add(new Entry(key, get(key)));
         }
@@ -277,7 +284,7 @@
             return count < LongObjectHashMap.this.size;
         }
 
-        public void remove() {
+        synchronized public void remove() {
             if (LongObjectHashMap.this.modCount != expectedModCount) {
                 throw new ConcurrentModificationException();
             }
diff -Naur src_origin/main/java/org/hose/AddParticlePool.java src_new/main/java/org/hose/AddParticlePool.java
--- src_origin/main/java/org/hose/AddParticlePool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/AddParticlePool.java	2016-02-29 09:37:05.947490719 +0800
@@ -0,0 +1,41 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.EnumParticle;
+import net.minecraft.server.World;
+/**
+ *
+ * @author softpak
+ */
+public class AddParticlePool implements Callable{
+    private World w;
+    private EnumParticle ep;
+    private int[] aint;
+    private double d0, d1, d2, d3, d4, d5;
+    
+    public AddParticlePool(World w, EnumParticle ep, double d0, double d1, double d2, double d3, double d4, double d5, int... aint){
+        this.w = w;
+        this.ep = ep;
+        this.aint = aint;
+        this.d0 = d0;
+        this.d1 = d1;
+        this.d2 = d2;
+        this.d3 = d3;
+        this.d4 = d4;
+        this.d5 = d5;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+        //this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        w.a(ep.c(), ep.e(), d0, d1, d2, d3, d4, d5, aint);
+        return null;
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/ChunkGenPool.java src_new/main/java/org/hose/ChunkGenPool.java
--- src_origin/main/java/org/hose/ChunkGenPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/ChunkGenPool.java	2016-02-29 09:37:05.947490719 +0800
@@ -0,0 +1,42 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkProviderGenerate;
+import net.minecraft.server.ChunkProviderServer;
+import net.minecraft.server.IChunkProvider;
+import net.minecraft.server.World;
+import net.minecraft.server.WorldServer;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkGenPool  implements Callable<Chunk>{
+    WorldServer worldserver;
+    BlockPosition blockposition;
+    
+    int k, l;
+    
+    public ChunkGenPool(WorldServer worldserver, BlockPosition blockposition, int k, int l) {
+        this.worldserver = worldserver;
+        this.blockposition = blockposition;
+        this.k = k;
+        this.l = l;
+    }
+
+    @Override
+    public Chunk call() throws Exception {
+        //worldserver.chunkProviderServer.getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+        return worldserver.chunkProviderServer.getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/GetChunkATPool.java src_new/main/java/org/hose/GetChunkATPool.java
--- src_origin/main/java/org/hose/GetChunkATPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/GetChunkATPool.java	2016-02-29 09:37:05.986490722 +0800
@@ -0,0 +1,35 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.ChunkProviderGenerate;
+import net.minecraft.server.IChunkProvider;
+/**
+ *
+ * @author softpak
+ */
+public class GetChunkATPool implements Callable{
+    ChunkProviderGenerate cpg;
+    IChunkProvider ichunkprovider;
+    int i, j;
+    
+    public GetChunkATPool(ChunkProviderGenerate cpg, IChunkProvider ichunkprovider, int i, int j) {
+        this.cpg = cpg;
+        this.ichunkprovider = ichunkprovider;
+        this.i = i;
+        this.j = j;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        cpg.getChunkAt_hose(ichunkprovider, i, j);
+        return null;
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/GetCreateChunkPool.java src_new/main/java/org/hose/GetCreateChunkPool.java
--- src_origin/main/java/org/hose/GetCreateChunkPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/GetCreateChunkPool.java	2016-02-29 09:37:05.991490723 +0800
@@ -0,0 +1,32 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkProviderGenerate;
+/**
+ *
+ * @author softpak
+ */
+public class GetCreateChunkPool implements Callable<Chunk>{
+    ChunkProviderGenerate cpg;
+    int i, j;
+    
+    public GetCreateChunkPool(ChunkProviderGenerate cpg, int i, int j) {
+        this.cpg = cpg;
+        this.i = i;
+        this.j = j;
+    }
+
+    @Override
+    public Chunk call() throws Exception {
+        return cpg.getOrCreateChunk_hose(i, j);
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/t_Pool.java src_new/main/java/org/hose/t_Pool.java
--- src_origin/main/java/org/hose/t_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/t_Pool.java	2016-02-29 09:37:06.027490726 +0800
@@ -0,0 +1,35 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Entity;
+import net.minecraft.server.World;
+
+/**
+ *
+ * @author softpak
+ */
+public class t_Pool  implements Callable{
+    private Entity e;
+    private World w;
+
+    public t_Pool(World w, Entity e) {
+        this.e = e;
+        this.w = w;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        //hoseentitytick(entity);
+        this.w.g(e);
+        //el.m();
+        return null;
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/spigotmc/ActivationRange.java src_new/main/java/org/spigotmc/ActivationRange.java
--- src_origin/main/java/org/spigotmc/ActivationRange.java	2016-02-26 15:27:05.386203091 +0800
+++ src_new/main/java/org/spigotmc/ActivationRange.java	2016-02-29 09:37:06.175490740 +0800
@@ -30,6 +30,7 @@
 import net.minecraft.server.MathHelper;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.World;
+import org.apache.commons.lang.ArrayUtils;
 import org.bukkit.craftbukkit.SpigotTimings;
 import org.bukkit.entity.Creeper;
 
@@ -145,37 +146,53 @@
     {
         for ( List<Entity> slice : chunk.entitySlices )
         {
-            for ( Entity entity : slice )
-            {
-                if ( MinecraftServer.currentTick > entity.activatedTick )
+            if (slice != null){
+                for ( Entity entity : slice )
                 {
-                    if ( entity.defaultActivationState )
-                    {
-                        entity.activatedTick = MinecraftServer.currentTick;
-                        continue;
-                    }
-                    switch ( entity.activationType )
-                    {
-                        case 1:
-                            if ( monsterBB.b( entity.getBoundingBox() ) )
+                    if (entity != null){
+                        if ( MinecraftServer.currentTick > entity.activatedTick )
+                        {
+                            if ( entity.defaultActivationState )
                             {
                                 entity.activatedTick = MinecraftServer.currentTick;
+                                continue;
                             }
-                            break;
-                        case 2:
-                            if ( animalBB.b( entity.getBoundingBox() ) )
+                            switch ( entity.activationType )
                             {
-                                entity.activatedTick = MinecraftServer.currentTick;
-                            }
-                            break;
-                        case 3:
-                        default:
-                            if ( miscBB.b( entity.getBoundingBox() ) )
-                            {
-                                entity.activatedTick = MinecraftServer.currentTick;
+                                case 1:
+                                    if ( monsterBB.b( entity.getBoundingBox() ) )
+                                    {
+                                        entity.activatedTick = MinecraftServer.currentTick;
+                                    }
+                                    break;
+                                case 2:
+                                    if ( animalBB.b( entity.getBoundingBox() ) )
+                                    {
+                                        entity.activatedTick = MinecraftServer.currentTick;
+                                    }
+                                    break;
+                                case 3:
+                                default:
+                                    if ( miscBB.b( entity.getBoundingBox() ) )
+                                    {
+                                        entity.activatedTick = MinecraftServer.currentTick;
+                                    }
                             }
+                        }
+                    } else {
+                        try {
+                            slice.remove(entity);
+                        } catch (Exception ex){
+
+                        }
                     }
                 }
+            } else {
+                try {
+                    ArrayUtils.removeElement(chunk.entitySlices, slice);
+                } catch (Exception ex){
+
+                }
             }
         }
     }
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src_new/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2016-02-26 15:27:05.429203095 +0800
+++ src_new/main/java/org/spigotmc/AsyncCatcher.java	2016-02-29 09:37:06.215490744 +0800
@@ -5,7 +5,7 @@
 public class AsyncCatcher
 {
 
-    public static boolean enabled = true;
+    public static boolean enabled = false;
 
     public static void catchOp(String reason)
     {
diff -Naur src_origin/main/java/org/spigotmc/SpigotWorldConfig.java src_new/main/java/org/spigotmc/SpigotWorldConfig.java
--- src_origin/main/java/org/spigotmc/SpigotWorldConfig.java	2016-02-26 15:27:05.636203114 +0800
+++ src_new/main/java/org/spigotmc/SpigotWorldConfig.java	2016-02-29 09:37:06.382490759 +0800
@@ -1,13 +1,61 @@
 package org.spigotmc;
 
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import java.util.Arrays;
 import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.ThreadFactory;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkCoordIntPair;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
 public class SpigotWorldConfig
 {
+    static public final int cpu_core = Runtime.getRuntime().availableProcessors();
+    
+    static public FutureTask TickTask;
+    static public FutureTask AddParticleTask;
+    static public FutureTask t_Task;
+    static public FutureTask<Chunk> ChunkGenTask;
+    static public FutureTask GetChunkATTask;
+    static public FutureTask<Chunk> GetCreateChunkTask;
+    
+    static final ThreadFactory tfgccp = new ThreadFactoryBuilder().setNameFormat("GetCreateChunkPool-%d").build();
+    static public final ExecutorService getcreatechunkatpool_executor = Executors.newFixedThreadPool(cpu_core*10, tfgccp);
+            
+    static final ThreadFactory tfgcap = new ThreadFactoryBuilder().setNameFormat("GetChunkATPool-%d").build();
+    static public final ExecutorService getchunkatpool_executor = Executors.newFixedThreadPool(cpu_core*10, tfgcap);
+    
+    static final ThreadFactory tfcgp = new ThreadFactoryBuilder().setNameFormat("ChunkGenPool-%d").build();
+    static public final ExecutorService chunkgenpool_executor = Executors.newFixedThreadPool(cpu_core*10, tfcgp);
+    
+    static final ThreadFactory tfapp = new ThreadFactoryBuilder().setNameFormat("AddParticlePool-%d").build();
+    static public final ExecutorService addparticlepool_executor = Executors.newFixedThreadPool(cpu_core, tfapp);
+    
+     static final ThreadFactory tftp = new ThreadFactoryBuilder().setNameFormat("Tick_Pool-%d").build();
+    static public ExecutorService tickpool_executor;
+    
+    static final ThreadFactory tftpp = new ThreadFactoryBuilder().setNameFormat("t_Pool-%d").build();
+    static public ExecutorService t_pool_executor;
 
+    public static int worldtickentitypool_core_multiple;
+    
+    public static int getthreadnumber(){
+        return cpu_core*worldtickentitypool_core_multiple;
+    }
+    private void wetp_core_multiple()
+    {
+        worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 1);
+        tickpool_executor = Executors.newFixedThreadPool(getthreadnumber(), tftp);
+        t_pool_executor = Executors.newFixedThreadPool(getthreadnumber(), tftpp);
+        log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
+    }
+    
+    
+    
     private final String worldName;
     private final YamlConfiguration config;
     private boolean verbose;
