diff -Naur src_origin/main/java/net/minecraft/server/BlockCactus.java src/main/java/net/minecraft/server/BlockCactus.java
--- src_origin/main/java/net/minecraft/server/BlockCactus.java	2016-05-29 15:00:13.729641642 +0800
+++ src/main/java/net/minecraft/server/BlockCactus.java	2016-05-29 23:32:54.260822421 +0800
@@ -89,7 +89,8 @@
         return false;
     }
 
-    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, Entity entity) {
+    //public void a(World world, BlockPosition blockposition, IBlockData iblockdata, Entity entity) {
+    public synchronized void a(World world, BlockPosition blockposition, IBlockData iblockdata, Entity entity) {
         CraftEventFactory.blockDamage = world.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()); // CraftBukkit
         entity.damageEntity(DamageSource.CACTUS, 1.0F);
         CraftEventFactory.blockDamage = null; // CraftBukkit
diff -Naur src_origin/main/java/net/minecraft/server/Chunk.java src/main/java/net/minecraft/server/Chunk.java
--- src_origin/main/java/net/minecraft/server/Chunk.java	2016-05-29 15:00:14.024641615 +0800
+++ src/main/java/net/minecraft/server/Chunk.java	2016-05-29 23:32:54.720822379 +0800
@@ -15,7 +15,10 @@
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists; // CraftBukkit
+import java.util.Queue;
 import org.bukkit.Bukkit; // CraftBukkit
+import org.hose.ChunkPopulate_Pool;
+import org.spigotmc.SpigotWorldConfig;
 
 public class Chunk {
 
@@ -32,7 +35,8 @@
     public final int locZ;
     private boolean m;
     public final Map<BlockPosition, TileEntity> tileEntities;
-    public final List<Entity>[] entitySlices; // Spigot
+    //public final List<Entity>[] entitySlices; // Spigot
+    public final Queue<Entity>[] entitySlices; // Spigot
     private boolean done;
     private boolean lit;
     private boolean r;
@@ -82,14 +86,16 @@
         this.tileEntities = Maps.newHashMap();
         this.x = 4096;
         this.y = Queues.newConcurrentLinkedQueue();
-        this.entitySlices = (List[]) (new List[16]); // Spigot
+        //this.entitySlices = (List[]) (new List[16]); // Spigot
+        this.entitySlices = (Queue[]) (new ConcurrentLinkedQueue[16]); // Spigot
         this.world = world;
         this.locX = i;
         this.locZ = j;
         this.heightMap = new int[256];
 
         for (int k = 0; k < this.entitySlices.length; ++k) {
-            this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            //this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[k] = new ConcurrentLinkedQueue(); // Spigot
         }
 
         Arrays.fill(this.h, -999);
@@ -945,9 +951,13 @@
             if (world != null) {
                 this.world.populating = true;
                 try {
+                    //fork join
                     for (org.bukkit.generator.BlockPopulator populator : world.getPopulators()) {
-                        populator.populate(world, random, bukkitChunk);
+                        //populator.populate(world, random, bukkitChunk);
+                        ChunkPopulate_Pool task = new ChunkPopulate_Pool(world, random, bukkitChunk, populator);
+                        task.fork();
                     }
+                    
                 } finally {
                     this.world.populating = false;
                 }
@@ -1264,7 +1274,8 @@
         return this.tileEntities;
     }
 
-    public List<Entity>[] getEntitySlices() {
+    //public List<Entity>[] getEntitySlices() {
+    public Queue<Entity>[] getEntitySlices() {
         return this.entitySlices;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderGenerate.java src/main/java/net/minecraft/server/ChunkProviderGenerate.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderGenerate.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderGenerate.java	2016-05-29 23:32:54.727822378 +0800
@@ -0,0 +1,451 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+import javax.annotation.Nullable;
+
+public class ChunkProviderGenerate implements ChunkGenerator {
+
+    protected static final IBlockData a = Blocks.STONE.getBlockData();
+    private final Random i;
+    private final NoiseGeneratorOctaves j;
+    private final NoiseGeneratorOctaves k;
+    private final NoiseGeneratorOctaves l;
+    private final NoiseGenerator3 m;
+    public NoiseGeneratorOctaves b;
+    public NoiseGeneratorOctaves c;
+    public NoiseGeneratorOctaves d;
+    private final World n;
+    private final boolean o;
+    private final WorldType p;
+    private final double[] q;
+    private final float[] r;
+    private CustomWorldSettingsFinal s;
+    private IBlockData t;
+    private double[] u;
+    private final WorldGenBase v;
+    private final WorldGenStronghold w;
+    private final WorldGenVillage x;
+    private final WorldGenMineshaft y;
+    private final WorldGenLargeFeature z;
+    private final WorldGenBase A;
+    private final WorldGenMonument B;
+    private BiomeBase[] C;
+    double[] e;
+    double[] f;
+    double[] g;
+    double[] h;
+
+    public ChunkProviderGenerate(World world, long i, boolean flag, String s) {
+        this.t = Blocks.WATER.getBlockData();
+        this.u = new double[256];
+        this.v = new WorldGenCaves();
+        this.w = new WorldGenStronghold();
+        this.x = new WorldGenVillage();
+        this.y = new WorldGenMineshaft();
+        this.z = new WorldGenLargeFeature();
+        this.A = new WorldGenCanyon();
+        this.B = new WorldGenMonument();
+        this.n = world;
+        this.o = flag;
+        this.p = world.getWorldData().getType();
+        this.i = new Random(i);
+        this.j = new NoiseGeneratorOctaves(this.i, 16);
+        this.k = new NoiseGeneratorOctaves(this.i, 16);
+        this.l = new NoiseGeneratorOctaves(this.i, 8);
+        this.m = new NoiseGenerator3(this.i, 4);
+        this.b = new NoiseGeneratorOctaves(this.i, 10);
+        this.c = new NoiseGeneratorOctaves(this.i, 16);
+        this.d = new NoiseGeneratorOctaves(this.i, 8);
+        this.q = new double[825];
+        this.r = new float[25];
+
+        for (int j = -2; j <= 2; ++j) {
+            for (int k = -2; k <= 2; ++k) {
+                float f = 10.0F / MathHelper.c((float) (j * j + k * k) + 0.2F);
+
+                this.r[j + 2 + (k + 2) * 5] = f;
+            }
+        }
+
+        if (s != null) {
+            this.s = CustomWorldSettingsFinal.CustomWorldSettings.a(s).b();
+            this.t = this.s.E ? Blocks.LAVA.getBlockData() : Blocks.WATER.getBlockData();
+            world.b(this.s.q);
+        }
+
+    }
+
+    public void a(int i, int j, ChunkSnapshot chunksnapshot) {
+        this.C = this.n.getWorldChunkManager().getBiomes(this.C, i * 4 - 2, j * 4 - 2, 10, 10);
+        this.a(i * 4, 0, j * 4);
+
+        for (int k = 0; k < 4; ++k) {
+            int l = k * 5;
+            int i1 = (k + 1) * 5;
+
+            for (int j1 = 0; j1 < 4; ++j1) {
+                int k1 = (l + j1) * 33;
+                int l1 = (l + j1 + 1) * 33;
+                int i2 = (i1 + j1) * 33;
+                int j2 = (i1 + j1 + 1) * 33;
+
+                for (int k2 = 0; k2 < 32; ++k2) {
+                    double d0 = 0.125D;
+                    double d1 = this.q[k1 + k2];
+                    double d2 = this.q[l1 + k2];
+                    double d3 = this.q[i2 + k2];
+                    double d4 = this.q[j2 + k2];
+                    double d5 = (this.q[k1 + k2 + 1] - d1) * d0;
+                    double d6 = (this.q[l1 + k2 + 1] - d2) * d0;
+                    double d7 = (this.q[i2 + k2 + 1] - d3) * d0;
+                    double d8 = (this.q[j2 + k2 + 1] - d4) * d0;
+
+                    for (int l2 = 0; l2 < 8; ++l2) {
+                        double d9 = 0.25D;
+                        double d10 = d1;
+                        double d11 = d2;
+                        double d12 = (d3 - d1) * d9;
+                        double d13 = (d4 - d2) * d9;
+
+                        for (int i3 = 0; i3 < 4; ++i3) {
+                            double d14 = 0.25D;
+                            double d15 = (d11 - d10) * d14;
+                            double d16 = d10 - d15;
+
+                            for (int j3 = 0; j3 < 4; ++j3) {
+                                if ((d16 += d15) > 0.0D) {
+                                    chunksnapshot.a(k * 4 + i3, k2 * 8 + l2, j1 * 4 + j3, ChunkProviderGenerate.a);
+                                } else if (k2 * 8 + l2 < this.s.q) {
+                                    chunksnapshot.a(k * 4 + i3, k2 * 8 + l2, j1 * 4 + j3, this.t);
+                                }
+                            }
+
+                            d10 += d12;
+                            d11 += d13;
+                        }
+
+                        d1 += d5;
+                        d2 += d6;
+                        d3 += d7;
+                        d4 += d8;
+                    }
+                }
+            }
+        }
+
+    }
+
+    public void a(int i, int j, ChunkSnapshot chunksnapshot, BiomeBase[] abiomebase) {
+        double d0 = 0.03125D;
+
+        this.u = this.m.a(this.u, (double) (i * 16), (double) (j * 16), 16, 16, d0 * 2.0D, d0 * 2.0D, 1.0D);
+
+        for (int k = 0; k < 16; ++k) {
+            for (int l = 0; l < 16; ++l) {
+                BiomeBase biomebase = abiomebase[l + k * 16];
+
+                biomebase.a(this.n, this.i, chunksnapshot, i * 16 + k, j * 16 + l, this.u[l + k * 16]);
+            }
+        }
+
+    }
+
+    public Chunk getOrCreateChunk(int i, int j) {
+        this.i.setSeed((long) i * 341873128712L + (long) j * 132897987541L);
+        ChunkSnapshot chunksnapshot = new ChunkSnapshot();
+
+        this.a(i, j, chunksnapshot);
+        this.C = this.n.getWorldChunkManager().getBiomeBlock(this.C, i * 16, j * 16, 16, 16);
+        this.a(i, j, chunksnapshot, this.C);
+        if (this.s.r) {
+            this.v.a(this.n, i, j, chunksnapshot);
+        }
+
+        if (this.s.z) {
+            this.A.a(this.n, i, j, chunksnapshot);
+        }
+
+        if (this.o) {
+            if (this.s.w) {
+                this.y.a(this.n, i, j, chunksnapshot);
+            }
+
+            if (this.s.v) {
+                this.x.a(this.n, i, j, chunksnapshot);
+            }
+
+            if (this.s.u) {
+                this.w.a(this.n, i, j, chunksnapshot);
+            }
+
+            if (this.s.x) {
+                this.z.a(this.n, i, j, chunksnapshot);
+            }
+
+            if (this.s.y) {
+                this.B.a(this.n, i, j, chunksnapshot);
+            }
+        }
+
+        Chunk chunk = new Chunk(this.n, chunksnapshot, i, j);
+        byte[] abyte = chunk.getBiomeIndex();
+
+        for (int k = 0; k < abyte.length; ++k) {
+            abyte[k] = (byte) BiomeBase.a(this.C[k]);
+        }
+
+        chunk.initLighting();
+        return chunk;
+    }
+
+    private void a(int i, int j, int k) {
+        this.h = this.c.a(this.h, i, k, 5, 5, (double) this.s.e, (double) this.s.f, (double) this.s.g);
+        float f = this.s.a;
+        float f1 = this.s.b;
+
+        this.e = this.l.a(this.e, i, j, k, 5, 33, 5, (double) (f / this.s.h), (double) (f1 / this.s.i), (double) (f / this.s.j));
+        this.f = this.j.a(this.f, i, j, k, 5, 33, 5, (double) f, (double) f1, (double) f);
+        this.g = this.k.a(this.g, i, j, k, 5, 33, 5, (double) f, (double) f1, (double) f);
+        boolean flag = false;
+        boolean flag1 = false;
+        int l = 0;
+        int i1 = 0;
+
+        for (int j1 = 0; j1 < 5; ++j1) {
+            for (int k1 = 0; k1 < 5; ++k1) {
+                float f2 = 0.0F;
+                float f3 = 0.0F;
+                float f4 = 0.0F;
+                byte b0 = 2;
+                BiomeBase biomebase = this.C[j1 + 2 + (k1 + 2) * 10];
+
+                for (int l1 = -b0; l1 <= b0; ++l1) {
+                    for (int i2 = -b0; i2 <= b0; ++i2) {
+                        BiomeBase biomebase1 = this.C[j1 + l1 + 2 + (k1 + i2 + 2) * 10];
+                        float f5 = this.s.n + biomebase1.j() * this.s.m;
+                        float f6 = this.s.p + biomebase1.m() * this.s.o;
+
+                        if (this.p == WorldType.AMPLIFIED && f5 > 0.0F) {
+                            f5 = 1.0F + f5 * 2.0F;
+                            f6 = 1.0F + f6 * 4.0F;
+                        }
+
+                        float f7 = this.r[l1 + 2 + (i2 + 2) * 5] / (f5 + 2.0F);
+
+                        if (biomebase1.j() > biomebase.j()) {
+                            f7 /= 2.0F;
+                        }
+
+                        f2 += f6 * f7;
+                        f3 += f5 * f7;
+                        f4 += f7;
+                    }
+                }
+
+                f2 /= f4;
+                f3 /= f4;
+                f2 = f2 * 0.9F + 0.1F;
+                f3 = (f3 * 4.0F - 1.0F) / 8.0F;
+                double d0 = this.h[i1] / 8000.0D;
+
+                if (d0 < 0.0D) {
+                    d0 = -d0 * 0.3D;
+                }
+
+                d0 = d0 * 3.0D - 2.0D;
+                if (d0 < 0.0D) {
+                    d0 /= 2.0D;
+                    if (d0 < -1.0D) {
+                        d0 = -1.0D;
+                    }
+
+                    d0 /= 1.4D;
+                    d0 /= 2.0D;
+                } else {
+                    if (d0 > 1.0D) {
+                        d0 = 1.0D;
+                    }
+
+                    d0 /= 8.0D;
+                }
+
+                ++i1;
+                double d1 = (double) f3;
+                double d2 = (double) f2;
+
+                d1 += d0 * 0.2D;
+                d1 = d1 * (double) this.s.k / 8.0D;
+                double d3 = (double) this.s.k + d1 * 4.0D;
+
+                for (int j2 = 0; j2 < 33; ++j2) {
+                    double d4 = ((double) j2 - d3) * (double) this.s.l * 128.0D / 256.0D / d2;
+
+                    if (d4 < 0.0D) {
+                        d4 *= 4.0D;
+                    }
+
+                    double d5 = this.f[l] / (double) this.s.d;
+                    double d6 = this.g[l] / (double) this.s.c;
+                    double d7 = (this.e[l] / 10.0D + 1.0D) / 2.0D;
+                    double d8 = MathHelper.b(d5, d6, d7) - d4;
+
+                    if (j2 > 29) {
+                        double d9 = (double) ((float) (j2 - 29) / 3.0F);
+
+                        d8 = d8 * (1.0D - d9) + -10.0D * d9;
+                    }
+
+                    this.q[l] = d8;
+                    ++l;
+                }
+            }
+        }
+
+    }
+
+    public void recreateStructures(int i, int j) {
+        BlockFalling.instaFall = true;
+        int k = i * 16;
+        int l = j * 16;
+        BlockPosition blockposition = new BlockPosition(k, 0, l);
+        BiomeBase biomebase = this.n.getBiome(blockposition.a(16, 0, 16));
+
+        this.i.setSeed(this.n.getSeed());
+        long i1 = this.i.nextLong() / 2L * 2L + 1L;
+        long j1 = this.i.nextLong() / 2L * 2L + 1L;
+
+        this.i.setSeed((long) i * i1 + (long) j * j1 ^ this.n.getSeed());
+        boolean flag = false;
+        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
+
+        if (this.o) {
+            if (this.s.w) {
+                this.y.a(this.n, this.i, chunkcoordintpair);
+            }
+
+            if (this.s.v) {
+                flag = this.x.a(this.n, this.i, chunkcoordintpair);
+            }
+
+            if (this.s.u) {
+                this.w.a(this.n, this.i, chunkcoordintpair);
+            }
+
+            if (this.s.x) {
+                this.z.a(this.n, this.i, chunkcoordintpair);
+            }
+
+            if (this.s.y) {
+                this.B.a(this.n, this.i, chunkcoordintpair);
+            }
+        }
+
+        int k1;
+        int l1;
+        int i2;
+
+        if (biomebase != Biomes.d && biomebase != Biomes.s && this.s.A && !flag && this.i.nextInt(this.s.B) == 0) {
+            k1 = this.i.nextInt(16) + 8;
+            l1 = this.i.nextInt(256);
+            i2 = this.i.nextInt(16) + 8;
+            (new WorldGenLakes(Blocks.WATER)).generate(this.n, this.i, blockposition.a(k1, l1, i2));
+        }
+
+        if (!flag && this.i.nextInt(this.s.D / 10) == 0 && this.s.C) {
+            k1 = this.i.nextInt(16) + 8;
+            l1 = this.i.nextInt(this.i.nextInt(248) + 8);
+            i2 = this.i.nextInt(16) + 8;
+            if (l1 < this.n.K() || this.i.nextInt(this.s.D / 8) == 0) {
+                (new WorldGenLakes(Blocks.LAVA)).generate(this.n, this.i, blockposition.a(k1, l1, i2));
+            }
+        }
+
+        if (this.s.s) {
+            for (k1 = 0; k1 < this.s.t; ++k1) {
+                l1 = this.i.nextInt(16) + 8;
+                i2 = this.i.nextInt(256);
+                int j2 = this.i.nextInt(16) + 8;
+
+                (new WorldGenDungeons()).generate(this.n, this.i, blockposition.a(l1, i2, j2));
+            }
+        }
+
+        biomebase.a(this.n, this.i, new BlockPosition(k, 0, l));
+        SpawnerCreature.a(this.n, biomebase, k + 8, l + 8, 16, 16, this.i);
+        blockposition = blockposition.a(8, 0, 8);
+
+        for (k1 = 0; k1 < 16; ++k1) {
+            for (l1 = 0; l1 < 16; ++l1) {
+                BlockPosition blockposition1 = this.n.p(blockposition.a(k1, 0, l1));
+                BlockPosition blockposition2 = blockposition1.down();
+
+                if (this.n.u(blockposition2)) {
+                    this.n.setTypeAndData(blockposition2, Blocks.ICE.getBlockData(), 2);
+                }
+
+                if (this.n.f(blockposition1, true)) {
+                    this.n.setTypeAndData(blockposition1, Blocks.SNOW_LAYER.getBlockData(), 2);
+                }
+            }
+        }
+
+        BlockFalling.instaFall = false;
+    }
+
+    public boolean a(Chunk chunk, int i, int j) {
+        boolean flag = false;
+
+        if (this.s.y && this.o && chunk.x() < 3600L) {
+            flag |= this.B.a(this.n, this.i, new ChunkCoordIntPair(i, j));
+        }
+
+        return flag;
+    }
+
+    public List<BiomeBase.BiomeMeta> getMobsFor(EnumCreatureType enumcreaturetype, BlockPosition blockposition) {
+        BiomeBase biomebase = this.n.getBiome(blockposition);
+
+        if (this.o) {
+            if (enumcreaturetype == EnumCreatureType.MONSTER && this.z.a(blockposition)) {
+                return this.z.b();
+            }
+
+            if (enumcreaturetype == EnumCreatureType.MONSTER && this.s.y && this.B.b(this.n, blockposition)) {
+                return this.B.b();
+            }
+        }
+
+        return biomebase.getMobs(enumcreaturetype);
+    }
+
+    @Nullable
+    public BlockPosition findNearestMapFeature(World world, String s, BlockPosition blockposition) {
+        return "Stronghold".equals(s) && this.w != null ? this.w.getNearestGeneratedFeature(world, blockposition) : null;
+    }
+
+    public void recreateStructures(Chunk chunk, int i, int j) {
+        if (this.o) {
+            if (this.s.w) {
+                this.y.a(this.n, i, j, (ChunkSnapshot) null);
+            }
+
+            if (this.s.v) {
+                this.x.a(this.n, i, j, (ChunkSnapshot) null);
+            }
+
+            if (this.s.u) {
+                this.w.a(this.n, i, j, (ChunkSnapshot) null);
+            }
+
+            if (this.s.x) {
+                this.z.a(this.n, i, j, (ChunkSnapshot) null);
+            }
+
+            if (this.s.y) {
+                this.B.a(this.n, i, j, (ChunkSnapshot) null);
+            }
+        }
+
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderHell.java src/main/java/net/minecraft/server/ChunkProviderHell.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderHell.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderHell.java	2016-05-29 23:32:54.750822376 +0800
@@ -0,0 +1,371 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+import javax.annotation.Nullable;
+
+public class ChunkProviderHell implements ChunkGenerator {
+
+    protected static final IBlockData a = Blocks.AIR.getBlockData();
+    protected static final IBlockData b = Blocks.NETHERRACK.getBlockData();
+    protected static final IBlockData c = Blocks.BEDROCK.getBlockData();
+    protected static final IBlockData d = Blocks.LAVA.getBlockData();
+    protected static final IBlockData e = Blocks.GRAVEL.getBlockData();
+    protected static final IBlockData f = Blocks.SOUL_SAND.getBlockData();
+    private final World n;
+    private final boolean o;
+    private final Random p;
+    private double[] q = new double[256];
+    private double[] r = new double[256];
+    private double[] s = new double[256];
+    private double[] t;
+    private final NoiseGeneratorOctaves u;
+    private final NoiseGeneratorOctaves v;
+    private final NoiseGeneratorOctaves w;
+    private final NoiseGeneratorOctaves x;
+    private final NoiseGeneratorOctaves y;
+    public final NoiseGeneratorOctaves g;
+    public final NoiseGeneratorOctaves h;
+    private final WorldGenFire z = new WorldGenFire();
+    private final WorldGenLightStone1 A = new WorldGenLightStone1();
+    private final WorldGenLightStone2 B = new WorldGenLightStone2();
+    private final WorldGenerator C;
+    private final WorldGenHellLava D;
+    private final WorldGenHellLava E;
+    private final WorldGenMushrooms F;
+    private final WorldGenMushrooms G;
+    private final WorldGenNether H;
+    private final WorldGenBase I;
+    double[] i;
+    double[] j;
+    double[] k;
+    double[] l;
+    double[] m;
+
+    public ChunkProviderHell(World world, boolean flag, long i) {
+        this.C = new WorldGenMinable(Blocks.QUARTZ_ORE.getBlockData(), 14, BlockPredicate.a(Blocks.NETHERRACK));
+        this.D = new WorldGenHellLava(Blocks.FLOWING_LAVA, true);
+        this.E = new WorldGenHellLava(Blocks.FLOWING_LAVA, false);
+        this.F = new WorldGenMushrooms(Blocks.BROWN_MUSHROOM);
+        this.G = new WorldGenMushrooms(Blocks.RED_MUSHROOM);
+        this.H = new WorldGenNether();
+        this.I = new WorldGenCavesHell();
+        this.n = world;
+        this.o = flag;
+        this.p = new Random(i);
+        this.u = new NoiseGeneratorOctaves(this.p, 16);
+        this.v = new NoiseGeneratorOctaves(this.p, 16);
+        this.w = new NoiseGeneratorOctaves(this.p, 8);
+        this.x = new NoiseGeneratorOctaves(this.p, 4);
+        this.y = new NoiseGeneratorOctaves(this.p, 4);
+        this.g = new NoiseGeneratorOctaves(this.p, 10);
+        this.h = new NoiseGeneratorOctaves(this.p, 16);
+        world.b(63);
+    }
+
+    public void a(int i, int j, ChunkSnapshot chunksnapshot) {
+        byte b0 = 4;
+        int k = this.n.K() / 2 + 1;
+        int l = b0 + 1;
+        byte b1 = 17;
+        int i1 = b0 + 1;
+
+        this.t = this.a(this.t, i * b0, 0, j * b0, l, b1, i1);
+
+        for (int j1 = 0; j1 < b0; ++j1) {
+            for (int k1 = 0; k1 < b0; ++k1) {
+                for (int l1 = 0; l1 < 16; ++l1) {
+                    double d0 = 0.125D;
+                    double d1 = this.t[((j1 + 0) * i1 + k1 + 0) * b1 + l1 + 0];
+                    double d2 = this.t[((j1 + 0) * i1 + k1 + 1) * b1 + l1 + 0];
+                    double d3 = this.t[((j1 + 1) * i1 + k1 + 0) * b1 + l1 + 0];
+                    double d4 = this.t[((j1 + 1) * i1 + k1 + 1) * b1 + l1 + 0];
+                    double d5 = (this.t[((j1 + 0) * i1 + k1 + 0) * b1 + l1 + 1] - d1) * d0;
+                    double d6 = (this.t[((j1 + 0) * i1 + k1 + 1) * b1 + l1 + 1] - d2) * d0;
+                    double d7 = (this.t[((j1 + 1) * i1 + k1 + 0) * b1 + l1 + 1] - d3) * d0;
+                    double d8 = (this.t[((j1 + 1) * i1 + k1 + 1) * b1 + l1 + 1] - d4) * d0;
+
+                    for (int i2 = 0; i2 < 8; ++i2) {
+                        double d9 = 0.25D;
+                        double d10 = d1;
+                        double d11 = d2;
+                        double d12 = (d3 - d1) * d9;
+                        double d13 = (d4 - d2) * d9;
+
+                        for (int j2 = 0; j2 < 4; ++j2) {
+                            double d14 = 0.25D;
+                            double d15 = d10;
+                            double d16 = (d11 - d10) * d14;
+
+                            for (int k2 = 0; k2 < 4; ++k2) {
+                                IBlockData iblockdata = null;
+
+                                if (l1 * 8 + i2 < k) {
+                                    iblockdata = ChunkProviderHell.d;
+                                }
+
+                                if (d15 > 0.0D) {
+                                    iblockdata = ChunkProviderHell.b;
+                                }
+
+                                int l2 = j2 + j1 * 4;
+                                int i3 = i2 + l1 * 8;
+                                int j3 = k2 + k1 * 4;
+
+                                chunksnapshot.a(l2, i3, j3, iblockdata);
+                                d15 += d16;
+                            }
+
+                            d10 += d12;
+                            d11 += d13;
+                        }
+
+                        d1 += d5;
+                        d2 += d6;
+                        d3 += d7;
+                        d4 += d8;
+                    }
+                }
+            }
+        }
+
+    }
+
+    public void b(int i, int j, ChunkSnapshot chunksnapshot) {
+        int k = this.n.K() + 1;
+        double d0 = 0.03125D;
+
+        this.q = this.x.a(this.q, i * 16, j * 16, 0, 16, 16, 1, d0, d0, 1.0D);
+        this.r = this.x.a(this.r, i * 16, 109, j * 16, 16, 1, 16, d0, 1.0D, d0);
+        this.s = this.y.a(this.s, i * 16, j * 16, 0, 16, 16, 1, d0 * 2.0D, d0 * 2.0D, d0 * 2.0D);
+
+        for (int l = 0; l < 16; ++l) {
+            for (int i1 = 0; i1 < 16; ++i1) {
+                boolean flag = this.q[l + i1 * 16] + this.p.nextDouble() * 0.2D > 0.0D;
+                boolean flag1 = this.r[l + i1 * 16] + this.p.nextDouble() * 0.2D > 0.0D;
+                int j1 = (int) (this.s[l + i1 * 16] / 3.0D + 3.0D + this.p.nextDouble() * 0.25D);
+                int k1 = -1;
+                IBlockData iblockdata = ChunkProviderHell.b;
+                IBlockData iblockdata1 = ChunkProviderHell.b;
+
+                for (int l1 = 127; l1 >= 0; --l1) {
+                    if (l1 < 127 - this.p.nextInt(5) && l1 > this.p.nextInt(5)) {
+                        IBlockData iblockdata2 = chunksnapshot.a(i1, l1, l);
+
+                        if (iblockdata2.getBlock() != null && iblockdata2.getMaterial() != Material.AIR) {
+                            if (iblockdata2.getBlock() == Blocks.NETHERRACK) {
+                                if (k1 == -1) {
+                                    if (j1 <= 0) {
+                                        iblockdata = ChunkProviderHell.a;
+                                        iblockdata1 = ChunkProviderHell.b;
+                                    } else if (l1 >= k - 4 && l1 <= k + 1) {
+                                        iblockdata = ChunkProviderHell.b;
+                                        iblockdata1 = ChunkProviderHell.b;
+                                        if (flag1) {
+                                            iblockdata = ChunkProviderHell.e;
+                                            iblockdata1 = ChunkProviderHell.b;
+                                        }
+
+                                        if (flag) {
+                                            iblockdata = ChunkProviderHell.f;
+                                            iblockdata1 = ChunkProviderHell.f;
+                                        }
+                                    }
+
+                                    if (l1 < k && (iblockdata == null || iblockdata.getMaterial() == Material.AIR)) {
+                                        iblockdata = ChunkProviderHell.d;
+                                    }
+
+                                    k1 = j1;
+                                    if (l1 >= k - 1) {
+                                        chunksnapshot.a(i1, l1, l, iblockdata);
+                                    } else {
+                                        chunksnapshot.a(i1, l1, l, iblockdata1);
+                                    }
+                                } else if (k1 > 0) {
+                                    --k1;
+                                    chunksnapshot.a(i1, l1, l, iblockdata1);
+                                }
+                            }
+                        } else {
+                            k1 = -1;
+                        }
+                    } else {
+                        chunksnapshot.a(i1, l1, l, ChunkProviderHell.c);
+                    }
+                }
+            }
+        }
+
+    }
+
+    public Chunk getOrCreateChunk(int i, int j) {
+        this.p.setSeed((long) i * 341873128712L + (long) j * 132897987541L);
+        ChunkSnapshot chunksnapshot = new ChunkSnapshot();
+
+        this.a(i, j, chunksnapshot);
+        this.b(i, j, chunksnapshot);
+        this.I.a(this.n, i, j, chunksnapshot);
+        if (this.o) {
+            this.H.a(this.n, i, j, chunksnapshot);
+        }
+
+        Chunk chunk = new Chunk(this.n, chunksnapshot, i, j);
+        BiomeBase[] abiomebase = this.n.getWorldChunkManager().getBiomeBlock((BiomeBase[]) null, i * 16, j * 16, 16, 16);
+        byte[] abyte = chunk.getBiomeIndex();
+
+        for (int k = 0; k < abyte.length; ++k) {
+            abyte[k] = (byte) BiomeBase.a(abiomebase[k]);
+        }
+
+        chunk.m();
+        return chunk;
+    }
+
+    private double[] a(double[] adouble, int i, int j, int k, int l, int i1, int j1) {
+        if (adouble == null) {
+            adouble = new double[l * i1 * j1];
+        }
+
+        double d0 = 684.412D;
+        double d1 = 2053.236D;
+
+        this.l = this.g.a(this.l, i, j, k, l, 1, j1, 1.0D, 0.0D, 1.0D);
+        this.m = this.h.a(this.m, i, j, k, l, 1, j1, 100.0D, 0.0D, 100.0D);
+        this.i = this.w.a(this.i, i, j, k, l, i1, j1, d0 / 80.0D, d1 / 60.0D, d0 / 80.0D);
+        this.j = this.u.a(this.j, i, j, k, l, i1, j1, d0, d1, d0);
+        this.k = this.v.a(this.k, i, j, k, l, i1, j1, d0, d1, d0);
+        int k1 = 0;
+        double[] adouble1 = new double[i1];
+
+        int l1;
+
+        for (l1 = 0; l1 < i1; ++l1) {
+            adouble1[l1] = Math.cos((double) l1 * 3.141592653589793D * 6.0D / (double) i1) * 2.0D;
+            double d2 = (double) l1;
+
+            if (l1 > i1 / 2) {
+                d2 = (double) (i1 - 1 - l1);
+            }
+
+            if (d2 < 4.0D) {
+                d2 = 4.0D - d2;
+                adouble1[l1] -= d2 * d2 * d2 * 10.0D;
+            }
+        }
+
+        for (l1 = 0; l1 < l; ++l1) {
+            for (int i2 = 0; i2 < j1; ++i2) {
+                double d3 = 0.0D;
+
+                for (int j2 = 0; j2 < i1; ++j2) {
+                    double d4 = 0.0D;
+                    double d5 = adouble1[j2];
+                    double d6 = this.j[k1] / 512.0D;
+                    double d7 = this.k[k1] / 512.0D;
+                    double d8 = (this.i[k1] / 10.0D + 1.0D) / 2.0D;
+
+                    if (d8 < 0.0D) {
+                        d4 = d6;
+                    } else if (d8 > 1.0D) {
+                        d4 = d7;
+                    } else {
+                        d4 = d6 + (d7 - d6) * d8;
+                    }
+
+                    d4 -= d5;
+                    double d9;
+
+                    if (j2 > i1 - 4) {
+                        d9 = (double) ((float) (j2 - (i1 - 4)) / 3.0F);
+                        d4 = d4 * (1.0D - d9) + -10.0D * d9;
+                    }
+
+                    if ((double) j2 < d3) {
+                        d9 = (d3 - (double) j2) / 4.0D;
+                        d9 = MathHelper.a(d9, 0.0D, 1.0D);
+                        d4 = d4 * (1.0D - d9) + -10.0D * d9;
+                    }
+
+                    adouble[k1] = d4;
+                    ++k1;
+                }
+            }
+        }
+
+        return adouble;
+    }
+
+    public void recreateStructures(int i, int j) {
+        BlockFalling.instaFall = true;
+        BlockPosition blockposition = new BlockPosition(i * 16, 0, j * 16);
+        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
+
+        this.H.a(this.n, this.p, chunkcoordintpair);
+
+        int k;
+
+        for (k = 0; k < 8; ++k) {
+            this.E.generate(this.n, this.p, blockposition.a(this.p.nextInt(16) + 8, this.p.nextInt(120) + 4, this.p.nextInt(16) + 8));
+        }
+
+        for (k = 0; k < this.p.nextInt(this.p.nextInt(10) + 1) + 1; ++k) {
+            this.z.generate(this.n, this.p, blockposition.a(this.p.nextInt(16) + 8, this.p.nextInt(120) + 4, this.p.nextInt(16) + 8));
+        }
+
+        for (k = 0; k < this.p.nextInt(this.p.nextInt(10) + 1); ++k) {
+            this.A.generate(this.n, this.p, blockposition.a(this.p.nextInt(16) + 8, this.p.nextInt(120) + 4, this.p.nextInt(16) + 8));
+        }
+
+        for (k = 0; k < 10; ++k) {
+            this.B.generate(this.n, this.p, blockposition.a(this.p.nextInt(16) + 8, this.p.nextInt(128), this.p.nextInt(16) + 8));
+        }
+
+        if (this.p.nextBoolean()) {
+            this.F.generate(this.n, this.p, blockposition.a(this.p.nextInt(16) + 8, this.p.nextInt(128), this.p.nextInt(16) + 8));
+        }
+
+        if (this.p.nextBoolean()) {
+            this.G.generate(this.n, this.p, blockposition.a(this.p.nextInt(16) + 8, this.p.nextInt(128), this.p.nextInt(16) + 8));
+        }
+
+        for (k = 0; k < 16; ++k) {
+            this.C.generate(this.n, this.p, blockposition.a(this.p.nextInt(16), this.p.nextInt(108) + 10, this.p.nextInt(16)));
+        }
+
+        for (k = 0; k < 16; ++k) {
+            this.D.generate(this.n, this.p, blockposition.a(this.p.nextInt(16), this.p.nextInt(108) + 10, this.p.nextInt(16)));
+        }
+
+        BlockFalling.instaFall = false;
+    }
+
+    public boolean a(Chunk chunk, int i, int j) {
+        return false;
+    }
+
+    public List<BiomeBase.BiomeMeta> getMobsFor(EnumCreatureType enumcreaturetype, BlockPosition blockposition) {
+        if (enumcreaturetype == EnumCreatureType.MONSTER) {
+            if (this.H.b(blockposition)) {
+                return this.H.b();
+            }
+
+            if (this.H.b(this.n, blockposition) && this.n.getType(blockposition.down()).getBlock() == Blocks.NETHER_BRICK) {
+                return this.H.b();
+            }
+        }
+
+        BiomeBase biomebase = this.n.getBiome(blockposition);
+
+        return biomebase.getMobs(enumcreaturetype);
+    }
+
+    @Nullable
+    public BlockPosition findNearestMapFeature(World world, String s, BlockPosition blockposition) {
+        return null;
+    }
+
+    public void recreateStructures(Chunk chunk, int i, int j) {
+        this.H.a(this.n, i, j, (ChunkSnapshot) null);
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderServer.java src/main/java/net/minecraft/server/ChunkProviderServer.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderServer.java	2016-05-29 15:00:14.015641616 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderServer.java	2016-05-29 23:32:54.756822375 +0800
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
@@ -10,6 +11,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.ConcurrentMap;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -27,6 +29,8 @@
     public final ChunkGenerator chunkGenerator;
     private final IChunkLoader chunkLoader;
     public final Long2ObjectMap<Chunk> chunks = new Long2ObjectOpenHashMap(8192);
+    //need to paste some copies according to cpu-cores and read from them
+    public ConcurrentMap<Long2ObjectMap<Chunk>, Boolean> chunks_clus = Maps.newConcurrentMap();
     public final WorldServer world;
 
     public ChunkProviderServer(WorldServer worldserver, IChunkLoader ichunkloader, ChunkGenerator chunkgenerator) {
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderTheEnd.java src/main/java/net/minecraft/server/ChunkProviderTheEnd.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderTheEnd.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderTheEnd.java	2016-05-29 23:32:54.753822376 +0800
@@ -0,0 +1,326 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+import javax.annotation.Nullable;
+
+public class ChunkProviderTheEnd implements ChunkGenerator {
+
+    private Random h;
+    protected static final IBlockData a = Blocks.END_STONE.getBlockData();
+    protected static final IBlockData b = Blocks.AIR.getBlockData();
+    private final NoiseGeneratorOctaves i;
+    private final NoiseGeneratorOctaves j;
+    private final NoiseGeneratorOctaves k;
+    public NoiseGeneratorOctaves c;
+    public NoiseGeneratorOctaves d;
+    private final World l;
+    private final boolean m;
+    private final WorldGenEndCity n = new WorldGenEndCity(this);
+    private final NoiseGenerator3Handler o;
+    private double[] p;
+    private BiomeBase[] q;
+    double[] e;
+    double[] f;
+    double[] g;
+    private final WorldGenEndIsland r = new WorldGenEndIsland();
+
+    public ChunkProviderTheEnd(World world, boolean flag, long i) {
+        this.l = world;
+        this.m = flag;
+        this.h = new Random(i);
+        this.i = new NoiseGeneratorOctaves(this.h, 16);
+        this.j = new NoiseGeneratorOctaves(this.h, 16);
+        this.k = new NoiseGeneratorOctaves(this.h, 8);
+        this.c = new NoiseGeneratorOctaves(this.h, 10);
+        this.d = new NoiseGeneratorOctaves(this.h, 16);
+        this.o = new NoiseGenerator3Handler(this.h);
+    }
+
+    public void a(int i, int j, ChunkSnapshot chunksnapshot) {
+        byte b0 = 2;
+        int k = b0 + 1;
+        byte b1 = 33;
+        int l = b0 + 1;
+
+        this.p = this.a(this.p, i * b0, 0, j * b0, k, b1, l);
+
+        for (int i1 = 0; i1 < b0; ++i1) {
+            for (int j1 = 0; j1 < b0; ++j1) {
+                for (int k1 = 0; k1 < 32; ++k1) {
+                    double d0 = 0.25D;
+                    double d1 = this.p[((i1 + 0) * l + j1 + 0) * b1 + k1 + 0];
+                    double d2 = this.p[((i1 + 0) * l + j1 + 1) * b1 + k1 + 0];
+                    double d3 = this.p[((i1 + 1) * l + j1 + 0) * b1 + k1 + 0];
+                    double d4 = this.p[((i1 + 1) * l + j1 + 1) * b1 + k1 + 0];
+                    double d5 = (this.p[((i1 + 0) * l + j1 + 0) * b1 + k1 + 1] - d1) * d0;
+                    double d6 = (this.p[((i1 + 0) * l + j1 + 1) * b1 + k1 + 1] - d2) * d0;
+                    double d7 = (this.p[((i1 + 1) * l + j1 + 0) * b1 + k1 + 1] - d3) * d0;
+                    double d8 = (this.p[((i1 + 1) * l + j1 + 1) * b1 + k1 + 1] - d4) * d0;
+
+                    for (int l1 = 0; l1 < 4; ++l1) {
+                        double d9 = 0.125D;
+                        double d10 = d1;
+                        double d11 = d2;
+                        double d12 = (d3 - d1) * d9;
+                        double d13 = (d4 - d2) * d9;
+
+                        for (int i2 = 0; i2 < 8; ++i2) {
+                            double d14 = 0.125D;
+                            double d15 = d10;
+                            double d16 = (d11 - d10) * d14;
+
+                            for (int j2 = 0; j2 < 8; ++j2) {
+                                IBlockData iblockdata = ChunkProviderTheEnd.b;
+
+                                if (d15 > 0.0D) {
+                                    iblockdata = ChunkProviderTheEnd.a;
+                                }
+
+                                int k2 = i2 + i1 * 8;
+                                int l2 = l1 + k1 * 4;
+                                int i3 = j2 + j1 * 8;
+
+                                chunksnapshot.a(k2, l2, i3, iblockdata);
+                                d15 += d16;
+                            }
+
+                            d10 += d12;
+                            d11 += d13;
+                        }
+
+                        d1 += d5;
+                        d2 += d6;
+                        d3 += d7;
+                        d4 += d8;
+                    }
+                }
+            }
+        }
+
+    }
+
+    public void a(ChunkSnapshot chunksnapshot) {
+        for (int i = 0; i < 16; ++i) {
+            for (int j = 0; j < 16; ++j) {
+                byte b0 = 1;
+                int k = -1;
+                IBlockData iblockdata = ChunkProviderTheEnd.a;
+                IBlockData iblockdata1 = ChunkProviderTheEnd.a;
+
+                for (int l = 127; l >= 0; --l) {
+                    IBlockData iblockdata2 = chunksnapshot.a(i, l, j);
+
+                    if (iblockdata2.getMaterial() == Material.AIR) {
+                        k = -1;
+                    } else if (iblockdata2.getBlock() == Blocks.STONE) {
+                        if (k == -1) {
+                            if (b0 <= 0) {
+                                iblockdata = ChunkProviderTheEnd.b;
+                                iblockdata1 = ChunkProviderTheEnd.a;
+                            }
+
+                            k = b0;
+                            if (l >= 0) {
+                                chunksnapshot.a(i, l, j, iblockdata);
+                            } else {
+                                chunksnapshot.a(i, l, j, iblockdata1);
+                            }
+                        } else if (k > 0) {
+                            --k;
+                            chunksnapshot.a(i, l, j, iblockdata1);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    public Chunk getOrCreateChunk(int i, int j) {
+        this.h.setSeed((long) i * 341873128712L + (long) j * 132897987541L);
+        ChunkSnapshot chunksnapshot = new ChunkSnapshot();
+
+        this.q = this.l.getWorldChunkManager().getBiomeBlock(this.q, i * 16, j * 16, 16, 16);
+        this.a(i, j, chunksnapshot);
+        this.a(chunksnapshot);
+        if (this.m) {
+            this.n.a(this.l, i, j, chunksnapshot);
+        }
+
+        Chunk chunk = new Chunk(this.l, chunksnapshot, i, j);
+        byte[] abyte = chunk.getBiomeIndex();
+
+        for (int k = 0; k < abyte.length; ++k) {
+            abyte[k] = (byte) BiomeBase.a(this.q[k]);
+        }
+
+        chunk.initLighting();
+        return chunk;
+    }
+
+    private float a(int i, int j, int k, int l) {
+        float f = (float) (i * 2 + k);
+        float f1 = (float) (j * 2 + l);
+        float f2 = 100.0F - MathHelper.c(f * f + f1 * f1) * 8.0F;
+
+        if (f2 > 80.0F) {
+            f2 = 80.0F;
+        }
+
+        if (f2 < -100.0F) {
+            f2 = -100.0F;
+        }
+
+        for (int i1 = -12; i1 <= 12; ++i1) {
+            for (int j1 = -12; j1 <= 12; ++j1) {
+                long k1 = (long) (i + i1);
+                long l1 = (long) (j + j1);
+
+                if (k1 * k1 + l1 * l1 > 4096L && this.o.a((double) k1, (double) l1) < -0.8999999761581421D) {
+                    float f3 = (MathHelper.e((float) k1) * 3439.0F + MathHelper.e((float) l1) * 147.0F) % 13.0F + 9.0F;
+
+                    f = (float) (k - i1 * 2);
+                    f1 = (float) (l - j1 * 2);
+                    float f4 = 100.0F - MathHelper.c(f * f + f1 * f1) * f3;
+
+                    if (f4 > 80.0F) {
+                        f4 = 80.0F;
+                    }
+
+                    if (f4 < -100.0F) {
+                        f4 = -100.0F;
+                    }
+
+                    if (f4 > f2) {
+                        f2 = f4;
+                    }
+                }
+            }
+        }
+
+        return f2;
+    }
+
+    public boolean c(int i, int j) {
+        return (long) i * (long) i + (long) j * (long) j > 4096L && this.a(i, j, 1, 1) >= 0.0F;
+    }
+
+    private double[] a(double[] adouble, int i, int j, int k, int l, int i1, int j1) {
+        if (adouble == null) {
+            adouble = new double[l * i1 * j1];
+        }
+
+        double d0 = 684.412D;
+        double d1 = 684.412D;
+
+        d0 *= 2.0D;
+        this.e = this.k.a(this.e, i, j, k, l, i1, j1, d0 / 80.0D, d1 / 160.0D, d0 / 80.0D);
+        this.f = this.i.a(this.f, i, j, k, l, i1, j1, d0, d1, d0);
+        this.g = this.j.a(this.g, i, j, k, l, i1, j1, d0, d1, d0);
+        int k1 = i / 2;
+        int l1 = k / 2;
+        int i2 = 0;
+
+        for (int j2 = 0; j2 < l; ++j2) {
+            for (int k2 = 0; k2 < j1; ++k2) {
+                float f = this.a(k1, l1, j2, k2);
+
+                for (int l2 = 0; l2 < i1; ++l2) {
+                    double d2 = 0.0D;
+                    double d3 = this.f[i2] / 512.0D;
+                    double d4 = this.g[i2] / 512.0D;
+                    double d5 = (this.e[i2] / 10.0D + 1.0D) / 2.0D;
+
+                    if (d5 < 0.0D) {
+                        d2 = d3;
+                    } else if (d5 > 1.0D) {
+                        d2 = d4;
+                    } else {
+                        d2 = d3 + (d4 - d3) * d5;
+                    }
+
+                    d2 -= 8.0D;
+                    d2 += (double) f;
+                    byte b0 = 2;
+                    double d6;
+
+                    if (l2 > i1 / 2 - b0) {
+                        d6 = (double) ((float) (l2 - (i1 / 2 - b0)) / 64.0F);
+                        d6 = MathHelper.a(d6, 0.0D, 1.0D);
+                        d2 = d2 * (1.0D - d6) + -3000.0D * d6;
+                    }
+
+                    b0 = 8;
+                    if (l2 < b0) {
+                        d6 = (double) ((float) (b0 - l2) / ((float) b0 - 1.0F));
+                        d2 = d2 * (1.0D - d6) + -30.0D * d6;
+                    }
+
+                    adouble[i2] = d2;
+                    ++i2;
+                }
+            }
+        }
+
+        return adouble;
+    }
+
+    public void recreateStructures(int i, int j) {
+        BlockFalling.instaFall = true;
+        BlockPosition blockposition = new BlockPosition(i * 16, 0, j * 16);
+
+        if (this.m) {
+            this.n.a(this.l, this.h, new ChunkCoordIntPair(i, j));
+        }
+
+        this.l.getBiome(blockposition.a(16, 0, 16)).a(this.l, this.l.random, blockposition);
+        long k = (long) i * (long) i + (long) j * (long) j;
+
+        if (k > 4096L) {
+            float f = this.a(i, j, 1, 1);
+
+            if (f < -20.0F && this.h.nextInt(14) == 0) {
+                this.r.generate(this.l, this.h, blockposition.a(this.h.nextInt(16) + 8, 55 + this.h.nextInt(16), this.h.nextInt(16) + 8));
+                if (this.h.nextInt(4) == 0) {
+                    this.r.generate(this.l, this.h, blockposition.a(this.h.nextInt(16) + 8, 55 + this.h.nextInt(16), this.h.nextInt(16) + 8));
+                }
+            }
+
+            if (this.a(i, j, 1, 1) > 40.0F) {
+                int l = this.h.nextInt(5);
+
+                for (int i1 = 0; i1 < l; ++i1) {
+                    int j1 = this.h.nextInt(16) + 8;
+                    int k1 = this.h.nextInt(16) + 8;
+                    int l1 = this.l.getHighestBlockYAt(blockposition.a(j1, 0, k1)).getY();
+
+                    if (l1 > 0) {
+                        int i2 = l1 - 1;
+
+                        if (this.l.isEmpty(blockposition.a(j1, i2 + 1, k1)) && this.l.getType(blockposition.a(j1, i2, k1)).getBlock() == Blocks.END_STONE) {
+                            BlockChorusFlower.a(this.l, blockposition.a(j1, i2 + 1, k1), this.h, 8);
+                        }
+                    }
+                }
+            }
+        }
+
+        BlockFalling.instaFall = false;
+    }
+
+    public boolean a(Chunk chunk, int i, int j) {
+        return false;
+    }
+
+    public List<BiomeBase.BiomeMeta> getMobsFor(EnumCreatureType enumcreaturetype, BlockPosition blockposition) {
+        return this.l.getBiome(blockposition).getMobs(enumcreaturetype);
+    }
+
+    @Nullable
+    public BlockPosition findNearestMapFeature(World world, String s, BlockPosition blockposition) {
+        return null;
+    }
+
+    public void recreateStructures(Chunk chunk, int i, int j) {}
+}
diff -Naur src_origin/main/java/net/minecraft/server/EntityLiving.java src/main/java/net/minecraft/server/EntityLiving.java
--- src_origin/main/java/net/minecraft/server/EntityLiving.java	2016-05-29 15:00:14.431641578 +0800
+++ src/main/java/net/minecraft/server/EntityLiving.java	2016-05-29 23:32:55.344822321 +0800
@@ -14,6 +14,7 @@
 import java.util.ArrayList;
 import com.google.common.base.Function;
 import com.google.common.collect.Lists;
+import java.util.concurrent.RecursiveAction;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.attribute.CraftAttributeMap;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
@@ -1539,7 +1540,9 @@
                 }
 
                 this.a(f, f1, f3);
-                this.move(this.motX, this.motY, this.motZ);
+                //this.move(this.motX, this.motY, this.motZ);
+                move move_task = new move(this, this.motX, this.motY, this.motZ);
+                move_task.fork();
                 this.motX *= (double) f4;
                 this.motY *= 0.800000011920929D;
                 this.motZ *= (double) f4;
@@ -1550,7 +1553,9 @@
             } else if (this.an() && (!(this instanceof EntityHuman) || !((EntityHuman) this).abilities.isFlying)) {
                 d1 = this.locY;
                 this.a(f, f1, 0.02F);
-                this.move(this.motX, this.motY, this.motZ);
+                //this.move(this.motX, this.motY, this.motZ);
+                move move_task = new move(this, this.motX, this.motY, this.motZ);
+                move_task.fork();
                 this.motX *= 0.5D;
                 this.motY *= 0.5D;
                 this.motZ *= 0.5D;
@@ -1597,7 +1602,10 @@
                 this.motX *= 0.9900000095367432D;
                 this.motY *= 0.9800000190734863D;
                 this.motZ *= 0.9900000095367432D;
-                this.move(this.motX, this.motY, this.motZ);
+                //this.move(this.motX, this.motY, this.motZ);
+                move move_task = new move(this, this.motX, this.motY, this.motZ);
+                move_task.fork();
+                
                 if (this.positionChanged && !this.world.isClientSide) {
                     d4 = Math.sqrt(this.motX * this.motX + this.motZ * this.motZ);
                     double d5 = d2 - d4;
@@ -1650,7 +1658,11 @@
                     }
                 }
 
-                this.move(this.motX, this.motY, this.motZ);
+                //this.move(this.motX, this.motY, this.motZ);
+                move move_task = new move(this, this.motX, this.motY, this.motZ);
+                move_task.fork();
+                move_task.join();//must have
+                
                 if (this.positionChanged && this.n_()) {
                     this.motY = 0.2D;
                 }
@@ -2386,4 +2398,22 @@
 
         }
     }
+    
+    class move extends RecursiveAction {
+        double d0, d1, d2;
+        EntityLiving el;
+                
+        move(EntityLiving el, double d0, double d1, double d2) {
+            this.d0 = d0;
+            this.d1 = d1;
+            this.d2 = d2;
+            this.el = el;
+        }
+        
+        @Override
+        protected void compute() {
+            el.move(d0, d1, d2);
+        }
+                 
+    }
 }
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2016-05-29 15:00:14.828641542 +0800
+++ src/main/java/net/minecraft/server/MinecraftServer.java	2016-05-29 23:32:55.935822267 +0800
@@ -33,6 +33,7 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
 import java.util.Random;
@@ -51,6 +52,8 @@
 import org.bukkit.craftbukkit.CraftServer;
 // CraftBukkit end
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.hose.ChunkGen_Pool;
+import org.spigotmc.SpigotWorldConfig;
 
 public abstract class MinecraftServer implements Runnable, ICommandListener, IAsyncTaskHandler, IMojangStatistics {
 
@@ -358,7 +361,10 @@
             BlockPosition blockposition = worldserver.getSpawn();
             long j = av();
             i = 0;
-
+            //hose
+            List<int[]> chunkgen_list = new LinkedList();
+            int[] pos = new int[2];
+            
             for (int k = -192; k <= 192 && this.isRunning(); k += 16) {
                 for (int l = -192; l <= 192 && this.isRunning(); l += 16) {
                     long i1 = av();
@@ -369,9 +375,13 @@
                     }
 
                     ++i;
-                    worldserver.getChunkProviderServer().getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    //worldserver.getChunkProviderServer().getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    pos[0] = blockposition.getX() + k >> 4;
+                    pos[1] = blockposition.getZ() + l >> 4;
+                    chunkgen_list.add(pos);
                 }
             }
+            SpigotWorldConfig.ChunkPool.invoke(new ChunkGen_Pool(worldserver, chunkgen_list));
         }
 
         for (WorldServer world : this.worlds) {
@@ -1027,7 +1037,8 @@
     }
 
     public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        //return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "HOSE"; // HOSE -> Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1109,7 +1120,8 @@
     }
 
     public String getName() {
-        return "Server";
+        //return "Server";
+        return org.bukkit.ChatColor.GREEN + "Server";
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
diff -Naur src_origin/main/java/net/minecraft/server/PlayerChunkMap.java src/main/java/net/minecraft/server/PlayerChunkMap.java
--- src_origin/main/java/net/minecraft/server/PlayerChunkMap.java	2016-05-29 15:00:14.995641526 +0800
+++ src/main/java/net/minecraft/server/PlayerChunkMap.java	2016-05-29 23:32:56.194822244 +0800
@@ -17,6 +17,8 @@
 
 // CraftBukkit start
 import java.util.LinkedList;
+import org.hose.ChunkFlush_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public class PlayerChunkMap {
@@ -100,11 +102,14 @@
         };
     }
 
+    List<PlayerChunk> chunkflush_list = new LinkedList();
+    
     public void flush() {
         long i = this.world.getTime();
         int j;
         PlayerChunk playerchunk;
-
+        
+        //long st1 = System.nanoTime();
         if (i - this.k > 8000L) {
             this.k = i;
 
@@ -114,7 +119,22 @@
                 playerchunk.c();
             }
         }
+        /*long et1 = System.nanoTime();
+        System.out.println("t1: "+(et1-st1));
+
+        long st2 = System.nanoTime();*/
+        /*
+        if (!this.f.isEmpty()) {
+            Iterator iterator = this.f.iterator();
 
+            chunkflush_list.clear();
+            while (iterator.hasNext()) {
+                chunkflush_list.add((PlayerChunk) iterator.next());
+            }
+            this.f.clear();
+        }
+        SpigotWorldConfig.ChunkFlushPool.invoke(new ChunkFlush_Pool(chunkflush_list));*/
+        
         if (!this.f.isEmpty()) {
             Iterator iterator = this.f.iterator();
 
@@ -125,6 +145,8 @@
 
             this.f.clear();
         }
+        /*long et2 = System.nanoTime();
+        System.out.println("t2: "+(et2-st2));*/
 
         if (this.l && i % 4L == 0L) {
             this.l = false;
@@ -152,11 +174,13 @@
             });
         }
 
+        //long st3 = System.nanoTime();
         if (!this.h.isEmpty()) {
             long k = System.nanoTime() + 50000000L;
-            int l = 49;
+            int l = 49;//49
             Iterator iterator1 = this.h.iterator();
 
+            //fork join
             while (iterator1.hasNext()) {
                 PlayerChunk playerchunk1 = (PlayerChunk) iterator1.next();
 
@@ -177,7 +201,10 @@
                 }
             }
         }
+        /*long et3 = System.nanoTime();
+        System.out.println("t3: "+(et3-st3));
 
+        long st4 = System.nanoTime();*/
         if (!this.g.isEmpty()) {
             j = 81;
             Iterator iterator2 = this.g.iterator();
@@ -194,6 +221,8 @@
                 }
             }
         }
+        /*long et4 = System.nanoTime();
+        System.out.println("t4: "+(et4-st4));*/
 
         if (this.managedPlayers.isEmpty()) {
             WorldProvider worldprovider = this.world.worldProvider;
diff -Naur src_origin/main/java/net/minecraft/server/StructureGenerator.java src/main/java/net/minecraft/server/StructureGenerator.java
--- src_origin/main/java/net/minecraft/server/StructureGenerator.java	2016-05-29 15:00:15.180641509 +0800
+++ src/main/java/net/minecraft/server/StructureGenerator.java	2016-05-29 23:32:56.445822221 +0800
@@ -5,6 +5,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
+import java.util.concurrent.RecursiveAction;
 
 public abstract class StructureGenerator extends WorldGenBase {
 
@@ -81,7 +82,9 @@
                 structurestart.a(world, random, new StructureBoundingBox(i, j, i + 15, j + 15));
                 structurestart.b(chunkcoordintpair);
                 flag = true;
-                this.a(structurestart.e(), structurestart.f(), structurestart);
+                //this.a(structurestart.e(), structurestart.f(), structurestart);
+                structure str_task = new structure(this, structurestart.e(), structurestart.f(), structurestart);
+                str_task.fork();
             }
         }
 
@@ -241,4 +244,23 @@
     protected abstract boolean a(int i, int j);
 
     protected abstract StructureStart b(int i, int j);
+    
+    class structure extends RecursiveAction {
+        int i, j;
+        StructureStart structurestart;
+        StructureGenerator sg;
+        
+        structure(StructureGenerator sg, int i, int j, StructureStart structurestart) {
+            this.sg = sg;
+            this.i = i;
+            this.j = j;
+            this.structurestart = structurestart;
+        }
+        
+        @Override
+        protected void compute() {
+            sg.a(structurestart.e(), structurestart.f(), structurestart);
+        }
+                 
+    }
 }
diff -Naur src_origin/main/java/net/minecraft/server/World.java src/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2016-05-29 15:00:15.302641498 +0800
+++ src/main/java/net/minecraft/server/World.java	2016-05-29 23:32:56.611822205 +0800
@@ -945,8 +945,11 @@
         return addEntity(entity, SpawnReason.DEFAULT);
     }
 
-    public boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
-        org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
+    public synchronized boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
+        //org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
+        if (org.spigotmc.AsyncCatcher.catchOp_flag("entity add")) { // HOSE
+            entity = null;
+        }
         if (entity == null) return false;
         // CraftBukkit end
         int i = MathHelper.floor(entity.locX / 16.0D);
diff -Naur src_origin/main/java/org/hose/ChunkFlush_Pool.java src/main/java/org/hose/ChunkFlush_Pool.java
--- src_origin/main/java/org/hose/ChunkFlush_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChunkFlush_Pool.java	2016-05-29 23:32:53.428822497 +0800
@@ -0,0 +1,53 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.PlayerChunk;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkFlush_Pool extends RecursiveAction {//need to use callable
+    List<PlayerChunk> chunkflush_list;
+    
+    public ChunkFlush_Pool(List<PlayerChunk> chunkflush_list){
+        this.chunkflush_list = chunkflush_list;
+    }
+    
+    @Override
+    protected void compute() {
+        List<RecursiveAction> forks = new LinkedList();
+        for (PlayerChunk pc : chunkflush_list) {
+            chunkflush task = new chunkflush(pc);
+            forks.add(task);
+            task.fork();
+            //task.join();
+        }
+        /*
+        for (RecursiveAction task : forks) {
+            task.join();
+        }*/
+    }
+    
+    
+    class chunkflush extends RecursiveAction {
+        PlayerChunk pc;
+        
+        chunkflush(PlayerChunk pc) {
+            this.pc = pc;
+        }
+        
+        @Override
+        protected void compute() {
+            pc.d();
+        }
+                 
+    }
+}
diff -Naur src_origin/main/java/org/hose/ChunkGen_Pool.java src/main/java/org/hose/ChunkGen_Pool.java
--- src_origin/main/java/org/hose/ChunkGen_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChunkGen_Pool.java	2016-05-29 23:32:53.427822497 +0800
@@ -0,0 +1,76 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.WorldServer;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkGen_Pool extends RecursiveAction {
+    WorldServer worldserver;
+    List<int[]> position;
+    
+    public ChunkGen_Pool(WorldServer worldserver, List<int[]> position){
+        this.worldserver = worldserver;
+        this.position = position;
+        
+    }
+    
+    @Override
+    protected void compute() {
+        List<RecursiveAction> forks = new LinkedList();
+        for (int[] pt : position) {
+            chunkgen task = new chunkgen(worldserver, pt);
+            forks.add(task);
+            task.fork();
+            //task.join();
+        }
+        /*
+        for (RecursiveAction task : forks) {
+            task.join();
+        }*/
+        /*
+        List<int[]> fork1 = this.position.subList(0, (this.position.size()/2));
+        List<int[]> fork2 = this.position.subList((this.position.size()/2), this.position.size());
+        chunkgen t1 = new chunkgen(worldserver, fork1);
+        chunkgen t2 = new chunkgen(worldserver, fork2);
+        t1.fork();
+        t2.fork();
+        t1.join();*/
+        /*
+        for (RecursiveAction task : forks) {
+            task.join();
+        }*/
+    }
+    
+    
+    class chunkgen extends RecursiveAction {
+        WorldServer worldserver;
+        int[] pt;
+        //List<int[]> position;
+        
+        chunkgen(WorldServer worldserver, int[] pt) {
+            this.worldserver = worldserver;
+            this.pt = pt;
+            //this.position = position;
+        }
+        
+        @Override
+        protected void compute() {
+            worldserver.getChunkProviderServer().getChunkAt(pt[0], pt[1]);
+            /*
+            for (int[] pt : position) {
+                worldserver.getChunkProviderServer().getChunkAt(pt[0], pt[1]);
+            }*/
+        }
+                 
+    }
+}
diff -Naur src_origin/main/java/org/hose/ChunkPopulate_Pool.java src/main/java/org/hose/ChunkPopulate_Pool.java
--- src_origin/main/java/org/hose/ChunkPopulate_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChunkPopulate_Pool.java	2016-05-29 23:32:53.427822497 +0800
@@ -0,0 +1,35 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.Random;
+import java.util.concurrent.RecursiveAction;
+import org.bukkit.Chunk;
+import org.bukkit.World;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkPopulate_Pool extends RecursiveAction {//need to use callable
+    World world;
+    Random random;
+    Chunk chunk;
+    org.bukkit.generator.BlockPopulator populator;
+    
+    public ChunkPopulate_Pool(World world, Random random, Chunk chunk, org.bukkit.generator.BlockPopulator populator){
+        this.world = world;
+        this.random = random;
+        this.chunk = chunk;
+        this.populator = populator;
+    }
+    
+    @Override
+    protected void compute() {
+        populator.populate(world, random, chunk);
+    }
+
+}
diff -Naur src_origin/main/java/org/spigotmc/ActivationRange.java src/main/java/org/spigotmc/ActivationRange.java
--- src_origin/main/java/org/spigotmc/ActivationRange.java	2016-05-29 15:00:13.207641690 +0800
+++ src/main/java/org/spigotmc/ActivationRange.java	2016-05-29 23:33:01.675821741 +0800
@@ -1,6 +1,7 @@
 package org.spigotmc;
 
 import java.util.List;
+import java.util.Queue;
 import java.util.Set;
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.Chunk;
@@ -141,7 +142,8 @@
      */
     private static void activateChunkEntities(Chunk chunk)
     {
-        for ( List<Entity> slice : chunk.entitySlices )
+        //for ( List<Entity> slice : chunk.entitySlices )
+        for ( Queue<Entity> slice : chunk.entitySlices )
         {
             for ( Entity entity : slice )
             {
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2016-05-29 15:00:13.192641692 +0800
+++ src/main/java/org/spigotmc/AsyncCatcher.java	2016-05-29 23:33:01.667821742 +0800
@@ -14,4 +14,14 @@
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
         }
     }
+    
+    //hose
+    public static boolean catchOp_flag(String reason)
+    {
+        if ( enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread )
+        {
+            return true;
+        }
+        return false;
+    }
 }
diff -Naur src_origin/main/java/org/spigotmc/SpigotWorldConfig.java src/main/java/org/spigotmc/SpigotWorldConfig.java
--- src_origin/main/java/org/spigotmc/SpigotWorldConfig.java	2016-05-29 15:00:13.200641691 +0800
+++ src/main/java/org/spigotmc/SpigotWorldConfig.java	2016-05-29 23:32:53.533822487 +0800
@@ -1,12 +1,115 @@
 package org.spigotmc;
 
+import io.netty.util.internal.ConcurrentSet;
 import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.ForkJoinWorkerThread;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
 public class SpigotWorldConfig
 {
-
+    //hose start
+    static public final int cpu_core = Runtime.getRuntime().availableProcessors();
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fetp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("EntityTickPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fttp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("TileTickPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fpcp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("PlayerChunkPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcfp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkFlushPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcfpt3 = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkFlushPool_T3-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcpp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkPopulate_Pool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    public static ForkJoinPool EntityTickPool;
+    public static ForkJoinPool TileTickPool;
+    public static ForkJoinPool ChunkPool;
+    public static ForkJoinPool PlayerChunkPool;
+    public static ForkJoinPool ChunkFlushPool;
+    public static ForkJoinPool ChunkFlushPool_T3;
+    public static ForkJoinPool ChunkPopulate_Pool;
+    
+    /*
+    static public FutureTask CollideTask;
+        
+    static final ThreadFactory tfcp = new ThreadFactoryBuilder().setNameFormat("Collide_Pool-%d").build();
+    static public final ExecutorService collidepool_executor = Executors.newFixedThreadPool(cpu_core, tfcp);*/
+    
+    public static int worldtickentitypool_core_multiple;
+    
+    public static int getthreadnumber(){
+        return cpu_core*worldtickentitypool_core_multiple;
+    }
+    
+    private void wetp_core_multiple()
+    {
+        worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 4);
+        EntityTickPool = new ForkJoinPool(getthreadnumber(), fetp, null, false);
+        TileTickPool = new ForkJoinPool(getthreadnumber(), fttp, null, false);
+        ChunkPool = new ForkJoinPool(getthreadnumber(), fcp, null, false);
+        PlayerChunkPool = new ForkJoinPool(getthreadnumber(), fpcp, null, false);
+        ChunkFlushPool = new ForkJoinPool(getthreadnumber(), fcfp, null, false);
+        ChunkFlushPool_T3 = new ForkJoinPool(getthreadnumber(), fcfpt3, null, false);
+        ChunkPopulate_Pool = new ForkJoinPool(getthreadnumber(), fcpp, null, false);
+        //executor = new ThreadPoolExecutor(getthreadnumber(), getthreadnumber(), 1, TimeUnit.DAYS, queue);
+        log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
+    }
+    
+    
+    //hose end
+    
     private final String worldName;
     private final YamlConfiguration config;
     private boolean verbose;
