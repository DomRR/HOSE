diff -Naur src_origin/main/java/net/minecraft/server/Chunk.java src/main/java/net/minecraft/server/Chunk.java
--- src_origin/main/java/net/minecraft/server/Chunk.java	2016-06-17 04:20:29.232705958 +0800
+++ src/main/java/net/minecraft/server/Chunk.java	2016-06-17 04:20:35.764705359 +0800
@@ -15,6 +15,7 @@
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists; // CraftBukkit
+import java.util.Queue;
 import org.bukkit.Bukkit; // CraftBukkit
 
 public class Chunk {
@@ -32,7 +33,8 @@
     public final int locZ;
     private boolean m;
     public final Map<BlockPosition, TileEntity> tileEntities;
-    public final List<Entity>[] entitySlices; // Spigot
+    //public final List<Entity>[] entitySlices; // Spigot
+    public final Queue<Entity>[] entitySlices; // Hose
     private boolean done;
     private boolean lit;
     private boolean r;
@@ -82,14 +84,16 @@
         this.tileEntities = Maps.newHashMap();
         this.x = 4096;
         this.y = Queues.newConcurrentLinkedQueue();
-        this.entitySlices = (List[]) (new List[16]); // Spigot
+        //this.entitySlices = (List[]) (new List[16]); // Spigot
+        this.entitySlices = (Queue[]) (new ConcurrentLinkedQueue[16]); // Hose
         this.world = world;
         this.locX = i;
         this.locZ = j;
         this.heightMap = new int[256];
 
         for (int k = 0; k < this.entitySlices.length; ++k) {
-            this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            //this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[k] = new ConcurrentLinkedQueue(); // Hose
         }
 
         Arrays.fill(this.h, -999);
@@ -742,12 +746,13 @@
     public void addEntities() {
         this.j = true;
         this.world.b(this.tileEntities.values());
-        List[] aentityslice = this.entitySlices; // Spigot
+        //List[] aentityslice = this.entitySlices; // Spigot
+        Queue[] aentityslice = this.entitySlices; // Hose
         int i = aentityslice.length;
 
         for (int j = 0; j < i; ++j) {
-            List entityslice = aentityslice[j]; // Spigot
-
+            //List entityslice = aentityslice[j]; // Spigot
+            Queue entityslice = aentityslice[j]; // Hose
             this.world.a((Collection) entityslice);
         }
 
@@ -775,7 +780,8 @@
             this.world.b(tileentity);
         }
 
-        List[] aentityslice = this.entitySlices; // Spigot
+        //List[] aentityslice = this.entitySlices; // Spigot
+        Queue[] aentityslice = this.entitySlices; // Hose
         int i = aentityslice.length;
 
         for (int j = 0; j < i; ++j) {
@@ -1259,7 +1265,8 @@
         return this.tileEntities;
     }
 
-    public List<Entity>[] getEntitySlices() {
+    //public List<Entity>[] getEntitySlices() {
+    public Queue<Entity>[] getEntitySlices() {
         return this.entitySlices;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityInsentient.java src/main/java/net/minecraft/server/EntityInsentient.java
--- src_origin/main/java/net/minecraft/server/EntityInsentient.java	2016-06-17 04:20:29.581705926 +0800
+++ src/main/java/net/minecraft/server/EntityInsentient.java	2016-06-17 04:20:36.128705326 +0800
@@ -7,6 +7,7 @@
 import java.util.Map;
 import java.util.Random;
 import java.util.UUID;
+import java.util.concurrent.RecursiveAction;
 import javax.annotation.Nullable;
 
 // CraftBukkit start
@@ -16,6 +17,8 @@
 import org.bukkit.event.entity.EntityTargetEvent;
 import org.bukkit.event.entity.EntityUnleashEvent;
 import org.bukkit.event.entity.EntityUnleashEvent.UnleashReason;
+import org.hose.Tick_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class EntityInsentient extends EntityLiving {
@@ -24,7 +27,8 @@
     public int a_;
     protected int b_;
     private final ControllerLook lookController;
-    protected ControllerMove moveController;
+    //protected ControllerMove moveController;
+    public ControllerMove moveController;
     protected ControllerJump g;
     private final EntityAIBodyControl c;
     protected NavigationAbstract navigation;
@@ -645,8 +649,9 @@
 
         }
     }
-
-    protected final void doTick() {
+    
+    /*
+    public final void doTick_hose() {
         ++this.ticksFarFromPlayer;
         this.world.methodProfiler.a("checkDespawn");
         this.L();
@@ -688,8 +693,54 @@
         this.g.b();
         this.world.methodProfiler.b();
         this.world.methodProfiler.b();
-    }
+    }*/
+    MT_Pool mt_task;
+    protected final void doTick() {
+        ++this.ticksFarFromPlayer;
+        this.world.methodProfiler.a("checkDespawn");
+        this.L();
+        this.world.methodProfiler.b();
+        // Spigot Start
+        if ( this.fromMobSpawner )
+        {
+            return;
+        }
+        // Spigot End
+        this.world.methodProfiler.a("sensing");
+        this.bw.a();
+        this.world.methodProfiler.b();
+        this.world.methodProfiler.a("targetSelector");
+        this.targetSelector.a();
+        this.world.methodProfiler.b();
+        this.world.methodProfiler.a("goalSelector");
+        this.goalSelector.a();
+        this.world.methodProfiler.b();
+        this.world.methodProfiler.a("navigation");
+        this.navigation.l();
+        this.world.methodProfiler.b();
+        this.world.methodProfiler.a("mob tick");
+        //this.M();
+        mt_task = new MT_Pool(this);
+        mt_task.fork();
+        this.world.methodProfiler.b();
+        if (this.isPassenger() && this.bB() instanceof EntityInsentient) {
+            EntityInsentient entityinsentient = (EntityInsentient) this.bB();
+
+            entityinsentient.getNavigation().a(this.getNavigation().k(), 1.5D);
+            entityinsentient.getControllerMove().a(this.getControllerMove());
+        }
 
+        this.world.methodProfiler.a("controls");
+        this.world.methodProfiler.a("move");
+        this.moveController.c();
+         this.world.methodProfiler.c("look");
+        this.lookController.a();
+        this.world.methodProfiler.c("jump");
+        this.g.b();
+        this.world.methodProfiler.b();
+        this.world.methodProfiler.b();
+    }
+    
     protected void M() {}
 
     public int N() {
@@ -1270,4 +1321,17 @@
 
         private EnumEntityPositionType() {}
     }
+    
+    public class MT_Pool extends RecursiveAction {
+    EntityInsentient ei;
+    
+    public MT_Pool(EntityInsentient ei){
+        this.ei = ei;
+    }
+    
+    @Override
+    protected void compute() {
+        ei.M();
+    }
+}
 }
diff -Naur src_origin/main/java/net/minecraft/server/Entity.java src/main/java/net/minecraft/server/Entity.java
--- src_origin/main/java/net/minecraft/server/Entity.java	2016-06-17 04:20:29.435705939 +0800
+++ src/main/java/net/minecraft/server/Entity.java	2016-06-17 04:20:35.971705340 +0800
@@ -2,15 +2,19 @@
 
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
+import java.util.concurrent.RecursiveAction;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -37,6 +41,9 @@
 import org.bukkit.event.entity.EntityCombustEvent;
 import org.bukkit.event.entity.EntityPortalEvent;
 import org.bukkit.plugin.PluginManager;
+import org.hose.TE_Pool;
+import org.hose.Tick_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class Entity implements ICommandListener {
@@ -295,12 +302,16 @@
         this.a(new AxisAlignedBB(d0 - (double) f, d1, d2 - (double) f, d0 + (double) f, d1 + (double) f1, d2 + (double) f));
     }
 
+    Tick_Pool t_task;
     public void m() {
         if (!this.world.isClientSide) {
             this.setFlag(6, this.aO());
         }
 
-        this.U();
+        //this.U();
+        t_task = new Tick_Pool(this);
+        t_task.fork();
+        //SpigotWorldConfig.move_forks.add(t_task);
     }
 
     public void U() {
@@ -465,7 +476,7 @@
         return this.world.getCubes(this, axisalignedbb).isEmpty() && !this.world.containsLiquid(axisalignedbb);
     }
 
-    public void move(double d0, double d1, double d2) {
+    public void move_hose(double d0, double d1, double d2) {
         org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.startTiming(); // Spigot
         if (this.noclip) {
             this.a(this.getBoundingBox().c(d0, d1, d2));
@@ -760,8 +771,56 @@
                 }
             }
 
-            // CraftBukkit start - Move to the top of the method
-            /*
+            boolean flag2 = this.ai();
+
+            if (this.world.f(this.getBoundingBox().shrink(0.001D))) {
+                this.burn(1);
+                if (!flag2) {
+                    ++this.fireTicks;
+                    // CraftBukkit start - Not on fire yet
+                    if (this.fireTicks <= 0) { // Only throw events on the first combust, otherwise it spams
+                        EntityCombustEvent event = new org.bukkit.event.entity.EntityCombustByBlockEvent(null, getBukkitEntity(), 8);
+                        world.getServer().getPluginManager().callEvent(event);
+
+                        if (!event.isCancelled()) {
+                            setOnFire(event.getDuration());
+                        }
+                    } else {
+                        // CraftBukkit end
+                        this.setOnFire(8);
+                    }
+                }
+            } else if (this.fireTicks <= 0) {
+                this.fireTicks = -this.maxFireTicks;
+            }
+
+            if (flag2 && this.fireTicks > 0) {
+                this.a(SoundEffects.bG, 0.7F, 1.6F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
+                this.fireTicks = -this.maxFireTicks;
+            }
+
+            this.world.methodProfiler.b();
+        }
+        org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.stopTiming(); // Spigot
+    }
+    
+    TE_Pool te_task;
+    public void move(double d0, double d1, double d2) {
+        /*double[] pos = {d0, d1, d2};
+        SpigotWorldConfig.entity_move.put(this, pos);*/
+        /*
+        m_task = new move(d0, d1, d2);
+        SpigotWorldConfig.move_forks.add(m_task);*/
+        //m_task.fork();
+        
+        
+        org.bukkit.craftbukkit.SpigotTimings.entityMoveTimer.startTiming(); // Spigot
+        if (this.noclip) {
+            this.a(this.getBoundingBox().c(d0, d1, d2));
+            this.recalcPosition();
+        } else {
+            // CraftBukkit start - Don't do anything if we aren't moving
+            // We need to do this regardless of whether or not we are moving thanks to portals
             try {
                 this.checkBlockCollisions();
             } catch (Throwable throwable) {
@@ -771,8 +830,290 @@
                 this.appendEntityCrashDetails(crashreportsystemdetails);
                 throw new ReportedException(crashreport);
             }
-            */
+            // Check if we're moving
+            if (d0 == 0 && d1 == 0 && d2 == 0 && this.isVehicle() && this.isPassenger()) {
+                return;
+            }
             // CraftBukkit end
+            this.world.methodProfiler.a("move");
+            double d3 = this.locX;
+            double d4 = this.locY;
+            double d5 = this.locZ;
+
+            if (this.E) {
+                this.E = false;
+                d0 *= 0.25D;
+                d1 *= 0.05000000074505806D;
+                d2 *= 0.25D;
+                this.motX = 0.0D;
+                this.motY = 0.0D;
+                this.motZ = 0.0D;
+            }
+
+            double d6 = d0;
+            double d7 = d1;
+            double d8 = d2;
+            boolean flag = this.onGround && this.isSneaking() && this instanceof EntityHuman;
+
+            if (flag) {
+                for (double d9 = 0.05D; d0 != 0.0D && this.world.getCubes(this, this.getBoundingBox().c(d0, -1.0D, 0.0D)).isEmpty(); d6 = d0) {
+                    if (d0 < 0.05D && d0 >= -0.05D) {
+                        d0 = 0.0D;
+                    } else if (d0 > 0.0D) {
+                        d0 -= 0.05D;
+                    } else {
+                        d0 += 0.05D;
+                    }
+                }
+
+                for (; d2 != 0.0D && this.world.getCubes(this, this.getBoundingBox().c(0.0D, -1.0D, d2)).isEmpty(); d8 = d2) {
+                    if (d2 < 0.05D && d2 >= -0.05D) {
+                        d2 = 0.0D;
+                    } else if (d2 > 0.0D) {
+                        d2 -= 0.05D;
+                    } else {
+                        d2 += 0.05D;
+                    }
+                }
+
+                for (; d0 != 0.0D && d2 != 0.0D && this.world.getCubes(this, this.getBoundingBox().c(d0, -1.0D, d2)).isEmpty(); d8 = d2) {
+                    if (d0 < 0.05D && d0 >= -0.05D) {
+                        d0 = 0.0D;
+                    } else if (d0 > 0.0D) {
+                        d0 -= 0.05D;
+                    } else {
+                        d0 += 0.05D;
+                    }
+
+                    d6 = d0;
+                    if (d2 < 0.05D && d2 >= -0.05D) {
+                        d2 = 0.0D;
+                    } else if (d2 > 0.0D) {
+                        d2 -= 0.05D;
+                    } else {
+                        d2 += 0.05D;
+                    }
+                }
+            }
+
+            //List list = this.world.getCubes(this, this.getBoundingBox().a(d0, d1, d2));
+            te_task = new TE_Pool(this, d0, d1, d2);
+            te_task.fork();
+            List list = te_task.join(); 
+            
+            AxisAlignedBB axisalignedbb = this.getBoundingBox();
+            int i = 0;
+
+            int j;
+
+            for (j = list.size(); i < j; ++i) {
+                d1 = ((AxisAlignedBB) list.get(i)).b(this.getBoundingBox(), d1);
+            }
+
+            this.a(this.getBoundingBox().c(0.0D, d1, 0.0D));
+            boolean flag1 = this.onGround || d7 != d1 && d7 < 0.0D;
+
+            j = 0;
+
+            int k;
+
+            for (k = list.size(); j < k; ++j) {
+                d0 = ((AxisAlignedBB) list.get(j)).a(this.getBoundingBox(), d0);
+            }
+
+            this.a(this.getBoundingBox().c(d0, 0.0D, 0.0D));
+            j = 0;
+
+            for (k = list.size(); j < k; ++j) {
+                d2 = ((AxisAlignedBB) list.get(j)).c(this.getBoundingBox(), d2);
+            }
+
+            this.a(this.getBoundingBox().c(0.0D, 0.0D, d2));
+            double d10;
+
+            if (this.P > 0.0F && flag1 && (d6 != d0 || d8 != d2)) {
+                double d11 = d0;
+                double d12 = d1;
+                double d13 = d2;
+                AxisAlignedBB axisalignedbb1 = this.getBoundingBox();
+
+                this.a(axisalignedbb);
+                d1 = (double) this.P;
+                //List list1 = this.world.getCubes(this, this.getBoundingBox().a(d6, d1, d8));
+                te_task = new TE_Pool(this, d6, d1, d8);
+                te_task.fork();
+                List list1 = te_task.join(); 
+                AxisAlignedBB axisalignedbb2 = this.getBoundingBox();
+                AxisAlignedBB axisalignedbb3 = axisalignedbb2.a(d6, 0.0D, d8);
+
+                d10 = d1;
+                int l = 0;
+
+                for (int i1 = list1.size(); l < i1; ++l) {
+                    d10 = ((AxisAlignedBB) list1.get(l)).b(axisalignedbb3, d10);
+                }
+
+                axisalignedbb2 = axisalignedbb2.c(0.0D, d10, 0.0D);
+                double d14 = d6;
+                int j1 = 0;
+
+                for (int k1 = list1.size(); j1 < k1; ++j1) {
+                    d14 = ((AxisAlignedBB) list1.get(j1)).a(axisalignedbb2, d14);
+                }
+
+                axisalignedbb2 = axisalignedbb2.c(d14, 0.0D, 0.0D);
+                double d15 = d8;
+                int l1 = 0;
+
+                for (int i2 = list1.size(); l1 < i2; ++l1) {
+                    d15 = ((AxisAlignedBB) list1.get(l1)).c(axisalignedbb2, d15);
+                }
+
+                axisalignedbb2 = axisalignedbb2.c(0.0D, 0.0D, d15);
+                AxisAlignedBB axisalignedbb4 = this.getBoundingBox();
+                double d16 = d1;
+                int j2 = 0;
+
+                for (int k2 = list1.size(); j2 < k2; ++j2) {
+                    d16 = ((AxisAlignedBB) list1.get(j2)).b(axisalignedbb4, d16);
+                }
+
+                axisalignedbb4 = axisalignedbb4.c(0.0D, d16, 0.0D);
+                double d17 = d6;
+                int l2 = 0;
+
+                for (int i3 = list1.size(); l2 < i3; ++l2) {
+                    d17 = ((AxisAlignedBB) list1.get(l2)).a(axisalignedbb4, d17);
+                }
+
+                axisalignedbb4 = axisalignedbb4.c(d17, 0.0D, 0.0D);
+                double d18 = d8;
+                int j3 = 0;
+
+                for (int k3 = list1.size(); j3 < k3; ++j3) {
+                    d18 = ((AxisAlignedBB) list1.get(j3)).c(axisalignedbb4, d18);
+                }
+
+                axisalignedbb4 = axisalignedbb4.c(0.0D, 0.0D, d18);
+                double d19 = d14 * d14 + d15 * d15;
+                double d20 = d17 * d17 + d18 * d18;
+
+                if (d19 > d20) {
+                    d0 = d14;
+                    d2 = d15;
+                    d1 = -d10;
+                    this.a(axisalignedbb2);
+                } else {
+                    d0 = d17;
+                    d2 = d18;
+                    d1 = -d16;
+                    this.a(axisalignedbb4);
+                }
+
+                int l3 = 0;
+
+                for (int i4 = list1.size(); l3 < i4; ++l3) {
+                    d1 = ((AxisAlignedBB) list1.get(l3)).b(this.getBoundingBox(), d1);
+                }
+
+                this.a(this.getBoundingBox().c(0.0D, d1, 0.0D));
+                if (d11 * d11 + d13 * d13 >= d0 * d0 + d2 * d2) {
+                    d0 = d11;
+                    d1 = d12;
+                    d2 = d13;
+                    this.a(axisalignedbb1);
+                }
+            }
+
+            this.world.methodProfiler.b();
+            this.world.methodProfiler.a("rest");
+            this.recalcPosition();
+            this.positionChanged = d6 != d0 || d8 != d2;
+            this.B = d7 != d1;
+            this.onGround = this.B && d7 < 0.0D;
+            this.C = this.positionChanged || this.B;
+            j = MathHelper.floor(this.locX);
+            k = MathHelper.floor(this.locY - 0.20000000298023224D);
+            int j4 = MathHelper.floor(this.locZ);
+            BlockPosition blockposition = new BlockPosition(j, k, j4);
+            IBlockData iblockdata = this.world.getType(blockposition);
+
+            if (iblockdata.getMaterial() == Material.AIR) {
+                BlockPosition blockposition1 = blockposition.down();
+                IBlockData iblockdata1 = this.world.getType(blockposition1);
+                Block block = iblockdata1.getBlock();
+
+                if (block instanceof BlockFence || block instanceof BlockCobbleWall || block instanceof BlockFenceGate) {
+                    iblockdata = iblockdata1;
+                    blockposition = blockposition1;
+                }
+            }
+
+            this.a(d1, this.onGround, iblockdata, blockposition);
+            if (d6 != d0) {
+                this.motX = 0.0D;
+            }
+
+            if (d8 != d2) {
+                this.motZ = 0.0D;
+            }
+
+            Block block1 = iblockdata.getBlock();
+
+            if (d7 != d1) {
+                block1.a(this.world, this);
+            }
+
+            // CraftBukkit start
+            if (positionChanged && getBukkitEntity() instanceof Vehicle) {
+                Vehicle vehicle = (Vehicle) this.getBukkitEntity();
+                org.bukkit.block.Block bl = this.world.getWorld().getBlockAt(MathHelper.floor(this.locX), MathHelper.floor(this.locY), MathHelper.floor(this.locZ));
+
+                if (d6 > d0) {
+                    bl = bl.getRelative(BlockFace.EAST);
+                } else if (d6 < d0) {
+                    bl = bl.getRelative(BlockFace.WEST);
+                } else if (d8 > d2) {
+                    bl = bl.getRelative(BlockFace.SOUTH);
+                } else if (d8 < d2) {
+                    bl = bl.getRelative(BlockFace.NORTH);
+                }
+
+                VehicleBlockCollisionEvent event = new VehicleBlockCollisionEvent(vehicle, bl);
+                world.getServer().getPluginManager().callEvent(event);
+            }
+            // CraftBukkit end
+
+            if (this.playStepSound() && !flag && !this.isPassenger()) {
+                double d21 = this.locX - d3;
+                double d22 = this.locY - d4;
+
+                d10 = this.locZ - d5;
+                if (block1 != Blocks.LADDER) {
+                    d22 = 0.0D;
+                }
+
+                if (block1 != null && this.onGround) {
+                    block1.stepOn(this.world, blockposition, this);
+                }
+
+                this.J = (float) ((double) this.J + (double) MathHelper.sqrt(d21 * d21 + d10 * d10) * 0.6D);
+                this.K = (float) ((double) this.K + (double) MathHelper.sqrt(d21 * d21 + d22 * d22 + d10 * d10) * 0.6D);
+                if (this.K > (float) this.ax && iblockdata.getMaterial() != Material.AIR) {
+                    this.ax = (int) this.K + 1;
+                    if (this.isInWater()) {
+                        float f = MathHelper.sqrt(this.motX * this.motX * 0.20000000298023224D + this.motY * this.motY + this.motZ * this.motZ * 0.20000000298023224D) * 0.35F;
+
+                        if (f > 1.0F) {
+                            f = 1.0F;
+                        }
+
+                        this.a(this.aa(), f, 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.4F);
+                    }
+
+                    this.a(blockposition, block1);
+                }
+            }
 
             boolean flag2 = this.ai();
 
@@ -2654,4 +2995,20 @@
 
         }
     }
+    
+    class move extends RecursiveAction {
+        double d0, d1, d2;
+        
+        move(double d0, double d1, double d2) {
+            this.d0 = d0;
+            this.d1 = d1;
+            this.d2 = d2;
+        }
+        
+        @Override
+        protected void compute() {
+            move_hose(d0, d1, d2);
+        }
+                 
+    }
 }
diff -Naur src_origin/main/java/net/minecraft/server/EntityLiving.java src/main/java/net/minecraft/server/EntityLiving.java
--- src_origin/main/java/net/minecraft/server/EntityLiving.java	2016-06-17 04:20:29.618705922 +0800
+++ src/main/java/net/minecraft/server/EntityLiving.java	2016-06-17 04:20:36.178705321 +0800
@@ -14,6 +14,7 @@
 import java.util.ArrayList;
 import com.google.common.base.Function;
 import com.google.common.collect.Lists;
+import java.util.concurrent.RecursiveAction;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.attribute.CraftAttributeMap;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
@@ -27,6 +28,7 @@
 // CraftBukkit end
 
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.hose.GE_Pool;
 
 public abstract class EntityLiving extends Entity {
 
@@ -1915,6 +1917,8 @@
         return f1;
     }
 
+    Collide co_task;
+    ai_move aim_task;
     public void n() {
         if (this.bC > 0) {
             --this.bC;
@@ -1958,7 +1962,9 @@
             this.bh = 0.0F;
         } else if (this.ct()) {
             this.world.methodProfiler.a("newAi");
-            this.doTick();
+            //this.doTick();
+            Tick t_task = new Tick(this);
+            t_task.fork();
             this.world.methodProfiler.b();
         }
         SpigotTimings.timerEntityAI.stopTiming(); // Spigot
@@ -1985,12 +1991,16 @@
         this.bh *= 0.9F;
         this.r();
         SpigotTimings.timerEntityAIMove.startTiming(); // Spigot
-        this.g(this.bf, this.bg);
+        //this.g(this.bf, this.bg);
+        aim_task = new ai_move(this);
+        aim_task.fork();
         SpigotTimings.timerEntityAIMove.stopTiming(); // Spigot
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("push");
         SpigotTimings.timerEntityAICollision.startTiming(); // Spigot
-        this.cs();
+        //this.cs();
+        co_task = new Collide(this);
+        co_task.fork();
         SpigotTimings.timerEntityAICollision.stopTiming(); // Spigot
         this.world.methodProfiler.b();
     }
@@ -2022,12 +2032,13 @@
 
     protected void doTick() {}
 
+    GE_Pool ge_task;
     protected void cs() {
         List list = this.world.getEntities(this, this.getBoundingBox(), IEntitySelector.a(this));
-
+        
         if (!list.isEmpty()) {
-                numCollisions = Math.max(0, numCollisions - world.spigotConfig.maxCollisionsPerEntity); // Spigot
-                for (int i = 0; i < list.size() && numCollisions < world.spigotConfig.maxCollisionsPerEntity; ++i) {
+            numCollisions = Math.max(0, numCollisions - world.spigotConfig.maxCollisionsPerEntity); // Spigot
+            for (int i = 0; i < list.size() && numCollisions < world.spigotConfig.maxCollisionsPerEntity; ++i) {
                 Entity entity = (Entity) list.get(i);
                 // TODO better check now?
                 // CraftBukkit start - Only handle mob (non-player) collisions every other tick
@@ -2418,4 +2429,50 @@
 
         }
     }
+    
+    class Collide extends RecursiveAction {
+        EntityLiving el;
+
+        public Collide(EntityLiving el){
+            this.el = el;
+
+        }
+
+        @Override
+        protected void compute() {
+            el.cs();
+        }
+
+    }
+    
+    class Tick extends RecursiveAction {
+        EntityLiving el;
+
+        public Tick(EntityLiving el){
+            this.el = el;
+
+        }
+
+        @Override
+        protected void compute() {
+            el.doTick();
+        }
+
+    }
+    
+    class ai_move extends RecursiveAction {
+        EntityLiving el;
+
+        public ai_move(EntityLiving el){
+            this.el = el;
+
+        }
+
+        @Override
+        protected void compute() {
+            el.g(el.bf, el.bg);
+        }
+
+    }
+    
 }
diff -Naur src_origin/main/java/net/minecraft/server/EntityTracker.java src/main/java/net/minecraft/server/EntityTracker.java
--- src_origin/main/java/net/minecraft/server/EntityTracker.java	2016-06-17 04:20:29.754705910 +0800
+++ src/main/java/net/minecraft/server/EntityTracker.java	2016-06-17 04:20:36.310705309 +0800
@@ -12,7 +12,8 @@
 
     private static final Logger a = LogManager.getLogger();
     private final WorldServer world;
-    private final Set<EntityTrackerEntry> c = Sets.newHashSet();
+    //private final Set<EntityTrackerEntry> c = Sets.newHashSet();
+    private final Set<EntityTrackerEntry> c = Sets.newConcurrentHashSet();
     public final IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
     private int e;
 
@@ -147,7 +148,7 @@
     }
 
     public void untrackEntity(Entity entity) {
-        org.spigotmc.AsyncCatcher.catchOp( "entity untrack"); // Spigot
+        //org.spigotmc.AsyncCatcher.catchOp( "entity untrack"); // Spigot
         if (entity instanceof EntityPlayer) {
             EntityPlayer entityplayer = (EntityPlayer) entity;
             Iterator iterator = this.c.iterator();
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2016-06-17 04:20:29.995705888 +0800
+++ src/main/java/net/minecraft/server/MinecraftServer.java	2016-06-17 04:20:36.553705287 +0800
@@ -33,6 +33,7 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
 import java.util.Random;
@@ -40,6 +41,7 @@
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executors;
 import java.util.concurrent.FutureTask;
+import java.util.concurrent.RecursiveAction;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
 import org.apache.commons.lang3.Validate;
@@ -51,6 +53,8 @@
 import org.bukkit.craftbukkit.CraftServer;
 // CraftBukkit end
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.hose.ChunkGen_Pool;
+import org.spigotmc.SpigotWorldConfig;
 
 public abstract class MinecraftServer implements Runnable, ICommandListener, IAsyncTaskHandler, IMojangStatistics {
 
@@ -359,6 +363,9 @@
             long j = av();
             i = 0;
 
+            //hose
+            List<int[]> chunkgen_list = new LinkedList();
+            int[] pos = new int[2];
             for (int k = -192; k <= 192 && this.isRunning(); k += 16) {
                 for (int l = -192; l <= 192 && this.isRunning(); l += 16) {
                     long i1 = av();
@@ -369,9 +376,13 @@
                     }
 
                     ++i;
-                    worldserver.getChunkProviderServer().getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    //worldserver.getChunkProviderServer().getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    pos[0] = blockposition.getX() + k >> 4;
+                    pos[1] = blockposition.getZ() + l >> 4;
+                    chunkgen_list.add(pos);
                 }
             }
+            SpigotWorldConfig.ChunkPool.invoke(new ChunkGen_Pool(worldserver, chunkgen_list));
         }
 
         for (WorldServer world : this.worlds) {
@@ -766,7 +777,7 @@
 
         for (i = 0; i < this.worlds.size(); ++i) { // CraftBukkit
             long j = System.nanoTime();
-
+            
             // if (i == 0 || this.getAllowNether()) {
                 WorldServer worldserver = this.worlds.get(i);
 
@@ -802,6 +813,11 @@
                 try {
                     worldserver.timings.tickEntities.startTiming(); // Spigot
                     worldserver.tickEntities();
+                    //entity move
+                    /*for (RecursiveAction task : SpigotWorldConfig.move_forks) {
+                        task.fork();
+                    }
+                    SpigotWorldConfig.move_forks.clear();*/
                     worldserver.timings.tickEntities.stopTiming(); // Spigot
                 } catch (Throwable throwable1) {
                     // Spigot Start
@@ -1034,7 +1050,8 @@
     }
 
     public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        //return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "Hose"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1116,7 +1133,8 @@
     }
 
     public String getName() {
-        return "Server";
+        //return "Server";
+        return org.bukkit.ChatColor.GREEN + "Server";
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
diff -Naur src_origin/main/java/net/minecraft/server/PlayerChunkMap.java src/main/java/net/minecraft/server/PlayerChunkMap.java
--- src_origin/main/java/net/minecraft/server/PlayerChunkMap.java	2016-06-17 04:20:30.145705874 +0800
+++ src/main/java/net/minecraft/server/PlayerChunkMap.java	2016-06-17 04:20:36.703705273 +0800
@@ -42,7 +42,8 @@
     private final WorldServer world;
     private final List<EntityPlayer> managedPlayers = Lists.newArrayList();
     private final Long2ObjectMap<PlayerChunk> e = new Long2ObjectOpenHashMap(4096);
-    private final Set<PlayerChunk> f = Sets.newHashSet();
+    //private final Set<PlayerChunk> f = Sets.newHashSet();
+    private final Set<PlayerChunk> f = Sets.newConcurrentHashSet();
     private final List<PlayerChunk> g = Lists.newLinkedList();
     private final List<PlayerChunk> h = Lists.newLinkedList();
     private final List<PlayerChunk> i = Lists.newArrayList();
diff -Naur src_origin/main/java/net/minecraft/server/SpawnerCreature.java src/main/java/net/minecraft/server/SpawnerCreature.java
--- src_origin/main/java/net/minecraft/server/SpawnerCreature.java	2016-06-17 04:20:30.309705859 +0800
+++ src/main/java/net/minecraft/server/SpawnerCreature.java	2016-06-17 04:20:36.868705258 +0800
@@ -1,8 +1,10 @@
 package net.minecraft.server;
 
+import com.google.common.collect.Sets;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
+import java.util.Set;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.util.LongHash;
@@ -13,7 +15,8 @@
 public final class SpawnerCreature {
 
     private static final int a = (int) Math.pow(17.0D, 2.0D);
-    private final LongHashSet b = new LongHashSet(); // CraftBukkit
+    //private final LongHashSet b = new LongHashSet(); // CraftBukkit
+    private final Set b = Sets.newConcurrentHashSet();
 
     public SpawnerCreature() {}
 
@@ -29,7 +32,9 @@
             int z = LongHash.lsw( coord );
             if ( !((ChunkProviderServer)server.chunkProvider).unloadQueue.contains( coord ) && server.isChunkLoaded( x, z, true ) )
             {
-                i += server.getChunkAt( x, z ).entityCount.get( oClass );
+                synchronized (this){
+                    i += server.getChunkAt( x, z ).entityCount.get( oClass );
+                }
             }
         }
         return i;
diff -Naur src_origin/main/java/net/minecraft/server/World.java src/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2016-06-17 04:20:30.435705848 +0800
+++ src/main/java/net/minecraft/server/World.java	2016-06-17 04:20:36.988705247 +0800
@@ -15,7 +15,10 @@
 
 // CraftBukkit start
 import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
 import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.RecursiveAction;
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
@@ -59,14 +62,17 @@
         }
     };
     // Spigot end
-    protected final List<Entity> f = Lists.newArrayList();
+    //protected final List<Entity> f = Lists.newArrayList();
+    protected final Queue<Entity> f = Queues.newConcurrentLinkedQueue();
     public final List<TileEntity> tileEntityList = Lists.newArrayList();
     public final List<TileEntity> tileEntityListTick = Lists.newArrayList();
     private final List<TileEntity> b = Lists.newArrayList();
     private final List<TileEntity> tileEntityListUnload = Lists.newArrayList();
     public final List<EntityHuman> players = Lists.newArrayList();
-    public final List<Entity> j = Lists.newArrayList();
-    protected final IntHashMap<Entity> entitiesById = new IntHashMap();
+    //public final List<Entity> j = Lists.newArrayList();
+    public final Queue<Entity> j = Queues.newConcurrentLinkedQueue();
+    //protected final IntHashMap<Entity> entitiesById = new IntHashMap();
+    protected final Map<Integer, Entity> entitiesById = Maps.newConcurrentMap();
     private final long I = 16777215L;
     private int J;
     protected int l = (new Random()).nextInt();
@@ -950,7 +956,7 @@
     }
 
     public boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
-        org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
+        //org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
         if (entity == null) return false;
         // CraftBukkit end
         int i = MathHelper.floor(entity.locX / 16.0D);
@@ -1030,12 +1036,12 @@
 
         entity.valid = true; // CraftBukkit
     }
-
+    
     protected void c(Entity entity) {
         for (int i = 0; i < this.u.size(); ++i) {
             ((IWorldAccess) this.u.get(i)).b(entity);
         }
-
+        
         entity.valid = false; // CraftBukkit
     }
 
@@ -1343,9 +1349,39 @@
         this.methodProfiler.a("entities");
         this.methodProfiler.a("global");
 
-        int i;
+        //int i;
         Entity entity;
+        
+        Iterator it_j = this.j.iterator();
+        while (it_j.hasNext()) {
+            entity = (Entity) it_j.next();
+            // CraftBukkit start - Fixed an NPE
+            if (entity == null) {
+                continue;
+            }
+            // CraftBukkit end
+
+            try {
+                ++entity.ticksLived;
+                entity.m();
+            } catch (Throwable throwable) {
+                CrashReport crashreport = CrashReport.a(throwable, "Ticking entity");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity being ticked");
+
+                if (entity == null) {
+                    crashreportsystemdetails.a("Entity", (Object) "~~NULL~~");
+                } else {
+                    entity.appendEntityCrashDetails(crashreportsystemdetails);
+                }
 
+                throw new ReportedException(crashreport);
+            }
+
+            if (entity.dead) {
+                this.j.remove(entity);
+            }
+        }
+        /*
         for (i = 0; i < this.j.size(); ++i) {
             entity = (Entity) this.j.get(i);
             // CraftBukkit start - Fixed an NPE
@@ -1373,13 +1409,24 @@
             if (entity.dead) {
                 this.j.remove(i--);
             }
-        }
+        }*/
 
         this.methodProfiler.c("remove");
         this.entityList.removeAll(this.f);
 
         int j;
 
+        Iterator it = this.f.iterator();
+        while (it.hasNext()) {
+            entity = (Entity) it.next();
+            int k = entity.ac;
+
+            j = entity.ae;
+            if (entity.ab && this.isChunkLoaded(k, j, true)) {
+                this.getChunkAt(k, j).b(entity);
+            }
+        }
+        /*
         for (i = 0; i < this.f.size(); ++i) {
             entity = (Entity) this.f.get(i);
             int k = entity.ac;
@@ -1388,11 +1435,16 @@
             if (entity.ab && this.isChunkLoaded(k, j, true)) {
                 this.getChunkAt(k, j).b(entity);
             }
-        }
+        }*/
 
+        Iterator it1 = this.f.iterator();
+        while (it1.hasNext()) {
+            this.c((Entity) it1.next());
+        }
+        /*
         for (i = 0; i < this.f.size(); ++i) {
             this.c((Entity) this.f.get(i));
-        }
+        }*/
 
         this.f.clear();
         this.l();
@@ -1428,6 +1480,8 @@
                 try {
                     SpigotTimings.tickEntityTimer.startTiming(); // Spigot
                     this.g(entity);
+                    /*tg_task = new TG_Pool(this, entity);
+                    SpigotWorldConfig.move_forks.add(tg_task);*/
                     SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
                 } catch (Throwable throwable1) {
                     crashreport1 = CrashReport.a(throwable1, "Ticking entity");
@@ -1455,8 +1509,16 @@
 
             this.methodProfiler.b();
         }
+        /*
+        for (RecursiveAction task : SpigotWorldConfig.move_forks) {
+            task.fork();
+        }
+        for (RecursiveAction task : SpigotWorldConfig.move_forks) {
+            task.join();
+        }
+        SpigotWorldConfig.move_forks.clear();*/
         guardEntityList = false; // Spigot
-
+        
         timings.entityTick.stopTiming(); // Spigot
         this.methodProfiler.c("blockEntities");
         this.M = true;
diff -Naur src_origin/main/java/net/minecraft/server/WorldManager.java src/main/java/net/minecraft/server/WorldManager.java
--- src_origin/main/java/net/minecraft/server/WorldManager.java	2016-06-17 04:20:30.465705845 +0800
+++ src/main/java/net/minecraft/server/WorldManager.java	2016-06-17 04:20:37.052705241 +0800
@@ -23,7 +23,7 @@
 
     }
 
-    public void b(Entity entity) {
+    public synchronized void b(Entity entity) {
         this.world.getTracker().untrackEntity(entity);
         this.world.getScoreboard().a(entity);
         if (entity instanceof EntityPlayer) {
diff -Naur src_origin/main/java/net/minecraft/server/WorldMap.java src/main/java/net/minecraft/server/WorldMap.java
--- src_origin/main/java/net/minecraft/server/WorldMap.java	2016-06-17 04:20:30.499705842 +0800
+++ src/main/java/net/minecraft/server/WorldMap.java	2016-06-17 04:20:37.075705239 +0800
@@ -25,7 +25,8 @@
     public byte scale;
     public byte[] colors = new byte[16384];
     public List<WorldMap.WorldMapHumanTracker> h = Lists.newArrayList();
-    public final Map<EntityHuman, WorldMap.WorldMapHumanTracker> j = Maps.newHashMap(); // Spigot
+    //public final Map<EntityHuman, WorldMap.WorldMapHumanTracker> j = Maps.newHashMap(); // Spigot
+    public final Map<EntityHuman, WorldMap.WorldMapHumanTracker> j = Maps.newConcurrentMap();
     public Map<UUID, MapIcon> decorations = Maps.newLinkedHashMap(); // Spigot
 
     // CraftBukkit start
diff -Naur src_origin/main/java/net/minecraft/server/WorldServer.java src/main/java/net/minecraft/server/WorldServer.java
--- src_origin/main/java/net/minecraft/server/WorldServer.java	2016-06-17 04:20:30.515705840 +0800
+++ src/main/java/net/minecraft/server/WorldServer.java	2016-06-17 04:20:37.076705239 +0800
@@ -38,6 +38,7 @@
     private final PlayerChunkMap manager;
     // private final Set<NextTickListEntry> nextTickListHash = Sets.newHashSet();
     private final HashTreeSet<NextTickListEntry> nextTickList = new HashTreeSet<NextTickListEntry>(); // CraftBukkit - HashTreeSet
+    //private final Set<NextTickListEntry> nextTickList = Sets.newLinkedHashSet();
     private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
     public boolean savingDisabled;
     private boolean O;
@@ -709,7 +710,8 @@
                 NextTickListEntry nextticklistentry;
 
                 for (int j = 0; j < i; ++j) {
-                    nextticklistentry = (NextTickListEntry) this.nextTickList.first();
+                    //nextticklistentry = (NextTickListEntry) this.nextTickList.first();
+                    nextticklistentry = (NextTickListEntry) this.nextTickList.iterator().next();
                     if (!flag && nextticklistentry.b > this.worldData.getTime()) {
                         break;
                     }
@@ -1124,7 +1126,8 @@
 
     protected void b(Entity entity) {
         super.b(entity);
-        this.entitiesById.a(entity.getId(), entity);
+        //this.entitiesById.a(entity.getId(), entity);
+        this.entitiesById.put(entity.getId(), entity);
         this.entitiesByUUID.put(entity.getUniqueID(), entity);
         Entity[] aentity = entity.aT();
 
@@ -1135,7 +1138,8 @@
             for (int j = 0; j < i; ++j) {
                 Entity entity1 = aentity1[j];
 
-                this.entitiesById.a(entity1.getId(), entity1);
+                //this.entitiesById.a(entity1.getId(), entity1);
+                this.entitiesById.put(entity1.getId(), entity1);
             }
         }
 
@@ -1143,7 +1147,8 @@
 
     protected void c(Entity entity) {
         super.c(entity);
-        this.entitiesById.d(entity.getId());
+        //this.entitiesById.d(entity.getId());
+        this.entitiesById.remove(entity.getId());
         this.entitiesByUUID.remove(entity.getUniqueID());
         Entity[] aentity = entity.aT();
 
@@ -1154,7 +1159,8 @@
             for (int j = 0; j < i; ++j) {
                 Entity entity1 = aentity1[j];
 
-                this.entitiesById.d(entity1.getId());
+                //this.entitiesById.d(entity1.getId());
+                this.entitiesById.remove(entity1.getId());
             }
         }
 
diff -Naur src_origin/main/java/org/hose/ChunkFlush_Pool.java src/main/java/org/hose/ChunkFlush_Pool.java
--- src_origin/main/java/org/hose/ChunkFlush_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChunkFlush_Pool.java	2016-06-17 04:20:34.931705435 +0800
@@ -0,0 +1,53 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.PlayerChunk;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkFlush_Pool extends RecursiveAction {//need to use callable
+    List<PlayerChunk> chunkflush_list;
+    
+    public ChunkFlush_Pool(List<PlayerChunk> chunkflush_list){
+        this.chunkflush_list = chunkflush_list;
+    }
+    
+    @Override
+    protected void compute() {
+        List<RecursiveAction> forks = new LinkedList();
+        for (PlayerChunk pc : chunkflush_list) {
+            chunkflush task = new chunkflush(pc);
+            forks.add(task);
+            task.fork();
+            //task.join();
+        }
+        /*
+        for (RecursiveAction task : forks) {
+            task.join();
+        }*/
+    }
+    
+    
+    class chunkflush extends RecursiveAction {
+        PlayerChunk pc;
+        
+        chunkflush(PlayerChunk pc) {
+            this.pc = pc;
+        }
+        
+        @Override
+        protected void compute() {
+            pc.d();
+        }
+                 
+    }
+}
diff -Naur src_origin/main/java/org/hose/ChunkGen_Pool.java src/main/java/org/hose/ChunkGen_Pool.java
--- src_origin/main/java/org/hose/ChunkGen_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChunkGen_Pool.java	2016-06-17 04:20:34.932705435 +0800
@@ -0,0 +1,54 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.WorldServer;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkGen_Pool extends RecursiveAction {
+    WorldServer worldserver;
+    List<int[]> position;
+    
+    public ChunkGen_Pool(WorldServer worldserver, List<int[]> position){
+        this.worldserver = worldserver;
+        this.position = position;
+        
+    }
+    
+    @Override
+    protected void compute() {
+        List<RecursiveAction> forks = new LinkedList();
+        for (int[] pt : position) {
+            chunkgen task = new chunkgen(worldserver, pt);
+            forks.add(task);
+            task.fork();
+        }
+        
+    }
+    
+    
+    class chunkgen extends RecursiveAction {
+        WorldServer worldserver;
+        int[] pt;
+        
+        chunkgen(WorldServer worldserver, int[] pt) {
+            this.worldserver = worldserver;
+            this.pt = pt;
+        }
+        
+        @Override
+        protected void compute() {
+            worldserver.getChunkProviderServer().getChunkAt(pt[0], pt[1]);
+        }
+                 
+    }
+}
diff -Naur src_origin/main/java/org/hose/ChunkPopulate_Pool.java src/main/java/org/hose/ChunkPopulate_Pool.java
--- src_origin/main/java/org/hose/ChunkPopulate_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChunkPopulate_Pool.java	2016-06-17 04:20:34.931705435 +0800
@@ -0,0 +1,35 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.Random;
+import java.util.concurrent.RecursiveAction;
+import org.bukkit.Chunk;
+import org.bukkit.World;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkPopulate_Pool extends RecursiveAction {//need to use callable
+    World world;
+    Random random;
+    Chunk chunk;
+    org.bukkit.generator.BlockPopulator populator;
+    
+    public ChunkPopulate_Pool(World world, Random random, Chunk chunk, org.bukkit.generator.BlockPopulator populator){
+        this.world = world;
+        this.random = random;
+        this.chunk = chunk;
+        this.populator = populator;
+    }
+    
+    @Override
+    protected void compute() {
+        populator.populate(world, random, chunk);
+    }
+
+}
diff -Naur src_origin/main/java/org/hose/GE_Pool.java src/main/java/org/hose/GE_Pool.java
--- src_origin/main/java/org/hose/GE_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/GE_Pool.java	2016-06-17 04:20:34.931705435 +0800
@@ -0,0 +1,32 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import java.util.concurrent.RecursiveTask;
+import net.minecraft.server.Entity;
+import net.minecraft.server.EntityLiving;
+import net.minecraft.server.IEntitySelector;
+import net.minecraft.server.World;
+
+
+/**
+ *
+ * @author softpak
+ */
+public class GE_Pool extends RecursiveTask<List> {
+    EntityLiving el;
+    
+    public GE_Pool(EntityLiving el){
+        this.el = el;
+    }
+    
+    @Override
+    protected List compute() {
+        return el.world.getEntities(el, el.getBoundingBox(), IEntitySelector.a(el));
+    }
+}
diff -Naur src_origin/main/java/org/hose/TE_Pool.java src/main/java/org/hose/TE_Pool.java
--- src_origin/main/java/org/hose/TE_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/TE_Pool.java	2016-06-17 04:20:34.932705435 +0800
@@ -0,0 +1,34 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import java.util.concurrent.RecursiveTask;
+import net.minecraft.server.Entity;
+import net.minecraft.server.World;
+
+
+/**
+ *
+ * @author softpak
+ */
+public class TE_Pool extends RecursiveTask<List> {
+    Entity entity;
+    double d0, d1, d2;
+    
+    public TE_Pool(Entity entity, double d0, double d1, double d2){
+        this.entity = entity;
+        this.d0 = d0;
+        this.d1 = d1;
+        this.d2 = d2;
+    }
+    
+    @Override
+    protected List compute() {
+        return entity.world.getCubes(entity, entity.getBoundingBox().a(d0, d1, d2));
+    }
+}
diff -Naur src_origin/main/java/org/hose/Tick_Pool.java src/main/java/org/hose/Tick_Pool.java
--- src_origin/main/java/org/hose/Tick_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/Tick_Pool.java	2016-06-17 04:20:34.932705435 +0800
@@ -0,0 +1,32 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.Entity;
+import net.minecraft.server.World;
+
+
+/**
+ *
+ * @author softpak
+ */
+public class Tick_Pool extends RecursiveAction {
+    Entity entity;
+    World world;
+    
+    public Tick_Pool(Entity entity){
+        this.entity = entity;
+        //this.world = world;
+        
+    }
+    
+    @Override
+    protected void compute() {
+        entity.U();
+    }
+    
+}
diff -Naur src_origin/main/java/org/spigotmc/ActivationRange.java src/main/java/org/spigotmc/ActivationRange.java
--- src_origin/main/java/org/spigotmc/ActivationRange.java	2016-06-17 04:20:28.481706027 +0800
+++ src/main/java/org/spigotmc/ActivationRange.java	2016-06-17 04:20:34.954705433 +0800
@@ -1,6 +1,7 @@
 package org.spigotmc;
 
 import java.util.List;
+import java.util.Queue;
 import java.util.Set;
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.Chunk;
@@ -141,7 +142,8 @@
      */
     private static void activateChunkEntities(Chunk chunk)
     {
-        for ( List<Entity> slice : chunk.entitySlices )
+        //for ( List<Entity> slice : chunk.entitySlices )
+        for ( Queue<Entity> slice : chunk.entitySlices )
         {
             for ( Entity entity : slice )
             {
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2016-06-17 04:20:28.473706027 +0800
+++ src/main/java/org/spigotmc/AsyncCatcher.java	2016-06-17 04:20:34.951705434 +0800
@@ -11,6 +11,7 @@
     {
         if ( enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread )
         {
+            MinecraftServer.getServer().postToMainThread(Thread.currentThread());
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
         }
     }
diff -Naur src_origin/main/java/org/spigotmc/SpigotWorldConfig.java src/main/java/org/spigotmc/SpigotWorldConfig.java
--- src_origin/main/java/org/spigotmc/SpigotWorldConfig.java	2016-06-17 04:20:28.481706027 +0800
+++ src/main/java/org/spigotmc/SpigotWorldConfig.java	2016-06-17 04:20:35.031705426 +0800
@@ -1,12 +1,115 @@
 package org.spigotmc;
 
 import java.util.List;
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.ForkJoinWorkerThread;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
 public class SpigotWorldConfig
 {
 
+    //hose start
+    static public final int cpu_core = Runtime.getRuntime().availableProcessors();
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fetp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("EntityTickPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fttp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("TileTickPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fmp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("MovePool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fpcp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("PlayerChunkPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcfpt3 = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkFlushPool_T3-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcpp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkPopulate_Pool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    public static ForkJoinPool EntityTickPool;
+    public static ForkJoinPool TileTickPool;
+    public static ForkJoinPool MovePool;
+    public static ForkJoinPool PlayerChunkPool;
+    public static ForkJoinPool ChunkPool;
+    public static ForkJoinPool ChunkFlushPool_T3;
+    public static ForkJoinPool ChunkPopulate_Pool;
+    
+    /*
+    static public FutureTask CollideTask;
+        
+    static final ThreadFactory tfcp = new ThreadFactoryBuilder().setNameFormat("Collide_Pool-%d").build();
+    static public final ExecutorService collidepool_executor = Executors.newFixedThreadPool(cpu_core, tfcp);*/
+    
+    public static int worldtickentitypool_core_multiple;
+    
+    public static int getthreadnumber(){
+        return cpu_core*worldtickentitypool_core_multiple;
+    }
+    
+    private void wetp_core_multiple()
+    {
+        worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 4);
+        EntityTickPool = new ForkJoinPool(getthreadnumber(), fetp, null, false);
+        TileTickPool = new ForkJoinPool(getthreadnumber(), fttp, null, false);
+        MovePool = new ForkJoinPool(getthreadnumber(), fmp, null, false);
+        PlayerChunkPool = new ForkJoinPool(getthreadnumber(), fpcp, null, false);
+        ChunkPool = new ForkJoinPool(getthreadnumber(), fcp, null, false);
+        ChunkFlushPool_T3 = new ForkJoinPool(getthreadnumber(), fcfpt3, null, false);
+        ChunkPopulate_Pool = new ForkJoinPool(getthreadnumber(), fcpp, null, false);
+        //executor = new ThreadPoolExecutor(getthreadnumber(), getthreadnumber(), 1, TimeUnit.DAYS, queue);
+        log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
+    }
+    
+    
+       
+    //hose end
+    
     private final String worldName;
     private final YamlConfiguration config;
     private boolean verbose;
