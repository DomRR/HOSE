diff -Naur src_origin/main/java/net/minecraft/server/BlockRedstoneWire.java src/main/java/net/minecraft/server/BlockRedstoneWire.java
--- src_origin/main/java/net/minecraft/server/BlockRedstoneWire.java	2016-04-03 23:27:21.334613929 +0800
+++ src/main/java/net/minecraft/server/BlockRedstoneWire.java	2016-04-17 03:42:14.362951678 +0800
@@ -9,6 +9,7 @@
 import java.util.Set;
 
 import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
+import org.spigotmc.SpigotWorldConfig;
 
 public class BlockRedstoneWire extends Block {
 
@@ -19,7 +20,8 @@
     public static final BlockStateInteger POWER = BlockStateInteger.of("power", 0, 15);
     protected static final AxisAlignedBB[] f = new AxisAlignedBB[] { new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 1.0D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 1.0D, 0.0625D, 1.0D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 1.0D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.0625D, 1.0D)};
     private boolean g = true;
-    private final Set<BlockPosition> B = Sets.newHashSet();
+    //private final Set<BlockPosition> B = Sets.newHashSet();
+    private final Set<BlockPosition> B = Sets.newConcurrentHashSet();
 
     public BlockRedstoneWire() {
         super(Material.ORIENTABLE);
diff -Naur src_origin/main/java/net/minecraft/server/Chunk.java src/main/java/net/minecraft/server/Chunk.java
--- src_origin/main/java/net/minecraft/server/Chunk.java	2016-04-03 23:27:21.438613929 +0800
+++ src/main/java/net/minecraft/server/Chunk.java	2016-04-17 03:42:14.454951670 +0800
@@ -15,6 +15,7 @@
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists; // CraftBukkit
+import java.util.Queue;
 import org.bukkit.Bukkit; // CraftBukkit
 
 public class Chunk {
@@ -32,7 +33,8 @@
     public final int locZ;
     private boolean l;
     public final Map<BlockPosition, TileEntity> tileEntities;
-    public final List<Entity>[] entitySlices; // Spigot
+    //public final List<Entity>[] entitySlices; // Spigot
+    public final Queue<Entity>[] entitySlices; // Spigot
     private boolean done;
     private boolean lit;
     private boolean q;
@@ -81,14 +83,16 @@
         this.tileEntities = Maps.newHashMap();
         this.w = 4096;
         this.x = Queues.newConcurrentLinkedQueue();
-        this.entitySlices = (List[]) (new List[16]); // Spigot
+        //this.entitySlices = (List[]) (new List[16]); // Spigot
+        this.entitySlices = (Queue[]) (new ConcurrentLinkedQueue[16]); // Spigot
         this.world = world;
         this.locX = i;
         this.locZ = j;
         this.heightMap = new int[256];
 
         for (int k = 0; k < this.entitySlices.length; ++k) {
-            this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            //this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[k] = new ConcurrentLinkedQueue(); // Spigot
         }
 
         Arrays.fill(this.g, -999);
@@ -1260,7 +1264,8 @@
         return this.tileEntities;
     }
 
-    public List<Entity>[] getEntitySlices() {
+    //public List<Entity>[] getEntitySlices() {
+    public Queue<Entity>[] getEntitySlices() {
         return this.entitySlices;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderServer.java src/main/java/net/minecraft/server/ChunkProviderServer.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderServer.java	2016-04-03 23:27:21.447613929 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderServer.java	2016-04-17 03:42:14.441951671 +0800
@@ -3,6 +3,8 @@
 import java.io.IOException;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -13,7 +15,7 @@
 import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
 import org.bukkit.craftbukkit.util.LongHash;
 import org.bukkit.craftbukkit.util.LongHashSet;
-import org.bukkit.craftbukkit.util.LongObjectHashMap;
+//import org.bukkit.craftbukkit.util.LongObjectHashMap;
 import org.bukkit.event.world.ChunkUnloadEvent;
 // CraftBukkit end
 
@@ -23,7 +25,8 @@
     public final LongHashSet unloadQueue = new LongHashSet(); // CraftBukkit - LongHashSet
     public final ChunkGenerator chunkGenerator; // CraftBukkit - public
     private final IChunkLoader chunkLoader;
-    public LongObjectHashMap<Chunk> chunks = new LongObjectHashMap<Chunk>(); // CraftBukkit
+    //public LongObjectHashMap<Chunk> chunks = new LongObjectHashMap<Chunk>(); // CraftBukkit
+    public Map<Long, Chunk> chunks = new ConcurrentHashMap<Long, Chunk>(); // CraftBukkit
     // private final LongHashMap<Chunk> chunks = new LongHashMap();
     // private final List<Chunk> chunkList = Lists.newArrayList();
     public final WorldServer world;
@@ -118,7 +121,7 @@
         return getChunkAt(i, j, null);
     }
 
-    public Chunk getChunkAt(int i, int j, Runnable runnable) {
+    synchronized public Chunk getChunkAt(int i, int j, Runnable runnable) {
         unloadQueue.remove(i, j);
         Chunk chunk = chunks.get(LongHash.toLong(i, j));
         ChunkRegionLoader loader = null;
diff -Naur src_origin/main/java/net/minecraft/server/EntityLiving.java src/main/java/net/minecraft/server/EntityLiving.java
--- src_origin/main/java/net/minecraft/server/EntityLiving.java	2016-04-03 23:27:22.056613930 +0800
+++ src/main/java/net/minecraft/server/EntityLiving.java	2016-04-17 03:42:14.934951626 +0800
@@ -13,6 +13,7 @@
 import java.util.ArrayList;
 import com.google.common.base.Function;
 import com.google.common.collect.Lists;
+import java.util.concurrent.FutureTask;
 import org.bukkit.craftbukkit.attribute.CraftAttributeMap;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
 import org.bukkit.craftbukkit.inventory.CraftItemStack;
@@ -2003,6 +2004,8 @@
 
     protected void C(Entity entity) {
         entity.collide(this);
+        /*SpigotWorldConfig.CollideTask = new FutureTask(new Collide_Pool(this, entity));
+        SpigotWorldConfig.collidepool_executor.submit(SpigotWorldConfig.CollideTask);*/
     }
 
     public void stopRiding() {
diff -Naur src_origin/main/java/net/minecraft/server/EntityPlayer.java src/main/java/net/minecraft/server/EntityPlayer.java
--- src_origin/main/java/net/minecraft/server/EntityPlayer.java	2016-04-03 23:27:22.123613930 +0800
+++ src/main/java/net/minecraft/server/EntityPlayer.java	2016-04-17 03:42:14.996951620 +0800
@@ -1,13 +1,18 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import com.mojang.authlib.GameProfile;
 import io.netty.buffer.Unpooled;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -31,7 +36,7 @@
     public final PlayerInteractManager playerInteractManager;
     public double d;
     public double e;
-    public final List<Integer> removeQueue = Lists.newLinkedList();
+    public final List<Integer> removeQueue = Collections.synchronizedList(Lists.newLinkedList());
     private final ServerStatisticManager bT;
     private float bU = Float.MIN_VALUE;
     private int bV = Integer.MIN_VALUE;
@@ -1033,9 +1038,6 @@
         if ("@".equals(s)) {
             return getBukkitEntity().hasPermission("minecraft.command.selector");
         }
-        if ("".equals(s)) {
-            return getBukkitEntity().isOp();
-        }
         return true;
         // CraftBukkit end
     }
diff -Naur src_origin/main/java/net/minecraft/server/EntityTrackerEntry.java src/main/java/net/minecraft/server/EntityTrackerEntry.java
--- src_origin/main/java/net/minecraft/server/EntityTrackerEntry.java	2016-04-03 23:27:22.299613930 +0800
+++ src/main/java/net/minecraft/server/EntityTrackerEntry.java	2016-04-17 03:42:15.120951608 +0800
@@ -41,7 +41,8 @@
     private boolean x;
     private boolean y;
     public boolean b;
-    public Set<EntityPlayer> trackedPlayers = Sets.newHashSet();
+    //public Set<EntityPlayer> trackedPlayers = Sets.newHashSet();
+    public Set<EntityPlayer> trackedPlayers = Sets.newConcurrentHashSet();
 
     public EntityTrackerEntry(Entity entity, int i, int j, int k, boolean flag) {
         this.tracker = entity;
diff -Naur src_origin/main/java/net/minecraft/server/EntityTracker.java src/main/java/net/minecraft/server/EntityTracker.java
--- src_origin/main/java/net/minecraft/server/EntityTracker.java	2016-04-03 23:27:22.293613930 +0800
+++ src/main/java/net/minecraft/server/EntityTracker.java	2016-04-17 03:42:15.097951611 +0800
@@ -1,9 +1,11 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.Map;
 import java.util.Set;
 import java.util.concurrent.Callable;
 import org.apache.logging.log4j.LogManager;
@@ -13,8 +15,10 @@
 
     private static final Logger a = LogManager.getLogger();
     private final WorldServer world;
-    private Set<EntityTrackerEntry> c = Sets.newHashSet();
-    public IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    //private Set<EntityTrackerEntry> c = Sets.newHashSet();
+    private Set<EntityTrackerEntry> c = Sets.newConcurrentHashSet();
+    //public IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    public Map<Integer, EntityTrackerEntry> trackedEntities = Maps.newConcurrentMap();
     private int e;
 
     public EntityTracker(WorldServer worldserver) {
@@ -105,14 +109,16 @@
         org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
         i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
         try {
-            if (this.trackedEntities.b(entity.getId())) {
+            //if (this.trackedEntities.b(entity.getId())) {
+            if (this.trackedEntities.containsKey(entity.getId())) {
                 throw new IllegalStateException("Entity is already tracked!");
             }
 
             EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, this.e, j, flag);
 
             this.c.add(entitytrackerentry);
-            this.trackedEntities.a(entity.getId(), entitytrackerentry);
+            //this.trackedEntities.a(entity.getId(), entitytrackerentry);
+            this.trackedEntities.put(entity.getId(), entitytrackerentry);
             entitytrackerentry.scanPlayers(this.world.players);
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
@@ -160,7 +166,9 @@
             }
         }
 
-        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
+        //EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
+        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        this.trackedEntities.remove(entity.getId());
 
         if (entitytrackerentry1 != null) {
             this.c.remove(entitytrackerentry1);
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2016-04-03 23:27:22.612613930 +0800
+++ src/main/java/net/minecraft/server/MinecraftServer.java	2016-04-17 03:42:15.420951581 +0800
@@ -2,7 +2,6 @@
 
 import com.google.common.base.Charsets;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.ListenableFutureTask;
@@ -33,6 +32,7 @@
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Date;
+import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
 import java.util.Random;
@@ -46,6 +46,8 @@
 // CraftBukkit start
 // CraftBukkit end
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.hose.ChunkGen_Pool;
+import org.spigotmc.SpigotWorldConfig;
 
 public abstract class MinecraftServer implements Runnable, ICommandListener, IAsyncTaskHandler, IMojangStatistics {
 
@@ -353,7 +355,8 @@
             BlockPosition blockposition = worldserver.getSpawn();
             long j = av();
             i = 0;
-
+            List<int[]> chunkgen_list = new LinkedList();
+            int[] pos = new int[2];
             for (int k = -192; k <= 192 && this.isRunning(); k += 16) {
                 for (int l = -192; l <= 192 && this.isRunning(); l += 16) {
                     long i1 = av();
@@ -364,9 +367,13 @@
                     }
 
                     ++i;
-                    worldserver.getChunkProviderServer().getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    //worldserver.getChunkProviderServer().getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    pos[0] = blockposition.getX() + k >> 4;
+                    pos[1] = blockposition.getZ() + l >> 4;
+                    chunkgen_list.add(pos);
                 }
             }
+            SpigotWorldConfig.ChunkPool.invoke(new ChunkGen_Pool(worldserver, chunkgen_list));
         }
 
         for (WorldServer world : this.worlds) {
@@ -1022,7 +1029,8 @@
     }
 
     public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        //return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "HOSE"; // HOSE -> Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1104,7 +1112,8 @@
     }
 
     public String getName() {
-        return "Server";
+        //return "Server";
+        return org.bukkit.ChatColor.GREEN + "Server";
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
diff -Naur src_origin/main/java/net/minecraft/server/NavigationAbstract.java src/main/java/net/minecraft/server/NavigationAbstract.java
--- src_origin/main/java/net/minecraft/server/NavigationAbstract.java	2016-04-03 23:27:22.656613931 +0800
+++ src/main/java/net/minecraft/server/NavigationAbstract.java	2016-04-17 03:42:15.432951580 +0800
@@ -73,17 +73,21 @@
         } else if (this.c != null && !this.c.b() && blockposition.equals(this.r)) {
             return this.c;
         } else {
-            this.r = blockposition;
-            float f = this.h();
+            try {
+                this.r = blockposition;
+                float f = this.h();
 
-            this.b.methodProfiler.a("pathfind");
-            BlockPosition blockposition1 = new BlockPosition(this.a);
-            int i = (int) (f + 8.0F);
-            ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
-            PathEntity pathentity = this.s.a(chunkcache, this.a, this.r, f);
+                this.b.methodProfiler.a("pathfind");
+                BlockPosition blockposition1 = new BlockPosition(this.a);
+                int i = (int) (f + 8.0F);
+                ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+                PathEntity pathentity = this.s.a(chunkcache, this.a, this.r, f);
 
-            this.b.methodProfiler.b();
-            return pathentity;
+                this.b.methodProfiler.b();
+                return pathentity;
+            } catch (Exception ex) {
+                return null;
+            }
         }
     }
 
@@ -184,35 +188,39 @@
     }
 
     protected void m() {
-        Vec3D vec3d = this.c();
-        int i = this.c.d();
-
-        for (int j = this.c.e(); j < this.c.d(); ++j) {
-            if ((double) this.c.a(j).b != Math.floor(vec3d.y)) {
-                i = j;
-                break;
+        try {
+            Vec3D vec3d = this.c();
+            int i = this.c.d();
+
+            for (int j = this.c.e(); j < this.c.d(); ++j) {
+                if ((double) this.c.a(j).b != Math.floor(vec3d.y)) {
+                    i = j;
+                    break;
+                }
             }
-        }
 
-        this.o = this.a.width > 0.75F ? this.a.width / 2.0F : 0.75F - this.a.width / 2.0F;
-        Vec3D vec3d1 = this.c.f();
+            this.o = this.a.width > 0.75F ? this.a.width / 2.0F : 0.75F - this.a.width / 2.0F;
+            Vec3D vec3d1 = this.c.f();
 
-        if (MathHelper.e((float) (this.a.locX - (vec3d1.x + 0.5D))) < this.o && MathHelper.e((float) (this.a.locZ - (vec3d1.z + 0.5D))) < this.o) {
-            this.c.c(this.c.e() + 1);
-        }
+            if (MathHelper.e((float) (this.a.locX - (vec3d1.x + 0.5D))) < this.o && MathHelper.e((float) (this.a.locZ - (vec3d1.z + 0.5D))) < this.o) {
+                this.c.c(this.c.e() + 1);
+            }
 
-        int k = MathHelper.f(this.a.width);
-        int l = (int) this.a.length + 1;
-        int i1 = k;
+            int k = MathHelper.f(this.a.width);
+            int l = (int) this.a.length + 1;
+            int i1 = k;
 
-        for (int j1 = i - 1; j1 >= this.c.e(); --j1) {
-            if (this.a(vec3d, this.c.a(this.a, j1), k, l, i1)) {
-                this.c.c(j1);
-                break;
+            for (int j1 = i - 1; j1 >= this.c.e(); --j1) {
+                if (this.a(vec3d, this.c.a(this.a, j1), k, l, i1)) {
+                    this.c.c(j1);
+                    break;
+                }
             }
-        }
 
-        this.a(vec3d);
+            this.a(vec3d);
+        } catch (Exception ex) {
+            //do nothing
+        }
     }
 
     protected void a(Vec3D vec3d) {
diff -Naur src_origin/main/java/net/minecraft/server/PathfinderNormal.java src/main/java/net/minecraft/server/PathfinderNormal.java
--- src_origin/main/java/net/minecraft/server/PathfinderNormal.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/PathfinderNormal.java	2016-04-17 03:42:15.586951566 +0800
@@ -0,0 +1,360 @@
+package net.minecraft.server;
+
+import java.util.EnumSet;
+import java.util.HashSet;
+import java.util.Iterator;
+
+public class PathfinderNormal extends PathfinderAbstract {
+
+    private float j;
+
+    public PathfinderNormal() {}
+
+    public void a(IBlockAccess iblockaccess, EntityInsentient entityinsentient) {
+        super.a(iblockaccess, entityinsentient);
+        this.j = entityinsentient.a(PathType.WATER);
+    }
+
+    public void a() {
+        super.a();
+        this.b.a(PathType.WATER, this.j);
+    }
+
+    public PathPoint b() {
+        int i;
+        BlockPosition blockposition;
+
+        if (this.e() && this.b.isInWater()) {
+            i = (int) this.b.getBoundingBox().b;
+            BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition(MathHelper.floor(this.b.locX), i, MathHelper.floor(this.b.locZ));
+
+            for (Block block = this.a.getType(blockposition_mutableblockposition).getBlock(); block == Blocks.FLOWING_WATER || block == Blocks.WATER; block = this.a.getType(blockposition_mutableblockposition).getBlock()) {
+                ++i;
+                blockposition_mutableblockposition.c(MathHelper.floor(this.b.locX), i, MathHelper.floor(this.b.locZ));
+            }
+        } else if (!this.b.onGround) {
+            for (blockposition = new BlockPosition(this.b); (this.a.getType(blockposition).getMaterial() == Material.AIR || this.a.getType(blockposition).getBlock().b(this.a, blockposition)) && blockposition.getY() > 0; blockposition = blockposition.down()) {
+                ;
+            }
+
+            i = blockposition.up().getY();
+        } else {
+            i = MathHelper.floor(this.b.getBoundingBox().b + 0.5D);
+        }
+
+        blockposition = new BlockPosition(this.b);
+        PathType pathtype = this.a(this.b, blockposition.getX(), i, blockposition.getZ());
+
+        if (this.b.a(pathtype) < 0.0F) {
+            HashSet hashset = new HashSet();
+
+            hashset.add(new BlockPosition(this.b.getBoundingBox().a, (double) i, this.b.getBoundingBox().c));
+            hashset.add(new BlockPosition(this.b.getBoundingBox().a, (double) i, this.b.getBoundingBox().f));
+            hashset.add(new BlockPosition(this.b.getBoundingBox().d, (double) i, this.b.getBoundingBox().c));
+            hashset.add(new BlockPosition(this.b.getBoundingBox().d, (double) i, this.b.getBoundingBox().f));
+            Iterator iterator = hashset.iterator();
+
+            while (iterator.hasNext()) {
+                BlockPosition blockposition1 = (BlockPosition) iterator.next();
+                PathType pathtype1 = this.a(this.b, blockposition1);
+
+                if (this.b.a(pathtype1) >= 0.0F) {
+                    return this.a(blockposition1.getX(), blockposition1.getY(), blockposition1.getZ());
+                }
+            }
+        }
+
+        return this.a(blockposition.getX(), i, blockposition.getZ());
+    }
+
+    public PathPoint a(double d0, double d1, double d2) {
+        return this.a(MathHelper.floor(d0 - (double) (this.b.width / 2.0F)), MathHelper.floor(d1), MathHelper.floor(d2 - (double) (this.b.width / 2.0F)));
+    }
+
+    public int a(PathPoint[] apathpoint, PathPoint pathpoint, PathPoint pathpoint1, float f) {
+        int i = 0;
+        byte b0 = 0;
+        PathType pathtype = this.a(this.b, pathpoint.a, pathpoint.b + 1, pathpoint.c);
+
+        if (this.b.a(pathtype) >= 0.0F) {
+            b0 = 1;
+        }
+
+        BlockPosition blockposition = (new BlockPosition(pathpoint.a, pathpoint.b, pathpoint.c)).down();
+        double d0 = (double) pathpoint.b - (1.0D - this.a.getType(blockposition).c(this.a, blockposition).e);
+        PathPoint pathpoint2 = this.a(pathpoint.a, pathpoint.b, pathpoint.c + 1, b0, d0, EnumDirection.SOUTH);
+        PathPoint pathpoint3 = this.a(pathpoint.a - 1, pathpoint.b, pathpoint.c, b0, d0, EnumDirection.WEST);
+        PathPoint pathpoint4 = this.a(pathpoint.a + 1, pathpoint.b, pathpoint.c, b0, d0, EnumDirection.EAST);
+        PathPoint pathpoint5 = this.a(pathpoint.a, pathpoint.b, pathpoint.c - 1, b0, d0, EnumDirection.NORTH);
+
+        if (pathpoint2 != null && !pathpoint2.i && pathpoint2.a(pathpoint1) < f) {
+            apathpoint[i++] = pathpoint2;
+        }
+
+        if (pathpoint3 != null && !pathpoint3.i && pathpoint3.a(pathpoint1) < f) {
+            apathpoint[i++] = pathpoint3;
+        }
+
+        if (pathpoint4 != null && !pathpoint4.i && pathpoint4.a(pathpoint1) < f) {
+            apathpoint[i++] = pathpoint4;
+        }
+
+        if (pathpoint5 != null && !pathpoint5.i && pathpoint5.a(pathpoint1) < f) {
+            apathpoint[i++] = pathpoint5;
+        }
+
+        boolean flag = pathpoint5 == null || pathpoint5.m == PathType.OPEN || pathpoint5.l != 0.0F;
+        boolean flag1 = pathpoint2 == null || pathpoint2.m == PathType.OPEN || pathpoint2.l != 0.0F;
+        boolean flag2 = pathpoint4 == null || pathpoint4.m == PathType.OPEN || pathpoint4.l != 0.0F;
+        boolean flag3 = pathpoint3 == null || pathpoint3.m == PathType.OPEN || pathpoint3.l != 0.0F;
+        PathPoint pathpoint6;
+
+        if (flag && flag3) {
+            pathpoint6 = this.a(pathpoint.a - 1, pathpoint.b, pathpoint.c - 1, b0, d0, EnumDirection.NORTH);
+            if (pathpoint6 != null && !pathpoint6.i && pathpoint6.a(pathpoint1) < f) {
+                apathpoint[i++] = pathpoint6;
+            }
+        }
+
+        if (flag && flag2) {
+            pathpoint6 = this.a(pathpoint.a + 1, pathpoint.b, pathpoint.c - 1, b0, d0, EnumDirection.NORTH);
+            if (pathpoint6 != null && !pathpoint6.i && pathpoint6.a(pathpoint1) < f) {
+                apathpoint[i++] = pathpoint6;
+            }
+        }
+
+        if (flag1 && flag3) {
+            pathpoint6 = this.a(pathpoint.a - 1, pathpoint.b, pathpoint.c + 1, b0, d0, EnumDirection.SOUTH);
+            if (pathpoint6 != null && !pathpoint6.i && pathpoint6.a(pathpoint1) < f) {
+                apathpoint[i++] = pathpoint6;
+            }
+        }
+
+        if (flag1 && flag2) {
+            pathpoint6 = this.a(pathpoint.a + 1, pathpoint.b, pathpoint.c + 1, b0, d0, EnumDirection.SOUTH);
+            if (pathpoint6 != null && !pathpoint6.i && pathpoint6.a(pathpoint1) < f) {
+                apathpoint[i++] = pathpoint6;
+            }
+        }
+
+        return i;
+    }
+
+    private PathPoint a(int i, int j, int k, int l, double d0, EnumDirection enumdirection) {
+        PathPoint pathpoint = null;
+        BlockPosition blockposition = new BlockPosition(i, j, k);
+        BlockPosition blockposition1 = blockposition.down();
+        double d1 = (double) j - (1.0D - this.a.getType(blockposition1).c(this.a, blockposition1).e);
+
+        if (d1 - d0 > 1.0D) {
+            return null;
+        } else {
+            try {
+                PathType pathtype = this.a(this.b, i, j, k);
+                float f = this.b.a(pathtype);
+                double d2 = (double) this.b.width / 2.0D;
+
+                if (f >= 0.0F) {
+                    pathpoint = this.a(i, j, k);
+                    pathpoint.m = pathtype;
+                    pathpoint.l = Math.max(pathpoint.l, f);
+                }
+
+                if (pathtype == PathType.WALKABLE) {
+                    return pathpoint;
+                } else {
+                    if (pathpoint == null && l > 0 && pathtype != PathType.FENCE && pathtype != PathType.TRAPDOOR) {
+                        pathpoint = this.a(i, j + 1, k, l - 1, d0, enumdirection);
+                        if (pathpoint != null && (pathpoint.m == PathType.OPEN || pathpoint.m == PathType.WALKABLE)) {
+                            double d3 = (double) (i - enumdirection.getAdjacentX()) + 0.5D;
+                            double d4 = (double) (k - enumdirection.getAdjacentZ()) + 0.5D;
+                            AxisAlignedBB axisalignedbb = new AxisAlignedBB(d3 - d2, (double) j + 0.001D, d4 - d2, d3 + d2, (double) ((float) j + this.b.length), d4 + d2);
+                            AxisAlignedBB axisalignedbb1 = this.a.getType(blockposition).c(this.a, blockposition);
+                            AxisAlignedBB axisalignedbb2 = axisalignedbb.a(0.0D, axisalignedbb1.e - 0.002D, 0.0D);
+
+                            if (this.b.world.b(axisalignedbb2)) {
+                                pathpoint = null;
+                            }
+                        }
+                    }
+
+                    if (pathtype == PathType.OPEN) {
+                        AxisAlignedBB axisalignedbb3 = new AxisAlignedBB((double) i - d2 + 0.5D, (double) j + 0.001D, (double) k - d2 + 0.5D, (double) i + d2 + 0.5D, (double) ((float) j + this.b.length), (double) k + d2 + 0.5D);
+
+                        if (this.b.world.b(axisalignedbb3)) {
+                            return null;
+                        }
+
+                        int i1 = 0;
+
+                        while (j > 0 && pathtype == PathType.OPEN) {
+                            --j;
+                            if (i1++ >= this.b.aW()) {
+                                return null;
+                            }
+
+                            pathtype = this.a(this.b, i, j, k);
+                            f = this.b.a(pathtype);
+                            if (pathtype != PathType.OPEN && f >= 0.0F) {
+                                pathpoint = this.a(i, j, k);
+                                pathpoint.m = pathtype;
+                                pathpoint.l = Math.max(pathpoint.l, f);
+                                break;
+                            }
+
+                            if (f < 0.0F) {
+                                return null;
+                            }
+                        }
+                    }
+
+                    return pathpoint;
+                }
+            } catch (Exception ex) {
+                return null;
+            }
+        }
+    }
+
+    public PathType a(IBlockAccess iblockaccess, int i, int j, int k, EntityInsentient entityinsentient, int l, int i1, int j1, boolean flag, boolean flag1) {
+        EnumSet enumset = EnumSet.noneOf(PathType.class);
+        PathType pathtype = PathType.BLOCKED;
+        double d0 = (double) entityinsentient.width / 2.0D;
+        BlockPosition blockposition = new BlockPosition(entityinsentient);
+
+        for (int k1 = i; k1 < i + l; ++k1) {
+            for (int l1 = j; l1 < j + i1; ++l1) {
+                for (int i2 = k; i2 < k + j1; ++i2) {
+                    PathType pathtype1 = a(iblockaccess, k1, l1, i2);
+
+                    if (pathtype1 == PathType.DOOR_WOOD_CLOSED && flag && flag1) {
+                        pathtype1 = PathType.WALKABLE;
+                    }
+
+                    if (pathtype1 == PathType.DOOR_OPEN && !flag1) {
+                        pathtype1 = PathType.BLOCKED;
+                    }
+
+                    if (pathtype1 == PathType.RAIL && !(iblockaccess.getType(blockposition).getBlock() instanceof BlockMinecartTrackAbstract) && !(iblockaccess.getType(blockposition.down()).getBlock() instanceof BlockMinecartTrackAbstract)) {
+                        pathtype1 = PathType.FENCE;
+                    }
+
+                    if (k1 == i && l1 == j && i2 == k) {
+                        pathtype = pathtype1;
+                    }
+
+                    if (l1 > j && pathtype1 != PathType.OPEN) {
+                        AxisAlignedBB axisalignedbb = new AxisAlignedBB((double) k1 - d0 + 0.5D, (double) j + 0.001D, (double) i2 - d0 + 0.5D, (double) k1 + d0 + 0.5D, (double) ((float) j + entityinsentient.length), (double) i2 + d0 + 0.5D);
+
+                        if (!entityinsentient.world.b(axisalignedbb)) {
+                            pathtype1 = PathType.OPEN;
+                        }
+                    }
+
+                    enumset.add(pathtype1);
+                }
+            }
+        }
+
+        if (enumset.contains(PathType.FENCE)) {
+            return PathType.FENCE;
+        } else {
+            PathType pathtype2 = PathType.BLOCKED;
+            Iterator iterator = enumset.iterator();
+
+            while (iterator.hasNext()) {
+                PathType pathtype3 = (PathType) iterator.next();
+
+                if (entityinsentient.a(pathtype3) < 0.0F) {
+                    return pathtype3;
+                }
+
+                if (entityinsentient.a(pathtype3) >= entityinsentient.a(pathtype2)) {
+                    pathtype2 = pathtype3;
+                }
+            }
+
+            if (pathtype == PathType.OPEN && entityinsentient.a(pathtype2) == 0.0F) {
+                return PathType.OPEN;
+            } else {
+                return pathtype2;
+            }
+        }
+    }
+
+    private PathType a(EntityInsentient entityinsentient, BlockPosition blockposition) {
+        return this.a(this.a, blockposition.getX(), blockposition.getY(), blockposition.getZ(), entityinsentient, this.d, this.e, this.f, this.d(), this.c());
+    }
+
+    private PathType a(EntityInsentient entityinsentient, int i, int j, int k) {
+        return this.a(this.a, i, j, k, entityinsentient, this.d, this.e, this.f, this.d(), this.c());
+    }
+
+    public static PathType a(IBlockAccess iblockaccess, int i, int j, int k) {
+        BlockPosition blockposition = new BlockPosition(i, j, k);
+        IBlockData iblockdata = iblockaccess.getType(blockposition);
+        Block block = iblockdata.getBlock();
+        Material material = iblockdata.getMaterial();
+        PathType pathtype = PathType.BLOCKED;
+
+        if (block != Blocks.TRAPDOOR && block != Blocks.IRON_TRAPDOOR && block != Blocks.WATERLILY) {
+            if (block == Blocks.FIRE) {
+                return PathType.DAMAGE_FIRE;
+            } else if (block == Blocks.CACTUS) {
+                return PathType.DAMAGE_CACTUS;
+            } else if (block instanceof BlockDoor && material == Material.WOOD && !((Boolean) iblockdata.get(BlockDoor.OPEN)).booleanValue()) {
+                return PathType.DOOR_WOOD_CLOSED;
+            } else if (block instanceof BlockDoor && material == Material.ORE && !((Boolean) iblockdata.get(BlockDoor.OPEN)).booleanValue()) {
+                return PathType.DOOR_IRON_CLOSED;
+            } else if (block instanceof BlockDoor && ((Boolean) iblockdata.get(BlockDoor.OPEN)).booleanValue()) {
+                return PathType.DOOR_OPEN;
+            } else if (block instanceof BlockMinecartTrackAbstract) {
+                return PathType.RAIL;
+            } else if (!(block instanceof BlockFence) && !(block instanceof BlockCobbleWall) && (!(block instanceof BlockFenceGate) || ((Boolean) iblockdata.get(BlockFenceGate.OPEN)).booleanValue())) {
+                if (material == Material.AIR) {
+                    pathtype = PathType.OPEN;
+                } else {
+                    if (material == Material.WATER) {
+                        return PathType.WATER;
+                    }
+
+                    if (material == Material.LAVA) {
+                        return PathType.LAVA;
+                    }
+                }
+
+                if (block.b(iblockaccess, blockposition) && pathtype == PathType.BLOCKED) {
+                    pathtype = PathType.OPEN;
+                }
+
+                if (pathtype == PathType.OPEN && j >= 1) {
+                    PathType pathtype1 = a(iblockaccess, i, j - 1, k);
+
+                    pathtype = pathtype1 != PathType.WALKABLE && pathtype1 != PathType.OPEN && pathtype1 != PathType.WATER && pathtype1 != PathType.LAVA ? PathType.WALKABLE : PathType.OPEN;
+                }
+
+                if (pathtype == PathType.WALKABLE) {
+                    for (int l = i - 1; l <= i + 1; ++l) {
+                        for (int i1 = k - 1; i1 <= k + 1; ++i1) {
+                            if (l != i || i1 != k) {
+                                Block block1 = iblockaccess.getType(new BlockPosition(l, j, i1)).getBlock();
+
+                                if (block1 == Blocks.CACTUS) {
+                                    pathtype = PathType.DANGER_CACTUS;
+                                } else if (block1 == Blocks.FIRE) {
+                                    pathtype = PathType.DANGER_FIRE;
+                                }
+                            }
+                        }
+                    }
+                }
+
+                return pathtype;
+            } else {
+                return PathType.FENCE;
+            }
+        } else {
+            return PathType.TRAPDOOR;
+        }
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/PersistentVillage.java src/main/java/net/minecraft/server/PersistentVillage.java
--- src_origin/main/java/net/minecraft/server/PersistentVillage.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/PersistentVillage.java	2016-04-17 03:42:15.596951565 +0800
@@ -0,0 +1,294 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Queue;
+
+public class PersistentVillage extends PersistentBase {
+
+    private World world;
+    /*private final List<BlockPosition> c = Lists.newArrayList();
+    private final List<VillageDoor> d = Lists.newArrayList();
+    private final List<Village> villages = Lists.newArrayList();*/
+    private final Queue<BlockPosition> c = Queues.newConcurrentLinkedQueue();
+    private final Queue<VillageDoor> d = Queues.newConcurrentLinkedQueue();
+    private final Queue<Village> villages = Queues.newConcurrentLinkedQueue();
+    private int time;
+
+    public PersistentVillage(String s) {
+        super(s);
+    }
+
+    public PersistentVillage(World world) {
+        super(a(world.worldProvider));
+        this.world = world;
+        this.c();
+    }
+
+    public void a(World world) {
+        this.world = world;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(world);
+        }
+
+    }
+
+    public void a(BlockPosition blockposition) {
+        if (this.c.size() <= 64) {
+            if (!this.e(blockposition)) {
+                this.c.add(blockposition);
+            }
+
+        }
+    }
+
+    public void tick() {
+        ++this.time;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(this.time);
+        }
+
+        this.e();
+        this.f();
+        this.g();
+        if (this.time % 400 == 0) {
+            this.c();
+        }
+
+    }
+
+    private void e() {
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            if (village.g()) {
+                iterator.remove();
+                this.c();
+            }
+        }
+
+    }
+
+    public List<Village> getVillages() {
+        //return this.villages;
+        List re = new ArrayList(this.villages);
+        return re;
+    }
+
+    public Village getClosestVillage(BlockPosition blockposition, int i) {
+        Village village = null;
+        double d0 = 3.4028234663852886E38D;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village1 = (Village) iterator.next();
+            double d1 = village1.a().k(blockposition);
+
+            if (d1 < d0) {
+                float f = (float) (i + village1.b());
+
+                if (d1 <= (double) (f * f)) {
+                    village = village1;
+                    d0 = d1;
+                }
+            }
+        }
+
+        return village;
+    }
+
+    private void f() {
+        if (!this.c.isEmpty()) {
+            //this.b((BlockPosition) this.c.remove(0));
+            //get and remove from queue
+            Iterator it = this.c.iterator();
+            BlockPosition bp = (BlockPosition) it.next();
+            this.b(bp);
+            this.c.remove(bp);
+        }
+    }
+
+    private void g() {
+        Iterator it = this.d.iterator();
+        while (it.hasNext()) {
+            VillageDoor villagedoor = (VillageDoor) it.next();
+            Village village = this.getClosestVillage(villagedoor.d(), 32);
+
+            if (village == null) {
+                village = new Village(this.world);
+                this.villages.add(village);
+                this.c();
+            }
+
+            village.a(villagedoor);
+        }
+        /*
+        for (int i = 0; i < this.d.size(); ++i) {
+            VillageDoor villagedoor = (VillageDoor) this.d.get(i);
+            Village village = this.getClosestVillage(villagedoor.d(), 32);
+
+            if (village == null) {
+                village = new Village(this.world);
+                this.villages.add(village);
+                this.c();
+            }
+
+            village.a(villagedoor);
+        }*/
+
+        this.d.clear();
+    }
+
+    private void b(BlockPosition blockposition) {
+        byte b0 = 16;
+        byte b1 = 4;
+        byte b2 = 16;
+
+        for (int i = -b0; i < b0; ++i) {
+            for (int j = -b1; j < b1; ++j) {
+                for (int k = -b2; k < b2; ++k) {
+                    BlockPosition blockposition1 = blockposition.a(i, j, k);
+
+                    if (this.f(blockposition1)) {
+                        VillageDoor villagedoor = this.c(blockposition1);
+
+                        if (villagedoor == null) {
+                            this.d(blockposition1);
+                        } else {
+                            villagedoor.a(this.time);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    private VillageDoor c(BlockPosition blockposition) {
+        Iterator iterator = this.d.iterator();
+
+        VillageDoor villagedoor;
+
+        do {
+            if (!iterator.hasNext()) {
+                iterator = this.villages.iterator();
+
+                VillageDoor villagedoor1;
+
+                do {
+                    if (!iterator.hasNext()) {
+                        return null;
+                    }
+
+                    Village village = (Village) iterator.next();
+
+                    villagedoor1 = village.e(blockposition);
+                } while (villagedoor1 == null);
+
+                return villagedoor1;
+            }
+
+            villagedoor = (VillageDoor) iterator.next();
+        } while (villagedoor.d().getX() != blockposition.getX() || villagedoor.d().getZ() != blockposition.getZ() || Math.abs(villagedoor.d().getY() - blockposition.getY()) > 1);
+
+        return villagedoor;
+    }
+
+    private void d(BlockPosition blockposition) {
+        EnumDirection enumdirection = BlockDoor.f(this.world, blockposition);
+        EnumDirection enumdirection1 = enumdirection.opposite();
+        int i = this.a(blockposition, enumdirection, 5);
+        int j = this.a(blockposition, enumdirection1, i + 1);
+
+        if (i != j) {
+            this.d.add(new VillageDoor(blockposition, i < j ? enumdirection : enumdirection1, this.time));
+        }
+
+    }
+
+    private int a(BlockPosition blockposition, EnumDirection enumdirection, int i) {
+        int j = 0;
+
+        for (int k = 1; k <= 5; ++k) {
+            if (this.world.h(blockposition.shift(enumdirection, k))) {
+                ++j;
+                if (j >= i) {
+                    return j;
+                }
+            }
+        }
+
+        return j;
+    }
+
+    private boolean e(BlockPosition blockposition) {
+        Iterator iterator = this.c.iterator();
+
+        BlockPosition blockposition1;
+
+        do {
+            if (!iterator.hasNext()) {
+                return false;
+            }
+
+            blockposition1 = (BlockPosition) iterator.next();
+        } while (!blockposition1.equals(blockposition));
+
+        return true;
+    }
+
+    private boolean f(BlockPosition blockposition) {
+        IBlockData iblockdata = this.world.getType(blockposition);
+        Block block = iblockdata.getBlock();
+
+        return block instanceof BlockDoor ? iblockdata.getMaterial() == Material.WOOD : false;
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        this.time = nbttagcompound.getInt("Tick");
+        NBTTagList nbttaglist = nbttagcompound.getList("Villages", 10);
+
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound1 = nbttaglist.get(i);
+            Village village = new Village();
+
+            village.a(nbttagcompound1);
+            this.villages.add(village);
+        }
+
+    }
+
+    public void b(NBTTagCompound nbttagcompound) {
+        nbttagcompound.setInt("Tick", this.time);
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+            village.b(nbttagcompound1);
+            nbttaglist.add(nbttagcompound1);
+        }
+
+        nbttagcompound.set("Villages", nbttaglist);
+    }
+
+    public static String a(WorldProvider worldprovider) {
+        return "villages" + worldprovider.getDimensionManager().c();
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/PlayerChunkMap.java src/main/java/net/minecraft/server/PlayerChunkMap.java
--- src_origin/main/java/net/minecraft/server/PlayerChunkMap.java	2016-04-03 23:27:22.917613931 +0800
+++ src/main/java/net/minecraft/server/PlayerChunkMap.java	2016-04-17 03:42:15.610951564 +0800
@@ -4,6 +4,7 @@
 import com.google.common.collect.AbstractIterator;
 import com.google.common.collect.ComparisonChain;
 import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -14,6 +15,10 @@
 
 // CraftBukkit start
 import java.util.LinkedList;
+import java.util.Queue;
+import org.hose.ChunkFlush_Pool;
+import org.hose.PlayerChunkMap_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public class PlayerChunkMap {
@@ -39,10 +44,14 @@
     private final WorldServer world;
     private final List<EntityPlayer> managedPlayers = Lists.newArrayList();
     private final LongHashMap<PlayerChunk> e = new LongHashMap();
-    private final Set<PlayerChunk> f = Sets.newHashSet();
-    private final List<PlayerChunk> g = Lists.newLinkedList();
-    private final List<PlayerChunk> h = Lists.newLinkedList();
-    private final List<PlayerChunk> i = Lists.newArrayList();
+    //private final Set<PlayerChunk> f = Sets.newHashSet();
+    private final Set<PlayerChunk> f = Sets.newConcurrentHashSet();
+    //private final List<PlayerChunk> g = Lists.newLinkedList();
+    private final List<PlayerChunk> g = Collections.synchronizedList(Lists.newLinkedList());
+    //private final List<PlayerChunk> h = Lists.newLinkedList();
+    private final List<PlayerChunk> h = Collections.synchronizedList(Lists.newLinkedList());
+    //private final List<PlayerChunk> i = Lists.newArrayList();
+    private final Queue<PlayerChunk> i = Queues.newConcurrentLinkedQueue();
     private int j;
     private long k;
     private boolean l = true;
@@ -97,6 +106,7 @@
         };
     }
 
+    List<PlayerChunk> chunkflush_list = new LinkedList();
     public void flush() {
         long i = this.world.getTime();
         int j;
@@ -105,20 +115,36 @@
         if (i - this.k > 8000L) {
             this.k = i;
 
+            Iterator it = this.i.iterator();
+            //chunkflush_list.clear();
+            while (it.hasNext()) {
+                playerchunk = (PlayerChunk) it.next();
+                playerchunk.d();
+                playerchunk.c();
+                //chunkflush_list.add((PlayerChunk) it.next());
+            }
+            //SpigotWorldConfig.ChunkFlushPool.invoke(new ChunkFlush_Pool(chunkflush_list));
+            /*
             for (j = 0; j < this.i.size(); ++j) {
                 playerchunk = (PlayerChunk) this.i.get(j);
                 playerchunk.d();
                 playerchunk.c();
-            }
+            }*/
         }
 
         if (!this.f.isEmpty()) {
             Iterator iterator = this.f.iterator();
 
+            chunkflush_list.clear();
+            while (iterator.hasNext()) {
+                chunkflush_list.add((PlayerChunk) iterator.next());
+            }
+            SpigotWorldConfig.ChunkFlushPool.invoke(new ChunkFlush_Pool(chunkflush_list));
+            /*
             while (iterator.hasNext()) {
                 playerchunk = (PlayerChunk) iterator.next();
                 playerchunk.d();
-            }
+            }*/
 
             this.f.clear();
         }
@@ -212,7 +238,8 @@
         return (PlayerChunk) this.e.getEntry(d(i, j));
     }
 
-    private PlayerChunk c(int i, int j) {
+    public PlayerChunk c(int i, int j) {
+    //private PlayerChunk c(int i, int j) {
         long k = d(i, j);
         PlayerChunk playerchunk = (PlayerChunk) this.e.getEntry(k);
 
@@ -271,9 +298,11 @@
         }
 
         Collections.sort(chunkList, new ChunkCoordComparator(entityplayer));
+        /*
         for (ChunkCoordIntPair pair : chunkList) {
             this.c(pair.x, pair.z).a(entityplayer);
-        }
+        }*/
+        SpigotWorldConfig.PlayerChunkPool.invoke(new PlayerChunkMap_Pool(this, chunkList, entityplayer));
         // CraftBukkit end
 
         this.managedPlayers.add(entityplayer);
@@ -345,9 +374,11 @@
 
                 // CraftBukkit start - send nearest chunks first
                 Collections.sort(chunksToLoad, new ChunkCoordComparator(entityplayer));
+                /*
                 for (ChunkCoordIntPair pair : chunksToLoad) {
                     this.c(pair.x, pair.z).a(entityplayer);
-                }
+                }*/
+                SpigotWorldConfig.PlayerChunkPool.invoke(new PlayerChunkMap_Pool(this, chunksToLoad, entityplayer));
                 // CraftBukkit end
             }
         }
diff -Naur src_origin/main/java/net/minecraft/server/PlayerConnection.java src/main/java/net/minecraft/server/PlayerConnection.java
--- src_origin/main/java/net/minecraft/server/PlayerConnection.java	2016-04-03 23:27:22.930613931 +0800
+++ src/main/java/net/minecraft/server/PlayerConnection.java	2016-04-17 03:42:15.638951561 +0800
@@ -313,7 +313,7 @@
                 }
                 speed *= 2f; // TODO: Get the speed of the vehicle instead of the player
 
-                if (d10 - d9 > Math.max(100, Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2)) && (!this.minecraftServer.R() || !this.minecraftServer.Q().equals(entity.getName()))) { // Spigot
+                if (d10 - d9 > Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2) && (!this.minecraftServer.R() || !this.minecraftServer.Q().equals(entity.getName()))) { // Spigot
                 // CraftBukkit end
                     PlayerConnection.LOGGER.warn(entity.getName() + " (vehicle of " + this.player.getName() + ") moved too quickly! " + d6 + "," + d7 + "," + d8);
                     this.networkManager.sendPacket(new PacketPlayOutVehicleMove(entity));
@@ -522,7 +522,7 @@
                         if (!this.player.K() && (!this.player.x().getGameRules().getBoolean("disableElytraMovementCheck") || !this.player.cB())) {
                             float f2 = this.player.cB() ? 300.0F : 100.0F;
 
-                            if (d11 - d10 > Math.max(100, Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2)) && (!this.minecraftServer.R() || !this.minecraftServer.Q().equals(this.player.getName()))) { // Spigot
+                            if (d11 - d10 > Math.pow((double) (org.spigotmc.SpigotConfig.movedTooQuicklyMultiplier * (float) i * speed), 2) && (!this.minecraftServer.R() || !this.minecraftServer.Q().equals(this.player.getName()))) { // Spigot
                         // CraftBukkit end
                                 PlayerConnection.LOGGER.warn(this.player.getName() + " moved too quickly! " + d7 + "," + d8 + "," + d9);
                                 this.a(this.player.locX, this.player.locY, this.player.locZ, this.player.yaw, this.player.pitch);
diff -Naur src_origin/main/java/net/minecraft/server/PlayerInventory.java src/main/java/net/minecraft/server/PlayerInventory.java
--- src_origin/main/java/net/minecraft/server/PlayerInventory.java	2016-04-03 23:27:22.952613931 +0800
+++ src/main/java/net/minecraft/server/PlayerInventory.java	2016-04-17 03:42:15.642951561 +0800
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.concurrent.Callable;
 
 // CraftBukkit start
@@ -23,7 +24,7 @@
     public boolean f;
 
     // CraftBukkit start - add fields and methods
-    public List<HumanEntity> transaction = new java.util.ArrayList<HumanEntity>();
+    public List<HumanEntity> transaction = Collections.synchronizedList(new java.util.ArrayList<HumanEntity>());
     private int maxStack = MAX_STACK;
 
     public ItemStack[] getContents() {
diff -Naur src_origin/main/java/net/minecraft/server/PlayerList.java src/main/java/net/minecraft/server/PlayerList.java
--- src_origin/main/java/net/minecraft/server/PlayerList.java	2016-04-03 23:27:22.954613931 +0800
+++ src/main/java/net/minecraft/server/PlayerList.java	2016-04-17 03:42:15.660951559 +0800
@@ -947,7 +947,7 @@
                         entity.getBukkitEntity().setVelocity(velocity);
                     }
                 }
-                // worldserver1.addEntity(entity);
+                worldserver1.addEntity(entity);
                 worldserver1.entityJoinedWorld(entity, false);
             }
 
diff -Naur src_origin/main/java/net/minecraft/server/PortalTravelAgent.java src/main/java/net/minecraft/server/PortalTravelAgent.java
--- src_origin/main/java/net/minecraft/server/PortalTravelAgent.java	2016-04-03 23:27:22.962613931 +0800
+++ src/main/java/net/minecraft/server/PortalTravelAgent.java	2016-04-17 03:42:15.664951559 +0800
@@ -7,13 +7,16 @@
 
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Random;
+import java.util.concurrent.ConcurrentHashMap;
 
 public class PortalTravelAgent {
 
     private final WorldServer world;
     private final Random b;
-    private final LongHashMap<PortalTravelAgent.ChunkCoordinatesPortal> c = new LongHashMap();
+    //private final LongHashMap<PortalTravelAgent.ChunkCoordinatesPortal> c = new LongHashMap();
+    private final Map<Long, PortalTravelAgent.ChunkCoordinatesPortal> c = new ConcurrentHashMap();
     private final List<Long> d = Lists.newArrayList();
 
     public PortalTravelAgent(WorldServer worldserver) {
@@ -121,8 +124,10 @@
         Object object = BlockPosition.ZERO;
         long k = ChunkCoordIntPair.a(i, j);
 
-        if (this.c.contains(k)) {
-            PortalTravelAgent.ChunkCoordinatesPortal portaltravelagent_chunkcoordinatesportal = (PortalTravelAgent.ChunkCoordinatesPortal) this.c.getEntry(k);
+        //if (this.c.contains(k)) {
+        if (this.c.containsKey(k)) {
+            //PortalTravelAgent.ChunkCoordinatesPortal portaltravelagent_chunkcoordinatesportal = (PortalTravelAgent.ChunkCoordinatesPortal) this.c.getEntry(k);
+            PortalTravelAgent.ChunkCoordinatesPortal portaltravelagent_chunkcoordinatesportal = (PortalTravelAgent.ChunkCoordinatesPortal) this.c.get(k);
 
             d0 = 0.0D;
             object = portaltravelagent_chunkcoordinatesportal;
@@ -459,7 +464,8 @@
 
             while (iterator.hasNext()) {
                 Long olong = (Long) iterator.next();
-                PortalTravelAgent.ChunkCoordinatesPortal portaltravelagent_chunkcoordinatesportal = (PortalTravelAgent.ChunkCoordinatesPortal) this.c.getEntry(olong.longValue());
+                //PortalTravelAgent.ChunkCoordinatesPortal portaltravelagent_chunkcoordinatesportal = (PortalTravelAgent.ChunkCoordinatesPortal) this.c.getEntry(olong.longValue());
+                PortalTravelAgent.ChunkCoordinatesPortal portaltravelagent_chunkcoordinatesportal = (PortalTravelAgent.ChunkCoordinatesPortal) this.c.get(olong.longValue());
 
                 if (portaltravelagent_chunkcoordinatesportal == null || portaltravelagent_chunkcoordinatesportal.c < j) {
                     iterator.remove();
diff -Naur src_origin/main/java/net/minecraft/server/TileEntity.java src/main/java/net/minecraft/server/TileEntity.java
--- src_origin/main/java/net/minecraft/server/TileEntity.java	2016-04-03 23:27:23.114613931 +0800
+++ src/main/java/net/minecraft/server/TileEntity.java	2016-04-17 03:42:15.812951545 +0800
@@ -20,11 +20,19 @@
     protected boolean d;
     private int h;
     protected Block e;
+    private static int entityCount;
+    private int id;
 
     public TileEntity() {
+        //add id
+        this.id = TileEntity.entityCount++;
         this.position = BlockPosition.ZERO;
         this.h = -1;
     }
+    
+    public int getId() {
+        return this.id;
+    }
 
     private static void a(Class<? extends TileEntity> oclass, String s) {
         if (TileEntity.f.containsKey(s)) {
diff -Naur src_origin/main/java/net/minecraft/server/World.java src/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2016-04-03 23:27:23.228613931 +0800
+++ src/main/java/net/minecraft/server/World.java	2016-04-17 03:42:15.923951535 +0800
@@ -15,7 +15,14 @@
 
 // CraftBukkit start
 import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.LinkedList;
 import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.RecursiveAction;
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
@@ -27,14 +34,21 @@
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 import org.bukkit.generator.ChunkGenerator;
+import org.hose.EntityTick_Pool;
+import org.hose.TileTick_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class World implements IBlockAccess {
 
+    List<Integer> ens_list = new LinkedList();
+    List<Integer> ents_list = new LinkedList();
     private int a = 63;
     protected boolean d;
     // Spigot start - guard entity list from removals
-    public final List<Entity> entityList = new java.util.ArrayList<Entity>()
+    public final ConcurrentHashMap<Integer, Entity> entityList_map = new ConcurrentHashMap();
+    public List<Entity> entityList = Collections.synchronizedList(new ArrayList<Entity>());
+    /*public final List<Entity> entityList = new java.util.ArrayList<Entity>()
     {
         @Override
         public Entity remove(int index)
@@ -57,11 +71,13 @@
                 throw new java.util.ConcurrentModificationException();
             }
         }
-    };
+    };*/
     // Spigot end
     protected final List<Entity> f = Lists.newArrayList();
-    public final List<TileEntity> tileEntityList = Lists.newArrayList();
-    public final List<TileEntity> tileEntityListTick = Lists.newArrayList();
+    //public final List<TileEntity> tileEntityList = Lists.newArrayList();
+    public final Queue<TileEntity> tileEntityList = Queues.newConcurrentLinkedQueue();
+    //public final List<TileEntity> tileEntityListTick = Lists.newArrayList();
+    public final Map<Integer, TileEntity> tileEntityListTick = new ConcurrentHashMap();
     private final List<TileEntity> b = Lists.newArrayList();
     private final List<TileEntity> tileEntityListUnload = Lists.newArrayList();
     public final List<EntityHuman> players = Lists.newArrayList();
@@ -122,16 +138,16 @@
     public long ticksPerAnimalSpawns;
     public long ticksPerMonsterSpawns;
     public boolean populating;
-    private int tickPosition;
+    //private int tickPosition;
     public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
 
     public final SpigotTimings.WorldTimingsHandler timings; // Spigot
-    private boolean guardEntityList; // Spigot
+    //private boolean guardEntityList; // Spigot
     public static boolean haveWeSilencedAPhysicsCrash;
     public static String blockLocation;
     private org.spigotmc.TickLimiter entityLimiter;
     private org.spigotmc.TickLimiter tileLimiter;
-    private int tileTickPosition;
+    //private int tileTickPosition;
 
     public CraftWorld getWorld() {
         return this.world;
@@ -152,7 +168,8 @@
         this.ticksPerAnimalSpawns = this.getServer().getTicksPerAnimalSpawns(); // CraftBukkit
         this.ticksPerMonsterSpawns = this.getServer().getTicksPerMonsterSpawns(); // CraftBukkit
         // CraftBukkit end
-        this.u = Lists.newArrayList(new IWorldAccess[] { this.t});
+        //this.u = Lists.newArrayList(new IWorldAccess[] { this.t});
+        this.u = Collections.synchronizedList(Lists.newArrayList(new IWorldAccess[] { this.t}));
         this.L = Calendar.getInstance();
         this.scoreboard = new Scoreboard();
         this.allowMonsters = true;
@@ -1004,7 +1021,9 @@
             }
 
             this.getChunkAt(i, j).a(entity);
-            this.entityList.add(entity);
+            //this.entityList.add(entity);
+            this.entityList_map.put(entity.getId(), entity);
+            this.entityList = new ArrayList<Entity>(entityList_map.values());
             this.b(entity);
             return true;
         }
@@ -1070,22 +1089,24 @@
             this.everyoneSleeping();
         }
 
-        if (!guardEntityList) { // Spigot - It will get removed after the tick if we are ticking
+        //if (!guardEntityList) { // Spigot - It will get removed after the tick if we are ticking
         int i = entity.ab;
         int j = entity.ad;
 
         if (entity.aa && this.isChunkLoaded(i, j, true)) {
             this.getChunkAt(i, j).b(entity);
-        }
+        //}
 
+        this.entityList_map.remove(entity.getId());
+        this.entityList = new ArrayList<Entity>(entityList_map.values());
         // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
-        int index = this.entityList.indexOf(entity);
+        /*int index = this.entityList.indexOf(entity);
         if (index != -1) {
             if (index <= this.tickPosition) {
                 this.tickPosition--;
             }
             this.entityList.remove(index);
-        }
+        }*/
         // CraftBukkit end
         } // Spigot
         this.c(entity);
@@ -1367,8 +1388,12 @@
         }
 
         this.methodProfiler.c("remove");
-        this.entityList.removeAll(this.f);
-
+        //this.entityList.removeAll(this.f);
+        for (Entity ent : this.f) {
+            this.entityList_map.remove(ent.getId());
+        }
+        this.entityList = new ArrayList<Entity>(entityList_map.values());
+        
         int j;
 
         for (i = 0; i < this.f.size(); ++i) {
@@ -1389,18 +1414,28 @@
         this.l();
         this.methodProfiler.c("regular");
 
-        CrashReportSystemDetails crashreportsystemdetails1;
-        CrashReport crashreport1;
+        //CrashReportSystemDetails crashreportsystemdetails1;
+        //CrashReport crashreport1;
 
         org.spigotmc.ActivationRange.activateEntities(this); // Spigot
         timings.entityTick.startTiming(); // Spigot
-        guardEntityList = true; // Spigot
+        //guardEntityList = true; // Spigot
         // CraftBukkit start - Use field for loop variable
-        int entitiesThisCycle = 0;
-        if (tickPosition < 0) tickPosition = 0;
+        //int entitiesThisCycle = 0;
+        //if (tickPosition < 0) tickPosition = 0;
+        ens_list.clear();
+        Iterator ite = entityList_map.keySet().iterator();
+        //List<RecursiveAction> forks = new LinkedList();
         for (entityLimiter.initTick();
-                entitiesThisCycle < entityList.size() && (entitiesThisCycle % 10 != 0 || entityLimiter.shouldContinue());
-                tickPosition++, entitiesThisCycle++) {
+                //entitiesThisCycle < entityList.size() && (entitiesThisCycle % 10 != 0 || entityLimiter.shouldContinue());
+                ite.hasNext() && entityLimiter.shouldContinue();
+                //tickPosition++, entitiesThisCycle++) {
+                ) {
+            ens_list.add((int) ite.next());
+            /*EntityTick_Pool tasks = new EntityTick_Pool(this, (int) ite.next());
+            forks.add(tasks);
+            tasks.fork();*/
+            /*
             tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
             entity = (Entity) this.entityList.get(this.tickPosition);
             // CraftBukkit end
@@ -1444,16 +1479,23 @@
                 this.c(entity);
             }
 
-            this.methodProfiler.b();
+            this.methodProfiler.b();*/
         }
-        guardEntityList = false; // Spigot
+        SpigotWorldConfig.EntityTickPool.invoke(new EntityTick_Pool(this, ens_list));
+        
+        
+        
+        //guardEntityList = false; // Spigot
 
         timings.entityTick.stopTiming(); // Spigot
         this.methodProfiler.c("blockEntities");
         this.M = true;
         // CraftBukkit start - From below, clean up tile entities before ticking them
         if (!this.tileEntityListUnload.isEmpty()) {
-            this.tileEntityListTick.removeAll(this.tileEntityListUnload);
+            //this.tileEntityListTick.removeAll(this.tileEntityListUnload);
+            for (TileEntity tent : this.tileEntityListUnload) {
+                this.tileEntityListTick.remove(tent.getId());
+            }
             this.tileEntityList.removeAll(this.tileEntityListUnload);
             this.tileEntityListUnload.clear();
         }
@@ -1461,10 +1503,20 @@
 
         // Spigot start
         // Iterator iterator = this.tileEntityListTick.iterator();
-        int tilesThisCycle = 0;
+        //int tilesThisCycle = 0;
+        Iterator itt = tileEntityListTick.keySet().iterator();
+        ents_list.clear();
+        //List<RecursiveAction> forkts = new LinkedList();
         for (tileLimiter.initTick();
-                tilesThisCycle < tileEntityListTick.size() && (tilesThisCycle % 10 != 0 || tileLimiter.shouldContinue());
-                tileTickPosition++, tilesThisCycle++) {
+                //tilesThisCycle < tileEntityListTick.size() && (tilesThisCycle % 10 != 0 || tileLimiter.shouldContinue());
+                itt.hasNext() && tileLimiter.shouldContinue();
+                //tileTickPosition++, tilesThisCycle++) {
+                ) {
+            ents_list.add((int) itt.next());
+            /*TileTick_Pool tasks = new TileTick_Pool(this, (int) itt.next());
+            tasks.fork();
+            tasks.join();*/
+            /*
             tileTickPosition = (tileTickPosition < tileEntityListTick.size()) ? tileTickPosition : 0;
             TileEntity tileentity = (TileEntity) this.tileEntityListTick.get(tileTickPosition);
             // Spigot start
@@ -1481,7 +1533,7 @@
 
                 if (this.isLoaded(blockposition) && this.N.a(blockposition)) {
                     try {
-                        this.methodProfiler.a(""/*tileentity.getClass().getSimpleName()*/); // CraftBukkit: SPIGOT-1900
+                        //this.methodProfiler.a(""/tileentity.getClass().getSimpleName()/); // CraftBukkit: SPIGOT-1900
                         tileentity.tickTimer.startTiming(); // Spigot
                         ((ITickable) tileentity).c();
                         this.methodProfiler.b();
@@ -1506,8 +1558,10 @@
                 if (this.isLoaded(tileentity.getPosition())) {
                     this.getChunkAtWorldCoords(tileentity.getPosition()).d(tileentity.getPosition());
                 }
-            }
+            }*/
         }
+        SpigotWorldConfig.TileTickPool.invoke(new TileTick_Pool(this, ents_list));
+        
 
         timings.tileEntityTick.stopTiming(); // Spigot
         timings.tileEntityPending.startTiming(); // Spigot
@@ -1556,13 +1610,116 @@
         this.methodProfiler.b();
     }
 
+    CrashReportSystemDetails crashreportsystemdetails1;
+    CrashReport crashreport1;
+    public void entity_tick_hose(int id){
+        //tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
+        //entity = (Entity) this.entityList.get(this.tickPosition);
+        Entity entity = (Entity) this.entityList_map.get(id);
+        // CraftBukkit end
+        Entity entity1 = entity.by();
+
+        if (entity1 != null) {
+            if (!entity1.dead && entity1.w(entity)) {
+                //continue;
+                return;
+            }
+
+            entity.stopRiding();
+        }
+
+        this.methodProfiler.a("tick");
+        if (!entity.dead && !(entity instanceof EntityPlayer)) {
+            try {
+                SpigotTimings.tickEntityTimer.startTiming(); // Spigot
+                this.g(entity);
+                SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
+            } catch (Throwable throwable1) {
+                crashreport1 = CrashReport.a(throwable1, "Ticking entity");
+                crashreportsystemdetails1 = crashreport1.a("Entity being ticked");
+                entity.appendEntityCrashDetails(crashreportsystemdetails1);
+                throw new ReportedException(crashreport1);
+            }
+        }
+
+        this.methodProfiler.b();
+        this.methodProfiler.a("remove");
+        if (entity.dead) {
+            int j = entity.ab;
+            int l = entity.ad;
+
+            if (entity.aa && this.isChunkLoaded(j, l, true)) {
+                this.getChunkAt(j, l).b(entity);
+            }
+
+            //guardEntityList = false; // Spigot
+            //this.entityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
+            this.entityList_map.remove(id); // CraftBukkit - Use field for loop variable
+            this.entityList = new ArrayList<Entity>(entityList_map.values());
+            //guardEntityList = true; // Spigot
+            this.c(entity);
+        }
+
+        this.methodProfiler.b();
+    }
+    
+    public void tile_tick_hose(int id) {
+        //tileTickPosition = (tileTickPosition < tileEntityListTick.size()) ? tileTickPosition : 0;
+        //TileEntity tileentity = (TileEntity) this.tileEntityListTick.get(tileTickPosition);
+        TileEntity tileentity = (TileEntity) this.tileEntityListTick.get(id);
+        // Spigot start
+        if (tileentity == null) {
+            getServer().getLogger().severe("Spigot has detected a null entity and has removed it, preventing a crash");
+            //tilesThisCycle--;
+            //this.tileEntityListTick.remove(tileTickPosition--);
+            this.tileEntityListTick.remove(id);
+            //continue;
+            return;
+        }
+        // Spigot end
+
+        if (!tileentity.x() && tileentity.t()) {
+            BlockPosition blockposition = tileentity.getPosition();
+
+            if (this.isLoaded(blockposition) && this.N.a(blockposition)) {
+                try {
+                    this.methodProfiler.a(""/*tileentity.getClass().getSimpleName()*/); // CraftBukkit: SPIGOT-1900
+                    tileentity.tickTimer.startTiming(); // Spigot
+                    ((ITickable) tileentity).c();
+                    this.methodProfiler.b();
+                } catch (Throwable throwable2) {
+                    crashreport1 = CrashReport.a(throwable2, "Ticking block entity");
+                    crashreportsystemdetails1 = crashreport1.a("Block entity being ticked");
+                    tileentity.a(crashreportsystemdetails1);
+                    throw new ReportedException(crashreport1);
+                }
+                // Spigot start
+                finally {
+                    tileentity.tickTimer.stopTiming();
+                }
+                // Spigot end
+            }
+        }
+
+        if (tileentity.x()) {
+            //tilesThisCycle--;
+            //this.tileEntityListTick.remove(tileTickPosition--);
+            this.tileEntityListTick.remove(id);
+            this.tileEntityList.remove(tileentity);
+            if (this.isLoaded(tileentity.getPosition())) {
+                this.getChunkAtWorldCoords(tileentity.getPosition()).d(tileentity.getPosition());
+            }
+        }
+    }
+    
     protected void l() {}
 
     public boolean a(TileEntity tileentity) {
         boolean flag = this.tileEntityList.add(tileentity);
 
         if (flag && tileentity instanceof ITickable) {
-            this.tileEntityListTick.add(tileentity);
+            //this.tileEntityListTick.add(tileentity);
+            this.tileEntityListTick.put(tileentity.getId(), tileentity);
         }
 
         return flag;
@@ -1593,7 +1750,7 @@
         byte b0 = 32;
 
         // Spigot start
-        if (flag && !org.spigotmc.ActivationRange.checkIfActive(entity)) {
+        if (!org.spigotmc.ActivationRange.checkIfActive(entity)) {
             entity.ticksLived++;
             entity.inactiveTick();
         } else {
@@ -2025,7 +2182,8 @@
             if (tileentity != null) {
                 this.b.remove(tileentity);
                 this.tileEntityList.remove(tileentity);
-                this.tileEntityListTick.remove(tileentity);
+                //this.tileEntityListTick.remove(tileentity);
+                this.tileEntityListTick.remove(tileentity.getId());
             }
 
             this.getChunkAtWorldCoords(blockposition).d(blockposition);
@@ -2449,6 +2607,14 @@
 
     public <T extends Entity> List<T> a(Class<? extends T> oclass, Predicate<? super T> predicate) {
         ArrayList arraylist = Lists.newArrayList();
+        
+        for (Map.Entry me : this.entityList_map.entrySet()) {
+            Entity entity = (Entity) me.getValue();
+            if (oclass.isAssignableFrom(entity.getClass()) && predicate.apply((T) entity)) {
+                arraylist.add(entity);
+            }
+        }
+        /*
         Iterator iterator = this.entityList.iterator();
 
         while (iterator.hasNext()) {
@@ -2457,7 +2623,7 @@
             if (oclass.isAssignableFrom(entity.getClass()) && predicate.apply((T) entity)) {
                 arraylist.add(entity);
             }
-        }
+        }*/
 
         return arraylist;
     }
@@ -2533,6 +2699,24 @@
 
     public int a(Class<?> oclass) {
         int i = 0;
+        
+        for (Map.Entry me : this.entityList_map.entrySet()) {
+            Entity entity = (Entity) me.getValue();
+            // CraftBukkit start - Split out persistent check, don't apply it to special persistent mobs
+            if (entity instanceof EntityInsentient) {
+                EntityInsentient entityinsentient = (EntityInsentient) entity;
+                if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
+                    continue;
+                }
+            }
+            
+            if (oclass.isAssignableFrom(entity.getClass())) {
+            // if ((!(entity instanceof EntityInsentient) || !((EntityInsentient) entity).isPersistent()) && oclass.isAssignableFrom(entity.getClass())) {
+                // CraftBukkit end
+                ++i;
+            }
+        }
+        /*
         Iterator iterator = this.entityList.iterator();
 
         while (iterator.hasNext()) {
@@ -2550,7 +2734,7 @@
                 // CraftBukkit end
                 ++i;
             }
-        }
+        }*/
 
         return i;
     }
@@ -2567,10 +2751,12 @@
             if (entity == null) {
                 continue;
             }
-            this.entityList.add(entity);
+            //this.entityList.add(entity);
+            this.entityList_map.put(entity.getId(), entity);
             // CraftBukkit end
             this.b(entity);
         }
+        this.entityList = new ArrayList<Entity>(entityList_map.values());
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/WorldServer.java src/main/java/net/minecraft/server/WorldServer.java
--- src_origin/main/java/net/minecraft/server/WorldServer.java	2016-04-03 23:27:23.309613931 +0800
+++ src/main/java/net/minecraft/server/WorldServer.java	2016-04-17 03:42:16.010951527 +0800
@@ -669,12 +669,14 @@
                     this.getChunkAt(j, k).b(entity);
                 }
 
-                this.entityList.remove(entity);
+                //this.entityList.remove(entity);
+                this.entityList_map.remove(entity.getId());
                 this.c(entity);
             }
 
             this.methodProfiler.b();
         }
+        this.entityList = new ArrayList<Entity>(entityList_map.values());
 
     }
 
@@ -704,7 +706,20 @@
                 this.methodProfiler.a("cleaning");
 
                 NextTickListEntry nextticklistentry;
+                
+                Iterator it = this.nextTickList.iterator();
+                while (it.hasNext()) {
+                    nextticklistentry = (NextTickListEntry) it.next();
+                    if (!flag && nextticklistentry.b > this.worldData.getTime()) {
+                        break;
+                    }
 
+                    // CraftBukkit - use nextTickList
+                    this.nextTickList.remove(nextticklistentry);
+                    // this.nextTickListHash.remove(nextticklistentry);
+                    this.U.add(nextticklistentry);
+                }
+                /*
                 for (int j = 0; j < i; ++j) {
                     nextticklistentry = (NextTickListEntry) this.nextTickList.first();
                     if (!flag && nextticklistentry.b > this.worldData.getTime()) {
@@ -715,7 +730,7 @@
                     this.nextTickList.remove(nextticklistentry);
                     // this.nextTickListHash.remove(nextticklistentry);
                     this.U.add(nextticklistentry);
-                }
+                }*/
 
                 this.methodProfiler.b();
                 this.methodProfiler.a("ticking");
@@ -1082,10 +1097,12 @@
             Entity entity = (Entity) iterator.next();
 
             if (this.i(entity)) {
-                this.entityList.add(entity);
+                //this.entityList.add(entity);
+                this.entityList_map.put(entity.getId(), entity);
                 this.b(entity);
             }
         }
+        this.entityList = new ArrayList<Entity>(entityList_map.values());
 
     }
 
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java src/main/java/org/bukkit/craftbukkit/CraftWorld.java
--- src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-04-03 23:27:23.448613931 +0800
+++ src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-04-17 03:42:16.293951501 +0800
@@ -8,6 +8,7 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Iterator;
+import java.util.Map;
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
@@ -656,7 +657,8 @@
     public List<Entity> getEntities() {
         List<Entity> list = new ArrayList<Entity>();
 
-        for (Object o : world.entityList) {
+        for (Map.Entry me : world.entityList_map.entrySet()) {
+            Object o = me.getValue();
             if (o instanceof net.minecraft.server.Entity) {
                 net.minecraft.server.Entity mcEnt = (net.minecraft.server.Entity) o;
                 Entity bukkitEntity = mcEnt.getBukkitEntity();
@@ -667,6 +669,18 @@
                 }
             }
         }
+        /*
+        for (Object o : world.entityList) {
+            if (o instanceof net.minecraft.server.Entity) {
+                net.minecraft.server.Entity mcEnt = (net.minecraft.server.Entity) o;
+                Entity bukkitEntity = mcEnt.getBukkitEntity();
+
+                // Assuming that bukkitEntity isn't null
+                if (bukkitEntity != null) {
+                    list.add(bukkitEntity);
+                }
+            }
+        }*/
 
         return list;
     }
@@ -674,7 +688,8 @@
     public List<LivingEntity> getLivingEntities() {
         List<LivingEntity> list = new ArrayList<LivingEntity>();
 
-        for (Object o : world.entityList) {
+        for (Map.Entry me : world.entityList_map.entrySet()) {
+            Object o = me.getValue();
             if (o instanceof net.minecraft.server.Entity) {
                 net.minecraft.server.Entity mcEnt = (net.minecraft.server.Entity) o;
                 Entity bukkitEntity = mcEnt.getBukkitEntity();
@@ -685,6 +700,18 @@
                 }
             }
         }
+        /*
+        for (Object o : world.entityList) {
+            if (o instanceof net.minecraft.server.Entity) {
+                net.minecraft.server.Entity mcEnt = (net.minecraft.server.Entity) o;
+                Entity bukkitEntity = mcEnt.getBukkitEntity();
+
+                // Assuming that bukkitEntity isn't null
+                if (bukkitEntity != null && bukkitEntity instanceof LivingEntity) {
+                    list.add((LivingEntity) bukkitEntity);
+                }
+            }
+        }*/
 
         return list;
     }
@@ -699,7 +726,8 @@
     public <T extends Entity> Collection<T> getEntitiesByClass(Class<T> clazz) {
         Collection<T> list = new ArrayList<T>();
 
-        for (Object entity: world.entityList) {
+        for (Map.Entry me : world.entityList_map.entrySet()) {
+            Entity entity = (Entity) me.getValue();
             if (entity instanceof net.minecraft.server.Entity) {
                 Entity bukkitEntity = ((net.minecraft.server.Entity) entity).getBukkitEntity();
 
@@ -714,6 +742,23 @@
                 }
             }
         }
+        
+        /*
+        for (Object entity: world.entityList) {
+            if (entity instanceof net.minecraft.server.Entity) {
+                Entity bukkitEntity = ((net.minecraft.server.Entity) entity).getBukkitEntity();
+
+                if (bukkitEntity == null) {
+                    continue;
+                }
+
+                Class<?> bukkitClass = bukkitEntity.getClass();
+
+                if (clazz.isAssignableFrom(bukkitClass)) {
+                    list.add((T) bukkitEntity);
+                }
+            }
+        }*/
 
         return list;
     }
@@ -721,6 +766,26 @@
     public Collection<Entity> getEntitiesByClasses(Class<?>... classes) {
         Collection<Entity> list = new ArrayList<Entity>();
 
+        for (Map.Entry me : world.entityList_map.entrySet()) {
+             Entity entity = (Entity) me.getValue();
+             if (entity instanceof net.minecraft.server.Entity) {
+                Entity bukkitEntity = ((net.minecraft.server.Entity) entity).getBukkitEntity();
+
+                if (bukkitEntity == null) {
+                    continue;
+                }
+
+                Class<?> bukkitClass = bukkitEntity.getClass();
+
+                for (Class<?> clazz : classes) {
+                    if (clazz.isAssignableFrom(bukkitClass)) {
+                        list.add(bukkitEntity);
+                        break;
+                    }
+                }
+            }
+        }
+        /*
         for (Object entity: world.entityList) {
             if (entity instanceof net.minecraft.server.Entity) {
                 Entity bukkitEntity = ((net.minecraft.server.Entity) entity).getBukkitEntity();
@@ -738,7 +803,7 @@
                     }
                 }
             }
-        }
+        }*/
 
         return list;
     }
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
--- src_origin/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java	2016-04-03 23:27:24.112613932 +0800
+++ src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java	2016-04-17 03:42:17.160951422 +0800
@@ -242,7 +242,6 @@
         // entity.world = ((CraftWorld) location.getWorld()).getHandle();
         // Spigot end
         entity.setLocation(location.getX(), location.getY(), location.getZ(), location.getYaw(), location.getPitch());
-        entity.world.entityJoinedWorld(entity, false); // Spigot - register to new chunk
         // entity.setLocation() throws no event, and so cannot be cancelled
         return true;
     }
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
--- src_origin/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java	2016-04-03 23:27:24.571613932 +0800
+++ src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java	2016-04-17 03:42:17.605951381 +0800
@@ -496,7 +496,8 @@
             if (source == DamageSource.CACTUS) {
                 cause = DamageCause.CONTACT;
             } else {
-                throw new RuntimeException(String.format("Unhandled damage of %s by %s from %s", entity, damager, source.translationIndex)); // Spigot
+                cause = DamageCause.FALL;
+                //throw new RuntimeException(String.format("Unhandled damage of %s by %s from %s", entity, damager, source.translationIndex)); // Spigot
             }
             EntityDamageEvent event = callEvent(new EntityDamageByBlockEvent(damager, entity.getBukkitEntity(), cause, modifiers, modifierFunctions));
             if (!event.isCancelled()) {
@@ -516,7 +517,8 @@
             } else if (source == DamageSource.DRAGON_BREATH) {
                 cause = DamageCause.DRAGON_BREATH;
             } else {
-                throw new RuntimeException(String.format("Unhandled damage of %s by %s from %s", entity, damager.getHandle(), source.translationIndex)); // Spigot
+                cause = DamageCause.FALL;
+                //throw new RuntimeException(String.format("Unhandled damage of %s by %s from %s", entity, damager.getHandle(), source.translationIndex)); // Spigot
             }
             EntityDamageEvent event = callEvent(new EntityDamageByEntityEvent(damager, entity.getBukkitEntity(), cause, modifiers, modifierFunctions));
             if (!event.isCancelled()) {
@@ -555,8 +557,8 @@
         if (cause != null) {
             return callEntityDamageEvent(null, entity, cause, modifiers, modifierFunctions);
         }
-
-        throw new RuntimeException(String.format("Unhandled damage of %s from %s", entity, source.translationIndex)); // Spigot
+        return callEntityDamageEvent(null, entity, cause, modifiers, modifierFunctions);
+        //throw new RuntimeException(String.format("Unhandled damage of %s from %s", entity, source.translationIndex)); // Spigot
     }
 
     private static EntityDamageEvent callEntityDamageEvent(Entity damager, Entity damagee, DamageCause cause, Map<DamageModifier, Double> modifiers, Map<DamageModifier, Function<? super Double, Double>> modifierFunctions) {
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-04-03 23:27:25.299613933 +0800
+++ src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-04-17 03:42:18.478951301 +0800
@@ -1,15 +1,19 @@
 package org.bukkit.craftbukkit.util;
 
+import com.google.common.collect.Sets;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.TreeSet;
+import java.util.concurrent.ConcurrentSkipListSet;
 
 public class HashTreeSet<V> implements Set<V> {
 
-    private HashSet<V> hash = new HashSet<V>();
-    private TreeSet<V> tree = new TreeSet<V>();
+    /*private HashSet<V> hash = new HashSet<V>();
+    private TreeSet<V> tree = new TreeSet<V>();*/
+    private Set<V> hash = Sets.newConcurrentHashSet();
+    private ConcurrentSkipListSet<V> tree = new ConcurrentSkipListSet<V>();
 
     public HashTreeSet() {
 
diff -Naur src_origin/main/java/org/hose/ChunkFlush_Pool.java src/main/java/org/hose/ChunkFlush_Pool.java
--- src_origin/main/java/org/hose/ChunkFlush_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChunkFlush_Pool.java	2016-04-17 03:42:13.578951750 +0800
@@ -0,0 +1,53 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.PlayerChunk;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkFlush_Pool extends RecursiveAction {//need to use callable
+    List<PlayerChunk> chunkflush_list;
+    
+    public ChunkFlush_Pool(List<PlayerChunk> chunkflush_list){
+        this.chunkflush_list = chunkflush_list;
+    }
+    
+    @Override
+    protected void compute() {
+        List<RecursiveAction> forks = new LinkedList();
+        for (PlayerChunk pc : chunkflush_list) {
+            chunkflush task = new chunkflush(pc);
+            forks.add(task);
+            task.fork();
+            //task.join();
+        }
+        
+        for (RecursiveAction task : forks) {
+            task.join();
+        }
+    }
+    
+    
+    class chunkflush extends RecursiveAction {
+        PlayerChunk pc;
+        
+        chunkflush(PlayerChunk pc) {
+            this.pc = pc;
+        }
+        
+        @Override
+        protected void compute() {
+            pc.d();
+        }
+                 
+    }
+}
diff -Naur src_origin/main/java/org/hose/ChunkGen_Pool.java src/main/java/org/hose/ChunkGen_Pool.java
--- src_origin/main/java/org/hose/ChunkGen_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChunkGen_Pool.java	2016-04-17 03:42:13.578951750 +0800
@@ -0,0 +1,76 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.WorldServer;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkGen_Pool extends RecursiveAction {
+    WorldServer worldserver;
+    List<int[]> position;
+    
+    public ChunkGen_Pool(WorldServer worldserver, List<int[]> position){
+        this.worldserver = worldserver;
+        this.position = position;
+        
+    }
+    
+    @Override
+    protected void compute() {
+        List<RecursiveAction> forks = new LinkedList();
+        for (int[] pt : position) {
+            chunkgen task = new chunkgen(worldserver, pt);
+            forks.add(task);
+            task.fork();
+            //task.join();
+        }
+        
+        for (RecursiveAction task : forks) {
+            task.join();
+        }
+        /*
+        List<int[]> fork1 = this.position.subList(0, (this.position.size()/2));
+        List<int[]> fork2 = this.position.subList((this.position.size()/2), this.position.size());
+        chunkgen t1 = new chunkgen(worldserver, fork1);
+        chunkgen t2 = new chunkgen(worldserver, fork2);
+        t1.fork();
+        t2.fork();
+        t1.join();*/
+        /*
+        for (RecursiveAction task : forks) {
+            task.join();
+        }*/
+    }
+    
+    
+    class chunkgen extends RecursiveAction {
+        WorldServer worldserver;
+        int[] pt;
+        //List<int[]> position;
+        
+        chunkgen(WorldServer worldserver, int[] pt) {
+            this.worldserver = worldserver;
+            this.pt = pt;
+            //this.position = position;
+        }
+        
+        @Override
+        protected void compute() {
+            worldserver.getChunkProviderServer().getChunkAt(pt[0], pt[1]);
+            /*
+            for (int[] pt : position) {
+                worldserver.getChunkProviderServer().getChunkAt(pt[0], pt[1]);
+            }*/
+        }
+                 
+    }
+}
diff -Naur src_origin/main/java/org/hose/EntityTick_Pool.java src/main/java/org/hose/EntityTick_Pool.java
--- src_origin/main/java/org/hose/EntityTick_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/EntityTick_Pool.java	2016-04-17 03:42:13.580951750 +0800
@@ -0,0 +1,139 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.World;
+import org.spigotmc.SpigotWorldConfig;
+
+/**
+ *
+ * @author softpak
+ */
+public class EntityTick_Pool extends RecursiveAction {
+    World world;
+    //int tp;
+    List<Integer> entitys_list;
+    
+    public EntityTick_Pool(World world, List<Integer> entitys_list){
+        this.world = world;
+        //this.tp = tp;
+        this.entitys_list = entitys_list;
+        
+    }
+    
+    @Override
+    protected void compute() {
+        //world.entity_tick_hose(tp);
+        if (this.entitys_list.size() < 200) {
+            dotick task = new dotick(world, entitys_list);
+            task.fork();
+            task.join();
+            /*
+            List<Integer> fork1 = this.entitys_list.subList(0, (this.entitys_list.size()/2));
+            List<Integer> fork2 = this.entitys_list.subList((this.entitys_list.size()/2), this.entitys_list.size());
+            dotick task1 = new dotick(world, fork1);
+            dotick task2 = new dotick(world, fork2);
+            task1.fork();
+            task2.fork();
+            task1.join();*/
+            /*int group_num = this.entitys_list.size()/SpigotWorldConfig.getthreadnumber();
+            List<RecursiveAction> fork = new LinkedList();*/
+            /*
+            for (int c = 0; c < SpigotWorldConfig.getthreadnumber() ; c++) {
+                if (c == SpigotWorldConfig.getthreadnumber() - 1) {
+                    List<Integer> forks = this.entitys_list.subList(c*group_num , this.entitys_list.size());
+                    dotick tasks = new dotick(world, forks);
+                    fork.add(tasks);
+                } else {
+                    List<Integer> forks = this.entitys_list.subList(c*group_num , (c+1)*group_num);
+                    dotick tasks = new dotick(world, forks);
+                    fork.add(tasks);
+                }
+            }*/
+            /*
+            for (RecursiveAction task : fork) {
+                task.fork();
+                task.join();
+            }*/
+        } else {
+            List<Integer> fork1 = this.entitys_list.subList(0, (this.entitys_list.size()/2));
+            List<Integer> fork2 = this.entitys_list.subList((this.entitys_list.size()/2), this.entitys_list.size());
+            EntityTick_Pool t1 = new EntityTick_Pool(this.world, fork1);
+            EntityTick_Pool t2 = new EntityTick_Pool(this.world, fork2);
+            t1.fork();
+            t2.compute();
+            t1.join();
+        }
+        /*
+        for (RecursiveAction task : fork) {
+            task.join();
+        }*/
+        /*
+        int group_num = this.entitys_list.size()/4;
+        
+        List<Integer> fork1 = new LinkedList(this.entitys_list.subList(0, group_num * 1));
+        List<Integer> fork2 = new LinkedList(this.entitys_list.subList(group_num * 1, group_num * 2));
+        List<Integer> fork3 = new LinkedList(this.entitys_list.subList(group_num * 2, group_num * 3));
+        List<Integer> fork4 = new LinkedList(this.entitys_list.subList(group_num * 3, this.entitys_list.size()));
+        //List<Integer> fork2 = this.entitys_list.subList((this.entitys_list.size()/2), this.entitys_list.size());
+        
+        dotick task1 = new dotick(world, fork1);
+        dotick task2 = new dotick(world, fork2);
+        dotick task3 = new dotick(world, fork3);
+        dotick task4 = new dotick(world, fork4);
+        task1.fork();
+        task2.fork();
+        task3.fork();
+        task4.fork();
+        task1.join();
+        task2.join();
+        task3.join();
+        task4.join();*/
+        //List<RecursiveAction> fork = new LinkedList();
+        /*dotick task1 = new dotick(world, this.entitys_list);
+        
+        task1.fork();
+        task1.join();*/
+        /*
+        //split entitys_list into 4 part
+        for (int tp : entitys_list) {
+            dotick task = new dotick(world, tp);
+            fork.add(task);
+            task.fork();
+            //task.join();
+        }
+        
+        for (RecursiveAction task : fork) {
+            //task.fork();
+            task.join();
+        }*/
+    }
+    
+    
+    class dotick extends RecursiveAction {
+        World world;
+        //int tp;
+        List<Integer> entitys_list;
+        
+        dotick(World world, List<Integer> entitys_list) {
+            this.world = world;
+            //this.tp = tp;
+            this.entitys_list = entitys_list;
+        }
+        
+        @Override
+        protected void compute() {
+            //world.entity_tick_hose(tp);
+            for (int tp : entitys_list) {
+                world.entity_tick_hose(tp);
+            }
+        }
+                 
+    }
+}
diff -Naur src_origin/main/java/org/hose/PlayerChunkMap_Pool.java src/main/java/org/hose/PlayerChunkMap_Pool.java
--- src_origin/main/java/org/hose/PlayerChunkMap_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/PlayerChunkMap_Pool.java	2016-04-17 03:42:13.575951750 +0800
@@ -0,0 +1,64 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.ChunkCoordIntPair;
+import net.minecraft.server.EntityPlayer;
+import net.minecraft.server.PlayerChunkMap;
+
+/**
+ *
+ * @author softpak
+ */
+public class PlayerChunkMap_Pool extends RecursiveAction {//need to use callable
+    PlayerChunkMap pcm;
+    List<ChunkCoordIntPair> chunkList;
+    EntityPlayer entityplayer;
+    
+    public PlayerChunkMap_Pool(PlayerChunkMap pcm, List<ChunkCoordIntPair> chunkList, EntityPlayer entityplayer){
+        this.pcm = pcm;
+        this.chunkList = chunkList;
+        this.entityplayer = entityplayer;
+    }
+    
+    @Override
+    protected void compute() {
+        List<RecursiveAction> forks = new LinkedList();
+        for (ChunkCoordIntPair cp : chunkList) {
+            getchunk task = new getchunk(pcm, cp.x, cp.z ,entityplayer);
+            forks.add(task);
+            task.fork();
+            //task.join();
+        }
+        
+        for (RecursiveAction task : forks) {
+            task.join();
+        }
+    }
+    
+    
+    class getchunk extends RecursiveAction {
+        PlayerChunkMap pcm;
+        int x, z;
+        EntityPlayer entityplayer;
+        
+        getchunk(PlayerChunkMap pcm, int x, int z, EntityPlayer entityplayer) {
+            this.pcm = pcm;
+            this.x = x;
+            this.z = z;
+            this.entityplayer = entityplayer;
+        }
+        
+        @Override
+        protected void compute() {
+            pcm.c(x, z).a(entityplayer);
+        }
+                 
+    }
+}
diff -Naur src_origin/main/java/org/hose/TileTick_Pool.java src/main/java/org/hose/TileTick_Pool.java
--- src_origin/main/java/org/hose/TileTick_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/TileTick_Pool.java	2016-04-17 03:42:13.581951750 +0800
@@ -0,0 +1,104 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.LinkedList;
+import java.util.List;
+import java.util.concurrent.RecursiveAction;
+import net.minecraft.server.World;
+import org.spigotmc.SpigotWorldConfig;
+
+/**
+ *
+ * @author softpak
+ */
+public class TileTick_Pool extends RecursiveAction {
+    World world;
+    //int tp;
+    List<Integer> tiles_list;
+    
+    public TileTick_Pool(World world, List<Integer> tiles_list){
+        this.world = world;
+        //this.tp = tp;
+        this.tiles_list = tiles_list;
+        
+    }
+    
+    @Override
+    protected void compute() {
+        //world.tile_tick_hose(tp);
+        /*
+        if (this.tiles_list.size() < 200) {
+            dotick task = new dotick(world, tiles_list);
+            task.fork();
+            task.join();
+        } else {
+            List<Integer> fork1 = this.tiles_list.subList(0, (this.tiles_list.size()/2));
+            List<Integer> fork2 = this.tiles_list.subList((this.tiles_list.size()/2), this.tiles_list.size());
+            TileTick_Pool t1 = new TileTick_Pool(this.world, fork1);
+            TileTick_Pool t2 = new TileTick_Pool(this.world, fork2);
+            t1.fork();
+            t2.compute();
+            t1.join();
+        }*/
+        
+        int group_num = this.tiles_list.size()/SpigotWorldConfig.getthreadnumber();
+        List<RecursiveAction> fork = new LinkedList();
+        for (int c = 0; c < SpigotWorldConfig.getthreadnumber() ; c++) {
+            if (c == SpigotWorldConfig.getthreadnumber() - 1) {
+                List<Integer> forks = this.tiles_list.subList(c*group_num , this.tiles_list.size());
+                dotick tasks = new dotick(world, forks);
+                fork.add(tasks);
+            } else {
+                List<Integer> forks = this.tiles_list.subList(c*group_num , (c+1)*group_num);
+                dotick tasks = new dotick(world, forks);
+                fork.add(tasks);
+            }
+        }
+        for (RecursiveAction task : fork) {
+            task.fork();
+            task.join();
+        }
+        /*
+        for (RecursiveAction task : fork) {
+            task.join();
+        }*/
+        /*
+        List<RecursiveAction> forks = new LinkedList();
+        
+        for (int tp : tiles_list) {
+            dotick task = new dotick(world, tp);
+            task.fork();
+            forks.add(task);
+            //task.join();
+        }
+        
+        for (RecursiveAction task : forks) {
+            task.join();
+        }*/
+    }
+    
+    
+    class dotick extends RecursiveAction {
+        World world;
+        //int tp;
+        List<Integer> entitys_list;
+        
+        dotick(World world, List<Integer> entitys_list) {
+            this.world = world;
+            //this.tp = tp;
+            this.entitys_list = entitys_list;
+        }
+        
+        @Override
+        protected void compute() {
+            //world.tile_tick_hose(tp);
+            for (int tp : entitys_list) {
+                world.tile_tick_hose(tp);
+            }
+        }
+    }
+}
diff -Naur src_origin/main/java/org/spigotmc/ActivationRange.java src/main/java/org/spigotmc/ActivationRange.java
--- src_origin/main/java/org/spigotmc/ActivationRange.java	2016-04-03 23:27:20.709613929 +0800
+++ src/main/java/org/spigotmc/ActivationRange.java	2016-04-17 03:42:13.614951747 +0800
@@ -1,6 +1,7 @@
 package org.spigotmc;
 
 import java.util.List;
+import java.util.Queue;
 import java.util.Set;
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.Chunk;
@@ -141,7 +142,8 @@
      */
     private static void activateChunkEntities(Chunk chunk)
     {
-        for ( List<Entity> slice : chunk.entitySlices )
+        //for ( List<Entity> slice : chunk.entitySlices )
+        for ( Queue<Entity> slice : chunk.entitySlices )
         {
             for ( Entity entity : slice )
             {
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2016-04-03 23:27:20.714613929 +0800
+++ src/main/java/org/spigotmc/AsyncCatcher.java	2016-04-17 03:42:13.610951747 +0800
@@ -5,7 +5,8 @@
 public class AsyncCatcher
 {
 
-    public static boolean enabled = true;
+    //public static boolean enabled = true;
+    public static boolean enabled = false;
 
     public static void catchOp(String reason)
     {
diff -Naur src_origin/main/java/org/spigotmc/SpigotWorldConfig.java src/main/java/org/spigotmc/SpigotWorldConfig.java
--- src_origin/main/java/org/spigotmc/SpigotWorldConfig.java	2016-04-03 23:27:20.782613929 +0800
+++ src/main/java/org/spigotmc/SpigotWorldConfig.java	2016-04-17 03:42:13.677951741 +0800
@@ -1,12 +1,93 @@
 package org.spigotmc;
 
+import io.netty.util.internal.ConcurrentSet;
 import java.util.List;
+import java.util.Set;
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.ForkJoinWorkerThread;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
 public class SpigotWorldConfig
 {
-
+    //hose start
+    static public Set<Integer> Block_dophy_list = new ConcurrentSet();
+    static public final int cpu_core = Runtime.getRuntime().availableProcessors();
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fetp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("EntityTickPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fttp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("TileTickPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fpcp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("PlayerChunkPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcfp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkFlushPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    public static ForkJoinPool EntityTickPool;
+    public static ForkJoinPool TileTickPool;
+    public static ForkJoinPool ChunkPool;
+    public static ForkJoinPool PlayerChunkPool;
+    public static ForkJoinPool ChunkFlushPool;
+    
+    /*
+    static public FutureTask CollideTask;
+        
+    static final ThreadFactory tfcp = new ThreadFactoryBuilder().setNameFormat("Collide_Pool-%d").build();
+    static public final ExecutorService collidepool_executor = Executors.newFixedThreadPool(cpu_core, tfcp);*/
+    
+    public static int worldtickentitypool_core_multiple;
+    
+    public static int getthreadnumber(){
+        return cpu_core*worldtickentitypool_core_multiple;
+    }
+    
+    private void wetp_core_multiple()
+    {
+        worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 4);
+        EntityTickPool = new ForkJoinPool(getthreadnumber(), fetp, null, false);
+        TileTickPool = new ForkJoinPool(getthreadnumber(), fttp, null, false);
+        ChunkPool = new ForkJoinPool(getthreadnumber(), fcp, null, false);
+        PlayerChunkPool = new ForkJoinPool(getthreadnumber(), fpcp, null, false);
+        ChunkFlushPool = new ForkJoinPool(getthreadnumber(), fcfp, null, false);
+        //executor = new ThreadPoolExecutor(getthreadnumber(), getthreadnumber(), 1, TimeUnit.DAYS, queue);
+        log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
+    }
+    
+    
+    //hose end
+    
     private final String worldName;
     private final YamlConfiguration config;
     private boolean verbose;
