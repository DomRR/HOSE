diff -Naur src_origin/main/java/net/minecraft/server/BlockSoil.java src/main/java/net/minecraft/server/BlockSoil.java
--- src_origin/main/java/net/minecraft/server/BlockSoil.java	2016-12-27 13:32:46.138835449 +0800
+++ src/main/java/net/minecraft/server/BlockSoil.java	2016-12-27 17:14:59.544848223 +0800
@@ -85,14 +85,17 @@
 
         world.setTypeUpdate(blockposition, iblockdata);
         AxisAlignedBB axisalignedbb = iblockdata.c(world, blockposition).a(blockposition);
-        List list = world.getEntities((Entity) null, axisalignedbb);
+        //List list = world.getEntities((Entity) null, axisalignedbb);
+        List<Entity> list = world.getEntities((Entity) null, axisalignedbb);    //hose
+        list.stream().forEach(entity -> entity.setPosition(entity.locX, axisalignedbb.e, entity.locZ)); //hose
+        /*
         Iterator iterator = list.iterator();
 
         while (iterator.hasNext()) {
             Entity entity = (Entity) iterator.next();
 
             entity.setPosition(entity.locX, axisalignedbb.e, entity.locZ);
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/Chunk.java src/main/java/net/minecraft/server/Chunk.java
--- src_origin/main/java/net/minecraft/server/Chunk.java	2016-12-27 13:32:46.235835449 +0800
+++ src/main/java/net/minecraft/server/Chunk.java	2016-12-27 17:14:59.653848223 +0800
@@ -15,6 +15,7 @@
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists; // CraftBukkit
+import java.util.Queue;
 import org.bukkit.Server; // CraftBukkit
 
 public class Chunk {
@@ -32,7 +33,8 @@
     public final int locZ;
     private boolean m;
     public final Map<BlockPosition, TileEntity> tileEntities;
-    public final List<Entity>[] entitySlices; // Spigot
+    //public final List<Entity>[] entitySlices; // Spigot
+    public final Queue<Entity>[] entitySlices;  //hose
     private boolean done;
     private boolean lit;
     private boolean r;
@@ -80,17 +82,20 @@
         this.g = new byte[256];
         this.h = new int[256];
         this.i = new boolean[256];
-        this.tileEntities = Maps.newHashMap();
+        //this.tileEntities = Maps.newHashMap();
+        this.tileEntities = Maps.newConcurrentMap();    //hose
         this.x = 4096;
         this.y = Queues.newConcurrentLinkedQueue();
-        this.entitySlices = (List[]) (new List[16]); // Spigot
+        //this.entitySlices = (List[]) (new List[16]); // Spigot
+        this.entitySlices = (Queue[]) (new Queue[16]);  //hose
         this.world = world;
         this.locX = i;
         this.locZ = j;
         this.heightMap = new int[256];
 
         for (int k = 0; k < this.entitySlices.length; ++k) {
-            this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            //this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[k] = Queues.newConcurrentLinkedQueue();   //hose
         }
 
         Arrays.fill(this.h, -999);
@@ -744,11 +749,13 @@
     public void addEntities() {
         this.j = true;
         this.world.b(this.tileEntities.values());
-        List[] aentityslice = this.entitySlices; // Spigot
+        //List[] aentityslice = this.entitySlices; // Spigot
+        Queue[] aentityslice = this.entitySlices;   //hose
         int i = aentityslice.length;
 
         for (int j = 0; j < i; ++j) {
-            List entityslice = aentityslice[j]; // Spigot
+            //List entityslice = aentityslice[j]; // Spigot
+            Queue entityslice = aentityslice[j];    //hose
 
             this.world.a((Collection) entityslice);
         }
@@ -777,7 +784,8 @@
             this.world.b(tileentity);
         }
 
-        List[] aentityslice = this.entitySlices; // Spigot
+        //List[] aentityslice = this.entitySlices; // Spigot
+        Queue[] aentityslice = this.entitySlices;   //hose
         int i = aentityslice.length;
 
         for (int j = 0; j < i; ++j) {
@@ -816,7 +824,8 @@
         this.s = true;
     }
 
-    public void a(@Nullable Entity entity, AxisAlignedBB axisalignedbb, List<Entity> list, Predicate<? super Entity> predicate) {
+    //public void a(@Nullable Entity entity, AxisAlignedBB axisalignedbb, List<Entity> list, Predicate<? super Entity> predicate) {
+    public void a(@Nullable Entity entity, AxisAlignedBB axisalignedbb, Queue<Entity> list, Predicate<? super Entity> predicate) {  //hose
         int i = MathHelper.floor((axisalignedbb.b - 2.0D) / 16.0D);
         int j = MathHelper.floor((axisalignedbb.e + 2.0D) / 16.0D);
 
@@ -825,6 +834,27 @@
 
         for (int k = i; k <= j; ++k) {
             if (!this.entitySlices[k].isEmpty()) {
+                this.entitySlices[k].stream().filter(entity1 -> entity1.getBoundingBox().c(axisalignedbb) && entity1 != entity).forEach(entity1 -> {    //hose
+                    if (predicate == null || predicate.apply(entity1)) {
+                        list.add(entity1);
+                    }
+
+                    Entity[] aentity = entity1.aT();
+
+                    if (aentity != null) {
+                        Entity[] aentity1 = aentity;
+                        int l = aentity.length;
+
+                        for (int i1 = 0; i1 < l; ++i1) {
+                            Entity entity2 = aentity1[i1];
+
+                            if (entity2 != entity && entity2.getBoundingBox().c(axisalignedbb) && (predicate == null || predicate.apply(entity2))) {
+                                list.add(entity2);
+                            }
+                        }
+                    }
+                });
+                /*
                 Iterator iterator = this.entitySlices[k].iterator();
 
                 while (iterator.hasNext()) {
@@ -850,7 +880,7 @@
                             }
                         }
                     }
-                }
+                }*/
             }
         }
 
@@ -1288,7 +1318,8 @@
         return this.tileEntities;
     }
 
-    public List<Entity>[] getEntitySlices() {
+    //public List<Entity>[] getEntitySlices() {
+    public Queue<Entity>[] getEntitySlices() {  //hose
         return this.entitySlices;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderServer.java src/main/java/net/minecraft/server/ChunkProviderServer.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderServer.java	2016-12-27 13:32:46.222835449 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderServer.java	2016-12-27 17:14:59.665848223 +0800
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
@@ -10,6 +11,7 @@
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
@@ -26,7 +28,8 @@
     public final Set<Long> unloadQueue = Sets.newHashSet();
     public final ChunkGenerator chunkGenerator;
     private final IChunkLoader chunkLoader;
-    public final Long2ObjectMap<Chunk> chunks = new Long2ObjectOpenHashMap(8192);
+    //public final Long2ObjectMap<Chunk> chunks = new Long2ObjectOpenHashMap(8192);
+    public final Map<Long, Chunk> chunks = Maps.newConcurrentMap(); //hose
     public final WorldServer world;
 
     public ChunkProviderServer(WorldServer worldserver, IChunkLoader ichunkloader, ChunkGenerator chunkgenerator) {
@@ -48,13 +51,15 @@
     }
 
     public void b() {
+        this.chunks.values().stream().forEach(chunk -> this.unload(chunk)); //hose
+        /*
         ObjectIterator objectiterator = this.chunks.values().iterator();
 
         while (objectiterator.hasNext()) {
             Chunk chunk = (Chunk) objectiterator.next();
 
             this.unload(chunk);
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityArmorStand.java src/main/java/net/minecraft/server/EntityArmorStand.java
--- src_origin/main/java/net/minecraft/server/EntityArmorStand.java	2016-12-27 13:32:46.507835449 +0800
+++ src/main/java/net/minecraft/server/EntityArmorStand.java	2016-12-27 17:15:00.041848224 +0800
@@ -297,6 +297,9 @@
     protected void C(Entity entity) {}
 
     protected void ct() {
+        List<Entity> list = this.world.getEntities(this, this.getBoundingBox(), EntityArmorStand.bw);   //hose
+        list.stream().filter(entity -> this.h(entity) <= 0.2D).forEach(entity -> entity.collide(this));   //hose
+        /*
         List list = this.world.getEntities(this, this.getBoundingBox(), EntityArmorStand.bw);
 
         for (int i = 0; i < list.size(); ++i) {
@@ -305,7 +308,7 @@
             if (this.h(entity) <= 0.2D) {
                 entity.collide(this);
             }
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityEnderDragon.java src/main/java/net/minecraft/server/EntityEnderDragon.java
--- src_origin/main/java/net/minecraft/server/EntityEnderDragon.java	2016-12-27 13:32:46.591835449 +0800
+++ src/main/java/net/minecraft/server/EntityEnderDragon.java	2016-12-27 17:15:00.131848224 +0800
@@ -389,6 +389,11 @@
     }
 
     private void b(List<Entity> list) {
+        list.stream().filter(entity -> entity instanceof EntityLiving).forEach(entity -> {  //hose
+            entity.damageEntity(DamageSource.mobAttack(this), 10.0F);
+            this.a((EntityLiving) this, entity);
+        });
+        /*
         for (int i = 0; i < list.size(); ++i) {
             Entity entity = (Entity) list.get(i);
 
@@ -396,7 +401,7 @@
                 entity.damageEntity(DamageSource.mobAttack(this), 10.0F);
                 this.a((EntityLiving) this, entity);
             }
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityHuman.java src/main/java/net/minecraft/server/EntityHuman.java
--- src_origin/main/java/net/minecraft/server/EntityHuman.java	2016-12-27 13:32:46.692835449 +0800
+++ src/main/java/net/minecraft/server/EntityHuman.java	2016-12-27 17:15:00.250848224 +0800
@@ -385,6 +385,9 @@
                 axisalignedbb = this.getBoundingBox().grow(1.0D, 0.5D, 1.0D);
             }
 
+            List<Entity> list = this.world.getEntities(this, axisalignedbb);    //hose
+            list.stream().filter(entity -> !entity.dead).forEach(entity -> this.c(entity)); //hose
+            /*
             List list = this.world.getEntities(this, axisalignedbb);
 
             for (int i = 0; i < list.size(); ++i) {
@@ -393,7 +396,7 @@
                 if (!entity.dead) {
                     this.c(entity);
                 }
-            }
+            }*/
         }
 
     }
diff -Naur src_origin/main/java/net/minecraft/server/EntityLightning.java src/main/java/net/minecraft/server/EntityLightning.java
--- src_origin/main/java/net/minecraft/server/EntityLightning.java	2016-12-27 13:32:46.708835449 +0800
+++ src/main/java/net/minecraft/server/EntityLightning.java	2016-12-27 17:15:00.309848224 +0800
@@ -110,13 +110,16 @@
                 this.world.d(2);
             } else if (!this.d) {
                 double d0 = 3.0D;
+                List<Entity> list = this.world.getEntities(this, new AxisAlignedBB(this.locX - 3.0D, this.locY - 3.0D, this.locZ - 3.0D, this.locX + 3.0D, this.locY + 6.0D + 3.0D, this.locZ + 3.0D)); //hose
+                list.stream().forEach(entity -> entity.onLightningStrike(this));    //hose
+                /*
                 List list = this.world.getEntities(this, new AxisAlignedBB(this.locX - 3.0D, this.locY - 3.0D, this.locZ - 3.0D, this.locX + 3.0D, this.locY + 6.0D + 3.0D, this.locZ + 3.0D));
 
                 for (int i = 0; i < list.size(); ++i) {
                     Entity entity = (Entity) list.get(i);
 
                     entity.onLightningStrike(this);
-                }
+                }*/
             }
         }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityLiving.java src/main/java/net/minecraft/server/EntityLiving.java
--- src_origin/main/java/net/minecraft/server/EntityLiving.java	2016-12-27 13:32:46.759835449 +0800
+++ src/main/java/net/minecraft/server/EntityLiving.java	2016-12-27 17:15:00.330848224 +0800
@@ -2118,11 +2118,13 @@
                 }
             }
 
+            list.stream().forEach(entity -> this.C((Entity)entity));    //hose
+            /*
             for (j = 0; j < list.size(); ++j) {
                 Entity entity = (Entity) list.get(j);
 
                 this.C(entity);
-            }
+            }*/
         }
 
     }
diff -Naur src_origin/main/java/net/minecraft/server/EntityPlayer.java src/main/java/net/minecraft/server/EntityPlayer.java
--- src_origin/main/java/net/minecraft/server/EntityPlayer.java	2016-12-27 13:32:46.806835449 +0800
+++ src/main/java/net/minecraft/server/EntityPlayer.java	2016-12-27 17:15:00.426848224 +0800
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import com.mojang.authlib.GameProfile;
 import io.netty.buffer.Unpooled;
@@ -8,6 +9,7 @@
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -34,7 +36,8 @@
     public final PlayerInteractManager playerInteractManager;
     public double d;
     public double e;
-    public final List<Integer> removeQueue = Lists.newLinkedList();
+    //public final List<Integer> removeQueue = Lists.newLinkedList();
+    public final List<Integer> removeQueue = Lists.newCopyOnWriteArrayList();   //hose
     private final ServerStatisticManager bU;
     private float bV = Float.MIN_VALUE;
     private int bW = Integer.MIN_VALUE;
@@ -206,6 +209,7 @@
         return new ItemCooldownPlayer(this);
     }
 
+    Queue temp_list = Queues.newConcurrentLinkedQueue();    //hose
     public void A_() {
         // CraftBukkit start
         if (this.joining) {
@@ -231,10 +235,14 @@
             int j = 0;
 
             while (iterator.hasNext() && j < i) {
-                aint[j++] = ((Integer) iterator.next()).intValue();
-                iterator.remove();
+                int aa = ((Integer) iterator.next()).intValue();
+                aint[j++] = aa;
+                //aint[j++] = ((Integer) iterator.next()).intValue();
+                //iterator.remove();
+                temp_list.add(aa);
             }
-
+            this.removeQueue.removeAll(temp_list);  //hose
+            temp_list.clear();  //hose
             this.playerConnection.sendPacket(new PacketPlayOutEntityDestroy(aint));
         }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityTrackerEntry.java src/main/java/net/minecraft/server/EntityTrackerEntry.java
--- src_origin/main/java/net/minecraft/server/EntityTrackerEntry.java	2016-12-27 13:32:46.901835449 +0800
+++ src/main/java/net/minecraft/server/EntityTrackerEntry.java	2016-12-27 17:15:00.577848224 +0800
@@ -41,7 +41,8 @@
     private boolean x;
     private boolean y;
     public boolean b;
-    public final Set<EntityPlayer> trackedPlayers = Sets.newHashSet();
+    //public final Set<EntityPlayer> trackedPlayers = Sets.newHashSet();
+    public final Set<EntityPlayer> trackedPlayers = Sets.newConcurrentHashSet();    //hose
 
     public EntityTrackerEntry(Entity entity, int i, int j, int k, boolean flag) {
         this.tracker = entity;
@@ -303,6 +304,11 @@
     }
 
     public void a() {
+        this.trackedPlayers.stream().forEach(entityplayer -> {  //hose
+            this.tracker.c(entityplayer);
+            entityplayer.c(this.tracker);
+        });
+        /*
         Iterator iterator = this.trackedPlayers.iterator();
 
         while (iterator.hasNext()) {
@@ -310,7 +316,7 @@
 
             this.tracker.c(entityplayer);
             entityplayer.c(this.tracker);
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityTracker.java src/main/java/net/minecraft/server/EntityTracker.java
--- src_origin/main/java/net/minecraft/server/EntityTracker.java	2016-12-27 13:32:46.894835449 +0800
+++ src/main/java/net/minecraft/server/EntityTracker.java	2016-12-27 17:15:00.554848224 +0800
@@ -1,9 +1,11 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.Map;
 import java.util.Set;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -12,8 +14,10 @@
 
     private static final Logger a = LogManager.getLogger();
     private final WorldServer world;
-    private final Set<EntityTrackerEntry> c = Sets.newHashSet();
-    public final IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    /*private final Set<EntityTrackerEntry> c = Sets.newHashSet();
+    public final IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();*/
+    private final Set<EntityTrackerEntry> c = Sets.newConcurrentHashSet();  //hose
+    public final Map<Integer, EntityTrackerEntry> trackedEntities = Maps.newConcurrentMap();    //hose
     private int e;
 
     public EntityTracker(WorldServer worldserver) {
@@ -108,14 +112,20 @@
         org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
         i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
         try {
+            if (this.trackedEntities.containsKey(entity.getId())) { //hose
+                //update it
+                this.trackedEntities.remove(entity.getId());
+            }
+            /*
             if (this.trackedEntities.b(entity.getId())) {
                 throw new IllegalStateException("Entity is already tracked!");
-            }
+            }*/
 
             EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, this.e, j, flag);
 
             this.c.add(entitytrackerentry);
-            this.trackedEntities.a(entity.getId(), entitytrackerentry);
+            //this.trackedEntities.a(entity.getId(), entitytrackerentry);
+            this.trackedEntities.put(entity.getId(), entitytrackerentry);   //hose
             entitytrackerentry.scanPlayers(this.world.players);
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
@@ -154,16 +164,19 @@
         org.spigotmc.AsyncCatcher.catchOp( "entity untrack"); // Spigot
         if (entity instanceof EntityPlayer) {
             EntityPlayer entityplayer = (EntityPlayer) entity;
+            this.c.parallelStream().forEach(entitytrackerentry -> entitytrackerentry.a(entityplayer));  //hose
+            /*
             Iterator iterator = this.c.iterator();
 
             while (iterator.hasNext()) {
                 EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
 
                 entitytrackerentry.a(entityplayer);
-            }
+            }*/
         }
 
-        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
+        //EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
+        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.remove(entity.getId());  //hose
 
         if (entitytrackerentry1 != null) {
             this.c.remove(entitytrackerentry1);
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2016-12-27 13:32:47.187835450 +0800
+++ src/main/java/net/minecraft/server/MinecraftServer.java	2016-12-27 17:15:00.950848225 +0800
@@ -1036,7 +1036,8 @@
     }
 
     public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        //return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "Hose"; // Hose - Hose > // Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1118,7 +1119,8 @@
     }
 
     public String getName() {
-        return "Server";
+        //return "Server";
+        return org.bukkit.ChatColor.GREEN + "Server";   //hose
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
diff -Naur src_origin/main/java/net/minecraft/server/SpawnerCreature.java src/main/java/net/minecraft/server/SpawnerCreature.java
--- src_origin/main/java/net/minecraft/server/SpawnerCreature.java	2016-12-27 13:32:47.571835450 +0800
+++ src/main/java/net/minecraft/server/SpawnerCreature.java	2016-12-27 17:15:01.443848225 +0800
@@ -38,7 +38,9 @@
     }
     // Spigot end
 
+    private org.spigotmc.TickLimiter spawnLimiter = new org.spigotmc.TickLimiter(10);   //hose
     public int a(WorldServer worldserver, boolean flag, boolean flag1, boolean flag2) {
+        spawnLimiter.initTick();    //hose
         if (!flag && !flag1) {
             return 0;
         } else {
@@ -129,6 +131,7 @@
                         int moblimit = (limit * i / 256) - mobcnt + 1; // Spigot - up to 1 more than limit
                         label120:
                         while (iterator1.hasNext() && (moblimit > 0)) { // Spigot - while more allowed
+                            if (!spawnLimiter.shouldContinue()) {break;}    //hose
                             // CraftBukkit start = use LongHash and LongObjectHashMap
                             long key = ((Long) iterator1.next()).longValue();
                             BlockPosition blockposition1 = getRandomPosition(worldserver, LongHash.msw(key), LongHash.lsw(key));
diff -Naur src_origin/main/java/net/minecraft/server/World.java src/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2016-12-27 13:32:47.733835450 +0800
+++ src/main/java/net/minecraft/server/World.java	2016-12-27 17:15:01.614848225 +0800
@@ -15,7 +15,11 @@
 
 // CraftBukkit start
 import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
 import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.stream.IntStream;
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
@@ -27,6 +31,7 @@
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 import org.bukkit.generator.ChunkGenerator;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class World implements IBlockAccess {
@@ -34,6 +39,8 @@
     private int a = 63;
     protected boolean d;
     // Spigot start - guard entity list from removals
+    public Queue<Entity> entityList = Queues.newConcurrentLinkedQueue();    //hose
+    /*
     public final List<Entity> entityList = new java.util.ArrayList<Entity>()
     {
         @Override
@@ -57,16 +64,21 @@
                 throw new java.util.ConcurrentModificationException();
             }
         }
-    };
+    };*/
     // Spigot end
     protected final List<Entity> f = Lists.newArrayList();
+    /*
     public final List<TileEntity> tileEntityList = Lists.newArrayList();
     public final List<TileEntity> tileEntityListTick = Lists.newArrayList();
-    private final List<TileEntity> b = Lists.newArrayList();
+    private final List<TileEntity> b = Lists.newArrayList();*/
+    public final Queue<TileEntity> tileEntityList = Queues.newConcurrentLinkedQueue();  //hose
+    public final Queue<TileEntity> tileEntityListTick = Queues.newConcurrentLinkedQueue();  //hose
+    private final Queue<TileEntity> b = Queues.newConcurrentLinkedQueue();  //hose
     private final List<TileEntity> tileEntityListUnload = Lists.newArrayList();
     public final List<EntityHuman> players = Lists.newArrayList();
     public final List<Entity> j = Lists.newArrayList();
-    protected final IntHashMap<Entity> entitiesById = new IntHashMap();
+    //protected final IntHashMap<Entity> entitiesById = new IntHashMap();
+    protected final Map<Integer, Entity> entitiesById = Maps.newConcurrentMap();    //hose
     private final long I = 16777215L;
     private int J;
     protected int l = (new Random()).nextInt();
@@ -122,7 +134,7 @@
     public long ticksPerAnimalSpawns;
     public long ticksPerMonsterSpawns;
     public boolean populating;
-    private int tickPosition;
+    //private int tickPosition;
     public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
 
     public final SpigotTimings.WorldTimingsHandler timings; // Spigot
@@ -131,7 +143,7 @@
     public static String blockLocation;
     private org.spigotmc.TickLimiter entityLimiter;
     private org.spigotmc.TickLimiter tileLimiter;
-    private int tileTickPosition;
+    //private int tileTickPosition;
 
     public CraftWorld getWorld() {
         return this.world;
@@ -1152,6 +1164,8 @@
             this.getChunkAt(i, j).b(entity);
         }
 
+        this.entityList.remove(entity); //hose
+        /*
         // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
         int index = this.entityList.indexOf(entity);
         if (index != -1) {
@@ -1159,7 +1173,7 @@
                 this.tickPosition--;
             }
             this.entityList.remove(index);
-        }
+        }*/
         // CraftBukkit end
         } // Spigot
         this.c(entity);
@@ -1234,12 +1248,29 @@
     }
 
     public List<AxisAlignedBB> getCubes(@Nullable Entity entity, AxisAlignedBB axisalignedbb) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();   //hose
 
         this.a(entity, axisalignedbb, false, arraylist);
         if (entity != null) {
-            List list = this.getEntities(entity, axisalignedbb.g(0.25D));
+            List<Entity> list = this.getEntities(entity, axisalignedbb.g(0.25D));   //hose
+            list.parallelStream().forEach(entity1 -> {  //hose
+                if (!entity.x(entity1)) {
+                    AxisAlignedBB axisalignedbb1 = entity1.ag();
+
+                    if (axisalignedbb1 != null && axisalignedbb1.c(axisalignedbb)) {
+                        arraylist.add(axisalignedbb1);
+                    }
 
+                    axisalignedbb1 = entity.j(entity1);
+                    if (axisalignedbb1 != null && axisalignedbb1.c(axisalignedbb)) {
+                        arraylist.add(axisalignedbb1);
+                    }
+                }
+            });
+            /*
+            List list = this.getEntities(entity, axisalignedbb.g(0.25D));
+            
             for (int i = 0; i < list.size(); ++i) {
                 Entity entity1 = (Entity) list.get(i);
 
@@ -1255,7 +1286,7 @@
                         arraylist.add(axisalignedbb1);
                     }
                 }
-            }
+            }*/
         }
 
         return arraylist;
@@ -1344,6 +1375,12 @@
 
     public void b(BlockPosition blockposition, Block block, int i, int j) {}
 
+    public class BreakException extends RuntimeException {} //hose
+
+    Queue<Entity> temp_list = Queues.newConcurrentLinkedQueue();    //hose
+    Queue<TileEntity> temp_tilelist = Queues.newConcurrentLinkedQueue();    //hose
+    CrashReportSystemDetails crashreportsystemdetails1; //hose
+    CrashReport crashreport1;   //hose
     public void tickEntities() {
         this.methodProfiler.a("entities");
         this.methodProfiler.a("global");
@@ -1402,14 +1439,70 @@
         this.f.clear();
         this.l();
         this.methodProfiler.c("regular");
-
+        /*
         CrashReportSystemDetails crashreportsystemdetails1;
-        CrashReport crashreport1;
+        CrashReport crashreport1;*/
 
         org.spigotmc.ActivationRange.activateEntities(this); // Spigot
         timings.entityTick.startTiming(); // Spigot
         guardEntityList = true; // Spigot
         // CraftBukkit start - Use field for loop variable
+        entityLimiter.initTick();   //hose
+        try {   //hose
+            IntStream.rangeClosed(0, Math.max(entityList.size()/SpigotWorldConfig.entity_piece , SpigotWorldConfig.entitymin_pertick)).parallel().forEach(ent_c -> {
+                if (!entityLimiter.shouldContinue()) {throw new BreakException();}
+                
+                try {
+                    Entity ent = entityList.poll();
+                    Entity entity1 = ent.bB();
+
+                    if (entity1 != null) {
+                        if (!entity1.dead && entity1.w(ent)) {
+                            return;
+                        }
+
+                        ent.stopRiding();
+                    }
+                    
+                    this.methodProfiler.a("tick");
+                    if (!ent.dead && !(ent instanceof EntityPlayer)) {
+                        try {
+                            SpigotTimings.tickEntityTimer.startTiming(); // Spigot
+                            this.h(ent);
+                            SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
+                        } catch (Throwable throwable1) {
+                            crashreport1 = CrashReport.a(throwable1, "Ticking entity");
+                            crashreportsystemdetails1 = crashreport1.a("Entity being ticked");
+                            ent.appendEntityCrashDetails(crashreportsystemdetails1);
+                            throw new ReportedException(crashreport1);
+                        }
+                    }
+
+                    this.methodProfiler.b();
+                    this.methodProfiler.a("remove");
+                    if (ent.dead) {
+                        int j1 = ent.ab;
+                        int l = ent.ad;
+
+                        if (ent.aa && this.isChunkLoaded(j1, l, true)) {
+                            this.getChunkAt(j1, l).b(ent);
+                        }
+                        this.c(ent);
+                    } else {
+                        temp_list.offer(ent);
+                    }
+
+                    this.methodProfiler.b();
+                } catch (Exception ex) {
+                    ;
+                }
+            });
+        } catch (BreakException e) {
+            //Stoped
+        }
+        entityList.addAll(temp_list);
+        temp_list.clear();
+        /*
         int entitiesThisCycle = 0;
         if (tickPosition < 0) tickPosition = 0;
         for (entityLimiter.initTick();
@@ -1459,7 +1552,7 @@
             }
 
             this.methodProfiler.b();
-        }
+        }*/
         guardEntityList = false; // Spigot
 
         timings.entityTick.stopTiming(); // Spigot
@@ -1476,6 +1569,56 @@
 
         // Spigot start
         // Iterator iterator = this.tileEntityListTick.iterator();
+        tileLimiter.initTick();     //hose
+        try {   //hose
+            IntStream.rangeClosed(0, Math.max(this.tileEntityListTick.size()/SpigotWorldConfig.entity_piece , SpigotWorldConfig.entitymin_pertick)).parallel().forEachOrdered(tile_c -> {
+                if (!tileLimiter.shouldContinue()) {throw new BreakException();}
+                TileEntity tileentity = this.tileEntityListTick.poll();
+                // Spigot start
+                if (tileentity == null) {
+                    return;
+                }
+                // Spigot end
+
+                if (!tileentity.y() && tileentity.u()) {
+                    BlockPosition blockposition = tileentity.getPosition();
+
+                    if (this.isLoaded(blockposition) && this.N.a(blockposition)) {
+                        try {
+                            this.methodProfiler.a(""); // CraftBukkit: SPIGOT-1900
+                            tileentity.tickTimer.startTiming(); // Spigot
+                            ((ITickable) tileentity).F_();
+                            this.methodProfiler.b();
+                        } catch (Throwable throwable2) {
+                            crashreport1 = CrashReport.a(throwable2, "Ticking block entity");
+                            crashreportsystemdetails1 = crashreport1.a("Block entity being ticked");
+                            tileentity.a(crashreportsystemdetails1);
+                            throw new ReportedException(crashreport1);
+                        }
+                        // Spigot start
+                        finally {
+                            tileentity.tickTimer.stopTiming();
+                        }
+                        // Spigot end
+                    }
+                }
+
+                if (tileentity.y()) {
+                    //this.tileEntityListTick.remove(tileentity);
+                    this.tileEntityList.remove(tileentity);
+                    if (this.isLoaded(tileentity.getPosition())) {
+                        this.getChunkAtWorldCoords(tileentity.getPosition()).d(tileentity.getPosition());
+                    }
+                } else {
+                    temp_tilelist.offer(tileentity);
+                }
+            });
+        } catch (BreakException e) {
+            //Stoped
+        }
+        tileEntityListTick.addAll(temp_tilelist);
+        temp_tilelist.clear();
+        /*
         int tilesThisCycle = 0;
         for (tileLimiter.initTick();
                 tilesThisCycle < tileEntityListTick.size() && (tilesThisCycle % 10 != 0 || tileLimiter.shouldContinue());
@@ -1496,7 +1639,7 @@
 
                 if (this.isLoaded(blockposition) && this.N.a(blockposition)) {
                     try {
-                        this.methodProfiler.a(""/*tileentity.getClass().getSimpleName()*/); // CraftBukkit: SPIGOT-1900
+                        this.methodProfiler.a(""); // CraftBukkit: SPIGOT-1900
                         tileentity.tickTimer.startTiming(); // Spigot
                         ((ITickable) tileentity).F_();
                         this.methodProfiler.b();
@@ -1522,7 +1665,7 @@
                     this.getChunkAtWorldCoords(tileentity.getPosition()).d(tileentity.getPosition());
                 }
             }
-        }
+        }*/
 
         timings.tileEntityTick.stopTiming(); // Spigot
         timings.tileEntityPending.startTiming(); // Spigot
@@ -1537,15 +1680,39 @@
 
         this.methodProfiler.c("pendingBlockEntities");
         if (!this.b.isEmpty()) {
+           IntStream.rangeClosed(0, this.b.size()).parallel().forEachOrdered(pb_c -> {  //hose
+                TileEntity tileentity1 = this.b.poll();
+                try {
+                    if (!tileentity1.y()) {
+
+                        if (this.isLoaded(tileentity1.getPosition())) {
+                            Chunk chunk = this.getChunkAtWorldCoords(tileentity1.getPosition());
+                            IBlockData iblockdata = chunk.getBlockData(tileentity1.getPosition());
+
+                            chunk.a(tileentity1.getPosition(), tileentity1);
+                            this.notify(tileentity1.getPosition(), iblockdata, iblockdata, 3);
+                            // CraftBukkit start
+                            // From above, don't screw this up - SPIGOT-1746
+                            if (!this.tileEntityList.contains(tileentity1)) {
+                                this.a(tileentity1);
+                            }
+                            // CraftBukkit end
+                        }
+                    }
+                } catch (Exception ex) {
+                    ;
+                }
+            });
+            /*
             for (int i1 = 0; i1 < this.b.size(); ++i1) {
                 TileEntity tileentity1 = (TileEntity) this.b.get(i1);
 
                 if (!tileentity1.y()) {
-                    /* CraftBukkit start - Order matters, moved down
-                    if (!this.tileEntityList.contains(tileentity1)) {
-                        this.a(tileentity1);
-                    }
-                    // CraftBukkit end */
+                    //CraftBukkit start - Order matters, moved down
+                    //if (!this.tileEntityList.contains(tileentity1)) {
+                    //    this.a(tileentity1);
+                    //}
+                    // CraftBukkit end 
 
                     if (this.isLoaded(tileentity1.getPosition())) {
                         Chunk chunk = this.getChunkAtWorldCoords(tileentity1.getPosition());
@@ -1563,7 +1730,7 @@
                 }
             }
 
-            this.b.clear();
+            this.b.clear();*/
         }
 
         timings.tileEntityPending.stopTiming(); // Spigot
@@ -1674,6 +1841,14 @@
 
             this.methodProfiler.b();
             if (flag && entity.aa) {
+                entity.bx().parallelStream().forEach(entity1 -> {   //hose
+                    if (!entity1.dead && entity1.bB() == entity) {
+                        this.h(entity1);
+                    } else {
+                        entity1.stopRiding();
+                    }
+                });
+                /*
                 Iterator iterator = entity.bx().iterator();
 
                 while (iterator.hasNext()) {
@@ -1684,7 +1859,7 @@
                     } else {
                         entity1.stopRiding();
                     }
-                }
+                }*/
             }
 
             entity.tickTimer.stopTiming(); // Spigot
@@ -1696,8 +1871,16 @@
     }
 
     public boolean a(AxisAlignedBB axisalignedbb, @Nullable Entity entity) {
+        List<Entity> list = this.getEntities((Entity) null, axisalignedbb); //hose
+        boolean re;
+        
+        java.util.function.Predicate<Entity> p1 = entity1 -> !entity1.dead && entity1.i && entity1 != entity && (entity == null || entity1.x(entity));
+        re = list.stream().anyMatch(p1);
+                
+        return !re;
+        /*
         List list = this.getEntities((Entity) null, axisalignedbb);
-
+        
         for (int i = 0; i < list.size(); ++i) {
             Entity entity1 = (Entity) list.get(i);
 
@@ -1706,7 +1889,7 @@
             }
         }
 
-        return true;
+        return true;*/
     }
 
     public boolean c(AxisAlignedBB axisalignedbb) {
@@ -1957,6 +2140,12 @@
 
     @Nullable
     private TileEntity F(BlockPosition blockposition) {
+        try {   //hose
+            return this.b.stream().filter(tileentity -> !tileentity.y() && tileentity.getPosition().equals(blockposition)).findFirst().get();
+        } catch (Exception ex) {
+            return null;
+        }
+        /*
         for (int i = 0; i < this.b.size(); ++i) {
             TileEntity tileentity = (TileEntity) this.b.get(i);
 
@@ -1965,7 +2154,7 @@
             }
         }
 
-        return null;
+        return null;*/
     }
 
     public void setTileEntity(BlockPosition blockposition, @Nullable TileEntity tileentity) {
@@ -1981,6 +2170,11 @@
             // CraftBukkit end
                 if (this.M) {
                     tileentity.setPosition(blockposition);
+                    this.b.stream().filter(tileentity1 -> tileentity1.getPosition().equals(blockposition)).forEach(tileentity1 -> {
+                        tileentity1.z();
+                        this.b.remove(tileentity1);
+                    });
+                    /*
                     Iterator iterator = this.b.iterator();
 
                     while (iterator.hasNext()) {
@@ -1990,7 +2184,7 @@
                             tileentity1.z();
                             iterator.remove();
                         }
-                    }
+                    }*/
 
                     tileentity.a(this); // Spigot - No null worlds
                     this.b.add(tileentity);
@@ -2424,12 +2618,17 @@
     }
 
     public List<Entity> getEntities(@Nullable Entity entity, AxisAlignedBB axisalignedbb, @Nullable Predicate<? super Entity> predicate) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        Queue arraylist = Queues.newConcurrentLinkedQueue();    //hose
         int i = MathHelper.floor((axisalignedbb.a - 2.0D) / 16.0D);
         int j = MathHelper.floor((axisalignedbb.d + 2.0D) / 16.0D);
         int k = MathHelper.floor((axisalignedbb.c - 2.0D) / 16.0D);
         int l = MathHelper.floor((axisalignedbb.f + 2.0D) / 16.0D);
 
+        IntStream.rangeClosed(i, j).parallel().forEach(i1 -> IntStream.rangeClosed(k, l).filter(j1 -> this.isChunkLoaded(i1, j1, true)) //hose
+                .forEach(j1 -> this.getChunkAt(i1, j1).a(entity, axisalignedbb, arraylist, predicate)));
+        return new CopyOnWriteArrayList(arraylist);
+        /*
         for (int i1 = i; i1 <= j; ++i1) {
             for (int j1 = k; j1 <= l; ++j1) {
                 if (this.isChunkLoaded(i1, j1, true)) {
@@ -2438,11 +2637,13 @@
             }
         }
 
-        return arraylist;
+        return arraylist;*/
     }
 
     public <T extends Entity> List<T> a(Class<? extends T> oclass, Predicate<? super T> predicate) {
         ArrayList arraylist = Lists.newArrayList();
+        this.entityList.stream().filter(entity -> oclass.isAssignableFrom(entity.getClass()) && predicate.apply((T) entity)).forEach(entity -> arraylist.add(entity));
+        /*
         Iterator iterator = this.entityList.iterator();
 
         while (iterator.hasNext()) {
@@ -2451,7 +2652,7 @@
             if (oclass.isAssignableFrom(entity.getClass()) && predicate.apply((T) entity)) {
                 arraylist.add(entity);
             }
-        }
+        }*/
 
         return arraylist;
     }
@@ -2528,6 +2729,10 @@
     }
 
     public int a(Class<?> oclass) {
+        return (int) this.entityList.stream().filter(entity -> entity instanceof EntityInsentient).filter(entityinsentient ->   //hose
+                !((EntityInsentient)entityinsentient).isTypeNotPersistent() && !((EntityInsentient)entityinsentient).isPersistent())
+                .filter(entity -> oclass.isAssignableFrom(entity.getClass())).count();
+        /*
         int i = 0;
         Iterator iterator = this.entityList.iterator();
 
@@ -2548,7 +2753,7 @@
             }
         }
 
-        return i;
+        return i;*/
     }
 
     public void a(Collection<Entity> collection) {
diff -Naur src_origin/main/java/net/minecraft/server/WorldServer.java src/main/java/net/minecraft/server/WorldServer.java
--- src_origin/main/java/net/minecraft/server/WorldServer.java	2016-12-27 13:32:47.804835450 +0800
+++ src/main/java/net/minecraft/server/WorldServer.java	2016-12-27 17:15:01.736848225 +0800
@@ -3,6 +3,7 @@
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.io.File;
@@ -11,16 +12,19 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
 import java.util.Random;
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentSkipListSet;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start
 import java.util.logging.Level;
+import java.util.stream.IntStream;
 
 import org.bukkit.WeatherType;
 import org.bukkit.block.BlockState;
@@ -39,7 +43,9 @@
     private final PlayerChunkMap manager;
     // private final Set<NextTickListEntry> nextTickListHash = Sets.newHashSet();
     private final HashTreeSet<NextTickListEntry> nextTickList = new HashTreeSet<NextTickListEntry>(); // CraftBukkit - HashTreeSet
-    private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
+    //private final ConcurrentSkipListSet<NextTickListEntry> nextTickList = new ConcurrentSkipListSet<NextTickListEntry>();   //hose
+    //private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
+    private final Map<UUID, Entity> entitiesByUUID = Maps.newConcurrentMap();   //hose
     public boolean savingDisabled;
     private boolean O;
     private int emptyTime;
@@ -48,7 +54,8 @@
     protected final VillageSiege siegeManager = new VillageSiege(this);
     private final WorldServer.BlockActionDataList[] S = new WorldServer.BlockActionDataList[] { new WorldServer.BlockActionDataList(null), new WorldServer.BlockActionDataList(null)};
     private int T;
-    private final List<NextTickListEntry> U = Lists.newArrayList();
+    //private final List<NextTickListEntry> U = Lists.newArrayList();
+    private final ConcurrentSkipListSet<NextTickListEntry> U = new ConcurrentSkipListSet();   //hose
 
     // CraftBukkit start
     public final int dimension;
@@ -670,6 +677,7 @@
         this.emptyTime = 0;
     }
 
+    NextTickListEntry nextticklistentry;    //hose
     public boolean a(boolean flag) {
         if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
             return false;
@@ -691,6 +699,18 @@
 
                 this.methodProfiler.a("cleaning");
 
+                IntStream.range(0, i).parallel().forEachOrdered(xx -> {  //hose
+                    nextticklistentry = (NextTickListEntry) this.nextTickList.first();
+                    if (!flag && nextticklistentry.b > this.worldData.getTime()) {
+                        return;
+                    }
+
+                    // CraftBukkit - use nextTickList
+                    this.nextTickList.remove(nextticklistentry);
+                    // this.nextTickListHash.remove(nextticklistentry);
+                    this.U.add(nextticklistentry);
+                });
+                /*
                 NextTickListEntry nextticklistentry;
 
                 for (int j = 0; j < i; ++j) {
@@ -703,10 +723,38 @@
                     this.nextTickList.remove(nextticklistentry);
                     // this.nextTickListHash.remove(nextticklistentry);
                     this.U.add(nextticklistentry);
-                }
+                }*/
 
                 this.methodProfiler.b();
                 this.methodProfiler.a("ticking");
+                
+                IntStream.rangeClosed(0, this.U.size()).parallel().forEachOrdered(xx-> {    //hose
+                    try {
+                        nextticklistentry = this.U.pollFirst();
+                        boolean flag1 = false;
+
+                        if (this.areChunksLoadedBetween(nextticklistentry.a.a(0, 0, 0), nextticklistentry.a.a(0, 0, 0))) {
+                            IBlockData iblockdata = this.getType(nextticklistentry.a);
+
+                            if (iblockdata.getMaterial() != Material.AIR && Block.a(iblockdata.getBlock(), nextticklistentry.a())) {
+                                try {
+                                    iblockdata.getBlock().b((World) this, nextticklistentry.a, iblockdata, this.random);
+                                } catch (Throwable throwable) {
+                                    CrashReport crashreport = CrashReport.a(throwable, "Exception while ticking a block");
+                                    CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being ticked");
+
+                                    CrashReportSystemDetails.a(crashreportsystemdetails, nextticklistentry.a, iblockdata);
+                                    throw new ReportedException(crashreport);
+                                }
+                            }
+                        } else {
+                            this.a(nextticklistentry.a, nextticklistentry.a(), 0);
+                        }
+                    } catch (Exception ex) {
+                        ;
+                    }
+                });
+                /*
                 Iterator iterator = this.U.iterator();
 
                 while (iterator.hasNext()) {
@@ -731,7 +779,7 @@
                     } else {
                         this.a(nextticklistentry.a, nextticklistentry.a(), 0);
                     }
-                }
+                }*/
 
                 this.methodProfiler.b();
                 this.U.clear();
@@ -751,19 +799,37 @@
         return this.a(new StructureBoundingBox(i, 0, k, j, 256, l), flag);
     }
 
+    ArrayList arraylist; //hose
     @Nullable
     public List<NextTickListEntry> a(StructureBoundingBox structureboundingbox, boolean flag) {
-        ArrayList arraylist = null;
-
+        //ArrayList arraylist = null;
+        arraylist = null;  //hose
         for (int i = 0; i < 2; ++i) {
-            Iterator iterator;
+            //Iterator iterator;
+            Iterator<NextTickListEntry> iterator;   //hose
 
             if (i == 0) {
                 iterator = this.nextTickList.iterator();
             } else {
                 iterator = this.U.iterator();
             }
+            
+            iterator.forEachRemaining(nextticklistentry -> {    //hose
+                BlockPosition blockposition = nextticklistentry.a;
 
+                if (blockposition.getX() >= structureboundingbox.a && blockposition.getX() < structureboundingbox.d && blockposition.getZ() >= structureboundingbox.c && blockposition.getZ() < structureboundingbox.f) {
+                    if (flag) {
+                        iterator.remove();
+                    }
+
+                    if (arraylist == null) {
+                        arraylist = Lists.newArrayList();
+                    }
+
+                    arraylist.add(nextticklistentry);
+                }
+            });
+            /*
             while (iterator.hasNext()) {
                 NextTickListEntry nextticklistentry = (NextTickListEntry) iterator.next();
                 BlockPosition blockposition = nextticklistentry.a;
@@ -783,7 +849,7 @@
 
                     arraylist.add(nextticklistentry);
                 }
-            }
+            }*/
         }
 
         return arraylist;
@@ -831,7 +897,24 @@
         // CraftBukkit end
     }
 
-    public List<TileEntity> getTileEntities(int i, int j, int k, int l, int i1, int j1) {
+    //public List<TileEntity> getTileEntities(int i, int j, int k, int l, int i1, int j1) {
+    public Queue<TileEntity> getTileEntities(int i, int j, int k, int l, int i1, int j1) {  //hose
+        Queue arraylist = Queues.newConcurrentLinkedQueue();    //hose
+        IntStream.rangeClosed((i >> 4), ((l - 1) >> 4)).parallel().forEach(chunkX -> {
+            IntStream.rangeClosed((k >> 4), ((j1 - 1) >> 4)).parallel().forEach(chunkZ -> {
+                Chunk chunk = getChunkAt(chunkX, chunkZ);
+                if (chunk == null) {
+                    return;
+                }
+                for (Object te : chunk.tileEntities.values()) {
+                    TileEntity tileentity = (TileEntity) te;
+                    if ((tileentity.position.getX() >= i) && (tileentity.position.getY() >= j) && (tileentity.position.getZ() >= k) && (tileentity.position.getX() < l) && (tileentity.position.getY() < i1) && (tileentity.position.getZ() < j1)) {
+                        arraylist.add(tileentity);
+                    }
+                }
+            });
+        });
+        /*
         ArrayList arraylist = Lists.newArrayList();
 
         // CraftBukkit start - Get tile entities from chunks instead of world
@@ -848,7 +931,7 @@
                     }
                 }
             }
-        }
+        }*/
         /*
         for (int k1 = 0; k1 < this.tileEntityList.size(); ++k1) {
             TileEntity tileentity = (TileEntity) this.tileEntityList.get(k1);
@@ -1110,7 +1193,8 @@
 
     protected void b(Entity entity) {
         super.b(entity);
-        this.entitiesById.a(entity.getId(), entity);
+        //this.entitiesById.a(entity.getId(), entity);
+        this.entitiesById.put(entity.getId(), entity);  //hose
         this.entitiesByUUID.put(entity.getUniqueID(), entity);
         Entity[] aentity = entity.aT();
 
@@ -1121,7 +1205,8 @@
             for (int j = 0; j < i; ++j) {
                 Entity entity1 = aentity1[j];
 
-                this.entitiesById.a(entity1.getId(), entity1);
+                //this.entitiesById.a(entity1.getId(), entity1);
+                this.entitiesById.put(entity1.getId(), entity1);    //hose
             }
         }
 
@@ -1129,7 +1214,8 @@
 
     protected void c(Entity entity) {
         super.c(entity);
-        this.entitiesById.d(entity.getId());
+        //this.entitiesById.d(entity.getId());
+        this.entitiesById.remove(entity.getId());   //hose
         this.entitiesByUUID.remove(entity.getUniqueID());
         Entity[] aentity = entity.aT();
 
@@ -1140,7 +1226,8 @@
             for (int j = 0; j < i; ++j) {
                 Entity entity1 = aentity1[j];
 
-                this.entitiesById.d(entity1.getId());
+                //this.entitiesById.d(entity1.getId());
+                this.entitiesById.remove(entity1.getId());  //hose
             }
         }
 
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java src/main/java/org/bukkit/craftbukkit/CraftWorld.java
--- src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-12-27 13:32:48.117835451 +0800
+++ src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-12-27 17:15:02.070848226 +0800
@@ -1,6 +1,7 @@
 package org.bukkit.craftbukkit;
 
 import com.google.common.base.Preconditions;
+import com.google.common.collect.Queues;
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Collection;
@@ -8,6 +9,7 @@
 import java.util.HashSet;
 import java.util.List;
 import java.util.Iterator;
+import java.util.Queue;
 import java.util.Random;
 import java.util.Set;
 import java.util.UUID;
@@ -69,7 +71,8 @@
     private Environment environment;
     private final CraftServer server = (CraftServer) Bukkit.getServer();
     private final ChunkGenerator generator;
-    private final List<BlockPopulator> populators = new ArrayList<BlockPopulator>();
+    //private final List<BlockPopulator> populators = new ArrayList<BlockPopulator>();
+    private final Queue<BlockPopulator> populators = Queues.newConcurrentLinkedQueue(); //hose
     private final BlockMetadataStore blockMetadata = new BlockMetadataStore(this);
     private int monsterSpawn = -1;
     private int animalSpawn = -1;
@@ -577,7 +580,8 @@
         return generator;
     }
 
-    public List<BlockPopulator> getPopulators() {
+    //public List<BlockPopulator> getPopulators() {
+    public Queue<BlockPopulator> getPopulators() {  //hose - api changed
         return populators;
     }
 
@@ -633,8 +637,10 @@
         return list;
     }
 
-    public List<LivingEntity> getLivingEntities() {
-        List<LivingEntity> list = new ArrayList<LivingEntity>();
+    //public List<LivingEntity> getLivingEntities() {
+    public Queue<LivingEntity> getLivingEntities() {    //hose - api changed
+        //List<LivingEntity> list = new ArrayList<LivingEntity>();
+        Queue<LivingEntity> list = Queues.newConcurrentLinkedQueue();   //hose
 
         for (Object o : world.entityList) {
             if (o instanceof net.minecraft.server.Entity) {
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-12-27 13:32:50.800835453 +0800
+++ src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-12-27 17:15:05.251848229 +0800
@@ -1,15 +1,19 @@
 package org.bukkit.craftbukkit.util;
 
+import com.google.common.collect.Sets;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.TreeSet;
+import java.util.concurrent.ConcurrentSkipListSet;
 
 public class HashTreeSet<V> implements Set<V> {
 
-    private HashSet<V> hash = new HashSet<V>();
-    private TreeSet<V> tree = new TreeSet<V>();
+    /*private HashSet<V> hash = new HashSet<V>();
+    private TreeSet<V> tree = new TreeSet<V>();*/
+    private Set<V> hash = Sets.newConcurrentHashSet();  //hose
+    private ConcurrentSkipListSet<V> tree = new ConcurrentSkipListSet<V>(); //hose
 
     public HashTreeSet() {
 
@@ -29,7 +33,7 @@
     public boolean contains(Object o) {
         return hash.contains(o);
     }
-
+    
     @Override
     public Iterator<V> iterator() {
         return new Iterator<V>() {
@@ -111,7 +115,20 @@
     }
 
     public V first() {
-        return tree.first();
+        //return tree.first();
+        label01:    //hose
+        while (true) {
+            try {
+                return tree.first();
+            } catch (Exception ex) {
+                if (tree.size() > 0) {
+                    tree.pollFirst();
+                    continue label01;
+                } else {
+                    return null;
+                }
+            }
+        }
     }
 
 }
diff -Naur src_origin/main/java/org/spigotmc/ActivationRange.java src/main/java/org/spigotmc/ActivationRange.java
--- src_origin/main/java/org/spigotmc/ActivationRange.java	2016-12-27 13:32:45.078835448 +0800
+++ src/main/java/org/spigotmc/ActivationRange.java	2016-12-27 17:14:58.352848222 +0800
@@ -1,6 +1,7 @@
 package org.spigotmc;
 
 import java.util.List;
+import java.util.Queue;
 import java.util.Set;
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.Chunk;
@@ -141,7 +142,8 @@
      */
     private static void activateChunkEntities(Chunk chunk)
     {
-        for ( List<Entity> slice : chunk.entitySlices )
+        //for ( List<Entity> slice : chunk.entitySlices )
+        for ( Queue<Entity> slice : chunk.entitySlices )    //hose
         {
             for ( Entity entity : slice )
             {
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2016-12-27 13:32:45.063835448 +0800
+++ src/main/java/org/spigotmc/AsyncCatcher.java	2016-12-27 17:15:00.450848224 +0800
@@ -11,7 +11,8 @@
     {
         if ( enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread )
         {
-            throw new IllegalStateException( "Asynchronous " + reason + "!" );
+            //throw new IllegalStateException( "Asynchronous " + reason + "!" );
+            //cancel for a while
         }
     }
 }
diff -Naur src_origin/main/java/org/spigotmc/SpigotWorldConfig.java src/main/java/org/spigotmc/SpigotWorldConfig.java
--- src_origin/main/java/org/spigotmc/SpigotWorldConfig.java	2016-12-27 13:32:45.073835448 +0800
+++ src/main/java/org/spigotmc/SpigotWorldConfig.java	2016-12-27 17:14:58.401848222 +0800
@@ -301,4 +301,14 @@
         entityMaxTickTime = getInt("max-tick-time.entity", 50);
         log("Tile Max Tick Time: " + tileMaxTickTime + "ms Entity max Tick Time: " + entityMaxTickTime + "ms");
     }
+    
+    //hose new sets
+    public static int entity_piece;
+    public static int entitymin_pertick;
+    private void entity_piece()
+    {
+        entity_piece = getInt("entity-piece", 2);
+        entitymin_pertick = getInt("entity-min-pertick", 2000);
+        log("Entity Piece: " + entity_piece + ". Entity Min Pertick: " + entitymin_pertick + ".");
+    }
 }
