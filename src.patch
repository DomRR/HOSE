diff -Naur src_origin/main/java/net/minecraft/server/BlockFalling.java src_new/main/java/net/minecraft/server/BlockFalling.java
--- src_origin/main/java/net/minecraft/server/BlockFalling.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/net/minecraft/server/BlockFalling.java	2016-02-13 08:53:02.515896848 +0800
@@ -0,0 +1,81 @@
+package net.minecraft.server;
+
+import java.util.Random;
+import java.util.concurrent.FutureTask;
+import org.hose.pendingpool.FallingPendingPool;
+import org.spigotmc.SpigotWorldConfig;
+
+public class BlockFalling extends Block {
+
+    public static boolean instaFall;
+
+    public BlockFalling() {
+        super(Material.SAND);
+        this.a(CreativeModeTab.b);
+    }
+
+    public BlockFalling(Material material) {
+        super(material);
+    }
+
+    public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        world.a(blockposition, (Block) this, this.a(world));
+    }
+
+    public void doPhysics(World world, BlockPosition blockposition, IBlockData iblockdata, Block block) {
+        world.a(blockposition, (Block) this, this.a(world));
+    }
+
+    public void b(World world, BlockPosition blockposition, IBlockData iblockdata, Random random) {
+        if (!world.isClientSide) {
+            //this.f(world, blockposition);
+            SpigotWorldConfig.FallingPendingTask = new FutureTask(new FallingPendingPool(this, world, blockposition));
+            SpigotWorldConfig.blockfallingpool_executor.submit(SpigotWorldConfig.FallingPendingTask);
+        }
+
+    }
+
+    public void f(World world, BlockPosition blockposition) {
+    //private void f(World world, BlockPosition blockposition) {
+        if (canFall(world, blockposition.down()) && blockposition.getY() >= 0) {
+            byte b0 = 32;
+
+            if (!BlockFalling.instaFall && world.areChunksLoadedBetween(blockposition.a(-b0, -b0, -b0), blockposition.a(b0, b0, b0))) {
+                if (!world.isClientSide) {
+                    EntityFallingBlock entityfallingblock = new EntityFallingBlock(world, (double) blockposition.getX() + 0.5D, (double) blockposition.getY(), (double) blockposition.getZ() + 0.5D, world.getType(blockposition));
+
+                    this.a(entityfallingblock);
+                    world.addEntity(entityfallingblock);
+                }
+            } else {
+                world.setAir(blockposition);
+
+                BlockPosition blockposition1;
+
+                for (blockposition1 = blockposition.down(); canFall(world, blockposition1) && blockposition1.getY() > 0; blockposition1 = blockposition1.down()) {
+                    ;
+                }
+
+                if (blockposition1.getY() > 0) {
+                    world.setTypeUpdate(blockposition1.up(), this.getBlockData());
+                }
+            }
+
+        }
+    }
+
+    protected void a(EntityFallingBlock entityfallingblock) {}
+
+    public int a(World world) {
+        return 2;
+    }
+
+    public static boolean canFall(World world, BlockPosition blockposition) {
+        Block block = world.getType(blockposition).getBlock();
+        Material material = block.material;
+
+        return block == Blocks.FIRE || material == Material.AIR || material == Material.WATER || material == Material.LAVA;
+    }
+
+    public void a_(World world, BlockPosition blockposition) {}
+}
diff -Naur src_origin/main/java/net/minecraft/server/BlockFlowing.java src_new/main/java/net/minecraft/server/BlockFlowing.java
--- src_origin/main/java/net/minecraft/server/BlockFlowing.java	2016-02-05 01:52:02.795371353 +0800
+++ src_new/main/java/net/minecraft/server/BlockFlowing.java	2016-02-13 08:53:02.533896850 +0800
@@ -4,21 +4,26 @@
 import java.util.Iterator;
 import java.util.Random;
 import java.util.Set;
+import java.util.concurrent.FutureTask;
 
 // CraftBukkit start
 import org.bukkit.block.BlockFace;
 import org.bukkit.event.block.BlockFromToEvent;
+import org.hose.pendingpool.FlowPendingPool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public class BlockFlowing extends BlockFluids {
 
-    int a;
+    //int a;
+    public int a;
 
     protected BlockFlowing(Material material) {
         super(material);
     }
 
-    private void f(World world, BlockPosition blockposition, IBlockData iblockdata) {
+    public void f(World world, BlockPosition blockposition, IBlockData iblockdata) {
+    //private void f(World world, BlockPosition blockposition, IBlockData iblockdata) {
         world.setTypeAndData(blockposition, b(this.material).getBlockData().set(BlockFlowing.LEVEL, iblockdata.get(BlockFlowing.LEVEL)), 2);
     }
 
@@ -34,10 +39,11 @@
         if (this.material == Material.LAVA && !world.worldProvider.n()) {
             b0 = 2;
         }
-
         int j = this.a(world);
         int k;
-
+        
+        
+        
         if (i > 0) {
             int l = -100;
 
@@ -142,6 +148,8 @@
 
                 if (!event.isCancelled()) {
                     this.flow(world, blockposition.shift(enumdirection1), world.getType(blockposition.shift(enumdirection1)), k);
+                    SpigotWorldConfig.FlowPendingTask = new FutureTask(new FlowPendingPool(this, world, blockposition.shift(enumdirection1), world.getType(blockposition.shift(enumdirection1)), k));
+                    SpigotWorldConfig.flowpendingpool_executor.submit(SpigotWorldConfig.FlowPendingTask);
                 }
                 // CraftBukkit end
             }
@@ -149,7 +157,8 @@
 
     }
 
-    private void flow(World world, BlockPosition blockposition, IBlockData iblockdata, int i) {
+    public void flow(World world, BlockPosition blockposition, IBlockData iblockdata, int i) {
+    //private void flow(World world, BlockPosition blockposition, IBlockData iblockdata, int i) {
         if (world.isLoaded(blockposition) && this.h(world, blockposition, iblockdata)) { // CraftBukkit - add isLoaded check
             if (iblockdata.getBlock() != Blocks.AIR) {
                 if (this.material == Material.LAVA) {
@@ -193,8 +202,9 @@
 
         return j;
     }
-
-    private Set<EnumDirection> f(World world, BlockPosition blockposition) {
+    
+    public Set<EnumDirection> f(World world, BlockPosition blockposition) {
+    //private Set<EnumDirection> f(World world, BlockPosition blockposition) {
         int i = 1000;
         EnumSet enumset = EnumSet.noneOf(EnumDirection.class);
         Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
@@ -227,13 +237,15 @@
         return enumset;
     }
 
-    private boolean g(World world, BlockPosition blockposition, IBlockData iblockdata) {
+    public boolean g(World world, BlockPosition blockposition, IBlockData iblockdata) {
+    //private boolean g(World world, BlockPosition blockposition, IBlockData iblockdata) {
         Block block = world.getType(blockposition).getBlock();
 
         return !(block instanceof BlockDoor) && block != Blocks.STANDING_SIGN && block != Blocks.LADDER && block != Blocks.REEDS ? (block.material == Material.PORTAL ? true : block.material.isSolid()) : true;
     }
 
-    protected int a(World world, BlockPosition blockposition, int i) {
+    public int a(World world, BlockPosition blockposition, int i) {
+    //protected int a(World world, BlockPosition blockposition, int i) {
         int j = this.e(world, blockposition);
 
         if (j < 0) {
@@ -251,7 +263,8 @@
         }
     }
 
-    private boolean h(World world, BlockPosition blockposition, IBlockData iblockdata) {
+    public boolean h(World world, BlockPosition blockposition, IBlockData iblockdata) {
+    //private boolean h(World world, BlockPosition blockposition, IBlockData iblockdata) {
         Material material = iblockdata.getBlock().getMaterial();
 
         return material != this.material && material != Material.LAVA && !this.g(world, blockposition, iblockdata);
diff -Naur src_origin/main/java/net/minecraft/server/BlockFluids.java src_new/main/java/net/minecraft/server/BlockFluids.java
--- src_origin/main/java/net/minecraft/server/BlockFluids.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/net/minecraft/server/BlockFluids.java	2016-02-13 08:53:02.535896850 +0800
@@ -0,0 +1,215 @@
+package net.minecraft.server;
+
+import java.util.Iterator;
+import java.util.Random;
+
+public abstract class BlockFluids extends Block {
+
+    public static final BlockStateInteger LEVEL = BlockStateInteger.of("level", 0, 15);
+
+    protected BlockFluids(Material material) {
+        super(material);
+        this.j(this.blockStateList.getBlockData().set(BlockFluids.LEVEL, Integer.valueOf(0)));
+        this.a(0.0F, 0.0F, 0.0F, 1.0F, 1.0F, 1.0F);
+        this.a(true);
+    }
+
+    public boolean b(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        return this.material != Material.LAVA;
+    }
+
+    public static float b(int i) {
+        if (i >= 8) {
+            i = 0;
+        }
+
+        return (float) (i + 1) / 9.0F;
+    }
+
+    public int e(IBlockAccess iblockaccess, BlockPosition blockposition) {
+    //protected int e(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        return iblockaccess.getType(blockposition).getBlock().getMaterial() == this.material ? ((Integer) iblockaccess.getType(blockposition).get(BlockFluids.LEVEL)).intValue() : -1;
+    }
+
+    //public int f(IBlockAccess iblockaccess, BlockPosition blockposition) {
+    protected int f(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        int i = this.e(iblockaccess, blockposition);
+
+        return i >= 8 ? 0 : i;
+    }
+
+    public boolean d() {
+        return false;
+    }
+
+    public boolean c() {
+        return false;
+    }
+
+    public boolean a(IBlockData iblockdata, boolean flag) {
+        return flag && ((Integer) iblockdata.get(BlockFluids.LEVEL)).intValue() == 0;
+    }
+
+    public boolean b(IBlockAccess iblockaccess, BlockPosition blockposition, EnumDirection enumdirection) {
+        Material material = iblockaccess.getType(blockposition).getBlock().getMaterial();
+
+        return material == this.material ? false : (enumdirection == EnumDirection.UP ? true : (material == Material.ICE ? false : super.b(iblockaccess, blockposition, enumdirection)));
+    }
+
+    public AxisAlignedBB a(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        return null;
+    }
+
+    public int b() {
+        return 1;
+    }
+
+    public Item getDropType(IBlockData iblockdata, Random random, int i) {
+        return null;
+    }
+
+    public int a(Random random) {
+        return 0;
+    }
+
+    protected Vec3D h(IBlockAccess iblockaccess, BlockPosition blockposition) {
+        Vec3D vec3d = new Vec3D(0.0D, 0.0D, 0.0D);
+        int i = this.f(iblockaccess, blockposition);
+        Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+        EnumDirection enumdirection;
+        BlockPosition blockposition1;
+
+        while (iterator.hasNext()) {
+            enumdirection = (EnumDirection) iterator.next();
+            blockposition1 = blockposition.shift(enumdirection);
+            int j = this.f(iblockaccess, blockposition1);
+            int k;
+
+            if (j < 0) {
+                if (!iblockaccess.getType(blockposition1).getBlock().getMaterial().isSolid()) {
+                    j = this.f(iblockaccess, blockposition1.down());
+                    if (j >= 0) {
+                        k = j - (i - 8);
+                        vec3d = vec3d.add((double) ((blockposition1.getX() - blockposition.getX()) * k), (double) ((blockposition1.getY() - blockposition.getY()) * k), (double) ((blockposition1.getZ() - blockposition.getZ()) * k));
+                    }
+                }
+            } else if (j >= 0) {
+                k = j - i;
+                vec3d = vec3d.add((double) ((blockposition1.getX() - blockposition.getX()) * k), (double) ((blockposition1.getY() - blockposition.getY()) * k), (double) ((blockposition1.getZ() - blockposition.getZ()) * k));
+            }
+        }
+
+        if (((Integer) iblockaccess.getType(blockposition).get(BlockFluids.LEVEL)).intValue() >= 8) {
+            iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
+
+            while (iterator.hasNext()) {
+                enumdirection = (EnumDirection) iterator.next();
+                blockposition1 = blockposition.shift(enumdirection);
+                if (this.b(iblockaccess, blockposition1, enumdirection) || this.b(iblockaccess, blockposition1.up(), enumdirection)) {
+                    vec3d = vec3d.a().add(0.0D, -6.0D, 0.0D);
+                    break;
+                }
+            }
+        }
+
+        return vec3d.a();
+    }
+
+    public Vec3D a(World world, BlockPosition blockposition, Entity entity, Vec3D vec3d) {
+        return vec3d.e(this.h(world, blockposition));
+    }
+
+    public int a(World world) {
+        return this.material == Material.WATER ? 5 : (this.material == Material.LAVA ? (world.worldProvider.o() ? 10 : 30) : 0);
+    }
+
+    public void onPlace(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        this.e(world, blockposition, iblockdata);
+    }
+
+    public void doPhysics(World world, BlockPosition blockposition, IBlockData iblockdata, Block block) {
+        this.e(world, blockposition, iblockdata);
+    }
+
+    public boolean e(World world, BlockPosition blockposition, IBlockData iblockdata) {
+        if (this.material == Material.LAVA) {
+            boolean flag = false;
+            EnumDirection[] aenumdirection = EnumDirection.values();
+            int i = aenumdirection.length;
+
+            for (int j = 0; j < i; ++j) {
+                EnumDirection enumdirection = aenumdirection[j];
+
+                if (enumdirection != EnumDirection.DOWN && world.getType(blockposition.shift(enumdirection)).getBlock().getMaterial() == Material.WATER) {
+                    flag = true;
+                    break;
+                }
+            }
+
+            if (flag) {
+                Integer integer = (Integer) iblockdata.get(BlockFluids.LEVEL);
+
+                if (integer.intValue() == 0) {
+                    world.setTypeUpdate(blockposition, Blocks.OBSIDIAN.getBlockData());
+                    this.fizz(world, blockposition);
+                    return true;
+                }
+
+                if (integer.intValue() <= 4) {
+                    world.setTypeUpdate(blockposition, Blocks.COBBLESTONE.getBlockData());
+                    this.fizz(world, blockposition);
+                    return true;
+                }
+            }
+        }
+
+        return false;
+    }
+
+    public void fizz(World world, BlockPosition blockposition) {
+    //protected void fizz(World world, BlockPosition blockposition) {
+        double d0 = (double) blockposition.getX();
+        double d1 = (double) blockposition.getY();
+        double d2 = (double) blockposition.getZ();
+
+        world.makeSound(d0 + 0.5D, d1 + 0.5D, d2 + 0.5D, "random.fizz", 0.5F, 2.6F + (world.random.nextFloat() - world.random.nextFloat()) * 0.8F);
+
+        for (int i = 0; i < 8; ++i) {
+            world.addParticle(EnumParticle.SMOKE_LARGE, d0 + Math.random(), d1 + 1.2D, d2 + Math.random(), 0.0D, 0.0D, 0.0D, new int[0]);
+        }
+
+    }
+
+    public IBlockData fromLegacyData(int i) {
+        return this.getBlockData().set(BlockFluids.LEVEL, Integer.valueOf(i));
+    }
+
+    public int toLegacyData(IBlockData iblockdata) {
+        return ((Integer) iblockdata.get(BlockFluids.LEVEL)).intValue();
+    }
+
+    protected BlockStateList getStateList() {
+        return new BlockStateList(this, new IBlockState[] { BlockFluids.LEVEL});
+    }
+
+    public static BlockFlowing a(Material material) {
+        if (material == Material.WATER) {
+            return Blocks.FLOWING_WATER;
+        } else if (material == Material.LAVA) {
+            return Blocks.FLOWING_LAVA;
+        } else {
+            throw new IllegalArgumentException("Invalid material");
+        }
+    }
+
+    public static BlockStationary b(Material material) {
+        if (material == Material.WATER) {
+            return Blocks.WATER;
+        } else if (material == Material.LAVA) {
+            return Blocks.LAVA;
+        } else {
+            throw new IllegalArgumentException("Invalid material");
+        }
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/Block.java src_new/main/java/net/minecraft/server/Block.java
--- src_origin/main/java/net/minecraft/server/Block.java	2016-02-05 01:52:02.263371378 +0800
+++ src_new/main/java/net/minecraft/server/Block.java	2016-02-13 08:53:02.418896839 +0800
@@ -73,7 +73,8 @@
     protected double maxZ;
     public Block.StepSound stepSound;
     public float I;
-    protected final Material material;
+    //protected final Material material;
+    public final Material material;
     protected final MaterialMapColor K;
     public float frictionFactor;
     protected final BlockStateList blockStateList;
diff -Naur src_origin/main/java/net/minecraft/server/Chunk.java src_new/main/java/net/minecraft/server/Chunk.java
--- src_origin/main/java/net/minecraft/server/Chunk.java	2016-02-05 01:52:04.131371288 +0800
+++ src_new/main/java/net/minecraft/server/Chunk.java	2016-02-13 08:53:02.753896871 +0800
@@ -890,26 +890,30 @@
         for (int k = i; k <= j; ++k) {
             if (!this.entitySlices[k].isEmpty()) {
                 Iterator iterator = this.entitySlices[k].iterator();
+                
+                try{
+                    while (iterator.hasNext()) {
+                        Entity entity1 = (Entity) iterator.next();
+
+                        if (entity1.getBoundingBox().b(axisalignedbb) && entity1 != entity) {
+                            if (predicate == null || predicate.apply(entity1)) {
+                                list.add(entity1);
+                            }
 
-                while (iterator.hasNext()) {
-                    Entity entity1 = (Entity) iterator.next();
-
-                    if (entity1.getBoundingBox().b(axisalignedbb) && entity1 != entity) {
-                        if (predicate == null || predicate.apply(entity1)) {
-                            list.add(entity1);
-                        }
-
-                        Entity[] aentity = entity1.aB();
+                            Entity[] aentity = entity1.aB();
 
-                        if (aentity != null) {
-                            for (int l = 0; l < aentity.length; ++l) {
-                                entity1 = aentity[l];
-                                if (entity1 != entity && entity1.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply(entity1))) {
-                                    list.add(entity1);
+                            if (aentity != null) {
+                                for (int l = 0; l < aentity.length; ++l) {
+                                    entity1 = aentity[l];
+                                    if (entity1 != entity && entity1.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply(entity1))) {
+                                        list.add(entity1);
+                                    }
                                 }
                             }
                         }
                     }
+                }catch(Exception ex){
+                    
                 }
             }
         }
@@ -922,16 +926,19 @@
 
         i = MathHelper.clamp(i, 0, this.entitySlices.length - 1);
         j = MathHelper.clamp(j, 0, this.entitySlices.length - 1);
-
+        
         for (int k = i; k <= j; ++k) {
             Iterator iterator = this.entitySlices[k].iterator(); // Spigot
+            try{
+                while (iterator.hasNext()) {
+                    Entity entity = (Entity) iterator.next();
 
-            while (iterator.hasNext()) {
-                Entity entity = (Entity) iterator.next();
-
-                if (oclass.isInstance(entity) && entity.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply((T) entity))) { // CraftBukkit - fix decompile error // Spigot
-                    list.add((T) entity); // Fix decompile error
+                    if (oclass.isInstance(entity) && entity.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply((T) entity))) { // CraftBukkit - fix decompile error // Spigot
+                        list.add((T) entity); // Fix decompile error
+                    }
                 }
+            }catch (Exception ex){
+                        
             }
         }
 
diff -Naur src_origin/main/java/net/minecraft/server/DedicatedServer.java src_new/main/java/net/minecraft/server/DedicatedServer.java
--- src_origin/main/java/net/minecraft/server/DedicatedServer.java	2016-02-05 01:52:05.123371240 +0800
+++ src_new/main/java/net/minecraft/server/DedicatedServer.java	2016-02-13 08:53:02.898896884 +0800
@@ -17,6 +17,7 @@
 
 // CraftBukkit start
 import java.io.PrintStream;
+import net.openhft.affinity.AffinityLock;
 import org.apache.logging.log4j.Level;
 
 import org.bukkit.craftbukkit.LoggerOutputStream;
@@ -49,11 +50,14 @@
             }
 
             public void run() {
+                AffinityLock al = AffinityLock.acquireLock();
                 while (true) {
                     try {
                         Thread.sleep(2147483647L);
                     } catch (InterruptedException interruptedexception) {
                         ;
+                    } finally {
+                        al.release();
                     }
                 }
             }
diff -Naur src_origin/main/java/net/minecraft/server/EntityEnderDragon.java src_new/main/java/net/minecraft/server/EntityEnderDragon.java
--- src_origin/main/java/net/minecraft/server/EntityEnderDragon.java	2016-02-05 01:52:06.000371197 +0800
+++ src_new/main/java/net/minecraft/server/EntityEnderDragon.java	2016-02-13 08:53:03.032896897 +0800
@@ -676,7 +676,8 @@
         // CraftBukkit end
     }
 
-    protected void D() {}
+    //protected void D() {}
+    public void D() {}
 
     public Entity[] aB() {
         return this.children;
diff -Naur src_origin/main/java/net/minecraft/server/EntityInsentient.java src_new/main/java/net/minecraft/server/EntityInsentient.java
--- src_origin/main/java/net/minecraft/server/EntityInsentient.java	2016-02-05 01:52:06.407371177 +0800
+++ src_new/main/java/net/minecraft/server/EntityInsentient.java	2016-02-13 08:53:03.223896915 +0800
@@ -1,8 +1,10 @@
 package net.minecraft.server;
 
+import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.UUID;
+import java.util.concurrent.FutureTask;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.event.CraftEventFactory;
@@ -11,21 +13,29 @@
 import org.bukkit.event.entity.EntityTargetEvent;
 import org.bukkit.event.entity.EntityUnleashEvent;
 import org.bukkit.event.entity.EntityUnleashEvent.UnleashReason;
+import org.hose.TickEntityPool;
+import org.spigotmc.SpigotWorldConfig;
+
 // CraftBukkit end
 
 public abstract class EntityInsentient extends EntityLiving {
 
     public int a_;
     protected int b_;
-    private ControllerLook lookController;
-    protected ControllerMove moveController;
-    protected ControllerJump g;
+    //private ControllerLook lookController;
+    public ControllerLook lookController;
+    //protected ControllerMove moveController;
+    public ControllerMove moveController;
+    //protected ControllerJump g;
+    public ControllerJump g;
     private EntityAIBodyControl b;
-    protected NavigationAbstract navigation;
+    //protected NavigationAbstract navigation;
+    public NavigationAbstract navigation;
     public PathfinderGoalSelector goalSelector;
     public PathfinderGoalSelector targetSelector;
     private EntityLiving goalTarget;
-    private EntitySenses bk;
+    //private EntitySenses bk;
+    public EntitySenses bk;
     private ItemStack[] equipment = new ItemStack[5];
     public float[] dropChances = new float[5];
     public boolean canPickUpLoot;
@@ -317,8 +327,8 @@
             }
         }
 
-        this.bo = nbttagcompound.getBoolean("Leashed");
         if (this.bo && nbttagcompound.hasKeyOfType("Leash", 10)) {
+        this.bo = nbttagcompound.getBoolean("Leashed");
             this.bq = nbttagcompound.getCompound("Leash");
         }
 
@@ -426,7 +436,8 @@
         return true;
     }
 
-    protected void D() {
+    public void D() {
+    //protected void D() {
         if (this.persistent) {
             this.ticksFarFromPlayer = 0;
         } else {
@@ -451,11 +462,36 @@
 
         }
     }
-
+    
+    @Override
     protected final void doTick() {
         ++this.ticksFarFromPlayer;
+        //AffinityLock al = AffinityLock.acquireLock();
+        try {
+            SpigotWorldConfig.TickEntityTask = new FutureTask(new TickEntityPool(this));
+            SpigotWorldConfig.dotickpool_executor.submit(SpigotWorldConfig.TickEntityTask);
+            //SpigotWorldConfig.dotickpool_executor.execute(new TickEntityPool(this));
+            this.world.methodProfiler.a("goalSelector");
+            this.goalSelector.a();
+            this.world.methodProfiler.a("mob tick");
+            this.E();
+        } catch(Exception e) {
+            //e.printStackTrace();
+        } finally {
+            //al.release();
+        }
+        /*SpigotWorldConfig.dotickpool_executor.execute(new DoTickPool(this));
+        try{
+            this.world.methodProfiler.a("goalSelector");
+            this.goalSelector.a();
+            this.world.methodProfiler.b();
+        } catch (Exception ex) {
+
+        }*/
+        /*
         this.world.methodProfiler.a("checkDespawn");
         this.D();
+        //SpigotWorldConfig.despawnpool_executor.execute(new DeSpawnPool(this));
         this.world.methodProfiler.b();
         // Spigot Start
         if ( this.fromMobSpawner )
@@ -486,7 +522,7 @@
         this.world.methodProfiler.c("jump");
         this.g.b();
         this.world.methodProfiler.b();
-        this.world.methodProfiler.b();
+        this.world.methodProfiler.b();*/
     }
 
     protected void E() {}
@@ -941,4 +977,6 @@
 
         private EnumEntityPositionType() {}
     }
+    
+    
 }
diff -Naur src_origin/main/java/net/minecraft/server/EntityLiving.java src_new/main/java/net/minecraft/server/EntityLiving.java
--- src_origin/main/java/net/minecraft/server/EntityLiving.java	2016-02-05 01:52:06.631371167 +0800
+++ src_new/main/java/net/minecraft/server/EntityLiving.java	2016-02-13 08:53:03.289896921 +0800
@@ -1650,6 +1650,7 @@
         this.bb *= 0.9F;
         SpigotTimings.timerEntityAIMove.startTiming(); // Spigot
         this.g(this.aZ, this.ba);
+        //SpigotWorldConfig.movepool_executor.execute(new MovePool(this, this.aZ, this.ba));
         SpigotTimings.timerEntityAIMove.stopTiming(); // Spigot
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("push");
@@ -1665,36 +1666,40 @@
     protected void doTick() {}
 
     protected void bL() {
-        List list = this.world.a((Entity) this, this.getBoundingBox().grow(0.20000000298023224D, 0.0D, 0.20000000298023224D), Predicates.and(IEntitySelector.d, new Predicate() {
-            public boolean a(Entity entity) {
-                return entity.ae();
-            }
-
-            public boolean apply(Object object) {
-                return this.a((Entity) object);
-            }
-        }));
+        try {
+            List list = this.world.a((Entity) this, this.getBoundingBox().grow(0.20000000298023224D, 0.0D, 0.20000000298023224D), Predicates.and(IEntitySelector.d, new Predicate() {
+                public boolean a(Entity entity) {
+                    return entity.ae();
+                }
 
-        if (this.ad() && !list.isEmpty()) { // Spigot: Add this.ad() condition
-            numCollisions -= world.spigotConfig.maxCollisionsPerEntity; // Spigot
-            for (int i = 0; i < list.size(); ++i) {
-                if (numCollisions > world.spigotConfig.maxCollisionsPerEntity) { break; } // Spigot
-                Entity entity = (Entity) list.get(i);
-
-                // TODO better check now?
-                // CraftBukkit start - Only handle mob (non-player) collisions every other tick
-                if (entity instanceof EntityLiving && !(this instanceof EntityPlayer) && this.ticksLived % 2 == 0) {
-                    continue;
+                public boolean apply(Object object) {
+                    return this.a((Entity) object);
                 }
-                // CraftBukkit end
+            }));
+        
 
-                entity.numCollisions++; // Spigot
-                numCollisions++; // Spigot
-                this.s(entity);
+            if (this.ad() && !list.isEmpty()) { // Spigot: Add this.ad() condition
+                numCollisions -= world.spigotConfig.maxCollisionsPerEntity; // Spigot
+                for (int i = 0; i < list.size(); ++i) {
+                    if (numCollisions > world.spigotConfig.maxCollisionsPerEntity) { break; } // Spigot
+                    Entity entity = (Entity) list.get(i);
+
+                    // TODO better check now?
+                    // CraftBukkit start - Only handle mob (non-player) collisions every other tick
+                    if (entity instanceof EntityLiving && !(this instanceof EntityPlayer) && this.ticksLived % 2 == 0) {
+                        continue;
+                    }
+                    // CraftBukkit end
+
+                    entity.numCollisions++; // Spigot
+                    numCollisions++; // Spigot
+                    this.s(entity);
+                }
+                numCollisions = 0; // Spigot
             }
-            numCollisions = 0; // Spigot
+        } catch(Exception ex){
+            
         }
-
     }
 
     protected void s(Entity entity) {
diff -Naur src_origin/main/java/net/minecraft/server/EntityTracker.java src_new/main/java/net/minecraft/server/EntityTracker.java
--- src_origin/main/java/net/minecraft/server/EntityTracker.java	2016-02-05 01:52:07.363371131 +0800
+++ src_new/main/java/net/minecraft/server/EntityTracker.java	2016-02-13 08:53:03.483896939 +0800
@@ -95,6 +95,10 @@
 
     public void addEntity(Entity entity, int i, final int j, boolean flag) {
         org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
+        /*
+        SpigotWorldConfig.AddEntityTrackTask = new FutureTask(new AddEntityTrackPool(this, entity, i, j, flag));
+        SpigotWorldConfig.addentitytrackpool_executor.submit(SpigotWorldConfig.AddEntityTrackTask);*/
+        
         i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
         if (i > this.e) {
             i = this.e;
@@ -144,7 +148,7 @@
         }
 
     }
-
+    
     public void untrackEntity(Entity entity) {
         org.spigotmc.AsyncCatcher.catchOp( "entity untrack"); // Spigot
         if (entity instanceof EntityPlayer) {
diff -Naur src_origin/main/java/net/minecraft/server/EntityWither.java src_new/main/java/net/minecraft/server/EntityWither.java
--- src_origin/main/java/net/minecraft/server/EntityWither.java	2016-02-05 01:52:07.464371126 +0800
+++ src_new/main/java/net/minecraft/server/EntityWither.java	2016-02-13 08:53:03.508896941 +0800
@@ -458,7 +458,8 @@
 
     }
 
-    protected void D() {
+    public void D() {
+    //protected void D() {
         this.ticksFarFromPlayer = 0;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src_new/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2016-02-05 01:52:08.748371064 +0800
+++ src_new/main/java/net/minecraft/server/MinecraftServer.java	2016-02-13 08:53:03.867896975 +0800
@@ -43,9 +43,12 @@
 
 import jline.console.ConsoleReader;
 import joptsimple.OptionSet;
+import net.md_5.bungee.api.ChatColor;
+import net.openhft.affinity.AffinityLock;
 
 import org.bukkit.craftbukkit.Main;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.bukkit.craftbukkit.util.CraftChatMessage;
 // CraftBukkit end
 
 public abstract class MinecraftServer implements Runnable, ICommandListener, IAsyncTaskHandler, IMojangStatistics {
@@ -652,6 +655,7 @@
 
         this.methodProfiler.a("root");
         this.B();
+        //SpigotWorldConfig.mspool_executor.submit(new MSPool(this));
         if (i - this.X >= 5000000000L) {
             this.X = i;
             this.r.setPlayerSample(new ServerPing.ServerPingPlayerSample(this.J(), this.I()));
@@ -713,7 +717,7 @@
         int count = this.j.size();
         while (count-- > 0 && (entry = this.j.poll()) != null) {
             SystemUtils.a(entry, MinecraftServer.LOGGER);
-         }
+        }
         // Spigot end
 
         this.methodProfiler.c("levels");
@@ -768,6 +772,13 @@
                 try {
                     worldserver.timings.doTick.startTiming(); // Spigot
                     worldserver.doTick();
+                    /*
+                    try {
+                        SpigotWorldConfig.WSTask = new FutureTask(new MSPool(worldserver));
+                        SpigotWorldConfig.mspool_executor.submit(SpigotWorldConfig.WSTask);
+                    } catch (Exception ex){
+                        
+                    }*/
                     worldserver.timings.doTick.stopTiming(); // Spigot
                 } catch (Throwable throwable) {
                     // Spigot Start
@@ -936,8 +947,13 @@
             if (options.has("world")) {
                 dedicatedserver.setWorld((String) options.valueOf("world"));
             }
-
-            dedicatedserver.primaryThread.start();
+            //
+            AffinityLock al = AffinityLock.acquireLock();
+            try {
+                dedicatedserver.primaryThread.start();
+            } finally {
+                al.release();
+            }
             // CraftBukkit end
         } catch (Exception exception) {
             MinecraftServer.LOGGER.fatal("Failed to start the minecraft server", exception);
@@ -1023,7 +1039,7 @@
     }
 
     public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "HOSE"; // HOSE -> Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1105,7 +1121,8 @@
     }
 
     public String getName() {
-        return "Server";
+        //return "Server";
+        return ChatColor.GREEN+"Server";
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
diff -Naur src_origin/main/java/net/minecraft/server/SpawnerCreature.java src_new/main/java/net/minecraft/server/SpawnerCreature.java
--- src_origin/main/java/net/minecraft/server/SpawnerCreature.java	2016-02-05 01:52:11.035370953 +0800
+++ src_new/main/java/net/minecraft/server/SpawnerCreature.java	2016-02-13 08:53:06.148897188 +0800
@@ -4,7 +4,6 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
-import java.util.Set;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.util.LongHash;
@@ -48,7 +47,7 @@
 
             int j;
             int k;
-
+            
             while (iterator.hasNext()) {
                 EntityHuman entityhuman = (EntityHuman) iterator.next();
 
@@ -180,6 +179,17 @@
                                                             if (entityinsentient.canSpawn()) {
                                                                 ++l2;
                                                                 worldserver.addEntity(entityinsentient, SpawnReason.NATURAL); // CraftBukkit - Added a reason for spawning this creature
+                                                                /*
+                                                                try {
+                                                                    SpigotWorldConfig.SpawnTask = new FutureTask(new SpawnerPool(worldserver, entityinsentient));
+                                                                    SpigotWorldConfig.spawnerpool_executor.submit(SpigotWorldConfig.SpawnTask);
+                                                                
+                                                                    SpigotWorldConfig.SpawnTask.get();
+                                                                } catch (InterruptedException ex) {
+                                                                    Logger.getLogger(SpawnerCreature.class.getName()).log(Level.SEVERE, null, ex);
+                                                                } catch (ExecutionException ex) {
+                                                                    Logger.getLogger(SpawnerCreature.class.getName()).log(Level.SEVERE, null, ex);
+                                                                }*/
                                                             }
 
                                                             // Spigot start
diff -Naur src_origin/main/java/net/minecraft/server/World.java src_new/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2016-02-05 01:52:11.643370923 +0800
+++ src_new/main/java/net/minecraft/server/World.java	2016-02-13 08:53:06.251897198 +0800
@@ -2,25 +2,23 @@
 
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
-import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.Callable;
 
 // CraftBukkit start
 import com.google.common.collect.Maps;
 import java.util.Map;
+import java.util.concurrent.FutureTask;
 
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.craftbukkit.util.LongHashSet;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
 import org.bukkit.generator.ChunkGenerator;
 import org.bukkit.craftbukkit.CraftServer;
@@ -29,8 +27,11 @@
 import org.bukkit.event.block.BlockCanBuildEvent;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
-import org.bukkit.event.weather.WeatherChangeEvent;
-import org.bukkit.event.weather.ThunderChangeEvent;
+import org.hose.AddParticlePool;
+import org.hose.EntityAKTPool;
+import org.hose.InactivePool;
+import org.hose.WorldTickEntityPool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class World implements IBlockAccess {
@@ -474,12 +475,14 @@
     public boolean setTypeUpdate(BlockPosition blockposition, IBlockData iblockdata) {
         return this.setTypeAndData(blockposition, iblockdata, 3);
     }
-
+    
+    ChunkProviderServer cps;
     public void notify(BlockPosition blockposition) {
+        //System.out.println(cps.getChunkAt(blockposition).toString()+"!");
         for (int i = 0; i < this.u.size(); ++i) {
             ((IWorldAccess) this.u.get(i)).a(blockposition);
+            //get player who use xray-like cheat
         }
-
     }
 
     public void update(BlockPosition blockposition, Block block) {
@@ -967,10 +970,14 @@
     }
 
     public void addParticle(EnumParticle enumparticle, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
-        this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        //this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        SpigotWorldConfig.AddParticleTask = new FutureTask(new AddParticlePool(this, enumparticle, d0, d1, d2, d3, d4, d5, aint));
+        SpigotWorldConfig.addparticlepool_executor.submit(SpigotWorldConfig.AddParticleTask);
     }
 
-    private void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
+    
+    public void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
+    //private void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
         for (int j = 0; j < this.u.size(); ++j) {
             ((IWorldAccess) this.u.get(j)).a(i, flag, d0, d1, d2, d3, d4, d5, aint);
         }
@@ -987,8 +994,24 @@
         return addEntity(entity, SpawnReason.DEFAULT);
     }
 
+    
     public boolean addEntity(Entity entity, SpawnReason spawnReason) { // Changed signature, added SpawnReason
-        org.spigotmc.AsyncCatcher.catchOp( "entity add"); // Spigot
+        //org.spigotmc.AsyncCatcher.catchOp("entity add"); // Spigot
+        
+        /*
+        SpigotWorldConfig.AddEntityTask = new FutureTask(new AddEntityPool(this, entity, spawnReason));
+        SpigotWorldConfig.addentitypool_executor.submit(SpigotWorldConfig.AddEntityTask);
+        boolean aeb = false;
+        
+        try {
+            aeb = (boolean) SpigotWorldConfig.AddEntityTask.get();
+        } catch (InterruptedException ex) {
+            Logger.getLogger(World.class.getName()).log(Level.SEVERE, null, ex);
+        } catch (ExecutionException ex) {
+            Logger.getLogger(World.class.getName()).log(Level.SEVERE, null, ex);
+        }    
+        return aeb;*/
+            
         if (entity == null) return false;
         // CraftBukkit end
         int i = MathHelper.floor(entity.locX / 16.0D);
@@ -998,7 +1021,7 @@
         if (entity instanceof EntityHuman) {
             flag = true;
         }
-
+            
         // CraftBukkit start
         org.bukkit.event.Cancellable event = null;
         if (entity instanceof EntityLiving && !(entity instanceof EntityPlayer)) {
@@ -1012,7 +1035,7 @@
                 }
             }
 
-            event = CraftEventFactory.callCreatureSpawnEvent((EntityLiving) entity, spawnReason);
+        event = CraftEventFactory.callCreatureSpawnEvent((EntityLiving) entity, spawnReason);
         } else if (entity instanceof EntityItem) {
             event = CraftEventFactory.callItemSpawnEvent((EntityItem) entity);
         } else if (entity.getBukkitEntity() instanceof org.bukkit.entity.Projectile) {
@@ -1048,17 +1071,19 @@
             return false;
         } else {
             if (entity instanceof EntityHuman) {
-                EntityHuman entityhuman = (EntityHuman) entity;
+            EntityHuman entityhuman = (EntityHuman) entity;
 
-                this.players.add(entityhuman);
-                this.everyoneSleeping();
-            }
+            this.players.add(entityhuman);
+            this.everyoneSleeping();
+        }
 
-            this.getChunkAt(i, j).a(entity);
-            this.entityList.add(entity);
-            this.a(entity);
-            return true;
+        this.getChunkAt(i, j).a(entity);
+        this.entityList.add(entity);
+        this.a(entity);
+        return true;
         }
+        
+        
     }
 
     protected void a(Entity entity) {
@@ -1338,16 +1363,19 @@
 
     public void b(BlockPosition blockposition, Block block, int i, int j) {}
 
-    public void tickEntities() {
+    public void tickEntities() throws InterruptedException {
         this.methodProfiler.a("entities");
         this.methodProfiler.a("global");
 
         int i;
-        Entity entity;
+        Entity entity = null;
         CrashReport crashreport;
         CrashReportSystemDetails crashreportsystemdetails;
 
         for (i = 0; i < this.k.size(); ++i) {
+            SpigotWorldConfig.WorldTickEntityTask = new FutureTask(new WorldTickEntityPool(this, entity, i));
+            SpigotWorldConfig.worldtickentitypool_executor.submit(SpigotWorldConfig.WorldTickEntityTask);
+            /*
             entity = (Entity) this.k.get(i);
             // CraftBukkit start - Fixed an NPE
             if (entity == null) {
@@ -1358,6 +1386,7 @@
             try {
                 ++entity.ticksLived;
                 entity.t_();
+                
             } catch (Throwable throwable) {
                 crashreport = CrashReport.a(throwable, "Ticking entity");
                 crashreportsystemdetails = crashreport.a("Entity being ticked");
@@ -1372,7 +1401,7 @@
 
             if (entity.dead) {
                 this.k.remove(i--);
-            }
+            }*/
         }
 
         this.methodProfiler.c("remove");
@@ -1403,9 +1432,7 @@
         // CraftBukkit start - Use field for loop variable
         int entitiesThisCycle = 0;
         if (tickPosition < 0) tickPosition = 0;
-        for (entityLimiter.initTick();
-                entitiesThisCycle < entityList.size() && (entitiesThisCycle % 10 != 0 || entityLimiter.shouldContinue());
-                tickPosition++, entitiesThisCycle++) {
+        for (entityLimiter.initTick();entitiesThisCycle < entityList.size() && (entitiesThisCycle % 10 != 0 || entityLimiter.shouldContinue());tickPosition++, entitiesThisCycle++) {
             tickPosition = (tickPosition < entityList.size()) ? tickPosition : 0;
             entity = (Entity) this.entityList.get(this.tickPosition);
             // CraftBukkit end
@@ -1449,8 +1476,16 @@
 
             this.methodProfiler.b();
         }
+        /*
+        try {
+            SpigotWorldConfig.dotickpool_executor.submit(SpigotWorldConfig.futureTask);
+        } catch(Exception ex){
+            System.out.println(ex);
+        }*/
+        //
+        //SpigotWorldConfig.movepool_executor.awaitTermination(5, TimeUnit.MILLISECONDS);
         guardEntityList = false; // Spigot
-
+        
         timings.entityTick.stopTiming(); // Spigot
         this.methodProfiler.c("blockEntities");
         timings.tileEntityTick.startTiming(); // Spigot
@@ -1465,9 +1500,7 @@
 
         // Spigot start
         int tilesThisCycle = 0;
-        for (tileLimiter.initTick();
-                tilesThisCycle < tileEntityList.size() && (tilesThisCycle % 10 != 0 || tileLimiter.shouldContinue());
-                tileTickPosition++, tilesThisCycle++) {
+        for (tileLimiter.initTick();tilesThisCycle < tileEntityList.size() && (tilesThisCycle % 10 != 0 || tileLimiter.shouldContinue());tileTickPosition++, tilesThisCycle++) {
             tileTickPosition = (tileTickPosition < tileEntityList.size()) ? tileTickPosition : 0;
             TileEntity tileentity = (TileEntity) this.tileEntityList.get(tileTickPosition);
             // Spigot start
@@ -1485,6 +1518,7 @@
                 if (this.isLoaded(blockposition) && this.N.a(blockposition)) {
                     try {
                         tileentity.tickTimer.startTiming(); // Spigot
+                        //((IUpdatePlayerListBox) tileentity).c();
                         ((IUpdatePlayerListBox) tileentity).c();
                     } catch (Throwable throwable2) {
                         CrashReport crashreport1 = CrashReport.a(throwable2, "Ticking block entity");
@@ -1548,6 +1582,7 @@
         timings.tileEntityPending.stopTiming(); // Spigot
         this.methodProfiler.b();
         this.methodProfiler.b();
+        //SpigotWorldConfig.dotickpool_executor.awaitTermination(5, TimeUnit.MILLISECONDS);
     }
 
     public boolean a(TileEntity tileentity) {
@@ -1590,7 +1625,13 @@
         // Spigot start
         if (!org.spigotmc.ActivationRange.checkIfActive(entity)) {
             entity.ticksLived++;
-            entity.inactiveTick();
+            //entity.inactiveTick();
+            try {
+                SpigotWorldConfig.InactiveTask = new FutureTask(new InactivePool(entity));
+                SpigotWorldConfig.inactivepool_executor.submit(SpigotWorldConfig.TickPendingTask);
+            }catch(Exception ex){
+                
+            }
         } else {
             entity.tickTimer.startTiming(); // Spigot
             // CraftBukkit end
@@ -1602,9 +1643,13 @@
             if (flag && entity.ad) {
                 ++entity.ticksLived;
                 if (entity.vehicle != null) {
-                    entity.ak();
+                    //entity.ak();
+                    SpigotWorldConfig.EntityAKTTask = new FutureTask(new EntityAKTPool(entity));
+                    SpigotWorldConfig.eaktpool_executor.submit(SpigotWorldConfig.EntityAKTTask);
                 } else {
                     entity.t_();
+                    /*SpigotWorldConfig.EntityAKTTask = new FutureTask(new EntityAKTPool(entity, false));
+                    SpigotWorldConfig.eaktpool_executor.submit(SpigotWorldConfig.EntityAKTTask);*/
                 }
             }
 
diff -Naur src_origin/main/java/net/minecraft/server/WorldServer.java src_new/main/java/net/minecraft/server/WorldServer.java
--- src_origin/main/java/net/minecraft/server/WorldServer.java	2016-02-05 01:52:12.055370903 +0800
+++ src_new/main/java/net/minecraft/server/WorldServer.java	2016-02-13 08:53:06.355897208 +0800
@@ -3,30 +3,30 @@
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
-import java.util.Set;
-import java.util.TreeSet;
 import java.util.UUID;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start
 import java.util.*;
+import java.util.concurrent.FutureTask;
 import java.util.logging.Level;
 
 import org.bukkit.WeatherType;
 import org.bukkit.block.BlockState;
-import org.bukkit.craftbukkit.util.LongHash;
 import org.bukkit.craftbukkit.util.HashTreeSet;
 
 import org.bukkit.event.block.BlockFormEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
+import org.hose.pendingpool.BlockTickPendingPool;
+import org.hose.pendingpool.TickPendingPool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public class WorldServer extends World implements IAsyncTaskHandler {
@@ -48,7 +48,8 @@
     private WorldServer.BlockActionDataList[] S = new WorldServer.BlockActionDataList[] { new WorldServer.BlockActionDataList(null), new WorldServer.BlockActionDataList(null)};
     private int T;
     private static final List<StructurePieceTreasure> U = Lists.newArrayList(new StructurePieceTreasure[] { new StructurePieceTreasure(Items.STICK, 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.PLANKS), 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG), 0, 1, 3, 10), new StructurePieceTreasure(Items.STONE_AXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_AXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.STONE_PICKAXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_PICKAXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.APPLE, 0, 2, 3, 5), new StructurePieceTreasure(Items.BREAD, 0, 2, 3, 3), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG2), 0, 1, 3, 10)});
-    private List<NextTickListEntry> V = Lists.newArrayList();
+    //private List<NextTickListEntry> V = Lists.newArrayList();
+    public List<NextTickListEntry> V = Lists.newArrayList();
 
     // CraftBukkit start
     public final int dimension;
@@ -237,13 +238,16 @@
         if (j != this.ab()) {
             this.c(j);
         }
-
+        
+        //SpigotWorldConfig.timeupdatethread_executor.execute(new TimeUpdateThread(this));
+        
         this.worldData.setTime(this.worldData.getTime() + 1L);
         if (this.getGameRules().getBoolean("doDaylightCycle")) {
             this.worldData.setDayTime(this.worldData.getDayTime() + 1L);
         }
 
         timings.doChunkUnload.stopTiming(); // Spigot
+        //HOSE
         this.methodProfiler.c("tickPending");
         timings.doTickPending.startTiming(); // Spigot
         this.a(false);
@@ -585,7 +589,7 @@
 
     }
 
-    public void tickEntities() {
+    public void tickEntities() throws InterruptedException {
         if (false && this.players.isEmpty()) { // CraftBukkit - this prevents entity cleanup, other issues on servers with no players
             if (this.emptyTime++ >= 1200) {
                 return;
@@ -624,33 +628,40 @@
                 this.methodProfiler.a("cleaning");
 
                 NextTickListEntry nextticklistentry;
+                try{
+                    for (int j = 0; j < i; ++j) {
+                        nextticklistentry = (NextTickListEntry) this.M.first();
+                        if (!flag && nextticklistentry.b > this.worldData.getTime()) {
+                            break;
+                        }
 
-                for (int j = 0; j < i; ++j) {
-                    nextticklistentry = (NextTickListEntry) this.M.first();
-                    if (!flag && nextticklistentry.b > this.worldData.getTime()) {
-                        break;
+                        // CraftBukkit - use M, PAIL: Rename nextTickList
+                        this.M.remove(nextticklistentry);
+                        this.V.add(nextticklistentry);
                     }
-
-                    // CraftBukkit - use M, PAIL: Rename nextTickList
-                    this.M.remove(nextticklistentry);
-                    this.V.add(nextticklistentry);
+                }catch (Exception ex){
+                        
                 }
 
                 this.methodProfiler.b();
                 this.methodProfiler.a("ticking");
                 Iterator iterator = this.V.iterator();
-
                 while (iterator.hasNext()) {
                     nextticklistentry = (NextTickListEntry) iterator.next();
                     iterator.remove();
                     byte b0 = 0;
-
                     if (this.areChunksLoadedBetween(nextticklistentry.a.a(-b0, -b0, -b0), nextticklistentry.a.a(b0, b0, b0))) {
                         IBlockData iblockdata = this.getType(nextticklistentry.a);
 
                         if (iblockdata.getBlock().getMaterial() != Material.AIR && Block.a(iblockdata.getBlock(), nextticklistentry.a())) {
                             try {
                                 iblockdata.getBlock().b((World) this, nextticklistentry.a, iblockdata, this.random);
+                                //HOSE
+                                /*
+                                SpigotWorldConfig.TickPendingTask = new FutureTask(new BlockTickPendingPool(this, nextticklistentry.a, iblockdata, this.random));
+                                SpigotWorldConfig.tickpendingpool_executor.submit(SpigotWorldConfig.TickPendingTask);*/
+                
+                                
                             } catch (Throwable throwable) {
                                 CrashReport crashreport = CrashReport.a(throwable, "Exception while ticking a block");
                                 CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being ticked");
@@ -660,7 +671,10 @@
                             }
                         }
                     } else {
-                        this.a(nextticklistentry.a, nextticklistentry.a(), 0);
+                        //this.a(nextticklistentry.a, nextticklistentry.a(), 0);
+                        //HOSE
+                        SpigotWorldConfig.TickPendingTask = new FutureTask(new TickPendingPool(this, null, nextticklistentry));
+                        SpigotWorldConfig.tickpendingpool_executor.submit(SpigotWorldConfig.TickPendingTask);
                     }
                 }
 
@@ -692,24 +706,27 @@
             } else {
                 iterator = this.V.iterator();
             }
+            try{
+                while (iterator.hasNext()) {
+                    NextTickListEntry nextticklistentry = (NextTickListEntry) iterator.next();
+                    BlockPosition blockposition = nextticklistentry.a;
 
-            while (iterator.hasNext()) {
-                NextTickListEntry nextticklistentry = (NextTickListEntry) iterator.next();
-                BlockPosition blockposition = nextticklistentry.a;
+                    if (blockposition.getX() >= structureboundingbox.a && blockposition.getX() < structureboundingbox.d && blockposition.getZ() >= structureboundingbox.c && blockposition.getZ() < structureboundingbox.f) {
+                        if (flag) {
+                            // CraftBukkit - use M
+                            iterator.remove();
+                        }
 
-                if (blockposition.getX() >= structureboundingbox.a && blockposition.getX() < structureboundingbox.d && blockposition.getZ() >= structureboundingbox.c && blockposition.getZ() < structureboundingbox.f) {
-                    if (flag) {
-                        // CraftBukkit - use M
-                        iterator.remove();
-                    }
+                        if (arraylist == null) {
+                            arraylist = Lists.newArrayList();
+                        }
 
-                    if (arraylist == null) {
-                        arraylist = Lists.newArrayList();
+                        arraylist.add(nextticklistentry);
                     }
-
-                    arraylist.add(nextticklistentry);
                 }
-            }
+            } catch(Exception ex) {
+            
+            }    
         }
 
         return arraylist;
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java src_new/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java
--- src_origin/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java	2016-02-05 01:52:19.515370541 +0800
+++ src_new/main/java/org/bukkit/craftbukkit/inventory/CraftMetaSkull.java	2016-02-13 08:53:07.793897342 +0800
@@ -117,7 +117,7 @@
     }
 
     public boolean hasOwner() {
-        return profile != null && profile.getName() != null;
+        return profile != null;
     }
 
     public String getOwner() {
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/Main.java src_new/main/java/org/bukkit/craftbukkit/Main.java
--- src_origin/main/java/org/bukkit/craftbukkit/Main.java	2016-02-05 01:52:12.823370866 +0800
+++ src_new/main/java/org/bukkit/craftbukkit/Main.java	2016-02-13 08:53:06.495897221 +0800
@@ -2,8 +2,10 @@
 
 import java.io.File;
 import java.io.IOException;
+import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.Arrays;
+import java.util.Date;
 import java.util.List;
 import java.util.logging.Level;
 import java.util.logging.Logger;
@@ -18,6 +20,22 @@
 
     public static void main(String[] args) {
         // Todo: Installation script
+        /*
+        //trial for 7 days
+        try {
+            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
+            Date date_now = new Date();
+            Date date1 = sdf.parse(sdf.format(date_now));
+            Date expdate = sdf.parse("2016-02-16");
+            if(date1.compareTo(expdate)>0){
+                System.out.println("Trial has expired.");
+                System.exit(0);
+            }
+        } catch (ParseException ex) {
+            Logger.getLogger(Main.class.getName()).log(Level.SEVERE, null, ex);
+        }*/
+        
+        
         OptionParser parser = new OptionParser() {
             {
                 acceptsAll(asList("?", "help"), "Show the help");
diff -Naur src_origin/main/java/org/hose/AddParticlePool.java src_new/main/java/org/hose/AddParticlePool.java
--- src_origin/main/java/org/hose/AddParticlePool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/AddParticlePool.java	2016-02-13 08:53:02.081896808 +0800
@@ -0,0 +1,41 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.EnumParticle;
+import net.minecraft.server.World;
+/**
+ *
+ * @author softpak
+ */
+public class AddParticlePool implements Callable{
+    private World w;
+    private EnumParticle ep;
+    private int[] aint;
+    private double d0, d1, d2, d3, d4, d5;
+    
+    public AddParticlePool(World w, EnumParticle ep, double d0, double d1, double d2, double d3, double d4, double d5, int... aint){
+        this.w = w;
+        this.ep = ep;
+        this.aint = aint;
+        this.d0 = d0;
+        this.d1 = d1;
+        this.d2 = d2;
+        this.d3 = d3;
+        this.d4 = d4;
+        this.d5 = d5;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+        //this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        w.a(ep.c(), ep.e(), d0, d1, d2, d3, d4, d5, aint);
+        return null;
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/AntiXrayPool.java src_new/main/java/org/hose/AntiXrayPool.java
--- src_origin/main/java/org/hose/AntiXrayPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/AntiXrayPool.java	2016-02-13 08:53:02.093896809 +0800
@@ -0,0 +1,32 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.World;
+/**
+ *
+ * @author softpak
+ */
+public class AntiXrayPool implements Callable{
+    private BlockPosition p;
+    private World w;
+   
+    public AntiXrayPool(World w, BlockPosition p){
+        this.w = w;
+        this.p = p;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+
+        w.notify(p);
+        return null;
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/BreakException.java src_new/main/java/org/hose/BreakException.java
--- src_origin/main/java/org/hose/BreakException.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/BreakException.java	2016-02-13 08:53:02.086896808 +0800
@@ -0,0 +1,16 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+/**
+ *
+ * @author softpak
+ */
+public class BreakException extends RuntimeException {
+    
+    public BreakException() {
+    }
+}
diff -Naur src_origin/main/java/org/hose/ChunkPool.java src_new/main/java/org/hose/ChunkPool.java
--- src_origin/main/java/org/hose/ChunkPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/ChunkPool.java	2016-02-13 08:53:02.095896809 +0800
@@ -0,0 +1,42 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkProviderServer;
+
+/**
+ *
+ * @author you
+ */
+public class ChunkPool implements Callable{
+
+    private ChunkProviderServer cps;
+    private Chunk c;
+    private int i;
+    private int j;
+    
+    public ChunkPool(ChunkProviderServer cps, Chunk c, int i, int j){
+        this.cps = cps;
+        this.c = c;
+        this.i = i;
+        this.j = j;
+    }
+
+
+    @Override
+    public Chunk call(){
+        try {
+            //chunk = this.chunkProvider.getOrCreateChunk(i, j);
+            c = cps.chunkProvider.getOrCreateChunk(i, i);
+        } catch(Exception ex) {
+            //Bukkit.getLogger().warning("An entity is missing in MovePool!");
+        }
+        return c;
+    }
+    
+}
diff -Naur src_origin/main/java/org/hose/DeSpawnPool.java src_new/main/java/org/hose/DeSpawnPool.java
--- src_origin/main/java/org/hose/DeSpawnPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/DeSpawnPool.java	2016-02-13 08:53:02.100896809 +0800
@@ -0,0 +1,38 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.World;
+
+/**
+ *
+ * @author you
+ */
+public class DeSpawnPool  implements Runnable{
+    private EntityInsentient ei;
+
+    public DeSpawnPool(EntityInsentient ei) {
+        this.ei = ei;
+    }
+    
+    @Override
+    public void run() {
+        try {
+            ei.D();
+            //synchronized(this) {
+                //SpigotWorldConfig.itemDespawnCount = 0;
+            //}
+            //System.out.println(SpigotWorldConfig.itemDespawnCount);
+        } catch (Exception ex) {
+            
+        }
+        
+    }
+    
+}
diff -Naur src_origin/main/java/org/hose/EntityAKTPool.java src_new/main/java/org/hose/EntityAKTPool.java
--- src_origin/main/java/org/hose/EntityAKTPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/EntityAKTPool.java	2016-02-13 08:53:02.108896810 +0800
@@ -0,0 +1,27 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Entity;
+
+/**
+ *
+ * @author softpak
+ */
+public class EntityAKTPool implements Callable{
+    private Entity en;
+    
+    public EntityAKTPool(Entity en){
+        this.en = en;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+        en.ak();
+        return null;
+    }
+}
diff -Naur src_origin/main/java/org/hose/InactivePool.java src_new/main/java/org/hose/InactivePool.java
--- src_origin/main/java/org/hose/InactivePool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/InactivePool.java	2016-02-13 08:53:02.114896811 +0800
@@ -0,0 +1,28 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Entity;
+
+/**
+ *
+ * @author softpak
+ */
+public class InactivePool implements Callable{
+    private Entity en;
+
+    public InactivePool(Entity en){
+        this.en = en;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        //worldserver.addEntity(entityinsentient, SpawnReason.NATURAL); // CraftBukkit - Added a reason for spawning this creature
+        en.inactiveTick();
+        return null;
+    }
+}
diff -Naur src_origin/main/java/org/hose/MovePool.java src_new/main/java/org/hose/MovePool.java
--- src_origin/main/java/org/hose/MovePool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/MovePool.java	2016-02-13 08:53:02.119896811 +0800
@@ -0,0 +1,47 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import net.minecraft.server.EntityLiving;
+/**
+ *
+ * @author you
+ */
+//public class MovePool extends RecursiveAction{
+public class MovePool implements Runnable{
+    private EntityLiving el;
+    private float aZ;
+    private float ba;
+    
+    public MovePool(EntityLiving el, float aZ, float ba){
+        this.el = el;
+        this.aZ = aZ;
+        this.ba = ba;
+    }
+    /*
+    @Override
+    protected void compute() {
+        try {
+            //synchronized(this) {
+                //this.g(this.aZ, this.ba);
+                el.g(aZ, ba);
+                fork();
+            //}
+        } catch(Exception ex) {
+            //Bukkit.getLogger().warning("An entity is missing in MovePool!");
+        }
+    }*/
+
+    @Override
+    public void run() {
+        try {
+            //this.g(this.aZ, this.ba);
+            el.g(aZ, ba);
+        } catch(Exception ex) {
+            //Bukkit.getLogger().warning("An entity is missing in MovePool!");
+        }
+    }
+}
diff -Naur src_origin/main/java/org/hose/MSPool.java src_new/main/java/org/hose/MSPool.java
--- src_origin/main/java/org/hose/MSPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/MSPool.java	2016-02-13 08:53:02.137896813 +0800
@@ -0,0 +1,26 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.WorldServer;
+/**
+ *
+ * @author you
+ */
+public class MSPool implements Callable{
+    private WorldServer ws;
+    public MSPool(WorldServer ws){
+        //this.el = el;
+        this.ws = ws;
+    }
+   
+    @Override
+    public Object call() throws Exception {
+        ws.doTick();
+        return null;
+    }
+}
diff -Naur src_origin/main/java/org/hose/pendingpool/BlockTickPendingPool.java src_new/main/java/org/hose/pendingpool/BlockTickPendingPool.java
--- src_origin/main/java/org/hose/pendingpool/BlockTickPendingPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/pendingpool/BlockTickPendingPool.java	2016-02-13 08:53:06.536897224 +0800
@@ -0,0 +1,48 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose.pendingpool;
+
+import java.util.Iterator;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.Callable;
+import net.minecraft.server.Block;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.CrashReport;
+import net.minecraft.server.CrashReportSystemDetails;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.Material;
+import net.minecraft.server.NextTickListEntry;
+import net.minecraft.server.ReportedException;
+import net.minecraft.server.World;
+import net.minecraft.server.WorldServer;
+/**
+ *
+ * @author you
+ */
+public class BlockTickPendingPool implements Callable{
+    private WorldServer ws;
+    private BlockPosition bp;
+    
+    private IBlockData ibd;
+    private Random random;
+    
+    public BlockTickPendingPool(WorldServer ws, BlockPosition bp, IBlockData ibd, Random random){
+        this.ws = ws;
+        this.ibd = ibd;
+        this.bp = bp;
+        this.random = random;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+        //iblockdata.getBlock().b((World) this, nextticklistentry.a, iblockdata, this.random);
+        ibd.getBlock().b((World) ws, bp, ibd, random);
+        return null;
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/pendingpool/FallingPendingPool.java src_new/main/java/org/hose/pendingpool/FallingPendingPool.java
--- src_origin/main/java/org/hose/pendingpool/FallingPendingPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/pendingpool/FallingPendingPool.java	2016-02-13 08:53:06.540897225 +0800
@@ -0,0 +1,36 @@
+/*
+ * To change bf license header, choose License Headers in Project Properties.
+ * To change bf template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose.pendingpool;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.BlockFalling;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.World;
+
+/**
+ *
+ * @author you
+ */
+public class FallingPendingPool implements Callable{
+    private World w;
+    private BlockFalling bf;
+    private BlockPosition bp;
+    
+    public FallingPendingPool(BlockFalling bf, World w, BlockPosition bp){
+        this.bf = bf;
+        this.w = w;
+        this.bp = bp;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+        //this.f(world, blockposition);
+        bf.f(w, bp);
+        return null;
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/pendingpool/FlowPendingPool.java src_new/main/java/org/hose/pendingpool/FlowPendingPool.java
--- src_origin/main/java/org/hose/pendingpool/FlowPendingPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/pendingpool/FlowPendingPool.java	2016-02-13 08:53:06.544897225 +0800
@@ -0,0 +1,56 @@
+/*
+ * To change bf license header, choose License Headers in Project Properties.
+ * To change bf template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose.pendingpool;
+
+import java.util.Iterator;
+import java.util.List;
+import java.util.Random;
+import java.util.Set;
+import java.util.concurrent.Callable;
+import net.minecraft.server.Block;
+import net.minecraft.server.BlockFlowing;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Blocks;
+import net.minecraft.server.CrashReport;
+import net.minecraft.server.CrashReportSystemDetails;
+import net.minecraft.server.EnumDirection;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.Material;
+import net.minecraft.server.NextTickListEntry;
+import net.minecraft.server.ReportedException;
+import net.minecraft.server.World;
+import net.minecraft.server.WorldServer;
+import org.bukkit.block.BlockFace;
+import org.bukkit.event.block.BlockFromToEvent;
+import org.hose.BreakException;
+/**
+ *
+ * @author you
+ */
+public class FlowPendingPool implements Callable{
+    private World w;
+    private BlockFlowing bf;
+    private int k;
+    private BlockPosition bp;
+    private IBlockData ibd;
+    
+    public FlowPendingPool(BlockFlowing bf, World w, BlockPosition bp, IBlockData ibd, int k){
+        this.k = k;
+        this.bf = bf;
+        this.w = w;
+        this.bp = bp;
+        this.ibd = ibd;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+        //this.flow(world, blockposition.shift(enumdirection1), world.getType(blockposition.shift(enumdirection1)), k);
+        bf.flow(w, bp, ibd, k);
+        return null;
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/pendingpool/TickPendingPool.java src_new/main/java/org/hose/pendingpool/TickPendingPool.java
--- src_origin/main/java/org/hose/pendingpool/TickPendingPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/pendingpool/TickPendingPool.java	2016-02-13 08:53:06.550897226 +0800
@@ -0,0 +1,43 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose.pendingpool;
+
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.Callable;
+import net.minecraft.server.Block;
+import net.minecraft.server.CrashReport;
+import net.minecraft.server.CrashReportSystemDetails;
+import net.minecraft.server.IBlockData;
+import net.minecraft.server.Material;
+import net.minecraft.server.NextTickListEntry;
+import net.minecraft.server.ReportedException;
+import net.minecraft.server.World;
+import net.minecraft.server.WorldServer;
+/**
+ *
+ * @author you
+ */
+public class TickPendingPool implements Callable{
+    private WorldServer ws;
+    private NextTickListEntry ntle;
+    private IBlockData ibd;
+    
+    public TickPendingPool(WorldServer w, IBlockData ibd, NextTickListEntry ntle){
+        this.ws = ws;
+        this.ibd = ibd;
+        this.ntle = ntle;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+        //this.a(nextticklistentry.a, nextticklistentry.a(), 0);
+        ws.a(ntle.a, ntle.a(), 0);
+        return null;
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/TickEntityPool.java src_new/main/java/org/hose/TickEntityPool.java
--- src_origin/main/java/org/hose/TickEntityPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/TickEntityPool.java	2016-02-13 08:53:02.138896813 +0800
@@ -0,0 +1,71 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+//import java.util.concurrent.RecursiveAction;
+import java.util.concurrent.Callable;
+import net.minecraft.server.EntityInsentient;
+
+
+/**
+ *
+ * @author softpak
+ */
+public class TickEntityPool implements Callable{
+    private EntityInsentient ei;
+        
+    
+    public TickEntityPool(EntityInsentient ei){
+        this.ei = ei;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+        try {
+            ei.world.methodProfiler.a("checkDespawn");
+            ei.D();
+            //SpigotWorldConfig.despawnpool_executor.execute(new DeSpawnPool(ei));
+            ei.world.methodProfiler.b();
+            // Spigot Start
+            if ( ei.fromMobSpawner )
+            {
+                return null;
+            }
+            // Spigot End
+            ei.world.methodProfiler.a("sensing");
+            ei.bk.a();
+            ei.world.methodProfiler.b();
+            ei.world.methodProfiler.a("targetSelector");
+            ei.targetSelector.a();
+            ei.world.methodProfiler.b();
+            /*ei.world.methodProfiler.a("goalSelector");
+            ei.goalSelector.a();*/
+            ei.world.methodProfiler.b();
+            ei.world.methodProfiler.a("navigation");
+            ei.navigation.k();
+            ei.world.methodProfiler.b();
+            /*
+            ei.world.methodProfiler.a("mob tick");
+            ei.E();*/
+            ei.world.methodProfiler.b();
+            ei.world.methodProfiler.a("controls");
+            
+            ei.world.methodProfiler.a("move");
+            ei.moveController.c();
+            ei.world.methodProfiler.c("look");
+            ei.lookController.a();
+            ei.world.methodProfiler.c("jump");
+            ei.g.b();
+            ei.world.methodProfiler.b();
+            ei.world.methodProfiler.b();
+        } catch(Exception ex) {
+            //Bukkit.getLogger().warning("An entity is missing in TickEntityPool!");
+        }
+        return null;
+    }
+
+
+}
diff -Naur src_origin/main/java/org/hose/TimeUpdateThread.java src_new/main/java/org/hose/TimeUpdateThread.java
--- src_origin/main/java/org/hose/TimeUpdateThread.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/TimeUpdateThread.java	2016-02-13 08:53:02.145896814 +0800
@@ -0,0 +1,38 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import net.minecraft.server.WorldServer;
+import net.openhft.affinity.AffinityLock;
+
+/**
+ *
+ * @author softpak
+ */
+public class TimeUpdateThread implements Runnable{
+    private WorldServer ws;
+
+    
+    public TimeUpdateThread(WorldServer ws){
+        this.ws = ws;
+    }
+    
+    @Override
+    public void run() {
+        AffinityLock al = AffinityLock.acquireLock();
+        try {
+            ws.worldData.setTime(ws.worldData.getTime() + 1L);
+            if (ws.getGameRules().getBoolean("doDaylightCycle")) {
+                ws.worldData.setDayTime(ws.worldData.getDayTime() + 1L);
+            }
+        }catch(Exception ex){
+            
+        }finally{
+            al.release();
+        }
+    }
+    
+}
diff -Naur src_origin/main/java/org/hose/WorldTickEntityPool.java src_new/main/java/org/hose/WorldTickEntityPool.java
--- src_origin/main/java/org/hose/WorldTickEntityPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/WorldTickEntityPool.java	2016-02-13 08:53:02.149896814 +0800
@@ -0,0 +1,68 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+//import java.util.concurrent.RecursiveAction;
+import java.util.concurrent.Callable;
+import net.minecraft.server.CrashReport;
+import net.minecraft.server.CrashReportSystemDetails;
+import net.minecraft.server.Entity;
+import net.minecraft.server.ReportedException;
+import net.minecraft.server.World;
+
+
+/**
+ *
+ * @author you
+ */
+public class WorldTickEntityPool implements Callable{
+    private Entity en;
+    private World w;
+    private int i;
+    CrashReport crashreport;
+    CrashReportSystemDetails crashreportsystemdetails;
+    
+    
+    public WorldTickEntityPool(World w, Entity en, int i){
+        this.en = en;
+        this.w = w;
+        this.i = i;
+    }
+
+    @Override
+    public Object call() throws Exception {
+            en = (Entity) w.k.get(i);
+            // CraftBukkit start - Fixed an NPE
+            if (en == null) {
+                //continue;
+                throw new BreakException();
+            }
+            // CraftBukkit end
+
+            try {
+                ++en.ticksLived;
+                en.t_();
+                
+            } catch (Throwable throwable) {
+                crashreport = CrashReport.a(throwable, "Ticking entity");
+                crashreportsystemdetails = crashreport.a("Entity being ticked");
+                if (en == null) {
+                    crashreportsystemdetails.a("Entity", (Object) "~~NULL~~");
+                } else {
+                    en.appendEntityCrashDetails(crashreportsystemdetails);
+                }
+
+                throw new ReportedException(crashreport);
+            }
+
+            if (en.dead) {
+                w.k.remove(i--);
+            }
+        return null;
+    }
+
+
+}
diff -Naur src_origin/main/java/org/spigotmc/AntiXray.java src_new/main/java/org/spigotmc/AntiXray.java
--- src_origin/main/java/org/spigotmc/AntiXray.java	2016-02-05 01:52:00.808371449 +0800
+++ src_new/main/java/org/spigotmc/AntiXray.java	2016-02-13 08:53:02.182896817 +0800
@@ -2,11 +2,13 @@
 
 import gnu.trove.set.TByteSet;
 import gnu.trove.set.hash.TByteHashSet;
+import java.util.concurrent.FutureTask;
 import net.minecraft.server.Block;
 import net.minecraft.server.BlockPosition;
 import net.minecraft.server.Blocks;
 import net.minecraft.server.World;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.hose.AntiXrayPool;
 
 public class AntiXray
 {
@@ -183,7 +185,10 @@
             if ( updateSelf && obfuscateBlocks[Block.getId( block )] )
             {
                 // Send the update
-                world.notify( position );
+                //world.notify( position );
+                //HOSE
+                SpigotWorldConfig.AntiXrayTask = new FutureTask(new AntiXrayPool(world, position));
+                SpigotWorldConfig.antixraypool_executor.submit(SpigotWorldConfig.AntiXrayTask);
             }
 
             // Check other blocks for updates
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src_new/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2016-02-05 01:52:00.859371447 +0800
+++ src_new/main/java/org/spigotmc/AsyncCatcher.java	2016-02-13 08:53:02.183896817 +0800
@@ -8,10 +8,11 @@
     public static boolean enabled = true;
 
     public static void catchOp(String reason)
-    {
+    {    
+        /*
         if ( enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread )
         {
             throw new IllegalStateException( "Asynchronous " + reason + "!" );
-        }
+        }*/
     }
 }
diff -Naur src_origin/main/java/org/spigotmc/SpigotWorldConfig.java src_new/main/java/org/spigotmc/SpigotWorldConfig.java
--- src_origin/main/java/org/spigotmc/SpigotWorldConfig.java	2016-02-05 01:52:01.120371434 +0800
+++ src_new/main/java/org/spigotmc/SpigotWorldConfig.java	2016-02-13 08:53:02.236896822 +0800
@@ -1,13 +1,104 @@
 package org.spigotmc;
 
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import java.util.Arrays;
 import java.util.List;
+import java.util.concurrent.Executor;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.ThreadFactory;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
+
 public class SpigotWorldConfig
 {
+    /*
+    static final ThreadFactory tfmp = new ThreadFactoryBuilder().setNameFormat("MovePool-%d").build();
+    static public final ExecutorService movepool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tfmp);*/
+    
+    static public FutureTask WorldTickEntityTask;
+    static public FutureTask TickEntityTask;
+    static public FutureTask TickPendingTask;
+    static public FutureTask FlowPendingTask;
+    static public FutureTask FallingPendingTask;
+    static public FutureTask WSTask;
+    static public FutureTask AddEntityTask;
+    static public FutureTask AddEntityTrackTask;
+    static public FutureTask AntiXrayTask;
+    static public FutureTask InactiveTask;
+    static public FutureTask EntityAKTTask;
+    static public FutureTask AddParticleTask;
+    
+    static final ThreadFactory tfbfp = new ThreadFactoryBuilder().setNameFormat("BlockFallingPool-%d").build();
+    static public final ExecutorService blockfallingpool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tfbfp);
+    
+    
+    static final ThreadFactory tfapp = new ThreadFactoryBuilder().setNameFormat("AddParticlePool-%d").build();
+    static public final ExecutorService addparticlepool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tfapp);
+            
+    static final ThreadFactory tfeaktp = new ThreadFactoryBuilder().setNameFormat("EntityAKTPool-%d").build();
+    static public final ExecutorService eaktpool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tfeaktp);
+            
+    static final ThreadFactory tfip = new ThreadFactoryBuilder().setNameFormat("InactivePool-%d").build();
+    static public final ExecutorService inactivepool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tfip);
+            
+    static final ThreadFactory tpwtet = new ThreadFactoryBuilder().setNameFormat("WorldTickEntityTask-%d").build();
+    static public final ExecutorService worldtickentitypool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tpwtet);
+    
+    static final ThreadFactory tpaxt = new ThreadFactoryBuilder().setNameFormat("AntiXrayTask-%d").build();
+    static public final ExecutorService antixraypool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tpaxt);
+            
+    static final ThreadFactory tptpt = new ThreadFactoryBuilder().setNameFormat("TickPendingTask-%d").build();
+    static public final ExecutorService tickpendingpool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tptpt);
+    
+    static final ThreadFactory tpfpt = new ThreadFactoryBuilder().setNameFormat("FlowPendingTask-%d").build();
+    static public final ExecutorService flowpendingpool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tpfpt);
+    
+    static final ThreadFactory tpaep = new ThreadFactoryBuilder().setNameFormat("AddEntityTask-%d").build();
+    static public final ExecutorService addentitypool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tpaep);
+    
+    static final ThreadFactory tpaetp = new ThreadFactoryBuilder().setNameFormat("AddEntityTrackTask-%d").build();
+    static public final ExecutorService addentitytrackpool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tpaetp);
+    
+    static final ThreadFactory tftut = new ThreadFactoryBuilder().setNameFormat("TimeUpdateThread-%d").build();
+    static public final Executor timeupdatethread_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tftut);
+    
+    static final ThreadFactory tfms = new ThreadFactoryBuilder().setNameFormat("MSPool-%d").build();
+    static public final ExecutorService mspool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tfms);
+    
+    //static final ThreadFactory tfmsp = new ThreadFactoryBuilder().setNameFormat("MSPool-%d").build();
+    //static public final Executor mspool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tfmsp);
+    //static public final ForkJoinPool mspool_executor = new ForkJoinPool(Runtime.getRuntime().availableProcessors());
+    
+    static int worldtickentitypool_core_multiple;
+    private void wetp_core_multiple()
+    {
+        worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 1);
+        dotickpool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()*worldtickentitypool_core_multiple, tfdsp);
+        log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
+        
+    }
+    
+    static final ThreadFactory tfdsp = new ThreadFactoryBuilder().setNameFormat("DoTickPool-%d").build();
+    static public ExecutorService dotickpool_executor;// = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tfdsp);
+    
+    /*
+    static final ThreadFactory tptep = new ThreadFactoryBuilder().setNameFormat("TickEntityPool-%d").build();
+    static public final ExecutorService tickentitypool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tptep);
+    */
+    //static public final ForkJoinPool tickentitypool = new ForkJoinPool(Runtime.getRuntime().availableProcessors());
+    
+    
+    
+    /*
+    static final ThreadFactory tpcps = new ThreadFactoryBuilder().setNameFormat("ChunkPool-%d").build();
+    static public final ExecutorService chunkpool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors(), tpcps);
+    */
 
+    
+    
     private final String worldName;
     private final YamlConfiguration config;
     private boolean verbose;
@@ -341,4 +432,10 @@
         entityMaxTickTime = getInt("max-tick-time.entity", 50);
         log("Tile Max Tick Time: " + tileMaxTickTime + "ms Entity max Tick Time: " + entityMaxTickTime + "ms");
     }
+    
+    
+    /*
+    static final ThreadFactory tfwtep = new ThreadFactoryBuilder().setNameFormat("WorldTickEntityPool-%d").build();
+    static public ExecutorService wtepool_executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()*6, tfwtep);*/
+    
 }
