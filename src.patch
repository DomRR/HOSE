diff -Naur src_origin/main/java/net/minecraft/server/Chunk.java src/main/java/net/minecraft/server/Chunk.java
--- src_origin/main/java/net/minecraft/server/Chunk.java	2017-05-15 13:09:52.500961596 +0800
+++ src/main/java/net/minecraft/server/Chunk.java	2017-05-15 13:10:01.938962479 +0800
@@ -15,6 +15,7 @@
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists; // CraftBukkit
+import java.util.Queue;
 import org.bukkit.Server; // CraftBukkit
 
 public class Chunk {
@@ -32,7 +33,8 @@
     public final int locZ;
     private boolean m;
     public final Map<BlockPosition, TileEntity> tileEntities;
-    public final List<Entity>[] entitySlices; // Spigot
+    //public final List<Entity>[] entitySlices; // Spigot
+    public final Queue<Entity>[] entitySlices;//hose
     private boolean done;
     private boolean lit;
     private boolean r;
@@ -83,14 +85,16 @@
         this.tileEntities = Maps.newHashMap();
         this.x = 4096;
         this.y = Queues.newConcurrentLinkedQueue();
-        this.entitySlices = (List[]) (new List[16]); // Spigot
+        //this.entitySlices = (List[]) (new List[16]); // Spigot
+        this.entitySlices = (Queue[]) (new Queue[16]);//hose
         this.world = world;
         this.locX = i;
         this.locZ = j;
         this.heightMap = new int[256];
 
         for (int k = 0; k < this.entitySlices.length; ++k) {
-            this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            //this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[k] = Queues.newConcurrentLinkedQueue();//hose
         }
 
         Arrays.fill(this.h, -999);
@@ -744,11 +748,13 @@
     public void addEntities() {
         this.j = true;
         this.world.b(this.tileEntities.values());
-        List[] aentityslice = this.entitySlices; // Spigot
+        //List[] aentityslice = this.entitySlices; // Spigot
+        Queue[] aentityslice = this.entitySlices;
         int i = aentityslice.length;
 
         for (int j = 0; j < i; ++j) {
-            List entityslice = aentityslice[j]; // Spigot
+            //List entityslice = aentityslice[j]; // Spigot
+            Queue entityslice = aentityslice[j];
 
             this.world.a((Collection) entityslice);
         }
@@ -777,7 +783,8 @@
             this.world.b(tileentity);
         }
 
-        List[] aentityslice = this.entitySlices; // Spigot
+        //List[] aentityslice = this.entitySlices; // Spigot
+        Queue[] aentityslice = this.entitySlices;//hose        
         int i = aentityslice.length;
 
         for (int j = 0; j < i; ++j) {
@@ -1288,7 +1295,8 @@
         return this.tileEntities;
     }
 
-    public List<Entity>[] getEntitySlices() {
+    //public List<Entity>[] getEntitySlices() {
+    public Queue<Entity>[] getEntitySlices() {//hose
         return this.entitySlices;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderServer.java src/main/java/net/minecraft/server/ChunkProviderServer.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderServer.java	2017-05-15 13:09:52.463961593 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderServer.java	2017-05-15 13:10:01.951962481 +0800
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
@@ -10,6 +11,7 @@
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
@@ -23,10 +25,12 @@
 public class ChunkProviderServer implements IChunkProvider {
 
     private static final Logger a = LogManager.getLogger();
-    public final Set<Long> unloadQueue = Sets.newHashSet();
+    //public final Set<Long> unloadQueue = Sets.newHashSet();
+    public final Set<Long> unloadQueue = Sets.newConcurrentHashSet();//hose
     public final ChunkGenerator chunkGenerator;
     private final IChunkLoader chunkLoader;
-    public final Long2ObjectMap<Chunk> chunks = new Long2ObjectOpenHashMap(8192);
+    //public final Long2ObjectMap<Chunk> chunks = new Long2ObjectOpenHashMap(8192);
+    public final Map<Long, Chunk> chunks = Maps.newConcurrentMap();//hose
     public final WorldServer world;
 
     public ChunkProviderServer(WorldServer worldserver, IChunkLoader ichunkloader, ChunkGenerator chunkgenerator) {
@@ -47,14 +51,16 @@
 
     }
 
-    public void b() {
+    public void b() {//hose
+        this.chunks.entrySet().forEach(map -> this.unload(map.getValue()));
+        /*
         ObjectIterator objectiterator = this.chunks.values().iterator();
 
         while (objectiterator.hasNext()) {
             Chunk chunk = (Chunk) objectiterator.next();
 
             this.unload(chunk);
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityLightning.java src/main/java/net/minecraft/server/EntityLightning.java
--- src_origin/main/java/net/minecraft/server/EntityLightning.java	2017-05-15 13:09:52.889961633 +0800
+++ src/main/java/net/minecraft/server/EntityLightning.java	2017-05-15 13:10:02.490962531 +0800
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import java.util.List;
+import java.util.Queue;
 
 import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
 
@@ -66,7 +67,8 @@
             // this.world.a((EntityHuman) null, this.locX, this.locY, this.locZ, SoundEffects.dv, SoundCategory.WEATHER, 10000.0F, 0.8F + this.random.nextFloat() * 0.2F);
             float pitch = 0.8F + this.random.nextFloat() * 0.2F;
             int viewDistance = ((WorldServer) this.world).getServer().getViewDistance() * 16;
-            for (EntityPlayer player : (List<EntityPlayer>) (List) this.world.players) {
+            //for (EntityPlayer player : (List<EntityPlayer>) (List) this.world.players) {
+            for (EntityPlayer player : (Queue<EntityPlayer>) (Queue) this.world.players) {//hose
                 double deltaX = this.locX - player.locX;
                 double deltaZ = this.locZ - player.locZ;
                 double distanceSquared = deltaX * deltaX + deltaZ * deltaZ;
diff -Naur src_origin/main/java/net/minecraft/server/EntityPlayer.java src/main/java/net/minecraft/server/EntityPlayer.java
--- src_origin/main/java/net/minecraft/server/EntityPlayer.java	2017-05-15 13:09:52.995961643 +0800
+++ src/main/java/net/minecraft/server/EntityPlayer.java	2017-05-15 13:10:02.595962541 +0800
@@ -14,6 +14,8 @@
 
 // CraftBukkit start
 import com.google.common.base.Preconditions;
+import com.google.common.collect.Queues;
+import java.util.Queue;
 import org.bukkit.Bukkit;
 import org.bukkit.GameMode;
 import org.bukkit.WeatherType;
@@ -37,7 +39,8 @@
     public final PlayerInteractManager playerInteractManager;
     public double d;
     public double e;
-    public final List<Integer> removeQueue = Lists.newLinkedList();
+    //public final List<Integer> removeQueue = Lists.newLinkedList();
+    public final Queue<Integer> removeQueue = Queues.newConcurrentLinkedQueue();//hose
     private final ServerStatisticManager bU;
     private float bV = Float.MIN_VALUE;
     private int bW = Integer.MIN_VALUE;
@@ -959,7 +962,10 @@
         this.lastSentExp = -1;
         this.lastHealthSent = -1.0F;
         this.cc = -1;
-        this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
+        //this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
+        Queue<Integer> q2 = Queues.newConcurrentLinkedQueue();//hose
+        ((EntityPlayer) entityhuman).removeQueue.stream().forEach(eh -> q2.add(eh));//hose
+        q2.stream().forEach(eh -> this.removeQueue.add(eh));//hose
     }
 
     protected void a(MobEffect mobeffect) {
diff -Naur src_origin/main/java/net/minecraft/server/EntityTrackerEntry.java src/main/java/net/minecraft/server/EntityTrackerEntry.java
--- src_origin/main/java/net/minecraft/server/EntityTrackerEntry.java	2017-05-15 13:09:53.098961652 +0800
+++ src/main/java/net/minecraft/server/EntityTrackerEntry.java	2017-05-15 13:10:02.745962555 +0800
@@ -1,10 +1,12 @@
 package net.minecraft.server;
 
+import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.Set;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -41,7 +43,8 @@
     private boolean x;
     private boolean y;
     public boolean b;
-    public final Set<EntityPlayer> trackedPlayers = Sets.newHashSet();
+    //public final Set<EntityPlayer> trackedPlayers = Sets.newHashSet();
+    public final Set<EntityPlayer> trackedPlayers = Sets.newConcurrentHashSet();//hose
 
     public EntityTrackerEntry(Entity entity, int i, int j, int k, boolean flag) {
         this.tracker = entity;
@@ -66,7 +69,8 @@
         return this.tracker.getId();
     }
 
-    public void track(List<EntityHuman> list) {
+    //public void track(List<EntityHuman> list) {
+    public void track(Queue<EntityHuman> list) {//hose
         this.b = false;
         if (!this.isMoving || this.tracker.d(this.q, this.r, this.s) > 16.0D) {
             this.q = this.tracker.locX;
@@ -91,6 +95,18 @@
 
             if (this.a % 10 == 0 && itemstack.getItem() instanceof ItemWorldMap) { // CraftBukkit - Moved this.a % 10 logic here so item frames do not enter the other blocks
                 WorldMap worldmap = Items.FILLED_MAP.getSavedMap(itemstack, this.tracker.world);
+                this.trackedPlayers.stream().forEach(iterator -> {//hose
+                    EntityHuman entityhuman = (EntityHuman) iterator;
+                    EntityPlayer entityplayer = (EntityPlayer) entityhuman;
+
+                    worldmap.a(entityplayer, itemstack);
+                    Packet packet = Items.FILLED_MAP.a(itemstack, this.tracker.world, (EntityHuman) entityplayer);
+
+                    if (packet != null) {
+                        entityplayer.playerConnection.sendPacket(packet);
+                    }
+                });
+                /*
                 Iterator iterator = this.trackedPlayers.iterator(); // CraftBukkit
 
                 while (iterator.hasNext()) {
@@ -103,7 +119,7 @@
                     if (packet != null) {
                         entityplayer.playerConnection.sendPacket(packet);
                     }
-                }
+                }*/
             }
 
             this.d();
@@ -171,7 +187,8 @@
                         this.v = 0;
                         // CraftBukkit start - Refresh list of who can see a player before sending teleport packet
                         if (this.tracker instanceof EntityPlayer) {
-                            this.scanPlayers(new java.util.ArrayList(this.trackedPlayers));
+                            //this.scanPlayers(new java.util.ArrayList(this.trackedPlayers));
+                            this.scanPlayers(Queues.newConcurrentLinkedQueue(this.trackedPlayers));//hose
                         }
                         // CraftBukkit end
                         this.c();
@@ -336,7 +353,8 @@
                         }
                     }
 
-                    entityplayer.removeQueue.remove(Integer.valueOf(this.tracker.getId()));
+                    //entityplayer.removeQueue.remove(Integer.valueOf(this.tracker.getId()));
+                    entityplayer.removeQueue.remove(this.tracker.getId());//hose
                     // CraftBukkit end
                     this.trackedPlayers.add(entityplayer);
                     Packet packet = this.e();
@@ -444,10 +462,12 @@
         return entityplayer.x().getPlayerChunkMap().a(entityplayer, this.tracker.ab, this.tracker.ad);
     }
 
-    public void scanPlayers(List<EntityHuman> list) {
-        for (int i = 0; i < list.size(); ++i) {
+    //public void scanPlayers(List<EntityHuman> list) {
+    public void scanPlayers(Queue<EntityHuman> list) {//hose
+        list.stream().forEach(pl -> this.updatePlayer((EntityPlayer) pl));
+        /*for (int i = 0; i < list.size(); ++i) {
             this.updatePlayer((EntityPlayer) list.get(i));
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityTracker.java src/main/java/net/minecraft/server/EntityTracker.java
--- src_origin/main/java/net/minecraft/server/EntityTracker.java	2017-05-15 13:09:53.090961652 +0800
+++ src/main/java/net/minecraft/server/EntityTracker.java	2017-05-15 13:10:02.743962555 +0800
@@ -1,9 +1,13 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.Map;
+import java.util.Queue;
 import java.util.Set;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -12,8 +16,10 @@
 
     private static final Logger a = LogManager.getLogger();
     private final WorldServer world;
-    private final Set<EntityTrackerEntry> c = Sets.newHashSet();
-    public final IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    //private final Set<EntityTrackerEntry> c = Sets.newHashSet();
+    private final Set<EntityTrackerEntry> c = Sets.newConcurrentHashSet();//hose
+    //public final IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    public final Map<Integer, EntityTrackerEntry> trackedEntities = Maps.newConcurrentMap();//hose
     private int e;
 
     public EntityTracker(WorldServer worldserver) {
@@ -108,14 +114,16 @@
         org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
         i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
         try {
-            if (this.trackedEntities.b(entity.getId())) {
+            //if (this.trackedEntities.b(entity.getId())) {
+            if (this.trackedEntities.containsKey(entity.getId())) {//hose
                 throw new IllegalStateException("Entity is already tracked!");
             }
 
             EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, this.e, j, flag);
 
             this.c.add(entitytrackerentry);
-            this.trackedEntities.a(entity.getId(), entitytrackerentry);
+            //this.trackedEntities.a(entity.getId(), entitytrackerentry);
+            this.trackedEntities.put(entity.getId(), entitytrackerentry);//hose
             entitytrackerentry.scanPlayers(this.world.players);
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
@@ -150,7 +158,7 @@
 
     }
 
-    public void untrackEntity(Entity entity) {
+    public void untrackEntity(Entity entity) {//the problem is here //hose
         org.spigotmc.AsyncCatcher.catchOp( "entity untrack"); // Spigot
         if (entity instanceof EntityPlayer) {
             EntityPlayer entityplayer = (EntityPlayer) entity;
@@ -163,8 +171,8 @@
             }
         }
 
-        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
-
+        //EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
+        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.remove(entity.getId());//hose
         if (entitytrackerentry1 != null) {
             this.c.remove(entitytrackerentry1);
             entitytrackerentry1.a();
@@ -172,7 +180,23 @@
 
     }
 
-    public void updatePlayers() {
+    public void updatePlayers() {//hose
+        Queue arraylist = Queues.newConcurrentLinkedQueue();
+        this.c.parallelStream().forEach(entitytrackerentry -> {
+            entitytrackerentry.track(this.world.players);
+            if (entitytrackerentry.b) {
+                Entity entity = entitytrackerentry.b();
+ 
+                if (entity instanceof EntityPlayer) {
+                    arraylist.add((EntityPlayer) entity);
+                }
+            }
+        });
+        
+        arraylist.parallelStream().forEach(entityplayer -> {
+            this.c.parallelStream().filter(entitytrackerentry1 -> entitytrackerentry1.b() != entityplayer).forEach(entitytrackerentry1 -> entitytrackerentry1.updatePlayer((EntityPlayer) entityplayer));
+        });
+        /*
         ArrayList arraylist = Lists.newArrayList();
         Iterator iterator = this.c.iterator();
 
@@ -200,7 +224,7 @@
                     entitytrackerentry1.updatePlayer(entityplayer);
                 }
             }
-        }
+        }*/
 
     }
 
@@ -236,8 +260,9 @@
         }
 
     }
-
-    public void untrackPlayer(EntityPlayer entityplayer) {
+    
+    Set<EntityTrackerEntry> remove_untrack = Sets.newConcurrentHashSet();//hose
+    public void untrackPlayer(EntityPlayer entityplayer) {//hose
         Iterator iterator = this.c.iterator();
 
         while (iterator.hasNext()) {
@@ -245,7 +270,22 @@
 
             entitytrackerentry.clear(entityplayer);
         }
-
+        //remove all untrack here
+        
+        for (EntityTrackerEntry ete: this.c) {
+            int exist_count = 0;
+            for (Entity ent:this.world.entityList) {
+                if (ent.getId() == ete.hashCode()) {
+                    exist_count++;
+                }
+            }
+            if (exist_count == 0) {
+                remove_untrack.add(ete);
+            }
+        }
+        
+        this.c.removeAll(remove_untrack);
+        remove_untrack.clear();
     }
 
     public void a(EntityPlayer entityplayer, Chunk chunk) {
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2017-05-15 13:09:53.392961680 +0800
+++ src/main/java/net/minecraft/server/MinecraftServer.java	2017-05-15 13:10:03.124962590 +0800
@@ -1043,8 +1043,9 @@
 
     }
 
-    public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+    public String getServerModName() {//hose
+        //return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "Hose"; // Hose > Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1125,8 +1126,9 @@
         return true; // CraftBukkit
     }
 
-    public String getName() {
-        return "Server";
+    public String getName() {//hose
+        //return "Server";
+        return org.bukkit.ChatColor.GREEN + "Server";
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
diff -Naur src_origin/main/java/net/minecraft/server/NavigationAbstract.java src/main/java/net/minecraft/server/NavigationAbstract.java
--- src_origin/main/java/net/minecraft/server/NavigationAbstract.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/NavigationAbstract.java	2017-05-15 13:10:03.154962593 +0800
@@ -0,0 +1,289 @@
+package net.minecraft.server;
+
+import javax.annotation.Nullable;
+
+public abstract class NavigationAbstract {
+
+    protected EntityInsentient a;
+    protected World b;
+    @Nullable
+    protected PathEntity c;
+    protected double d;
+    private final AttributeInstance f;
+    private int g;
+    private int h;
+    private Vec3D i;
+    private Vec3D j;
+    private long k;
+    private long l;
+    private double m;
+    private float n;
+    private boolean o;
+    private long p;
+    protected PathfinderAbstract e;
+    private BlockPosition q;
+    private final Pathfinder r;
+
+    public NavigationAbstract(EntityInsentient entityinsentient, World world) {
+        this.i = Vec3D.a;
+        this.j = Vec3D.a;
+        this.n = 0.5F;
+        this.a = entityinsentient;
+        this.b = world;
+        this.f = entityinsentient.getAttributeInstance(GenericAttributes.FOLLOW_RANGE);
+        this.r = this.a();
+    }
+
+    protected abstract Pathfinder a();
+
+    public void a(double d0) {
+        this.d = d0;
+    }
+
+    public float h() {
+        return (float) this.f.getValue();
+    }
+
+    public boolean i() {
+        return this.o;
+    }
+
+    public void j() {
+        if (this.b.getTime() - this.p > 20L) {
+            if (this.q != null) {
+                this.c = null;
+                this.c = this.a(this.q);
+                this.p = this.b.getTime();
+                this.o = false;
+            }
+        } else {
+            this.o = true;
+        }
+
+    }
+
+    @Nullable
+    public final PathEntity a(double d0, double d1, double d2) {
+        return this.a(new BlockPosition(d0, d1, d2));
+    }
+
+    @Nullable
+    public PathEntity a(BlockPosition blockposition) {
+        if (!this.b()) {
+            return null;
+        } else if (this.c != null && !this.c.b() && blockposition.equals(this.q)) {
+            return this.c;
+        } else {
+            try {//hose
+                this.q = blockposition;
+                float f = this.h();
+
+                this.b.methodProfiler.a("pathfind");
+                BlockPosition blockposition1 = new BlockPosition(this.a);
+                int i = (int) (f + 8.0F);
+                ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+                PathEntity pathentity = this.r.a(chunkcache, this.a, this.q, f);
+
+                this.b.methodProfiler.b();
+                return pathentity;
+            } catch (Exception ex) {
+                this.b.getServer().getLogger().warning("Nav PathEntity a() exception:"+ex.getMessage());
+                return null;
+            }
+        }
+    }
+
+    @Nullable
+    public PathEntity a(Entity entity) {
+        if (!this.b()) {
+            return null;
+        } else {
+            BlockPosition blockposition = new BlockPosition(entity);
+
+            if (this.c != null && !this.c.b() && blockposition.equals(this.q)) {
+                return this.c;
+            } else {
+                this.q = blockposition;
+                float f = this.h();
+
+                this.b.methodProfiler.a("pathfind");
+                BlockPosition blockposition1 = (new BlockPosition(this.a)).up();
+                int i = (int) (f + 16.0F);
+                ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+                PathEntity pathentity = this.r.a(chunkcache, this.a, entity, f);
+
+                this.b.methodProfiler.b();
+                return pathentity;
+            }
+        }
+    }
+
+    public boolean a(double d0, double d1, double d2, double d3) {
+        return this.a(this.a(d0, d1, d2), d3);
+    }
+
+    public boolean a(Entity entity, double d0) {
+        PathEntity pathentity = this.a(entity);
+
+        return pathentity != null && this.a(pathentity, d0);
+    }
+
+    public boolean a(@Nullable PathEntity pathentity, double d0) {
+        if (pathentity == null) {
+            this.c = null;
+            return false;
+        } else {
+            if (!pathentity.a(this.c)) {
+                this.c = pathentity;
+            }
+
+            this.d();
+            if (this.c.d() == 0) {
+                return false;
+            } else {
+                this.d = d0;
+                Vec3D vec3d = this.c();
+
+                this.h = this.g;
+                this.i = vec3d;
+                return true;
+            }
+        }
+    }
+
+    @Nullable
+    public PathEntity k() {
+        return this.c;
+    }
+
+    public void l() {
+        ++this.g;
+        if (this.o) {
+            this.j();
+        }
+
+        if (!this.n()) {
+            Vec3D vec3d;
+
+            if (this.b()) {
+                this.m();
+            } else if (this.c != null && this.c.e() < this.c.d()) {
+                vec3d = this.c();
+                Vec3D vec3d1 = this.c.a(this.a, this.c.e());
+
+                if (vec3d.y > vec3d1.y && !this.a.onGround && MathHelper.floor(vec3d.x) == MathHelper.floor(vec3d1.x) && MathHelper.floor(vec3d.z) == MathHelper.floor(vec3d1.z)) {
+                    this.c.c(this.c.e() + 1);
+                }
+            }
+
+            if (!this.n()) {
+                vec3d = this.c.a((Entity) this.a);
+                if (vec3d != null) {
+                    BlockPosition blockposition = (new BlockPosition(vec3d)).down();
+                    AxisAlignedBB axisalignedbb = this.b.getType(blockposition).d(this.b, blockposition);
+
+                    vec3d = vec3d.a(0.0D, 1.0D - axisalignedbb.e, 0.0D);
+                    this.a.getControllerMove().a(vec3d.x, vec3d.y, vec3d.z, this.d);
+                }
+            }
+        }
+    }
+
+    protected void m() {
+        Vec3D vec3d = this.c();
+        int i = this.c.d();
+
+        for (int j = this.c.e(); j < this.c.d(); ++j) {
+            if ((double) this.c.a(j).b != Math.floor(vec3d.y)) {
+                i = j;
+                break;
+            }
+        }
+
+        this.n = this.a.width > 0.75F ? this.a.width / 2.0F : 0.75F - this.a.width / 2.0F;
+        Vec3D vec3d1 = this.c.f();
+
+        if (MathHelper.e((float) (this.a.locX - (vec3d1.x + 0.5D))) < this.n && MathHelper.e((float) (this.a.locZ - (vec3d1.z + 0.5D))) < this.n && Math.abs(this.a.locY - vec3d1.y) < 1.0D) {
+            this.c.c(this.c.e() + 1);
+        }
+
+        int k = MathHelper.f(this.a.width);
+        int l = MathHelper.f(this.a.length);
+        int i1 = k;
+        
+        try {//hose
+            for (int j1 = i - 1; j1 >= this.c.e(); --j1) {
+                if (this.a(vec3d, this.c.a(this.a, j1), k, l, i1)) {
+                    this.c.c(j1);
+                    break;
+                }
+            }
+        } catch (Exception ex) {
+            this.b.getServer().getLogger().warning("Nav m() exception:"+ex.getMessage());
+            return;
+        }
+        this.a(vec3d);
+    }
+
+    protected void a(Vec3D vec3d) {
+        if (this.g - this.h > 100) {
+            if (vec3d.distanceSquared(this.i) < 2.25D) {
+                this.o();
+            }
+
+            this.h = this.g;
+            this.i = vec3d;
+        }
+
+        if (this.c != null && !this.c.b()) {
+            Vec3D vec3d1 = this.c.f();
+
+            if (vec3d1.equals(this.j)) {
+                this.k += System.currentTimeMillis() - this.l;
+            } else {
+                this.j = vec3d1;
+                double d0 = vec3d.f(this.j);
+
+                this.m = this.a.cq() > 0.0F ? d0 / (double) this.a.cq() * 1000.0D : 0.0D;
+            }
+
+            if (this.m > 0.0D && (double) this.k > this.m * 3.0D) {
+                this.j = Vec3D.a;
+                this.k = 0L;
+                this.m = 0.0D;
+                this.o();
+            }
+
+            this.l = System.currentTimeMillis();
+        }
+
+    }
+
+    public boolean n() {
+        return this.c == null || this.c.b();
+    }
+
+    public void o() {
+        this.c = null;
+    }
+
+    protected abstract Vec3D c();
+
+    protected abstract boolean b();
+
+    protected boolean p() {
+        return this.a.isInWater() || this.a.ao();
+    }
+
+    protected void d() {}
+
+    protected abstract boolean a(Vec3D vec3d, Vec3D vec3d1, int i, int j, int k);
+
+    public boolean b(BlockPosition blockposition) {
+        return this.b.getType(blockposition.down()).b();
+    }
+
+    public PathfinderAbstract q() {
+        return this.e;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/PersistentVillage.java src/main/java/net/minecraft/server/PersistentVillage.java
--- src_origin/main/java/net/minecraft/server/PersistentVillage.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/PersistentVillage.java	2017-05-15 13:10:03.390962615 +0800
@@ -0,0 +1,273 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Queue;
+import javax.annotation.Nullable;
+
+public class PersistentVillage extends PersistentBase {
+
+    private World world;
+    //private final List<BlockPosition> c = Lists.newArrayList();
+    private final Queue<BlockPosition> c = Queues.newConcurrentLinkedQueue();//hose    
+    private final List<VillageDoor> d = Lists.newArrayList();
+    private final List<Village> villages = Lists.newArrayList();
+    private int time;
+
+    public PersistentVillage(String s) {
+        super(s);
+    }
+
+    public PersistentVillage(World world) {
+        super(a(world.worldProvider));
+        this.world = world;
+        this.c();
+    }
+
+    public void a(World world) {
+        this.world = world;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(world);
+        }
+
+    }
+
+    public void a(BlockPosition blockposition) {
+        if (this.c.size() <= 64) {
+            if (!this.e(blockposition)) {
+                this.c.add(blockposition);
+            }
+
+        }
+    }
+
+    public void tick() {
+        ++this.time;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(this.time);
+        }
+
+        this.e();
+        this.f();
+        this.g();
+        if (this.time % 400 == 0) {
+            this.c();
+        }
+
+    }
+
+    private void e() {
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            if (village.g()) {
+                iterator.remove();
+                this.c();
+            }
+        }
+
+    }
+
+    public List<Village> getVillages() {
+        return this.villages;
+    }
+
+    public Village getClosestVillage(BlockPosition blockposition, int i) {
+        Village village = null;
+        double d0 = 3.4028234663852886E38D;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village1 = (Village) iterator.next();
+            double d1 = village1.a().n(blockposition);
+
+            if (d1 < d0) {
+                float f = (float) (i + village1.b());
+
+                if (d1 <= (double) (f * f)) {
+                    village = village1;
+                    d0 = d1;
+                }
+            }
+        }
+
+        return village;
+    }
+
+    private void f() {
+        if (!this.c.isEmpty()) {
+            //this.b((BlockPosition) this.c.remove(0));
+            this.b((BlockPosition) this.c.poll());//hose
+        }
+    }
+
+    private void g() {
+        for (int i = 0; i < this.d.size(); ++i) {
+            VillageDoor villagedoor = (VillageDoor) this.d.get(i);
+            Village village = this.getClosestVillage(villagedoor.d(), 32);
+
+            if (village == null) {
+                village = new Village(this.world);
+                this.villages.add(village);
+                this.c();
+            }
+
+            village.a(villagedoor);
+        }
+
+        this.d.clear();
+    }
+
+    private void b(BlockPosition blockposition) {
+        boolean flag = true;
+        boolean flag1 = true;
+        boolean flag2 = true;
+
+        for (int i = -16; i < 16; ++i) {
+            for (int j = -4; j < 4; ++j) {
+                for (int k = -16; k < 16; ++k) {
+                    BlockPosition blockposition1 = blockposition.a(i, j, k);
+
+                    if (this.f(blockposition1)) {
+                        VillageDoor villagedoor = this.c(blockposition1);
+
+                        if (villagedoor == null) {
+                            this.d(blockposition1);
+                        } else {
+                            villagedoor.a(this.time);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    @Nullable
+    private VillageDoor c(BlockPosition blockposition) {
+        Iterator iterator = this.d.iterator();
+
+        VillageDoor villagedoor;
+
+        do {
+            if (!iterator.hasNext()) {
+                iterator = this.villages.iterator();
+
+                VillageDoor villagedoor1;
+
+                do {
+                    if (!iterator.hasNext()) {
+                        return null;
+                    }
+
+                    Village village = (Village) iterator.next();
+
+                    villagedoor1 = village.e(blockposition);
+                } while (villagedoor1 == null);
+
+                return villagedoor1;
+            }
+
+            villagedoor = (VillageDoor) iterator.next();
+        } while (villagedoor.d().getX() != blockposition.getX() || villagedoor.d().getZ() != blockposition.getZ() || Math.abs(villagedoor.d().getY() - blockposition.getY()) > 1);
+
+        return villagedoor;
+    }
+
+    private void d(BlockPosition blockposition) {
+        EnumDirection enumdirection = BlockDoor.f(this.world, blockposition);
+        EnumDirection enumdirection1 = enumdirection.opposite();
+        int i = this.a(blockposition, enumdirection, 5);
+        int j = this.a(blockposition, enumdirection1, i + 1);
+
+        if (i != j) {
+            this.d.add(new VillageDoor(blockposition, i < j ? enumdirection : enumdirection1, this.time));
+        }
+
+    }
+
+    private int a(BlockPosition blockposition, EnumDirection enumdirection, int i) {
+        int j = 0;
+
+        for (int k = 1; k <= 5; ++k) {
+            if (this.world.h(blockposition.shift(enumdirection, k))) {
+                ++j;
+                if (j >= i) {
+                    return j;
+                }
+            }
+        }
+
+        return j;
+    }
+
+    private boolean e(BlockPosition blockposition) {
+        Iterator iterator = this.c.iterator();
+
+        BlockPosition blockposition1;
+
+        do {
+            if (!iterator.hasNext()) {
+                return false;
+            }
+
+            blockposition1 = (BlockPosition) iterator.next();
+        } while (!blockposition1.equals(blockposition));
+
+        return true;
+    }
+
+    private boolean f(BlockPosition blockposition) {
+        IBlockData iblockdata = this.world.getType(blockposition);
+        Block block = iblockdata.getBlock();
+
+        return block instanceof BlockDoor ? iblockdata.getMaterial() == Material.WOOD : false;
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        this.time = nbttagcompound.getInt("Tick");
+        NBTTagList nbttaglist = nbttagcompound.getList("Villages", 10);
+
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound1 = nbttaglist.get(i);
+            Village village = new Village();
+
+            village.a(nbttagcompound1);
+            this.villages.add(village);
+        }
+
+    }
+
+    public NBTTagCompound b(NBTTagCompound nbttagcompound) {
+        nbttagcompound.setInt("Tick", this.time);
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+            village.b(nbttagcompound1);
+            nbttaglist.add(nbttagcompound1);
+        }
+
+        nbttagcompound.set("Villages", nbttaglist);
+        return nbttagcompound;
+    }
+
+    public static String a(WorldProvider worldprovider) {
+        return "villages" + worldprovider.getDimensionManager().c();
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/PlayerChunkMap.java src/main/java/net/minecraft/server/PlayerChunkMap.java
--- src_origin/main/java/net/minecraft/server/PlayerChunkMap.java	2017-05-15 13:09:53.595961699 +0800
+++ src/main/java/net/minecraft/server/PlayerChunkMap.java	2017-05-15 13:10:03.400962616 +0800
@@ -42,7 +42,8 @@
     private final WorldServer world;
     private final List<EntityPlayer> managedPlayers = Lists.newArrayList();
     private final Long2ObjectMap<PlayerChunk> e = new Long2ObjectOpenHashMap(4096);
-    private final Set<PlayerChunk> f = Sets.newHashSet();
+    //private final Set<PlayerChunk> f = Sets.newHashSet();
+    private final Set<PlayerChunk> f = Sets.newConcurrentHashSet();//hose
     private final List<PlayerChunk> g = Lists.newLinkedList();
     private final List<PlayerChunk> h = Lists.newLinkedList();
     private final List<PlayerChunk> i = Lists.newArrayList();
diff -Naur src_origin/main/java/net/minecraft/server/PlayerList.java src/main/java/net/minecraft/server/PlayerList.java
--- src_origin/main/java/net/minecraft/server/PlayerList.java	2017-05-15 13:09:53.649961704 +0800
+++ src/main/java/net/minecraft/server/PlayerList.java	2017-05-15 13:10:03.465962622 +0800
@@ -432,7 +432,8 @@
         // CraftBukkit end
 
         ChunkIOExecutor.adjustPoolSize(this.getPlayerCount()); // CraftBukkit
-
+        //untrack player
+        entityplayer.x().getTracker().untrackPlayer(entityplayer);
         return playerQuitEvent.getQuitMessage(); // CraftBukkit
     }
 
@@ -996,9 +997,11 @@
     }
 
     public void sendAll(Packet packet, World world) {
+        world.players.stream().forEach(pl -> ((EntityPlayer) pl).playerConnection.sendPacket(packet));
+        /*
         for (int i = 0; i < world.players.size(); ++i) {
             ((EntityPlayer) world.players.get(i)).playerConnection.sendPacket(packet);
-        }
+        }*/
 
     }
     // CraftBukkit end
diff -Naur src_origin/main/java/net/minecraft/server/VillageSiege.java src/main/java/net/minecraft/server/VillageSiege.java
--- src_origin/main/java/net/minecraft/server/VillageSiege.java	2017-05-15 13:09:53.865961724 +0800
+++ src/main/java/net/minecraft/server/VillageSiege.java	2017-05-15 13:10:03.758962650 +0800
@@ -64,6 +64,58 @@
     }
 
     private boolean b() {
+        for (EntityHuman entityhuman:this.a.players) {
+            if (!entityhuman.isSpectator()) {
+                this.f = this.a.ai().getClosestVillage(new BlockPosition(entityhuman), 1);
+                if (this.f != null && this.f.c() >= 10 && this.f.d() >= 20 && this.f.e() >= 20) {
+                    BlockPosition blockposition = this.f.a();
+                    float f = (float) this.f.b();
+                    boolean flag = false;
+                    int i = 0;
+
+                    while (true) {
+                        if (i < 10) {
+                            float f1 = this.a.random.nextFloat() * 6.2831855F;
+
+                            this.g = blockposition.getX() + (int) ((double) (MathHelper.cos(f1) * f) * 0.9D);
+                            this.h = blockposition.getY();
+                            this.i = blockposition.getZ() + (int) ((double) (MathHelper.sin(f1) * f) * 0.9D);
+                            flag = false;
+                            Iterator iterator1 = this.a.ai().getVillages().iterator();
+
+                            while (iterator1.hasNext()) {
+                                Village village = (Village) iterator1.next();
+
+                                if (village != this.f && village.a(new BlockPosition(this.g, this.h, this.i))) {
+                                    flag = true;
+                                    break;
+                                }
+                            }
+
+                            if (flag) {
+                                ++i;
+                                continue;
+                            }
+                        }
+
+                        if (flag) {
+                            return false;
+                        }
+
+                        Vec3D vec3d = this.a(new BlockPosition(this.g, this.h, this.i));
+
+                        if (vec3d != null) {
+                            this.e = 0;
+                            this.d = 20;
+                            return true;
+                        }
+                        break;
+                    }
+                }
+            }
+        }
+        
+        /*
         List list = this.a.players;
         Iterator iterator = list.iterator();
 
@@ -118,7 +170,7 @@
                     }
                 }
             }
-        }
+        }*/
 
         return false;
     }
diff -Naur src_origin/main/java/net/minecraft/server/WorldData.java src/main/java/net/minecraft/server/WorldData.java
--- src_origin/main/java/net/minecraft/server/WorldData.java	2017-05-15 13:09:53.902961727 +0800
+++ src/main/java/net/minecraft/server/WorldData.java	2017-05-15 13:10:03.800962654 +0800
@@ -630,7 +630,8 @@
         this.C = enumdifficulty;
         // CraftBukkit start
         PacketPlayOutServerDifficulty packet = new PacketPlayOutServerDifficulty(this.getDifficulty(), this.isDifficultyLocked());
-        for (EntityPlayer player : (java.util.List<EntityPlayer>) (java.util.List) world.players) {
+        //for (EntityPlayer player : (java.util.List<EntityPlayer>) (java.util.List) world.players) {
+        for (EntityPlayer player : (java.util.Queue<EntityPlayer>) (java.util.Queue) world.players) {
             player.playerConnection.sendPacket(packet);
         }
         // CraftBukkit end
diff -Naur src_origin/main/java/net/minecraft/server/World.java src/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2017-05-15 13:09:53.897961727 +0800
+++ src/main/java/net/minecraft/server/World.java	2017-05-15 13:10:03.794962653 +0800
@@ -15,7 +15,10 @@
 
 // CraftBukkit start
 import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
 import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.CopyOnWriteArrayList;
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
@@ -34,6 +37,8 @@
     private int a = 63;
     protected boolean d;
     // Spigot start - guard entity list from removals
+    public final List<Entity> entityList = new CopyOnWriteArrayList();//hose
+    /*
     public final List<Entity> entityList = new java.util.ArrayList<Entity>()
     {
         @Override
@@ -57,14 +62,15 @@
                 throw new java.util.ConcurrentModificationException();
             }
         }
-    };
+    };*/
     // Spigot end
     protected final List<Entity> f = Lists.newArrayList();
     public final List<TileEntity> tileEntityList = Lists.newArrayList();
     public final List<TileEntity> tileEntityListTick = Lists.newArrayList();
     private final List<TileEntity> b = Lists.newArrayList();
     private final List<TileEntity> tileEntityListUnload = Lists.newArrayList();
-    public final List<EntityHuman> players = Lists.newArrayList();
+    //public final List<EntityHuman> players = Lists.newArrayList();
+    public final Queue<EntityHuman> players = Queues.newConcurrentLinkedQueue();//hose
     public final List<Entity> j = Lists.newArrayList();
     protected final IntHashMap<Entity> entitiesById = new IntHashMap();
     private final long I = 16777215L;
@@ -1341,6 +1347,9 @@
 
     public void b(BlockPosition blockposition, Block block, int i, int j) {}
 
+    CrashReportSystemDetails crashreportsystemdetails1;//hose
+    CrashReport crashreport1;
+    public final Queue<Entity> entityList_remove = Queues.newConcurrentLinkedQueue();
     public void tickEntities() {
         this.methodProfiler.a("entities");
         this.methodProfiler.a("global");
@@ -1400,8 +1409,8 @@
         this.l();
         this.methodProfiler.c("regular");
 
-        CrashReportSystemDetails crashreportsystemdetails1;
-        CrashReport crashreport1;
+        //CrashReportSystemDetails crashreportsystemdetails1;
+        //CrashReport crashreport1;
 
         org.spigotmc.ActivationRange.activateEntities(this); // Spigot
         timings.entityTick.startTiming(); // Spigot
@@ -1409,6 +1418,59 @@
         // CraftBukkit start - Use field for loop variable
         int entitiesThisCycle = 0;
         if (tickPosition < 0) tickPosition = 0;
+        entityLimiter.initTick();//hose
+        entityList.parallelStream().forEach(ent -> {//hose
+            if (!entityLimiter.shouldContinue()) {
+                return;
+            }
+            
+            Entity entity1 = ent.bB();
+
+            if (entity1 != null) {
+                if (!entity1.dead && entity1.w(ent)) {
+                    return;
+                }
+
+                ent.stopRiding();
+            }
+
+            this.methodProfiler.a("tick");
+            if (!ent.dead && !(ent instanceof EntityPlayer)) {
+                try {
+                    SpigotTimings.tickEntityTimer.startTiming(); // Spigot
+                    this.h(ent);
+                    SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
+                } catch (Throwable throwable1) {
+                    crashreport1 = CrashReport.a(throwable1, "Ticking entity");
+                    crashreportsystemdetails1 = crashreport1.a("Entity being ticked");
+                    ent.appendEntityCrashDetails(crashreportsystemdetails1);
+                    throw new ReportedException(crashreport1);
+                }
+            }
+
+            this.methodProfiler.b();
+            this.methodProfiler.a("remove");
+            if (ent.dead) {
+                int jj = ent.ab;
+                int l = ent.ad;
+
+                if (ent.aa && this.isChunkLoaded(jj, l, true)) {
+                    this.getChunkAt(jj, l).b(ent);
+                }
+
+                //guardEntityList = false; // Spigot
+                //this.entityList.remove(this.tickPosition--); // CraftBukkit - Use field for loop variable
+                //this.entityList.remove(ent);
+                entityList_remove.add(ent);
+                //guardEntityList = true; // Spigot
+                this.c(ent);
+            }
+
+            this.methodProfiler.b();
+        });
+        this.entityList.removeAll(entityList_remove);
+        entityList_remove.clear();
+        /*
         for (entityLimiter.initTick();
                 entitiesThisCycle < entityList.size() && (entitiesThisCycle % 10 != 0 || entityLimiter.shouldContinue());
                 tickPosition++, entitiesThisCycle++) {
@@ -1456,7 +1518,7 @@
             }
 
             this.methodProfiler.b();
-        }
+        }*/
         guardEntityList = false; // Spigot
 
         timings.entityTick.stopTiming(); // Spigot
@@ -2139,11 +2201,13 @@
                 this.o = MathHelper.a(this.o, 0.0F, 1.0F);
 
                 // CraftBukkit start
+                this.players.stream().filter(pl -> ((EntityPlayer) pl).world == this).forEach(pltw -> ((EntityPlayer) pltw).tickWeather());//hose
+                /*
                 for (int idx = 0; idx < this.players.size(); ++idx) {
                     if (((EntityPlayer) this.players.get(idx)).world == this) {
                         ((EntityPlayer) this.players.get(idx)).tickWeather();
                     }
-                }
+                }*/
                 // CraftBukkit end
             }
         }
@@ -2689,7 +2753,23 @@
     public EntityHuman a(double d0, double d1, double d2, double d3, Predicate<Entity> predicate) {
         double d4 = -1.0D;
         EntityHuman entityhuman = null;
+        
+        for (EntityHuman entityhuman1: this.players) {//hose
+            if (entityhuman1 == null || entityhuman1.dead) {
+                continue;
+            }
+            // CraftBukkit end
 
+            if (predicate.apply(entityhuman1)) {
+                double d5 = entityhuman1.d(d0, d1, d2);
+ 
+                if ((d3 < 0.0D || d5 < d3 * d3) && (d4 == -1.0D || d5 < d4)) {
+                    d4 = d5;
+                    entityhuman = entityhuman1;
+                }
+            }
+        }
+        /*
         for (int i = 0; i < this.players.size(); ++i) {
             EntityHuman entityhuman1 = (EntityHuman) this.players.get(i);
             // CraftBukkit start - Fixed an NPE
@@ -2706,12 +2786,14 @@
                     entityhuman = entityhuman1;
                 }
             }
-        }
+        }*/
 
         return entityhuman;
     }
 
     public boolean isPlayerNearby(double d0, double d1, double d2, double d3) {
+        return this.players.stream().filter((entityhuman) -> (IEntitySelector.e.apply(entityhuman))).map((entityhuman) -> entityhuman.d(d0, d1, d2)).anyMatch((d4) -> (d3 < 0.0D || d4 < d3 * d3));//hose
+        /*
         for (int i = 0; i < this.players.size(); ++i) {
             EntityHuman entityhuman = (EntityHuman) this.players.get(i);
 
@@ -2724,7 +2806,7 @@
             }
         }
 
-        return false;
+        return false;*/
     }
 
     @Nullable
@@ -2741,7 +2823,37 @@
     public EntityHuman a(double d0, double d1, double d2, double d3, double d4, @Nullable Function<EntityHuman, Double> function, @Nullable Predicate<EntityHuman> predicate) {
         double d5 = -1.0D;
         EntityHuman entityhuman = null;
+        
+       for (EntityHuman entityhuman1: this.players) {//hose
+            if (!entityhuman1.abilities.isInvulnerable && entityhuman1.isAlive() && !entityhuman1.isSpectator() && (predicate == null || predicate.apply(entityhuman1))) {
+                double d6 = entityhuman1.d(d0, entityhuman1.locY, d2);
+                double d7 = d3;
+
+                if (entityhuman1.isSneaking()) {
+                    d7 = d3 * 0.800000011920929D;
+                }
+
+                if (entityhuman1.isInvisible()) {
+                    float f = entityhuman1.cO();
+
+                    if (f < 0.1F) {
+                        f = 0.1F;
+                    }
+
+                    d7 *= (double) (0.7F * f);
+                }
 
+                if (function != null) {
+                    d7 *= ((Double) Objects.firstNonNull(function.apply(entityhuman1), Double.valueOf(1.0D))).doubleValue();
+                }
+
+                if ((d4 < 0.0D || Math.abs(entityhuman1.locY - d1) < d4 * d4) && (d3 < 0.0D || d6 < d7 * d7) && (d5 == -1.0D || d6 < d5)) {
+                    d5 = d6;
+                    entityhuman = entityhuman1;
+                }
+            }
+        }
+        /*
         for (int i = 0; i < this.players.size(); ++i) {
             EntityHuman entityhuman1 = (EntityHuman) this.players.get(i);
 
@@ -2772,33 +2884,45 @@
                     entityhuman = entityhuman1;
                 }
             }
-        }
+        }*/
 
         return entityhuman;
     }
 
     @Nullable
     public EntityHuman a(String s) {
+        for (EntityHuman entityhuman: this.players) {//hose
+            if (s.equals(entityhuman.getName())) {
+                return entityhuman;
+            }
+        }
+        /*
         for (int i = 0; i < this.players.size(); ++i) {
             EntityHuman entityhuman = (EntityHuman) this.players.get(i);
 
             if (s.equals(entityhuman.getName())) {
                 return entityhuman;
             }
-        }
+        }*/
 
         return null;
     }
 
     @Nullable
     public EntityHuman b(UUID uuid) {
+        for (EntityHuman entityhuman: this.players) {//hose
+            if (uuid.equals(entityhuman.getUniqueID())) {
+                return entityhuman;
+            }
+        }
+        /*
         for (int i = 0; i < this.players.size(); ++i) {
             EntityHuman entityhuman = (EntityHuman) this.players.get(i);
 
             if (uuid.equals(entityhuman.getUniqueID())) {
                 return entityhuman;
             }
-        }
+        }*/
 
         return null;
     }
diff -Naur src_origin/main/java/net/minecraft/server/WorldServer.java src/main/java/net/minecraft/server/WorldServer.java
--- src_origin/main/java/net/minecraft/server/WorldServer.java	2017-05-15 13:09:53.994961736 +0800
+++ src/main/java/net/minecraft/server/WorldServer.java	2017-05-15 13:10:03.903962663 +0800
@@ -15,6 +15,7 @@
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.UUID;
+import java.util.concurrent.RecursiveAction;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -226,7 +227,12 @@
         long time = this.worldData.getTime();
         if (this.getGameRules().getBoolean("doMobSpawning") && this.worldData.getType() != WorldType.DEBUG_ALL_BLOCK_STATES && (this.allowMonsters || this.allowAnimals) && (this instanceof WorldServer && this.players.size() > 0)) {
             timings.mobSpawn.startTiming(); // Spigot
-            this.spawnerCreature.a(this, this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldData.getTime() % 400L == 0L);
+            //this.spawnerCreature.a(this, this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldData.getTime() % 400L == 0L);
+            boolean flag = this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L);//hose
+            boolean flag1 = this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L);//hose
+            boolean flag2 = this.worldData.getTime() % 400L == 0L;//hose
+            spawnerCreature sc = new spawnerCreature(this, flag, flag1, flag2);//hose
+            sc.fork();//hose
             timings.mobSpawn.stopTiming(); // Spigot
             // CraftBukkit end
         }
@@ -386,7 +392,9 @@
         this.methodProfiler.a("playerCheckLight");
         if (spigotConfig.randomLightUpdates && !this.players.isEmpty()) { // Spigot
             int i = this.random.nextInt(this.players.size());
-            EntityHuman entityhuman = (EntityHuman) this.players.get(i);
+            //EntityHuman entityhuman = (EntityHuman) this.players.get(i);
+            ArrayList rndarr = new ArrayList(this.players);
+            EntityHuman entityhuman = (EntityHuman) rndarr.get(i);
             int j = MathHelper.floor(entityhuman.locX) + this.random.nextInt(11) - 5;
             int k = MathHelper.floor(entityhuman.locY) + this.random.nextInt(11) - 5;
             int l = MathHelper.floor(entityhuman.locZ) + this.random.nextInt(11) - 5;
@@ -623,8 +631,9 @@
         super.l();
         this.methodProfiler.c("players");
 
-        for (int i = 0; i < this.players.size(); ++i) {
-            Entity entity = (Entity) this.players.get(i);
+        //for (int i = 0; i < this.players.size(); ++i) {
+        for (Entity entity: this.players) {//hose
+            //Entity entity = (Entity) this.players.get(i);
             Entity entity1 = entity.bB();
 
             if (entity1 != null) {
@@ -696,6 +705,9 @@
 
                 for (int j = 0; j < i; ++j) {
                     nextticklistentry = (NextTickListEntry) this.nextTickList.first();
+                    if (nextticklistentry == null) {
+                        break;
+                    }
                     if (!flag && nextticklistentry.b > this.worldData.getTime()) {
                         break;
                     }
@@ -1278,17 +1290,20 @@
         // */
         if (flag != this.W()) {
             // Only send weather packets to those affected
-            for (int i = 0; i < this.players.size(); ++i) {
+            this.players.stream().filter(pl -> ((EntityPlayer) pl).world == this).forEach(pl -> ((EntityPlayer) pl).setPlayerWeather((!flag ? WeatherType.DOWNFALL : WeatherType.CLEAR), false));//hose
+            /*for (int i = 0; i < this.players.size(); ++i) {
                 if (((EntityPlayer) this.players.get(i)).world == this) {
                     ((EntityPlayer) this.players.get(i)).setPlayerWeather((!flag ? WeatherType.DOWNFALL : WeatherType.CLEAR), false);
                 }
-            }
+            }*/
         }
+        this.players.stream().filter(pl -> ((EntityPlayer) pl).world == this).forEach(pl -> ((EntityPlayer) pl).updateWeather(this.n, this.o, this.p, this.q));//hose
+        /*
         for (int i = 0; i < this.players.size(); ++i) {
             if (((EntityPlayer) this.players.get(i)).world == this) {
                 ((EntityPlayer) this.players.get(i)).updateWeather(this.n, this.o, this.p, this.q);
             }
-        }
+        }*/
         // CraftBukkit end
 
     }
@@ -1326,7 +1341,16 @@
     public void sendParticles(EntityPlayer sender, EnumParticle enumparticle, boolean flag, double d0, double d1, double d2, int i, double d3, double d4, double d5, double d6, int... aint) {
         // CraftBukkit end
         PacketPlayOutWorldParticles packetplayoutworldparticles = new PacketPlayOutWorldParticles(enumparticle, flag, (float) d0, (float) d1, (float) d2, (float) d3, (float) d4, (float) d5, (float) d6, i, aint);
+        
+        for (EntityHuman entityplayer: this.players){//hose
+            if (sender != null && !((EntityPlayer)entityplayer).getBukkitEntity().canSee(sender.getBukkitEntity())) continue; // CraftBukkit
+            BlockPosition blockposition = ((EntityPlayer)entityplayer).getChunkCoordinates();
+            double d7 = blockposition.distanceSquared(d0, d1, d2);
 
+
+            this.a((EntityPlayer)entityplayer, flag, d0, d1, d2, packetplayoutworldparticles);
+        }
+        /*
         for (int j = 0; j < this.players.size(); ++j) {
             EntityPlayer entityplayer = (EntityPlayer) this.players.get(j);
             if (sender != null && !entityplayer.getBukkitEntity().canSee(sender.getBukkitEntity())) continue; // CraftBukkit
@@ -1335,7 +1359,7 @@
 
 
             this.a(entityplayer, flag, d0, d1, d2, packetplayoutworldparticles);
-        }
+        }*/
 
     }
 
@@ -1385,4 +1409,22 @@
             this();
         }
     }
+    
+    public class spawnerCreature extends RecursiveAction {
+        WorldServer worldserver;
+        boolean flag, flag1, flag2;
+        
+        public spawnerCreature(WorldServer worldserver, boolean flag, boolean flag1, boolean flag2) {
+            this.worldserver = worldserver;
+            this.flag = flag;
+            this.flag1 = flag1;
+            this.flag2 = flag2;
+        }
+        
+        @Override
+        protected void compute() {
+            spawnerCreature.a(worldserver, flag, flag1, flag2);
+        }
+        
+    }
 }
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
--- src_origin/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java	2017-05-15 13:09:55.835961908 +0800
+++ src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java	2017-05-15 13:10:06.139962872 +0800
@@ -500,7 +500,9 @@
                 cause = DamageCause.CONTACT;
             } else if (source == DamageSource.HOT_FLOOR) {
                 cause = DamageCause.HOT_FLOOR;
-            } else {
+            } else if (source == DamageSource.CRAMMING) {//hose
+                cause = DamageCause.CRAMMING;
+             } else {
                 throw new IllegalStateException(String.format("Unhandled damage of %s by %s from %s", entity, damager, source.translationIndex));
             }
             EntityDamageEvent event = callEvent(new EntityDamageByBlockEvent(damager, entity.getBukkitEntity(), cause, modifiers, modifierFunctions));
@@ -557,8 +559,10 @@
             cause = DamageCause.CRAMMING;
         } else if (source == DamageSource.GENERIC) {
             cause = DamageCause.CUSTOM;
+        } else if (source == DamageSource.CACTUS) {//hose
+            cause = DamageCause.CONTACT;
         }
-
+        
         if (cause != null) {
             return callEntityDamageEvent(null, entity, cause, modifiers, modifierFunctions);
         }
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2017-05-15 13:09:56.791961998 +0800
+++ src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2017-05-15 13:10:07.525963002 +0800
@@ -1,15 +1,17 @@
 package org.bukkit.craftbukkit.util;
 
+import com.google.common.collect.Sets;
 import java.util.Collection;
-import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
-import java.util.TreeSet;
+import java.util.concurrent.ConcurrentSkipListSet;
 
 public class HashTreeSet<V> implements Set<V> {
 
-    private HashSet<V> hash = new HashSet<V>();
-    private TreeSet<V> tree = new TreeSet<V>();
+    //private HashSet<V> hash = new HashSet<V>();
+    //private TreeSet<V> tree = new TreeSet<V>();
+    private Set<V> hash = Sets.newConcurrentHashSet();//hose
+    private ConcurrentSkipListSet<V> tree = new ConcurrentSkipListSet();//hose
 
     public HashTreeSet() {
 
@@ -110,8 +112,11 @@
         tree.clear();
     }
 
-    public V first() {
-        return tree.first();
+    public V first() {//hose
+        if (tree.size() > 0) {
+            return tree.first();
+        }
+        return null;
     }
 
 }
diff -Naur src_origin/main/java/org/spigotmc/ActivationRange.java src/main/java/org/spigotmc/ActivationRange.java
--- src_origin/main/java/org/spigotmc/ActivationRange.java	2017-05-15 13:09:51.314961485 +0800
+++ src/main/java/org/spigotmc/ActivationRange.java	2017-05-15 13:10:00.671962361 +0800
@@ -1,6 +1,7 @@
 package org.spigotmc;
 
 import java.util.List;
+import java.util.Queue;
 import java.util.Set;
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.Chunk;
@@ -141,7 +142,8 @@
      */
     private static void activateChunkEntities(Chunk chunk)
     {
-        for ( List<Entity> slice : chunk.entitySlices )
+        //for ( List<Entity> slice : chunk.entitySlices )
+        for ( Queue<Entity> slice : chunk.entitySlices )//hose
         {
             for ( Entity entity : slice )
             {
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2017-05-15 13:09:51.314961485 +0800
+++ src/main/java/org/spigotmc/AsyncCatcher.java	2017-05-15 13:10:00.665962360 +0800
@@ -11,7 +11,7 @@
     {
         if ( enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread )
         {
-            throw new IllegalStateException( "Asynchronous " + reason + "!" );
+            //throw new IllegalStateException( "Asynchronous " + reason + "!" );
         }
     }
 }
