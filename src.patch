diff -Naur src_origin/main/java/net/minecraft/server/Chunk.java src_new/main/java/net/minecraft/server/Chunk.java
--- src_origin/main/java/net/minecraft/server/Chunk.java	2016-02-26 15:27:08.084203343 +0800
+++ src_new/main/java/net/minecraft/server/Chunk.java	2016-02-26 15:27:47.240207007 +0800
@@ -15,6 +15,7 @@
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists; // CraftBukkit
+import java.util.concurrent.CopyOnWriteArrayList;
 import org.bukkit.Bukkit; // CraftBukkit
 
 public class Chunk {
@@ -80,14 +81,16 @@
         this.tileEntities = Maps.newHashMap();
         this.v = 4096;
         this.w = Queues.newConcurrentLinkedQueue();
-        this.entitySlices = (List[]) (new List[16]); // Spigot
+        //this.entitySlices = (List[]) (new List[16]); // Spigot
+        this.entitySlices = (List[]) (new CopyOnWriteArrayList[16]); // Spigot
         this.world = world;
         this.locX = i;
         this.locZ = j;
         this.heightMap = new int[256];
 
         for (int k = 0; k < this.entitySlices.length; ++k) {
-            this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            //this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[k] = new CopyOnWriteArrayList(); // Spigot
         }
 
         Arrays.fill(this.f, -999);
diff -Naur src_origin/main/java/net/minecraft/server/EntityItem.java src_new/main/java/net/minecraft/server/EntityItem.java
--- src_origin/main/java/net/minecraft/server/EntityItem.java	2016-02-26 15:27:09.641203489 +0800
+++ src_new/main/java/net/minecraft/server/EntityItem.java	2016-02-26 15:27:49.151207186 +0800
@@ -82,7 +82,7 @@
                     this.makeSound("random.fizz", 0.4F, 2.0F + this.random.nextFloat() * 0.4F);
                 }
 
-                if (!this.world.isClientSide) {
+                if (!this.world.isClientSide && this.portalCooldown > 0) {
                     this.w();
                 }
             }
@@ -143,6 +143,7 @@
     }
     // Spigot end
 
+    //merge will cause dup through portal
     private void w() {
         // Spigot start
         double radius = world.spigotConfig.itemMerge;
diff -Naur src_origin/main/java/net/minecraft/server/Entity.java src_new/main/java/net/minecraft/server/Entity.java
--- src_origin/main/java/net/minecraft/server/Entity.java	2016-02-26 15:27:08.930203422 +0800
+++ src_new/main/java/net/minecraft/server/Entity.java	2016-02-26 15:27:48.511207126 +0800
@@ -291,9 +291,14 @@
                     this.al = 0;
                 }
             }
-
+            /*
             if (this.portalCooldown > 0) {
                 --this.portalCooldown;
+            }*/
+            if (this.portalCooldown > 0) {
+                this.portalCooldown--;
+            } else {
+                teleport_count = 0;
             }
 
             this.world.methodProfiler.b();
@@ -1640,7 +1645,7 @@
     }
 
     public int aq() {
-        return 300;
+        return 300;//300
     }
 
     public ItemStack[] getEquipment() {
@@ -1924,8 +1929,11 @@
         }
     }
 
+    int teleport_count = 0;
     public void teleportTo(Location exit, boolean portal) {
-        if (true) {
+        //if (true) {
+        if (true && teleport_count == 0) {
+            teleport_count = 1;
             WorldServer worldserver = ((CraftWorld) getBukkitEntity().getLocation().getWorld()).getHandle();
             WorldServer worldserver1 = ((CraftWorld) exit.getWorld()).getHandle();
             int i = worldserver1.dimension;
diff -Naur src_origin/main/java/net/minecraft/server/EntityPlayer.java src_new/main/java/net/minecraft/server/EntityPlayer.java
--- src_origin/main/java/net/minecraft/server/EntityPlayer.java	2016-02-26 15:27:09.996203522 +0800
+++ src_new/main/java/net/minecraft/server/EntityPlayer.java	2016-02-26 15:27:49.513207220 +0800
@@ -9,7 +9,9 @@
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.LinkedList;
 import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -894,11 +896,16 @@
     }
 
     public void copyTo(EntityHuman entityhuman, boolean flag) {
-        super.copyTo(entityhuman, flag);
-        this.lastSentExp = -1;
-        this.bM = -1.0F;
-        this.bN = -1;
-        this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
+        try {
+            super.copyTo(entityhuman, flag);
+            this.lastSentExp = -1;
+            this.bM = -1.0F;
+            this.bN = -1;
+            this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
+        } catch (Exception ex){
+            
+        }
+        
     }
 
     protected void a(MobEffect mobeffect) {
diff -Naur src_origin/main/java/net/minecraft/server/EntityTracker.java src_new/main/java/net/minecraft/server/EntityTracker.java
--- src_origin/main/java/net/minecraft/server/EntityTracker.java	2016-02-26 15:27:10.352203555 +0800
+++ src_new/main/java/net/minecraft/server/EntityTracker.java	2016-02-26 15:27:49.889207255 +0800
@@ -1,11 +1,12 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.Set;
-import java.util.concurrent.Callable;
+import java.util.concurrent.BlockingDeque;
+import java.util.concurrent.CopyOnWriteArraySet;
+import java.util.concurrent.LinkedBlockingDeque;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -13,7 +14,8 @@
 
     private static final Logger a = LogManager.getLogger();
     private final WorldServer world;
-    private Set<EntityTrackerEntry> c = Sets.newHashSet();
+    //private Set<EntityTrackerEntry> c = Sets.newHashSet();
+    private Set<EntityTrackerEntry> c = new CopyOnWriteArraySet<EntityTrackerEntry>();
     public IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
     private int e;
 
@@ -101,16 +103,30 @@
         }
 
         try {
+            //just track once
             if (this.trackedEntities.b(entity.getId())) {
-                throw new IllegalStateException("Entity is already tracked!");
+                //throw new IllegalStateException("Entity is already tracked!");
+                throw new Exception();
+            } else {
+                EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, j, flag);
+
+                this.c.add(entitytrackerentry);
+                //key point causing error
+                this.trackedEntities.a(entity.getId(), entitytrackerentry);
+                entitytrackerentry.scanPlayers(this.world.players);
             }
-
+            
+            /*
             EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, j, flag);
 
             this.c.add(entitytrackerentry);
+            //key point causing error
             this.trackedEntities.a(entity.getId(), entitytrackerentry);
-            entitytrackerentry.scanPlayers(this.world.players);
-        } catch (Throwable throwable) {
+            entitytrackerentry.scanPlayers(this.world.players);*/
+        } catch (Exception ex) {
+            System.out.println(ex+" sop");
+        }
+        /*} catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
             CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity To Track");
 
@@ -141,7 +157,7 @@
             } catch (ReportedException reportedexception) {
                 EntityTracker.a.error("\"Silently\" catching entity tracking error.", reportedexception);
             }
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/IntHashMap.java src_new/main/java/net/minecraft/server/IntHashMap.java
--- src_origin/main/java/net/minecraft/server/IntHashMap.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/net/minecraft/server/IntHashMap.java	2016-02-26 15:27:50.272207291 +0800
@@ -0,0 +1,211 @@
+package net.minecraft.server;
+
+public class IntHashMap<V> {
+
+    private transient IntHashMap.IntHashMapEntry<V>[] a = new IntHashMap.IntHashMapEntry[16];
+    //private IntHashMap.IntHashMapEntry<V>[] a = new IntHashMap.IntHashMapEntry[16];
+    private transient int b;
+    //private int b;
+    private int c = 12;
+    private final float d = 0.75F;
+
+    public IntHashMap() {}
+
+    private static int g(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
+
+    private static int a(int i, int j) {
+        return i & j - 1;
+    }
+
+    public V get(int i) {
+        int j = g(i);
+
+        for (IntHashMap.IntHashMapEntry inthashmap_inthashmapentry = this.a[a(j, this.a.length)]; inthashmap_inthashmapentry != null; inthashmap_inthashmapentry = inthashmap_inthashmapentry.c) {
+            if (inthashmap_inthashmapentry.a == i) {
+                return (V) inthashmap_inthashmapentry.b;
+            }
+        }
+
+        return null;
+    }
+
+    public boolean b(int i) {
+        return this.c(i) != null;
+    }
+
+    final IntHashMap.IntHashMapEntry<V> c(int i) {
+        synchronized (this){
+            int j = g(i);
+
+            for (IntHashMap.IntHashMapEntry inthashmap_inthashmapentry = this.a[a(j, this.a.length)]; inthashmap_inthashmapentry != null; inthashmap_inthashmapentry = inthashmap_inthashmapentry.c) {
+                if (inthashmap_inthashmapentry.a == i) {
+                    return inthashmap_inthashmapentry;
+                }
+            }
+
+            return null;
+        }
+    }
+
+    public void a(int i, V v0) {
+        int j = g(i);
+        int k = a(j, this.a.length);
+
+        for (IntHashMap.IntHashMapEntry inthashmap_inthashmapentry = this.a[k]; inthashmap_inthashmapentry != null; inthashmap_inthashmapentry = inthashmap_inthashmapentry.c) {
+            if (inthashmap_inthashmapentry.a == i) {
+                inthashmap_inthashmapentry.b = v0;
+                return;
+            }
+        }
+
+        this.a(j, i, v0, k);
+    }
+
+    private void h(int i) {
+        IntHashMap.IntHashMapEntry[] ainthashmap_inthashmapentry = this.a;
+        int j = ainthashmap_inthashmapentry.length;
+
+        if (j == 1073741824) {
+            this.c = Integer.MAX_VALUE;
+        } else {
+            IntHashMap.IntHashMapEntry[] ainthashmap_inthashmapentry1 = new IntHashMap.IntHashMapEntry[i];
+
+            this.a(ainthashmap_inthashmapentry1);
+            this.a = ainthashmap_inthashmapentry1;
+            this.c = (int) ((float) i * this.d);
+        }
+    }
+
+    private void a(IntHashMap.IntHashMapEntry<V>[] ainthashmap_inthashmapentry) {
+        IntHashMap.IntHashMapEntry[] ainthashmap_inthashmapentry1 = this.a;
+        int i = ainthashmap_inthashmapentry.length;
+
+        for (int j = 0; j < ainthashmap_inthashmapentry1.length; ++j) {
+            IntHashMap.IntHashMapEntry inthashmap_inthashmapentry = ainthashmap_inthashmapentry1[j];
+
+            if (inthashmap_inthashmapentry != null) {
+                ainthashmap_inthashmapentry1[j] = null;
+
+                IntHashMap.IntHashMapEntry inthashmap_inthashmapentry1;
+
+                do {
+                    inthashmap_inthashmapentry1 = inthashmap_inthashmapentry.c;
+                    int k = a(inthashmap_inthashmapentry.d, i);
+
+                    inthashmap_inthashmapentry.c = ainthashmap_inthashmapentry[k];
+                    ainthashmap_inthashmapentry[k] = inthashmap_inthashmapentry;
+                    inthashmap_inthashmapentry = inthashmap_inthashmapentry1;
+                } while (inthashmap_inthashmapentry1 != null);
+            }
+        }
+
+    }
+
+    public V d(int i) {
+        IntHashMap.IntHashMapEntry inthashmap_inthashmapentry = this.e(i);
+
+        return (V) (inthashmap_inthashmapentry == null ? null : inthashmap_inthashmapentry.b);
+    }
+
+    final IntHashMap.IntHashMapEntry<V> e(int i) {
+        int j = g(i);
+        int k = a(j, this.a.length);
+        IntHashMap.IntHashMapEntry inthashmap_inthashmapentry = this.a[k];
+
+        IntHashMap.IntHashMapEntry inthashmap_inthashmapentry1;
+        IntHashMap.IntHashMapEntry inthashmap_inthashmapentry2;
+
+        for (inthashmap_inthashmapentry1 = inthashmap_inthashmapentry; inthashmap_inthashmapentry1 != null; inthashmap_inthashmapentry1 = inthashmap_inthashmapentry2) {
+            inthashmap_inthashmapentry2 = inthashmap_inthashmapentry1.c;
+            if (inthashmap_inthashmapentry1.a == i) {
+                --this.b;
+                if (inthashmap_inthashmapentry == inthashmap_inthashmapentry1) {
+                    this.a[k] = inthashmap_inthashmapentry2;
+                } else {
+                    inthashmap_inthashmapentry.c = inthashmap_inthashmapentry2;
+                }
+
+                return inthashmap_inthashmapentry1;
+            }
+
+            inthashmap_inthashmapentry = inthashmap_inthashmapentry1;
+        }
+
+        return inthashmap_inthashmapentry1;
+    }
+
+    public void c() {
+        IntHashMap.IntHashMapEntry[] ainthashmap_inthashmapentry = this.a;
+
+        for (int i = 0; i < ainthashmap_inthashmapentry.length; ++i) {
+            ainthashmap_inthashmapentry[i] = null;
+        }
+
+        this.b = 0;
+    }
+
+    private void a(int i, int j, V v0, int k) {
+        IntHashMap.IntHashMapEntry inthashmap_inthashmapentry = this.a[k];
+
+        this.a[k] = new IntHashMap.IntHashMapEntry(i, j, v0, inthashmap_inthashmapentry);
+        if (this.b++ >= this.c) {
+            this.h(2 * this.a.length);
+        }
+
+    }
+
+    static class IntHashMapEntry<V> {
+
+        final int a;
+        V b;
+        IntHashMap.IntHashMapEntry<V> c;
+        final int d;
+
+        IntHashMapEntry(int i, int j, V v0, IntHashMap.IntHashMapEntry<V> inthashmap_inthashmapentry) {
+            this.b = v0;
+            this.c = inthashmap_inthashmapentry;
+            this.a = j;
+            this.d = i;
+        }
+
+        public final int a() {
+            return this.a;
+        }
+
+        public final V b() {
+            return this.b;
+        }
+
+        public final boolean equals(Object object) {
+            if (!(object instanceof IntHashMap.IntHashMapEntry)) {
+                return false;
+            } else {
+                IntHashMap.IntHashMapEntry inthashmap_inthashmapentry = (IntHashMap.IntHashMapEntry) object;
+                Integer integer = Integer.valueOf(this.a());
+                Integer integer1 = Integer.valueOf(inthashmap_inthashmapentry.a());
+
+                if (integer == integer1 || integer != null && integer.equals(integer1)) {
+                    Object object1 = this.b();
+                    Object object2 = inthashmap_inthashmapentry.b();
+
+                    if (object1 == object2 || object1 != null && object1.equals(object2)) {
+                        return true;
+                    }
+                }
+
+                return false;
+            }
+        }
+
+        public final int hashCode() {
+            return IntHashMap.g(this.a);
+        }
+
+        public final String toString() {
+            return this.a() + "=" + this.b();
+        }
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src_new/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2016-02-26 15:27:11.493203662 +0800
+++ src_new/main/java/net/minecraft/server/MinecraftServer.java	2016-02-26 15:27:51.010207360 +0800
@@ -1023,7 +1023,8 @@
     }
 
     public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        //return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "HOSE"; // HOSE -> Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1105,7 +1106,8 @@
     }
 
     public String getName() {
-        return "Server";
+        //return "Server";
+        return org.bukkit.ChatColor.GREEN+"Server";
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
diff -Naur src_origin/main/java/net/minecraft/server/PortalTravelAgent.java src_new/main/java/net/minecraft/server/PortalTravelAgent.java
--- src_origin/main/java/net/minecraft/server/PortalTravelAgent.java	2016-02-26 15:27:12.766203781 +0800
+++ src_new/main/java/net/minecraft/server/PortalTravelAgent.java	2016-02-26 15:27:52.206207471 +0800
@@ -3,7 +3,11 @@
 import com.google.common.collect.Lists;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.Random;
+import java.util.concurrent.ConcurrentLinkedDeque;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 // CraftBukkit start
 import org.bukkit.Location;
@@ -17,6 +21,7 @@
     private final Random b;
     private final LongHashMap<PortalTravelAgent.ChunkCoordinatesPortal> c = new LongHashMap();
     private final List<Long> d = Lists.newArrayList();
+    //private final CopyOnWriteArrayList<Long> d = new CopyOnWriteArrayList<Long>();
 
     public PortalTravelAgent(WorldServer worldserver) {
         this.a = worldserver;
diff -Naur src_origin/main/java/net/minecraft/server/World.java src_new/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2016-02-26 15:27:13.782203876 +0800
+++ src_new/main/java/net/minecraft/server/World.java	2016-02-26 15:27:53.196207564 +0800
@@ -15,7 +15,13 @@
 
 // CraftBukkit start
 import com.google.common.collect.Maps;
+import java.util.Collections;
 import java.util.Map;
+import java.util.concurrent.BlockingDeque;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.LinkedBlockingDeque;
 
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
@@ -31,6 +37,10 @@
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
 import org.bukkit.event.weather.WeatherChangeEvent;
 import org.bukkit.event.weather.ThunderChangeEvent;
+import org.hose.AddParticlePool;
+import org.hose.Tick_Pool;
+import org.hose.t_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class World implements IBlockAccess {
@@ -38,32 +48,36 @@
     private int a = 63;
     protected boolean e;
     // Spigot start - guard entity list from removals
-    public final List<Entity> entityList = new java.util.ArrayList<Entity>()
+    //public final List<Entity> entityList = new java.util.ArrayList<Entity>()
+    //public final CopyOnWriteArrayList<Entity> entityList = new CopyOnWriteArrayList<Entity>()
+    public final List<Entity> entityList = new CopyOnWriteArrayList<Entity>()
     {
         @Override
         public Entity remove(int index)
         {
-            guard();
+            //guard();
             return super.remove( index );
         }
 
         @Override
         public boolean remove(Object o)
         {
-            guard();
+            //guard();
             return super.remove( o );
         }
-
+        
+        /*
         private void guard()
         {
             if ( guardEntityList )
             {
                 throw new java.util.ConcurrentModificationException();
             }
-        }
+        }*/
     };
     // Spigot end
     protected final List<Entity> g = Lists.newArrayList();
+    //protected final ConcurrentLinkedQueue<Entity> g = new ConcurrentLinkedQueue<Entity>();
     public final List<TileEntity> h = Lists.newArrayList();
     public final List<TileEntity> tileEntityList = Lists.newArrayList();
     private final List<TileEntity> b = Lists.newArrayList();
@@ -967,10 +981,13 @@
     }
 
     public void addParticle(EnumParticle enumparticle, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
-        this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        //this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        SpigotWorldConfig.AddParticleTask = new FutureTask(new AddParticlePool(this, enumparticle, d0, d1, d2, d3, d4, d5, aint));
+        SpigotWorldConfig.addparticlepool_executor.submit(SpigotWorldConfig.AddParticleTask);
     }
 
-    private void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
+    public void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
+    //private void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
         for (int j = 0; j < this.u.size(); ++j) {
             ((IWorldAccess) this.u.get(j)).a(i, flag, d0, d1, d2, d3, d4, d5, aint);
         }
@@ -1422,7 +1439,9 @@
             if (!entity.dead) {
                 try {
                     SpigotTimings.tickEntityTimer.startTiming(); // Spigot
-                    this.g(entity);
+                    //this.g(entity);
+                    SpigotWorldConfig.t_Task = new FutureTask(new t_Pool(this,entity));
+                    SpigotWorldConfig.t_pool_executor.submit(SpigotWorldConfig.t_Task);
                     SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
                 } catch (Throwable throwable1) {
                     crashreport = CrashReport.a(throwable1, "Ticking entity");
@@ -1580,6 +1599,8 @@
 
     public void g(Entity entity) {
         this.entityJoinedWorld(entity, true);
+        /*SpigotWorldConfig.TickTask = new FutureTask(new Tick_Pool(this,entity));
+        SpigotWorldConfig.tickpool_executor.submit(SpigotWorldConfig.TickTask);*/
     }
 
     public void entityJoinedWorld(Entity entity, boolean flag) {
@@ -2607,25 +2628,26 @@
 
     public int a(Class<?> oclass) {
         int i = 0;
-        Iterator iterator = this.entityList.iterator();
+        synchronized (this.entityList) {
+            Iterator iterator = this.entityList.iterator();
 
-        while (iterator.hasNext()) {
-            Entity entity = (Entity) iterator.next();
-            // CraftBukkit start - Split out persistent check, don't apply it to special persistent mobs
-            if (entity instanceof EntityInsentient) {
-                EntityInsentient entityinsentient = (EntityInsentient) entity;
-                if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
-                    continue;
+            while (iterator.hasNext()) {
+                Entity entity = (Entity) iterator.next();
+                // CraftBukkit start - Split out persistent check, don't apply it to special persistent mobs
+                if (entity instanceof EntityInsentient) {
+                    EntityInsentient entityinsentient = (EntityInsentient) entity;
+                    if (entityinsentient.isTypeNotPersistent() && entityinsentient.isPersistent()) {
+                        continue;
+                    }
+                }
+
+                if (oclass.isAssignableFrom(entity.getClass())) {
+                // if ((!(entity instanceof EntityInsentient) || !((EntityInsentient) entity).isPersistent()) && oclass.isAssignableFrom(entity.getClass())) {
+                    // CraftBukkit end
+                    ++i;
                 }
-            }
-            
-            if (oclass.isAssignableFrom(entity.getClass())) {
-            // if ((!(entity instanceof EntityInsentient) || !((EntityInsentient) entity).isPersistent()) && oclass.isAssignableFrom(entity.getClass())) {
-                // CraftBukkit end
-                ++i;
             }
         }
-
         return i;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/WorldServer.java src_new/main/java/net/minecraft/server/WorldServer.java
--- src_origin/main/java/net/minecraft/server/WorldServer.java	2016-02-26 15:27:14.144203910 +0800
+++ src_new/main/java/net/minecraft/server/WorldServer.java	2016-02-26 15:27:53.565207599 +0800
@@ -18,6 +18,8 @@
 
 // CraftBukkit start
 import java.util.*;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.logging.Level;
 
 import org.bukkit.WeatherType;
@@ -49,6 +51,7 @@
     private int T;
     private static final List<StructurePieceTreasure> U = Lists.newArrayList(new StructurePieceTreasure[] { new StructurePieceTreasure(Items.STICK, 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.PLANKS), 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG), 0, 1, 3, 10), new StructurePieceTreasure(Items.STONE_AXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_AXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.STONE_PICKAXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_PICKAXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.APPLE, 0, 2, 3, 5), new StructurePieceTreasure(Items.BREAD, 0, 2, 3, 3), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG2), 0, 1, 3, 10)});
     private List<NextTickListEntry> V = Lists.newArrayList();
+    //private List<NextTickListEntry> V = new CopyOnWriteArrayList<NextTickListEntry>();
 
     // CraftBukkit start
     public final int dimension;
@@ -624,9 +627,9 @@
                 this.methodProfiler.a("cleaning");
 
                 NextTickListEntry nextticklistentry;
-
-                for (int j = 0; j < i; ++j) {
-                    nextticklistentry = (NextTickListEntry) this.M.first();
+                Iterator it = this.M.iterator();
+                while (it.hasNext()){
+                    nextticklistentry = (NextTickListEntry) it.next();
                     if (!flag && nextticklistentry.b > this.worldData.getTime()) {
                         break;
                     }
@@ -635,6 +638,23 @@
                     this.M.remove(nextticklistentry);
                     this.V.add(nextticklistentry);
                 }
+                /*
+                for (int j = 0; j < i; ++j) {
+                    try {
+                        nextticklistentry = (NextTickListEntry) this.M.first();
+                        if (!flag && nextticklistentry.b > this.worldData.getTime()) {
+                            break;
+                        }
+
+                        // CraftBukkit - use M, PAIL: Rename nextTickList
+                        this.M.remove(nextticklistentry);
+                        this.V.add(nextticklistentry);
+                    } catch (Exception ex){
+                        LogManager.getLogger().warn(this.M.size()+":"+ex);
+                        
+                        break;
+                    }
+                }*/
 
                 this.methodProfiler.b();
                 this.methodProfiler.a("ticking");
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java src_new/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-02-26 15:27:22.350204678 +0800
+++ src_new/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-02-26 15:28:01.375208329 +0800
@@ -1,15 +1,19 @@
 package org.bukkit.craftbukkit.util;
 
+import com.google.common.collect.Sets;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.TreeSet;
+import java.util.concurrent.ConcurrentSkipListSet;
 
 public class HashTreeSet<V> implements Set<V> {
 
-    private HashSet<V> hash = new HashSet<V>();
-    private TreeSet<V> tree = new TreeSet<V>();
+    //private HashSet<V> hash = new HashSet<V>();
+    private Set<V> hash = Sets.newConcurrentHashSet();
+    //private TreeSet<V> tree = new TreeSet<V>();
+    private ConcurrentSkipListSet<V> tree = new ConcurrentSkipListSet<V>();
 
     public HashTreeSet() {
 
@@ -112,6 +116,6 @@
 
     public V first() {
         return tree.first();
-    }
+   }
 
 }
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java src_new/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java	2016-02-26 15:27:22.480204690 +0800
+++ src_new/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java	2016-02-26 15:28:01.477208339 +0800
@@ -14,6 +14,8 @@
 import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.Set;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 @SuppressWarnings("unchecked")
 public class LongObjectHashMap<V> implements Cloneable, Serializable {
@@ -31,7 +33,7 @@
         initialize();
     }
 
-    public LongObjectHashMap(Map<? extends Long, ? extends V> map) {
+    public LongObjectHashMap(ConcurrentMap<? extends Long, ? extends V> map) {
         this();
         putAll(map);
     }
diff -Naur src_origin/main/java/org/hose/AddParticlePool.java src_new/main/java/org/hose/AddParticlePool.java
--- src_origin/main/java/org/hose/AddParticlePool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/AddParticlePool.java	2016-02-26 15:27:44.366206738 +0800
@@ -0,0 +1,41 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.EnumParticle;
+import net.minecraft.server.World;
+/**
+ *
+ * @author softpak
+ */
+public class AddParticlePool implements Callable{
+    private World w;
+    private EnumParticle ep;
+    private int[] aint;
+    private double d0, d1, d2, d3, d4, d5;
+    
+    public AddParticlePool(World w, EnumParticle ep, double d0, double d1, double d2, double d3, double d4, double d5, int... aint){
+        this.w = w;
+        this.ep = ep;
+        this.aint = aint;
+        this.d0 = d0;
+        this.d1 = d1;
+        this.d2 = d2;
+        this.d3 = d3;
+        this.d4 = d4;
+        this.d5 = d5;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+        //this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        w.a(ep.c(), ep.e(), d0, d1, d2, d3, d4, d5, aint);
+        return null;
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/Tick_Pool.java src_new/main/java/org/hose/Tick_Pool.java
--- src_origin/main/java/org/hose/Tick_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/Tick_Pool.java	2016-02-26 15:27:44.358206737 +0800
@@ -0,0 +1,34 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Entity;
+import net.minecraft.server.World;
+
+/**
+ *
+ * @author softpak
+ */
+public class Tick_Pool  implements Callable{
+    private Entity e;
+    private World w;
+
+    public Tick_Pool(World w, Entity e) {
+        this.e = e;
+        this.w = w;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        //this.entityJoinedWorld(entity, true);
+        w.entityJoinedWorld(e, true);
+        return null;
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/t_Pool.java src_new/main/java/org/hose/t_Pool.java
--- src_origin/main/java/org/hose/t_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src_new/main/java/org/hose/t_Pool.java	2016-02-26 15:27:44.398206741 +0800
@@ -0,0 +1,35 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Entity;
+import net.minecraft.server.World;
+
+/**
+ *
+ * @author softpak
+ */
+public class t_Pool  implements Callable{
+    private Entity e;
+    private World w;
+
+    public t_Pool(World w, Entity e) {
+        this.e = e;
+        this.w = w;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        //hoseentitytick(entity);
+        this.w.g(e);
+        //el.m();
+        return null;
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/spigotmc/ActivationRange.java src_new/main/java/org/spigotmc/ActivationRange.java
--- src_origin/main/java/org/spigotmc/ActivationRange.java	2016-02-26 15:27:05.386203091 +0800
+++ src_new/main/java/org/spigotmc/ActivationRange.java	2016-02-26 15:27:44.563206756 +0800
@@ -30,6 +30,7 @@
 import net.minecraft.server.MathHelper;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.World;
+import org.apache.commons.lang.ArrayUtils;
 import org.bukkit.craftbukkit.SpigotTimings;
 import org.bukkit.entity.Creeper;
 
@@ -145,37 +146,53 @@
     {
         for ( List<Entity> slice : chunk.entitySlices )
         {
-            for ( Entity entity : slice )
-            {
-                if ( MinecraftServer.currentTick > entity.activatedTick )
+            if (slice != null){
+                for ( Entity entity : slice )
                 {
-                    if ( entity.defaultActivationState )
-                    {
-                        entity.activatedTick = MinecraftServer.currentTick;
-                        continue;
-                    }
-                    switch ( entity.activationType )
-                    {
-                        case 1:
-                            if ( monsterBB.b( entity.getBoundingBox() ) )
+                    if (entity != null){
+                        if ( MinecraftServer.currentTick > entity.activatedTick )
+                        {
+                            if ( entity.defaultActivationState )
                             {
                                 entity.activatedTick = MinecraftServer.currentTick;
+                                continue;
                             }
-                            break;
-                        case 2:
-                            if ( animalBB.b( entity.getBoundingBox() ) )
+                            switch ( entity.activationType )
                             {
-                                entity.activatedTick = MinecraftServer.currentTick;
-                            }
-                            break;
-                        case 3:
-                        default:
-                            if ( miscBB.b( entity.getBoundingBox() ) )
-                            {
-                                entity.activatedTick = MinecraftServer.currentTick;
+                                case 1:
+                                    if ( monsterBB.b( entity.getBoundingBox() ) )
+                                    {
+                                        entity.activatedTick = MinecraftServer.currentTick;
+                                    }
+                                    break;
+                                case 2:
+                                    if ( animalBB.b( entity.getBoundingBox() ) )
+                                    {
+                                        entity.activatedTick = MinecraftServer.currentTick;
+                                    }
+                                    break;
+                                case 3:
+                                default:
+                                    if ( miscBB.b( entity.getBoundingBox() ) )
+                                    {
+                                        entity.activatedTick = MinecraftServer.currentTick;
+                                    }
                             }
+                        }
+                    } else {
+                        try {
+                            slice.remove(entity);
+                        } catch (Exception ex){
+
+                        }
                     }
                 }
+            } else {
+                try {
+                    ArrayUtils.removeElement(chunk.entitySlices, slice);
+                } catch (Exception ex){
+
+                }
             }
         }
     }
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src_new/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2016-02-26 15:27:05.429203095 +0800
+++ src_new/main/java/org/spigotmc/AsyncCatcher.java	2016-02-26 15:27:44.610206761 +0800
@@ -5,7 +5,7 @@
 public class AsyncCatcher
 {
 
-    public static boolean enabled = true;
+    public static boolean enabled = false;
 
     public static void catchOp(String reason)
     {
diff -Naur src_origin/main/java/org/spigotmc/SpigotWorldConfig.java src_new/main/java/org/spigotmc/SpigotWorldConfig.java
--- src_origin/main/java/org/spigotmc/SpigotWorldConfig.java	2016-02-26 15:27:05.636203114 +0800
+++ src_new/main/java/org/spigotmc/SpigotWorldConfig.java	2016-02-26 15:27:44.789206777 +0800
@@ -1,13 +1,47 @@
 package org.spigotmc;
 
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import java.util.Arrays;
 import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.ThreadFactory;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
 public class SpigotWorldConfig
 {
+    static public final int cpu_core = Runtime.getRuntime().availableProcessors();
+    
+    static public FutureTask TickTask;
+    static public FutureTask AddParticleTask;
+    static public FutureTask t_Task;
+    
+    static final ThreadFactory tfapp = new ThreadFactoryBuilder().setNameFormat("AddParticlePool-%d").build();
+    static public final ExecutorService addparticlepool_executor = Executors.newFixedThreadPool(cpu_core, tfapp);
+    
+     static final ThreadFactory tftp = new ThreadFactoryBuilder().setNameFormat("Tick_Pool-%d").build();
+    static public ExecutorService tickpool_executor;
+    
+    static final ThreadFactory tftpp = new ThreadFactoryBuilder().setNameFormat("t_Pool-%d").build();
+    static public ExecutorService t_pool_executor;
 
+    public static int worldtickentitypool_core_multiple;
+    
+    public static int getthreadnumber(){
+        return cpu_core*worldtickentitypool_core_multiple;
+    }
+    private void wetp_core_multiple()
+    {
+        worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 1);
+        tickpool_executor = Executors.newFixedThreadPool(getthreadnumber(), tftp);
+        t_pool_executor = Executors.newFixedThreadPool(getthreadnumber(), tftpp);
+        log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
+    }
+    
+    
+    
     private final String worldName;
     private final YamlConfiguration config;
     private boolean verbose;
