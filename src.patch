diff -Naur src_origin/main/java/net/minecraft/server/BlockDiodeAbstract.java src/main/java/net/minecraft/server/BlockDiodeAbstract.java
--- src_origin/main/java/net/minecraft/server/BlockDiodeAbstract.java	2016-08-25 04:49:41.803594057 +0800
+++ src/main/java/net/minecraft/server/BlockDiodeAbstract.java	2016-08-25 16:43:38.315602126 +0800
@@ -102,6 +102,8 @@
                 }
 
                 world.a(blockposition, this, this.i(iblockdata), b0);
+                /*WorldServer.nextTickList.addAll(WorldServer.nextTickQueue);
+                WorldServer.nextTickQueue.clear();*/
             }
 
         }
diff -Naur src_origin/main/java/net/minecraft/server/BlockRedstoneWire.java src/main/java/net/minecraft/server/BlockRedstoneWire.java
--- src_origin/main/java/net/minecraft/server/BlockRedstoneWire.java	2016-08-25 04:49:42.045594080 +0800
+++ src/main/java/net/minecraft/server/BlockRedstoneWire.java	2016-08-25 16:43:38.534602147 +0800
@@ -3,6 +3,7 @@
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.EnumSet;
 import java.util.Iterator;
 import java.util.Random;
@@ -20,7 +21,8 @@
     public static final BlockStateInteger POWER = BlockStateInteger.of("power", 0, 15);
     protected static final AxisAlignedBB[] f = new AxisAlignedBB[] { new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.8125D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 0.8125D, 0.0625D, 1.0D), new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.1875D, 1.0D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.1875D, 1.0D, 0.0625D, 1.0D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.1875D, 0.0D, 0.0D, 1.0D, 0.0625D, 1.0D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.0625D, 0.8125D), new AxisAlignedBB(0.0D, 0.0D, 0.0D, 1.0D, 0.0625D, 1.0D)};
     private boolean g = true;
-    private final Set<BlockPosition> B = Sets.newHashSet();
+    //private final Set<BlockPosition> B = Sets.newHashSet();
+    private final Set<BlockPosition> B = Collections.synchronizedSet(Sets.newHashSet());
 
     public BlockRedstoneWire() {
         super(Material.ORIENTABLE);
@@ -109,18 +111,20 @@
 
     private IBlockData e(World world, BlockPosition blockposition, IBlockData iblockdata) {
         iblockdata = this.a(world, blockposition, blockposition, iblockdata);
-        ArrayList arraylist = Lists.newArrayList(this.B);
+        synchronized (this.B) {
+            ArrayList arraylist = Lists.newArrayList(this.B);
 
-        this.B.clear();
-        Iterator iterator = arraylist.iterator();
+            this.B.clear();
+            Iterator iterator = arraylist.iterator();
 
-        while (iterator.hasNext()) {
-            BlockPosition blockposition1 = (BlockPosition) iterator.next();
+            while (iterator.hasNext()) {
+                BlockPosition blockposition1 = (BlockPosition) iterator.next();
 
-            world.applyPhysics(blockposition1, this);
-        }
+                world.applyPhysics(blockposition1, this);
+            }
 
-        return iblockdata;
+            return iblockdata;
+        }
     }
 
     private IBlockData a(World world, BlockPosition blockposition, BlockPosition blockposition1, IBlockData iblockdata) {
diff -Naur src_origin/main/java/net/minecraft/server/Chunk.java src/main/java/net/minecraft/server/Chunk.java
--- src_origin/main/java/net/minecraft/server/Chunk.java	2016-08-25 04:49:42.178594092 +0800
+++ src/main/java/net/minecraft/server/Chunk.java	2016-08-25 16:43:38.672602160 +0800
@@ -15,6 +15,7 @@
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists; // CraftBukkit
+import java.util.Queue;
 import org.bukkit.Server; // CraftBukkit
 
 public class Chunk {
@@ -32,7 +33,8 @@
     public final int locZ;
     private boolean m;
     public final Map<BlockPosition, TileEntity> tileEntities;
-    public final List<Entity>[] entitySlices; // Spigot
+    //public final List<Entity>[] entitySlices; // Spigot
+    public final Queue<Entity>[] entitySlices;
     private boolean done;
     private boolean lit;
     private boolean r;
@@ -83,14 +85,16 @@
         this.tileEntities = Maps.newHashMap();
         this.x = 4096;
         this.y = Queues.newConcurrentLinkedQueue();
-        this.entitySlices = (List[]) (new List[16]); // Spigot
+        //this.entitySlices = (List[]) (new List[16]); // Spigot
+        this.entitySlices = (Queue[]) (new Queue[16]);
         this.world = world;
         this.locX = i;
         this.locZ = j;
         this.heightMap = new int[256];
 
         for (int k = 0; k < this.entitySlices.length; ++k) {
-            this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            //this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[k] = Queues.newConcurrentLinkedQueue();
         }
 
         Arrays.fill(this.h, -999);
@@ -744,11 +748,13 @@
     public void addEntities() {
         this.j = true;
         this.world.b(this.tileEntities.values());
-        List[] aentityslice = this.entitySlices; // Spigot
+        //List[] aentityslice = this.entitySlices; // Spigot
+        Queue[] aentityslice = this.entitySlices;
         int i = aentityslice.length;
 
         for (int j = 0; j < i; ++j) {
-            List entityslice = aentityslice[j]; // Spigot
+            //List entityslice = aentityslice[j]; // Spigot
+            Queue entityslice = aentityslice[j];
 
             this.world.a((Collection) entityslice);
         }
@@ -777,7 +783,8 @@
             this.world.b(tileentity);
         }
 
-        List[] aentityslice = this.entitySlices; // Spigot
+        //List[] aentityslice = this.entitySlices; // Spigot
+        Queue[] aentityslice = this.entitySlices;
         int i = aentityslice.length;
 
         for (int j = 0; j < i; ++j) {
@@ -826,29 +833,31 @@
         for (int k = i; k <= j; ++k) {
             if (!this.entitySlices[k].isEmpty()) {
                 Iterator iterator = this.entitySlices[k].iterator();
-
                 while (iterator.hasNext()) {
-                    Entity entity1 = (Entity) iterator.next();
-
-                    if (entity1.getBoundingBox().b(axisalignedbb) && entity1 != entity) {
-                        if (predicate == null || predicate.apply(entity1)) {
-                            list.add(entity1);
-                        }
-
-                        Entity[] aentity = entity1.aT();
-
-                        if (aentity != null) {
-                            Entity[] aentity1 = aentity;
-                            int l = aentity.length;
+                    try {
+                        Entity entity1 = (Entity) iterator.next();
+                        if (entity1.getBoundingBox().b(axisalignedbb) && entity1 != entity) {
+                            if (predicate == null || predicate.apply(entity1)) {
+                                list.add(entity1);
+                            }
 
-                            for (int i1 = 0; i1 < l; ++i1) {
-                                Entity entity2 = aentity1[i1];
+                            Entity[] aentity = entity1.aT();
 
-                                if (entity2 != entity && entity2.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply(entity2))) {
-                                    list.add(entity2);
+                            if (aentity != null) {
+                                Entity[] aentity1 = aentity;
+                                int l = aentity.length;
+
+                                for (int i1 = 0; i1 < l; ++i1) {
+                                    Entity entity2 = aentity1[i1];
+
+                                    if (entity2 != entity && entity2.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply(entity2))) {
+                                        list.add(entity2);
+                                    }
                                 }
                             }
                         }
+                    } catch (Exception ex) {
+                        ;
                     }
                 }
             }
@@ -867,10 +876,13 @@
             Iterator iterator = this.entitySlices[k].iterator(); // Spigot
 
             while (iterator.hasNext()) {
-                Entity entity = (Entity) iterator.next();
-
-                if (oclass.isInstance(entity) && entity.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply((T) entity))) { // CraftBukkit - fix decompile error // Spigot
-                    list.add((T) entity); // Fix decompile error
+                try {
+                    Entity entity = (Entity) iterator.next();
+                    if (oclass.isInstance(entity) && entity.getBoundingBox().b(axisalignedbb) && (predicate == null || predicate.apply((T) entity))) { // CraftBukkit - fix decompile error // Spigot
+                        list.add((T) entity); // Fix decompile error
+                    }
+                } catch (Exception ex) {
+                    ;
                 }
             }
         }
@@ -1288,7 +1300,8 @@
         return this.tileEntities;
     }
 
-    public List<Entity>[] getEntitySlices() {
+    //public List<Entity>[] getEntitySlices() {
+    public Queue<Entity>[] getEntitySlices() {
         return this.entitySlices;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderServer.java src/main/java/net/minecraft/server/ChunkProviderServer.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderServer.java	2016-08-25 04:49:42.187594093 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderServer.java	2016-08-25 16:43:38.676602160 +0800
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
@@ -9,7 +10,12 @@
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ForkJoinTask;
+import java.util.logging.Level;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -17,6 +23,7 @@
 // CraftBukkit start
 import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
 import org.bukkit.event.world.ChunkUnloadEvent;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public class ChunkProviderServer implements IChunkProvider {
@@ -25,7 +32,8 @@
     public final Set<Long> unloadQueue = Sets.newHashSet();
     public final ChunkGenerator chunkGenerator;
     private final IChunkLoader chunkLoader;
-    public final Long2ObjectMap<Chunk> chunks = new Long2ObjectOpenHashMap(8192);
+    //public final Long2ObjectMap<Chunk> chunks = new Long2ObjectOpenHashMap(8192);
+    public final Map<Long, Chunk> chunks = Maps.newConcurrentMap();
     public final WorldServer world;
 
     public ChunkProviderServer(WorldServer worldserver, IChunkLoader ichunkloader, ChunkGenerator chunkgenerator) {
@@ -156,7 +164,10 @@
             long k = ChunkCoordIntPair.a(i, j);
 
             try {
-                chunk = this.chunkGenerator.getOrCreateChunk(i, j);
+                //chunk = this.chunkGenerator.getOrCreateChunk(i, j);
+                SpigotWorldConfig.ChunkTask = ForkJoinTask.adapt(new originalGetChunkAt(i, j));
+                SpigotWorldConfig.ChunkPool.submit(SpigotWorldConfig.ChunkTask);
+                chunk = SpigotWorldConfig.ChunkTask.get();
             } catch (Throwable throwable) {
                 CrashReport crashreport = CrashReport.a(throwable, "Exception generating new chunk");
                 CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Chunk to be generated");
@@ -329,4 +340,19 @@
     public boolean isLoaded(int i, int j) {
         return this.chunks.containsKey(ChunkCoordIntPair.a(i, j));
     }
+    
+    class originalGetChunkAt implements Callable<Chunk> {
+        int i, j;
+        
+        originalGetChunkAt(int i, int j){
+            this.i = i;
+            this.j = j;
+        }
+        
+        @Override
+        public Chunk call() throws Exception {
+            return chunkGenerator.getOrCreateChunk(i, j);
+        }
+        
+    }
 }
diff -Naur src_origin/main/java/net/minecraft/server/ChunkRegionLoader.java src/main/java/net/minecraft/server/ChunkRegionLoader.java
--- src_origin/main/java/net/minecraft/server/ChunkRegionLoader.java	2016-08-25 04:49:42.202594095 +0800
+++ src/main/java/net/minecraft/server/ChunkRegionLoader.java	2016-08-25 16:43:38.686602161 +0800
@@ -10,10 +10,17 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ForkJoinTask;
+import java.util.concurrent.RecursiveAction;
+import java.util.logging.Level;
+import java.util.stream.IntStream;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.spigotmc.SpigotWorldConfig;
 
 public class ChunkRegionLoader implements IChunkLoader, IAsyncChunkSaver {
 
@@ -385,6 +392,7 @@
         return chunk;
     }
 
+    //fork this
     public void loadEntities(Chunk chunk, NBTTagCompound nbttagcompound, World world) {
         // CraftBukkit end
         world.timings.syncChunkLoadEntitiesTimer.startTiming(); // Spigot
@@ -428,11 +436,16 @@
                     } else {
                         block = Block.getById(nbttagcompound4.getInt("i"));
                     }
-
+                    //add to next tick, include button
                     world.b(new BlockPosition(nbttagcompound4.getInt("x"), nbttagcompound4.getInt("y"), nbttagcompound4.getInt("z")), block, nbttagcompound4.getInt("t"), nbttagcompound4.getInt("p"));
                 }
             }
         }
+        //add to next at once
+        /*if (!WorldServer.nextTickQueue.isEmpty()) {
+            WorldServer.nextTickList.addAll(WorldServer.nextTickQueue);
+            WorldServer.nextTickQueue.clear();
+        }*/
         world.timings.syncChunkLoadTileTicksTimer.stopTiming(); // Spigot
 
         // return chunk; // CraftBukkit
diff -Naur src_origin/main/java/net/minecraft/server/EntityInsentient.java src/main/java/net/minecraft/server/EntityInsentient.java
--- src_origin/main/java/net/minecraft/server/EntityInsentient.java	2016-08-25 04:49:42.714594143 +0800
+++ src/main/java/net/minecraft/server/EntityInsentient.java	2016-08-25 16:43:39.168602206 +0800
@@ -664,10 +664,18 @@
         this.targetSelector.a();
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("goalSelector");
-        this.goalSelector.a();
+        try {
+            this.goalSelector.a();
+        } catch (Exception ex) {
+            ;
+        }
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("navigation");
-        this.navigation.l();
+        try {
+            this.navigation.l();
+        } catch (Exception ex) {
+            ;
+        }
         this.world.methodProfiler.b();
         this.world.methodProfiler.a("mob tick");
         this.M();
diff -Naur src_origin/main/java/net/minecraft/server/EntityPlayer.java src/main/java/net/minecraft/server/EntityPlayer.java
--- src_origin/main/java/net/minecraft/server/EntityPlayer.java	2016-08-25 04:49:42.831594154 +0800
+++ src/main/java/net/minecraft/server/EntityPlayer.java	2016-08-25 16:43:39.272602216 +0800
@@ -5,6 +5,7 @@
 import com.mojang.authlib.GameProfile;
 import io.netty.buffer.Unpooled;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
@@ -34,7 +35,8 @@
     public final PlayerInteractManager playerInteractManager;
     public double d;
     public double e;
-    public final List<Integer> removeQueue = Lists.newLinkedList();
+    //public final List<Integer> removeQueue = Lists.newLinkedList();
+    public final List<Integer> removeQueue = Collections.synchronizedList(Lists.newLinkedList());
     private final ServerStatisticManager bV;
     private float bW = Float.MIN_VALUE;
     private int bX = Integer.MIN_VALUE;
@@ -210,12 +212,14 @@
         while (!this.removeQueue.isEmpty()) {
             int i = Math.min(this.removeQueue.size(), Integer.MAX_VALUE);
             int[] aint = new int[i];
-            Iterator iterator = this.removeQueue.iterator();
-            int j = 0;
-
-            while (iterator.hasNext() && j < i) {
-                aint[j++] = ((Integer) iterator.next()).intValue();
-                iterator.remove();
+            synchronized (this.removeQueue) {
+                Iterator iterator = this.removeQueue.iterator();
+                int j = 0;
+
+                while (iterator.hasNext() && j < i) {
+                    aint[j++] = ((Integer) iterator.next()).intValue();
+                    iterator.remove();
+                }
             }
 
             this.playerConnection.sendPacket(new PacketPlayOutEntityDestroy(aint));
diff -Naur src_origin/main/java/net/minecraft/server/EntityTracker.java src/main/java/net/minecraft/server/EntityTracker.java
--- src_origin/main/java/net/minecraft/server/EntityTracker.java	2016-08-25 04:49:42.951594165 +0800
+++ src/main/java/net/minecraft/server/EntityTracker.java	2016-08-25 16:43:39.394602227 +0800
@@ -1,9 +1,12 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
 import com.google.common.collect.Sets;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Iterator;
+import java.util.Map;
 import java.util.Set;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -12,8 +15,10 @@
 
     private static final Logger a = LogManager.getLogger();
     private final WorldServer world;
-    private final Set<EntityTrackerEntry> c = Sets.newHashSet();
-    public final IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    //private final Set<EntityTrackerEntry> c = Sets.newHashSet();
+    private final Set<EntityTrackerEntry> c = Collections.synchronizedSet(Sets.newHashSet());
+    //public final IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    public final Map<Integer, EntityTrackerEntry> trackedEntities = Maps.newConcurrentMap();
     private int e;
 
     public EntityTracker(WorldServer worldserver) {
@@ -104,14 +109,21 @@
         org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
         i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
         try {
-            if (this.trackedEntities.b(entity.getId())) {
-                throw new IllegalStateException("Entity is already tracked!");
+            if (this.trackedEntities.containsKey(entity.getId())) {
+                //throw new IllegalStateException("Entity is already tracked!");
+                this.trackedEntities.remove(entity.getId());
             }
+            /*
+            if (this.trackedEntities.b(entity.getId())) {
+                //throw new IllegalStateException("Entity is already tracked!");
+                this.trackedEntities.d(entity.getId());
+            }*/
 
             EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, this.e, j, flag);
 
             this.c.add(entitytrackerentry);
-            this.trackedEntities.a(entity.getId(), entitytrackerentry);
+            //this.trackedEntities.a(entity.getId(), entitytrackerentry);
+            this.trackedEntities.put(entity.getId(), entitytrackerentry);
             entitytrackerentry.scanPlayers(this.world.players);
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
@@ -150,16 +162,19 @@
         org.spigotmc.AsyncCatcher.catchOp( "entity untrack"); // Spigot
         if (entity instanceof EntityPlayer) {
             EntityPlayer entityplayer = (EntityPlayer) entity;
-            Iterator iterator = this.c.iterator();
+            synchronized (this.c) {
+                Iterator iterator = this.c.iterator();
 
-            while (iterator.hasNext()) {
-                EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
+                while (iterator.hasNext()) {
+                    EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
 
-                entitytrackerentry.a(entityplayer);
+                    entitytrackerentry.a(entityplayer);
+                }
             }
         }
 
-        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
+        //EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
+        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.remove(entity.getId());
 
         if (entitytrackerentry1 != null) {
             this.c.remove(entitytrackerentry1);
@@ -170,46 +185,49 @@
 
     public void updatePlayers() {
         ArrayList arraylist = Lists.newArrayList();
-        Iterator iterator = this.c.iterator();
+        synchronized (this.c) {
+            Iterator iterator = this.c.iterator();
 
-        while (iterator.hasNext()) {
-            EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
+            while (iterator.hasNext()) {
+                EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
 
-            entitytrackerentry.track(this.world.players);
-            if (entitytrackerentry.b) {
-                Entity entity = entitytrackerentry.b();
+                entitytrackerentry.track(this.world.players);
+                if (entitytrackerentry.b) {
+                    Entity entity = entitytrackerentry.b();
 
-                if (entity instanceof EntityPlayer) {
-                    arraylist.add((EntityPlayer) entity);
+                    if (entity instanceof EntityPlayer) {
+                        arraylist.add((EntityPlayer) entity);
+                    }
                 }
             }
-        }
 
-        for (int i = 0; i < arraylist.size(); ++i) {
-            EntityPlayer entityplayer = (EntityPlayer) arraylist.get(i);
-            Iterator iterator1 = this.c.iterator();
+            for (int i = 0; i < arraylist.size(); ++i) {
+                EntityPlayer entityplayer = (EntityPlayer) arraylist.get(i);
+                Iterator iterator1 = this.c.iterator();
 
-            while (iterator1.hasNext()) {
-                EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) iterator1.next();
+                while (iterator1.hasNext()) {
+                    EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) iterator1.next();
 
-                if (entitytrackerentry1.b() != entityplayer) {
-                    entitytrackerentry1.updatePlayer(entityplayer);
+                    if (entitytrackerentry1.b() != entityplayer) {
+                        entitytrackerentry1.updatePlayer(entityplayer);
+                    }
                 }
             }
         }
-
     }
 
     public void a(EntityPlayer entityplayer) {
-        Iterator iterator = this.c.iterator();
+        synchronized (this.c) {
+            Iterator iterator = this.c.iterator();
 
-        while (iterator.hasNext()) {
-            EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
+            while (iterator.hasNext()) {
+                EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
 
-            if (entitytrackerentry.b() == entityplayer) {
-                entitytrackerentry.scanPlayers(this.world.players);
-            } else {
-                entitytrackerentry.updatePlayer(entityplayer);
+                if (entitytrackerentry.b() == entityplayer) {
+                    entitytrackerentry.scanPlayers(this.world.players);
+                } else {
+                    entitytrackerentry.updatePlayer(entityplayer);
+                }
             }
         }
 
@@ -247,41 +265,43 @@
     public void a(EntityPlayer entityplayer, Chunk chunk) {
         ArrayList arraylist = Lists.newArrayList();
         ArrayList arraylist1 = Lists.newArrayList();
-        Iterator iterator = this.c.iterator();
+        synchronized (this.c) {
+            Iterator iterator = this.c.iterator();
 
-        while (iterator.hasNext()) {
-            EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
-            Entity entity = entitytrackerentry.b();
+            while (iterator.hasNext()) {
+                EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
+                Entity entity = entitytrackerentry.b();
 
-            if (entity != entityplayer && entity.ac == chunk.locX && entity.ae == chunk.locZ) {
-                entitytrackerentry.updatePlayer(entityplayer);
-                if (entity instanceof EntityInsentient && ((EntityInsentient) entity).getLeashHolder() != null) {
-                    arraylist.add(entity);
-                }
+                if (entity != entityplayer && entity.ac == chunk.locX && entity.ae == chunk.locZ) {
+                    entitytrackerentry.updatePlayer(entityplayer);
+                    if (entity instanceof EntityInsentient && ((EntityInsentient) entity).getLeashHolder() != null) {
+                        arraylist.add(entity);
+                    }
 
-                if (!entity.bx().isEmpty()) {
-                    arraylist1.add(entity);
+                    if (!entity.bx().isEmpty()) {
+                        arraylist1.add(entity);
+                    }
                 }
             }
-        }
 
-        Entity entity1;
+            Entity entity1;
 
-        if (!arraylist.isEmpty()) {
-            iterator = arraylist.iterator();
+            if (!arraylist.isEmpty()) {
+                iterator = arraylist.iterator();
 
-            while (iterator.hasNext()) {
-                entity1 = (Entity) iterator.next();
-                entityplayer.playerConnection.sendPacket(new PacketPlayOutAttachEntity(entity1, ((EntityInsentient) entity1).getLeashHolder()));
+                while (iterator.hasNext()) {
+                    entity1 = (Entity) iterator.next();
+                    entityplayer.playerConnection.sendPacket(new PacketPlayOutAttachEntity(entity1, ((EntityInsentient) entity1).getLeashHolder()));
+                }
             }
-        }
 
-        if (!arraylist1.isEmpty()) {
-            iterator = arraylist1.iterator();
+            if (!arraylist1.isEmpty()) {
+                iterator = arraylist1.iterator();
 
-            while (iterator.hasNext()) {
-                entity1 = (Entity) iterator.next();
-                entityplayer.playerConnection.sendPacket(new PacketPlayOutMount(entity1));
+                while (iterator.hasNext()) {
+                    entity1 = (Entity) iterator.next();
+                    entityplayer.playerConnection.sendPacket(new PacketPlayOutMount(entity1));
+                }
             }
         }
 
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2016-08-25 04:49:43.388594206 +0800
+++ src/main/java/net/minecraft/server/MinecraftServer.java	2016-08-25 16:43:39.749602260 +0800
@@ -32,7 +32,9 @@
 import java.util.UUID;
 import java.util.concurrent.Callable;
 import java.util.concurrent.Executors;
+import java.util.concurrent.ForkJoinTask;
 import java.util.concurrent.FutureTask;
+import java.util.logging.Level;
 import javax.annotation.Nullable;
 import javax.imageio.ImageIO;
 import org.apache.commons.lang3.Validate;
@@ -46,6 +48,7 @@
 import org.bukkit.craftbukkit.Main;
 // CraftBukkit end
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.spigotmc.SpigotWorldConfig;
 
 public abstract class MinecraftServer implements Runnable, ICommandListener, IAsyncTaskHandler, IMojangStatistics {
 
@@ -682,6 +685,7 @@
 
         if (autosavePeriod > 0 && this.ticks % autosavePeriod == 0) { // CraftBukkit
             SpigotTimings.worldSaveTimer.startTiming(); // Spigot
+            //try to fork this
             this.methodProfiler.a("save");
             this.v.savePlayers();
             // Spigot Start
@@ -689,9 +693,10 @@
             // and causes the main thread to sleep for random amounts of time depending on chunk activity
             // Also pass flag to only save modified chunks
             server.playerCommandState = true;
-            for (World world : worlds) {
+            this.worlds.parallelStream().forEach(world -> world.getWorld().save(false));
+            /*for (World world : worlds) {
                 world.getWorld().save(false);
-            }
+            }*/
             server.playerCommandState = false;
             // this.saveChunks(true);
             // Spigot End
@@ -833,9 +838,13 @@
         this.methodProfiler.c("tickables");
 
         SpigotTimings.tickablesTimer.startTiming(); // Spigot
+        this.o.parallelStream().forEach(it -> {
+            ((ITickable) it).E_();
+        });
+        /*
         for (i = 0; i < this.o.size(); ++i) {
             ((ITickable) this.o.get(i)).E_();
-        }
+        }*/
         SpigotTimings.tickablesTimer.stopTiming(); // Spigot
 
         this.methodProfiler.b();
@@ -1029,7 +1038,8 @@
     }
 
     public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        //return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "HOSE"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1111,7 +1121,8 @@
     }
 
     public String getName() {
-        return "Server";
+        //return "Server";
+        return org.bukkit.ChatColor.GREEN + "Server";
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
@@ -1496,6 +1507,7 @@
 
             // Spigot start
             this.j.add(listenablefuturetask);
+            //SpigotWorldConfig.missionpool_executor.execute(listenablefuturetask);
             return listenablefuturetask;
             // Spigot end
         } else {
diff -Naur src_origin/main/java/net/minecraft/server/NavigationAbstract.java src/main/java/net/minecraft/server/NavigationAbstract.java
--- src_origin/main/java/net/minecraft/server/NavigationAbstract.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/NavigationAbstract.java	2016-08-25 16:43:39.776602263 +0800
@@ -0,0 +1,280 @@
+package net.minecraft.server;
+
+import javax.annotation.Nullable;
+
+public abstract class NavigationAbstract {
+
+    protected EntityInsentient a;
+    protected World b;
+    @Nullable
+    protected PathEntity c;
+    protected double d;
+    private final AttributeInstance f;
+    private int g;
+    private int h;
+    private Vec3D i;
+    private Vec3D j;
+    private long k;
+    private long l;
+    private double m;
+    private float n;
+    private boolean o;
+    private long p;
+    protected PathfinderAbstract e;
+    private BlockPosition q;
+    private final Pathfinder r;
+
+    public NavigationAbstract(EntityInsentient entityinsentient, World world) {
+        this.i = Vec3D.a;
+        this.j = Vec3D.a;
+        this.n = 0.5F;
+        this.a = entityinsentient;
+        this.b = world;
+        this.f = entityinsentient.getAttributeInstance(GenericAttributes.FOLLOW_RANGE);
+        this.r = this.a();
+    }
+
+    protected abstract Pathfinder a();
+
+    public void a(double d0) {
+        this.d = d0;
+    }
+
+    public float h() {
+        return (float) this.f.getValue();
+    }
+
+    public boolean i() {
+        return this.o;
+    }
+
+    public void j() {
+        if (this.b.getTime() - this.p > 20L) {
+            if (this.q != null) {
+                this.c = null;
+                this.c = this.a(this.q);
+                this.p = this.b.getTime();
+                this.o = false;
+            }
+        } else {
+            this.o = true;
+        }
+
+    }
+
+    @Nullable
+    public final PathEntity a(double d0, double d1, double d2) {
+        return this.a(new BlockPosition(d0, d1, d2));
+    }
+
+    @Nullable
+    public PathEntity a(BlockPosition blockposition) {
+        if (!this.b() || this.a == null) {
+            return null;
+        } else if (this.c != null && !this.c.b() && blockposition.equals(this.q)) {
+            return this.c;
+        } else {
+            this.q = blockposition;
+            float f = this.h();
+
+            this.b.methodProfiler.a("pathfind");
+            BlockPosition blockposition1 = new BlockPosition(this.a);
+            int i = (int) (f + 8.0F);
+            ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+            PathEntity pathentity = this.r.a(chunkcache, this.a, this.q, f);
+
+            this.b.methodProfiler.b();
+            return pathentity;
+        }
+    }
+
+    @Nullable
+    public PathEntity a(Entity entity) {
+        if (!this.b()) {
+            return null;
+        } else {
+            BlockPosition blockposition = new BlockPosition(entity);
+
+            if (this.c != null && !this.c.b() && blockposition.equals(this.q)) {
+                return this.c;
+            } else {
+                this.q = blockposition;
+                float f = this.h();
+
+                this.b.methodProfiler.a("pathfind");
+                BlockPosition blockposition1 = (new BlockPosition(this.a)).up();
+                int i = (int) (f + 16.0F);
+                ChunkCache chunkcache = new ChunkCache(this.b, blockposition1.a(-i, -i, -i), blockposition1.a(i, i, i), 0);
+                PathEntity pathentity = this.r.a(chunkcache, this.a, entity, f);
+
+                this.b.methodProfiler.b();
+                return pathentity;
+            }
+        }
+    }
+
+    public boolean a(double d0, double d1, double d2, double d3) {
+        return this.a(this.a(d0, d1, d2), d3);
+    }
+
+    public boolean a(Entity entity, double d0) {
+        PathEntity pathentity = this.a(entity);
+
+        return pathentity != null && this.a(pathentity, d0);
+    }
+
+    public boolean a(@Nullable PathEntity pathentity, double d0) {
+        if (pathentity == null) {
+            this.c = null;
+            return false;
+        } else {
+            if (!pathentity.a(this.c)) {
+                this.c = pathentity;
+            }
+
+            this.d();
+            if (this.c.d() == 0) {
+                return false;
+            } else {
+                this.d = d0;
+                Vec3D vec3d = this.c();
+
+                this.h = this.g;
+                this.i = vec3d;
+                return true;
+            }
+        }
+    }
+
+    @Nullable
+    public PathEntity k() {
+        return this.c;
+    }
+
+    public void l() {
+        ++this.g;
+        if (this.o) {
+            this.j();
+        }
+
+        if (!this.n()) {
+            Vec3D vec3d;
+
+            if (this.b()) {
+                this.m();
+            } else if (this.c != null && this.c.e() < this.c.d()) {
+                vec3d = this.c();
+                Vec3D vec3d1 = this.c.a(this.a, this.c.e());
+
+                if (vec3d.y > vec3d1.y && !this.a.onGround && MathHelper.floor(vec3d.x) == MathHelper.floor(vec3d1.x) && MathHelper.floor(vec3d.z) == MathHelper.floor(vec3d1.z)) {
+                    this.c.c(this.c.e() + 1);
+                }
+            }
+
+            if (!this.n()) {
+                vec3d = this.c.a((Entity) this.a);
+                if (vec3d != null) {
+                    BlockPosition blockposition = (new BlockPosition(vec3d)).down();
+                    AxisAlignedBB axisalignedbb = this.b.getType(blockposition).c(this.b, blockposition);
+
+                    vec3d = vec3d.a(0.0D, 1.0D - axisalignedbb.e, 0.0D);
+                    this.a.getControllerMove().a(vec3d.x, vec3d.y, vec3d.z, this.d);
+                }
+            }
+        }
+    }
+
+    protected void m() {
+        Vec3D vec3d = this.c();
+        int i = this.c.d();
+
+        for (int j = this.c.e(); j < this.c.d(); ++j) {
+            if ((double) this.c.a(j).b != Math.floor(vec3d.y)) {
+                i = j;
+                break;
+            }
+        }
+
+        this.n = this.a.width > 0.75F ? this.a.width / 2.0F : 0.75F - this.a.width / 2.0F;
+        Vec3D vec3d1 = this.c.f();
+
+        if (MathHelper.e((float) (this.a.locX - (vec3d1.x + 0.5D))) < this.n && MathHelper.e((float) (this.a.locZ - (vec3d1.z + 0.5D))) < this.n && Math.abs(this.a.locY - vec3d1.y) < 1.0D) {
+            this.c.c(this.c.e() + 1);
+        }
+
+        int k = MathHelper.f(this.a.width);
+        int l = MathHelper.f(this.a.length);
+        int i1 = k;
+
+        for (int j1 = i - 1; j1 >= this.c.e(); --j1) {
+            if (this.a(vec3d, this.c.a(this.a, j1), k, l, i1)) {
+                this.c.c(j1);
+                break;
+            }
+        }
+
+        this.a(vec3d);
+    }
+
+    protected void a(Vec3D vec3d) {
+        if (this.g - this.h > 100) {
+            if (vec3d.distanceSquared(this.i) < 2.25D) {
+                this.o();
+            }
+
+            this.h = this.g;
+            this.i = vec3d;
+        }
+
+        if (this.c != null && !this.c.b()) {
+            Vec3D vec3d1 = this.c.f();
+
+            if (vec3d1.equals(this.j)) {
+                this.k += System.currentTimeMillis() - this.l;
+            } else {
+                this.j = vec3d1;
+                double d0 = vec3d.f(this.j);
+
+                this.m = this.a.cp() > 0.0F ? d0 / (double) this.a.cp() * 1000.0D : 0.0D;
+            }
+
+            if (this.m > 0.0D && (double) this.k > this.m * 3.0D) {
+                this.j = Vec3D.a;
+                this.k = 0L;
+                this.m = 0.0D;
+                this.o();
+            }
+
+            this.l = System.currentTimeMillis();
+        }
+
+    }
+
+    public boolean n() {
+        return this.c == null || this.c.b();
+    }
+
+    public void o() {
+        this.c = null;
+    }
+
+    protected abstract Vec3D c();
+
+    protected abstract boolean b();
+
+    protected boolean p() {
+        return this.a.isInWater() || this.a.ao();
+    }
+
+    protected void d() {}
+
+    protected abstract boolean a(Vec3D vec3d, Vec3D vec3d1, int i, int j, int k);
+
+    public boolean b(BlockPosition blockposition) {
+        return this.b.getType(blockposition.down()).b();
+    }
+
+    public PathfinderAbstract q() {
+        return this.e;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/NavigationListener.java src/main/java/net/minecraft/server/NavigationListener.java
--- src_origin/main/java/net/minecraft/server/NavigationListener.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/NavigationListener.java	2016-08-25 16:43:39.782602263 +0800
@@ -0,0 +1,91 @@
+package net.minecraft.server;
+
+//import com.google.common.collect.Lists;
+import com.google.common.collect.Queues;
+//import java.util.List;
+import java.util.Queue;
+import javax.annotation.Nullable;
+
+public class NavigationListener implements IWorldAccess {
+
+    //private final List<NavigationAbstract> a = Lists.newArrayList();
+    private final Queue<NavigationAbstract> a = Queues.newConcurrentLinkedQueue();
+
+    public NavigationListener() {}
+
+    public void a(World world, BlockPosition blockposition, IBlockData iblockdata, IBlockData iblockdata1, int i) {
+        if (this.a(world, blockposition, iblockdata, iblockdata1)) {
+            this.a.parallelStream().filter(navigationabstract -> navigationabstract != null && !navigationabstract.i()).forEach(navigationabstract -> {
+                PathEntity pathentity = navigationabstract.k();
+
+                if (pathentity != null && !pathentity.b() && pathentity.d() != 0) {
+                    PathPoint pathpoint = navigationabstract.c.c();
+                    double d0 = blockposition.distanceSquared(((double) pathpoint.a + navigationabstract.a.locX) / 2.0D, ((double) pathpoint.b + navigationabstract.a.locY) / 2.0D, ((double) pathpoint.c + navigationabstract.a.locZ) / 2.0D);
+                    int l = (pathentity.d() - pathentity.e()) * (pathentity.d() - pathentity.e());
+
+                    if (d0 < (double) l) {
+                        navigationabstract.j();
+                    }
+                }
+            });
+            
+            /*int j = 0;
+            
+            for (int k = this.a.size(); j < k; ++j) {
+                NavigationAbstract navigationabstract = (NavigationAbstract) this.a.get(j);
+
+                if (navigationabstract != null && !navigationabstract.i()) {
+                    PathEntity pathentity = navigationabstract.k();
+
+                    if (pathentity != null && !pathentity.b() && pathentity.d() != 0) {
+                        PathPoint pathpoint = navigationabstract.c.c();
+                        double d0 = blockposition.distanceSquared(((double) pathpoint.a + navigationabstract.a.locX) / 2.0D, ((double) pathpoint.b + navigationabstract.a.locY) / 2.0D, ((double) pathpoint.c + navigationabstract.a.locZ) / 2.0D);
+                        int l = (pathentity.d() - pathentity.e()) * (pathentity.d() - pathentity.e());
+
+                        if (d0 < (double) l) {
+                            navigationabstract.j();
+                        }
+                    }
+                }
+            }*/
+
+        }
+    }
+
+    protected boolean a(World world, BlockPosition blockposition, IBlockData iblockdata, IBlockData iblockdata1) {
+        AxisAlignedBB axisalignedbb = iblockdata.d(world, blockposition);
+        AxisAlignedBB axisalignedbb1 = iblockdata1.d(world, blockposition);
+
+        return axisalignedbb != axisalignedbb1 && (axisalignedbb == null || !axisalignedbb.equals(axisalignedbb1));
+    }
+
+    public void a(BlockPosition blockposition) {}
+
+    public void a(int i, int j, int k, int l, int i1, int j1) {}
+
+    public void a(@Nullable EntityHuman entityhuman, SoundEffect soundeffect, SoundCategory soundcategory, double d0, double d1, double d2, float f, float f1) {}
+
+    public void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {}
+
+    public void a(Entity entity) {
+        if (entity instanceof EntityInsentient) {
+            this.a.add(((EntityInsentient) entity).getNavigation());
+        }
+
+    }
+
+    public void b(Entity entity) {
+        if (entity instanceof EntityInsentient) {
+            this.a.remove(((EntityInsentient) entity).getNavigation());
+        }
+
+    }
+
+    public void a(SoundEffect soundeffect, BlockPosition blockposition) {}
+
+    public void a(int i, BlockPosition blockposition, int j) {}
+
+    public void a(EntityHuman entityhuman, int i, BlockPosition blockposition, int j) {}
+
+    public void b(int i, BlockPosition blockposition, int j) {}
+}
diff -Naur src_origin/main/java/net/minecraft/server/PersistentVillage.java src/main/java/net/minecraft/server/PersistentVillage.java
--- src_origin/main/java/net/minecraft/server/PersistentVillage.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/PersistentVillage.java	2016-08-25 16:43:40.027602286 +0800
@@ -0,0 +1,271 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.List;
+
+public class PersistentVillage extends PersistentBase {
+
+    private World world;
+    //private final List<BlockPosition> c = Lists.newArrayList();
+    private final List<BlockPosition> c = Collections.synchronizedList(Lists.newArrayList());
+    private final List<VillageDoor> d = Lists.newArrayList();
+    private final List<Village> villages = Lists.newArrayList();
+    private int time;
+
+    public PersistentVillage(String s) {
+        super(s);
+    }
+
+    public PersistentVillage(World world) {
+        super(a(world.worldProvider));
+        this.world = world;
+        this.c();
+    }
+
+    public void a(World world) {
+        this.world = world;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(world);
+        }
+
+    }
+
+    public void a(BlockPosition blockposition) {
+        if (this.c.size() <= 64) {
+            if (!this.e(blockposition)) {
+                this.c.add(blockposition);
+            }
+
+        }
+    }
+
+    public void tick() {
+        ++this.time;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            village.a(this.time);
+        }
+
+        this.e();
+        this.f();
+        this.g();
+        if (this.time % 400 == 0) {
+            this.c();
+        }
+
+    }
+
+    private void e() {
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+
+            if (village.g()) {
+                iterator.remove();
+                this.c();
+            }
+        }
+
+    }
+
+    public List<Village> getVillages() {
+        return this.villages;
+    }
+
+    public Village getClosestVillage(BlockPosition blockposition, int i) {
+        Village village = null;
+        double d0 = 3.4028234663852886E38D;
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village1 = (Village) iterator.next();
+            double d1 = village1.a().n(blockposition);
+
+            if (d1 < d0) {
+                float f = (float) (i + village1.b());
+
+                if (d1 <= (double) (f * f)) {
+                    village = village1;
+                    d0 = d1;
+                }
+            }
+        }
+
+        return village;
+    }
+
+    private void f() {
+        if (!this.c.isEmpty()) {
+            this.b((BlockPosition) this.c.remove(0));
+        }
+    }
+
+    private void g() {
+        for (int i = 0; i < this.d.size(); ++i) {
+            VillageDoor villagedoor = (VillageDoor) this.d.get(i);
+            Village village = this.getClosestVillage(villagedoor.d(), 32);
+
+            if (village == null) {
+                village = new Village(this.world);
+                this.villages.add(village);
+                this.c();
+            }
+
+            village.a(villagedoor);
+        }
+
+        this.d.clear();
+    }
+
+    private void b(BlockPosition blockposition) {
+        boolean flag = true;
+        boolean flag1 = true;
+        boolean flag2 = true;
+
+        for (int i = -16; i < 16; ++i) {
+            for (int j = -4; j < 4; ++j) {
+                for (int k = -16; k < 16; ++k) {
+                    BlockPosition blockposition1 = blockposition.a(i, j, k);
+
+                    if (this.f(blockposition1)) {
+                        VillageDoor villagedoor = this.c(blockposition1);
+
+                        if (villagedoor == null) {
+                            this.d(blockposition1);
+                        } else {
+                            villagedoor.a(this.time);
+                        }
+                    }
+                }
+            }
+        }
+
+    }
+
+    private VillageDoor c(BlockPosition blockposition) {
+        Iterator iterator = this.d.iterator();
+
+        VillageDoor villagedoor;
+
+        do {
+            if (!iterator.hasNext()) {
+                iterator = this.villages.iterator();
+
+                VillageDoor villagedoor1;
+
+                do {
+                    if (!iterator.hasNext()) {
+                        return null;
+                    }
+
+                    Village village = (Village) iterator.next();
+
+                    villagedoor1 = village.e(blockposition);
+                } while (villagedoor1 == null);
+
+                return villagedoor1;
+            }
+
+            villagedoor = (VillageDoor) iterator.next();
+        } while (villagedoor.d().getX() != blockposition.getX() || villagedoor.d().getZ() != blockposition.getZ() || Math.abs(villagedoor.d().getY() - blockposition.getY()) > 1);
+
+        return villagedoor;
+    }
+
+    private void d(BlockPosition blockposition) {
+        EnumDirection enumdirection = BlockDoor.f(this.world, blockposition);
+        EnumDirection enumdirection1 = enumdirection.opposite();
+        int i = this.a(blockposition, enumdirection, 5);
+        int j = this.a(blockposition, enumdirection1, i + 1);
+
+        if (i != j) {
+            this.d.add(new VillageDoor(blockposition, i < j ? enumdirection : enumdirection1, this.time));
+        }
+
+    }
+
+    private int a(BlockPosition blockposition, EnumDirection enumdirection, int i) {
+        int j = 0;
+
+        for (int k = 1; k <= 5; ++k) {
+            if (this.world.h(blockposition.shift(enumdirection, k))) {
+                ++j;
+                if (j >= i) {
+                    return j;
+                }
+            }
+        }
+
+        return j;
+    }
+
+    private boolean e(BlockPosition blockposition) {
+        synchronized (this.c) {
+            Iterator iterator = this.c.iterator();
+
+            BlockPosition blockposition1;
+
+            do {
+                if (!iterator.hasNext()) {
+                    return false;
+                }
+
+                blockposition1 = (BlockPosition) iterator.next();
+            } while (!blockposition1.equals(blockposition));
+
+            return true;
+        }
+    }
+
+    private boolean f(BlockPosition blockposition) {
+        IBlockData iblockdata = this.world.getType(blockposition);
+        Block block = iblockdata.getBlock();
+
+        return block instanceof BlockDoor ? iblockdata.getMaterial() == Material.WOOD : false;
+    }
+
+    public void a(NBTTagCompound nbttagcompound) {
+        this.time = nbttagcompound.getInt("Tick");
+        NBTTagList nbttaglist = nbttagcompound.getList("Villages", 10);
+
+        for (int i = 0; i < nbttaglist.size(); ++i) {
+            NBTTagCompound nbttagcompound1 = nbttaglist.get(i);
+            Village village = new Village();
+
+            village.a(nbttagcompound1);
+            this.villages.add(village);
+        }
+
+    }
+
+    public NBTTagCompound b(NBTTagCompound nbttagcompound) {
+        nbttagcompound.setInt("Tick", this.time);
+        NBTTagList nbttaglist = new NBTTagList();
+        Iterator iterator = this.villages.iterator();
+
+        while (iterator.hasNext()) {
+            Village village = (Village) iterator.next();
+            NBTTagCompound nbttagcompound1 = new NBTTagCompound();
+
+            village.b(nbttagcompound1);
+            nbttaglist.add(nbttagcompound1);
+        }
+
+        nbttagcompound.set("Villages", nbttaglist);
+        return nbttagcompound;
+    }
+
+    public static String a(WorldProvider worldprovider) {
+        return "villages" + worldprovider.getDimensionManager().c();
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/PlayerChunkMap.java src/main/java/net/minecraft/server/PlayerChunkMap.java
--- src_origin/main/java/net/minecraft/server/PlayerChunkMap.java	2016-08-25 04:49:43.672594232 +0800
+++ src/main/java/net/minecraft/server/PlayerChunkMap.java	2016-08-25 16:43:40.045602288 +0800
@@ -42,7 +42,8 @@
     private final WorldServer world;
     private final List<EntityPlayer> managedPlayers = Lists.newArrayList();
     private final Long2ObjectMap<PlayerChunk> e = new Long2ObjectOpenHashMap(4096);
-    private final Set<PlayerChunk> f = Sets.newHashSet();
+    //private final Set<PlayerChunk> f = Sets.newHashSet();
+    private final Set<PlayerChunk> f = Sets.newConcurrentHashSet();
     private final List<PlayerChunk> g = Lists.newLinkedList();
     private final List<PlayerChunk> h = Lists.newLinkedList();
     private final List<PlayerChunk> i = Lists.newArrayList();
diff -Naur src_origin/main/java/net/minecraft/server/PlayerList.java src/main/java/net/minecraft/server/PlayerList.java
--- src_origin/main/java/net/minecraft/server/PlayerList.java	2016-08-25 04:49:43.748594239 +0800
+++ src/main/java/net/minecraft/server/PlayerList.java	2016-08-25 16:43:40.106602294 +0800
@@ -1167,9 +1167,11 @@
     }
 
     public void savePlayers() {
+        this.players.parallelStream().forEach(pl -> this.savePlayerFile((EntityPlayer) pl));
+        /*
         for (int i = 0; i < this.players.size(); ++i) {
             this.savePlayerFile((EntityPlayer) this.players.get(i));
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/SpawnerCreature.java src/main/java/net/minecraft/server/SpawnerCreature.java
--- src_origin/main/java/net/minecraft/server/SpawnerCreature.java	2016-08-25 04:49:43.888594252 +0800
+++ src/main/java/net/minecraft/server/SpawnerCreature.java	2016-08-25 16:43:40.269602309 +0800
@@ -1,6 +1,7 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Sets;
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
@@ -15,7 +16,8 @@
 public final class SpawnerCreature {
 
     private static final int a = (int) Math.pow(17.0D, 2.0D);
-    private final LongHashSet b = new LongHashSet(); // CraftBukkit
+    //private final LongHashSet b = new LongHashSet(); // CraftBukkit
+    private final Set<Long> b = Sets.newConcurrentHashSet();
 
     public SpawnerCreature() {}
 
@@ -130,7 +132,8 @@
                         label120:
                         while (iterator1.hasNext() && (moblimit > 0)) { // Spigot - while more allowed
                             // CraftBukkit start = use LongHash and LongObjectHashMap
-                            long key = ((Long) iterator1.next()).longValue();
+                            //long key = ((Long) iterator1.next()).longValue();
+                            long key = (long) iterator1.next();
                             BlockPosition blockposition1 = getRandomPosition(worldserver, LongHash.msw(key), LongHash.lsw(key));
                             // CraftBukkit
                             int i2 = blockposition1.getX();
diff -Naur src_origin/main/java/net/minecraft/server/World.java src/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2016-08-25 04:49:44.077594270 +0800
+++ src/main/java/net/minecraft/server/World.java	2016-08-25 16:43:40.471602328 +0800
@@ -15,7 +15,12 @@
 
 // CraftBukkit start
 import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
+import java.util.LinkedList;
 import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
@@ -33,8 +38,11 @@
 
     private int a = 63;
     protected boolean d;
+    //Queue<Entity> entityremoveList = Queues.newConcurrentLinkedQueue();
     // Spigot start - guard entity list from removals
-    public final List<Entity> entityList = new java.util.ArrayList<Entity>()
+    public final Queue<Entity> entityQueue = Queues.newConcurrentLinkedQueue();
+    //public final List<Entity> entityList = new java.util.ArrayList<Entity>()
+    public List<Entity> entityList = new ArrayList<Entity>()
     {
         @Override
         public Entity remove(int index)
@@ -122,7 +130,7 @@
     public long ticksPerAnimalSpawns;
     public long ticksPerMonsterSpawns;
     public boolean populating;
-    private int tickPosition;
+    //private int tickPosition;
     public final org.spigotmc.SpigotWorldConfig spigotConfig; // Spigot
 
     public final SpigotTimings.WorldTimingsHandler timings; // Spigot
@@ -1017,7 +1025,8 @@
             }
 
             this.getChunkAt(i, j).a(entity);
-            this.entityList.add(entity);
+            //this.entityList.add(entity);
+            this.entityQueue.add(entity);
             this.b(entity);
             return true;
         }
@@ -1092,13 +1101,16 @@
         }
 
         // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
+        //this.entityremoveList.add(entity);
+        this.entityQueue.remove(entity);
+        /*
         int index = this.entityList.indexOf(entity);
         if (index != -1) {
             if (index <= this.tickPosition) {
                 this.tickPosition--;
             }
             this.entityList.remove(index);
-        }
+        }*/
         // CraftBukkit end
         } // Spigot
         this.c(entity);
@@ -1339,6 +1351,8 @@
 
     public void b(BlockPosition blockposition, Block block, int i, int j) {}
 
+    CrashReportSystemDetails crashreportsystemdetails1;
+    CrashReport crashreport1;
     public void tickEntities() {
         this.methodProfiler.a("entities");
         this.methodProfiler.a("global");
@@ -1376,19 +1390,24 @@
         }
 
         this.methodProfiler.c("remove");
-        this.entityList.removeAll(this.f);
-
-        int j;
+        //this.entityList.removeAll(this.f);
+        this.entityQueue.removeAll(this.f);
 
+        //int j;
+        this.f.parallelStream().filter(ent -> ent.ab && this.isChunkLoaded(ent.ac, ent.ae, true)).forEach(ent -> {
+            this.getChunkAt(ent.ac, ent.ae).b(ent);
+        });
+        
+        /*
         for (i = 0; i < this.f.size(); ++i) {
             entity = (Entity) this.f.get(i);
             int k = entity.ac;
 
-            j = entity.ae;
+            int j = entity.ae;
             if (entity.ab && this.isChunkLoaded(k, j, true)) {
                 this.getChunkAt(k, j).b(entity);
             }
-        }
+        }*/
 
         for (i = 0; i < this.f.size(); ++i) {
             this.c((Entity) this.f.get(i));
@@ -1397,16 +1416,59 @@
         this.f.clear();
         this.l();
         this.methodProfiler.c("regular");
-
+        /*
         CrashReportSystemDetails crashreportsystemdetails1;
-        CrashReport crashreport1;
+        CrashReport crashreport1;*/
 
         org.spigotmc.ActivationRange.activateEntities(this); // Spigot
         timings.entityTick.startTiming(); // Spigot
+        //this.entityQueue = new ConcurrentLinkedQueue(this.entityList);
         guardEntityList = true; // Spigot
         // CraftBukkit start - Use field for loop variable
-        int entitiesThisCycle = 0;
-        if (tickPosition < 0) tickPosition = 0;
+        //int entitiesThisCycle = 0;
+        //if (tickPosition < 0) tickPosition = 0;
+        this.entityQueue.parallelStream().forEach(ent -> {
+            Entity entity1 = ent.bB();
+            
+            if (entity1 != null) {
+                if (!entity1.dead && entity1.w(ent)) {
+                    return;
+                }
+
+                ent.stopRiding();
+            }
+            
+            this.methodProfiler.a("tick");
+            if (!ent.dead && !(ent instanceof EntityPlayer)) {
+                try {
+                    SpigotTimings.tickEntityTimer.startTiming(); // Spigot
+                    this.g(ent);
+                    SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
+                } catch (Throwable throwable1) {
+                    crashreport1 = CrashReport.a(throwable1, "Ticking entity");
+                    crashreportsystemdetails1 = crashreport1.a("Entity being ticked");
+                    ent.appendEntityCrashDetails(crashreportsystemdetails1);
+                    throw new ReportedException(crashreport1);
+                }
+            }
+
+            this.methodProfiler.b();
+            this.methodProfiler.a("remove");
+            if (ent.dead) {
+                int j = ent.ac;
+                int l = ent.ae;
+
+                if (ent.ab && this.isChunkLoaded(j, l, true)) {
+                    this.getChunkAt(j, l).b(ent);
+                }
+                //this.entityremoveList.add(ent);
+                this.entityQueue.remove(ent);
+                this.c(ent);
+            }
+
+            this.methodProfiler.b();
+        });
+        /*
         for (entityLimiter.initTick();
                 entitiesThisCycle < entityList.size() && (entitiesThisCycle % 10 != 0 || entityLimiter.shouldContinue());
                 tickPosition++, entitiesThisCycle++) {
@@ -1454,8 +1516,15 @@
             }
 
             this.methodProfiler.b();
-        }
+        }*/
         guardEntityList = false; // Spigot
+        /*
+        guardEntityList = true;
+        if (!this.entityremoveList.isEmpty()) {
+            this.entityList.removeAll(this.entityremoveList);
+            this.entityremoveList.clear();
+        }
+        guardEntityList = false;*/
 
         timings.entityTick.stopTiming(); // Spigot
         this.methodProfiler.c("blockEntities");
@@ -1472,6 +1541,10 @@
         // Spigot start
         // Iterator iterator = this.tileEntityListTick.iterator();
         int tilesThisCycle = 0;
+        if (!WorldServer.nextTickQueue.isEmpty()) {
+            WorldServer.nextTickList.addAll(WorldServer.nextTickQueue);
+            WorldServer.nextTickQueue.clear();
+        }
         for (tileLimiter.initTick();
                 tilesThisCycle < tileEntityListTick.size() && (tilesThisCycle % 10 != 0 || tileLimiter.shouldContinue());
                 tileTickPosition++, tilesThisCycle++) {
@@ -1485,7 +1558,7 @@
                 continue;
             }
             // Spigot end
-
+           
             if (!tileentity.x() && tileentity.t()) {
                 BlockPosition blockposition = tileentity.getPosition();
 
@@ -1621,7 +1694,7 @@
             entity.O = entity.locZ;
             entity.lastYaw = entity.yaw;
             entity.lastPitch = entity.pitch;
-            if (flag && entity.ab) {
+            if (flag && entity.ab) {//where to poll a ConcurrentModificationException
                 ++entity.ticksLived;
                 if (entity.isPassenger()) {
                     entity.aw();
@@ -2469,6 +2542,7 @@
 
     public <T extends Entity> List<T> a(Class<? extends T> oclass, Predicate<? super T> predicate) {
         ArrayList arraylist = Lists.newArrayList();
+        this.entityList = new ArrayList(this.entityQueue);
         Iterator iterator = this.entityList.iterator();
 
         while (iterator.hasNext()) {
@@ -2555,6 +2629,7 @@
 
     public int a(Class<?> oclass) {
         int i = 0;
+        this.entityList = new ArrayList(this.entityQueue);
         Iterator iterator = this.entityList.iterator();
 
         while (iterator.hasNext()) {
@@ -2589,7 +2664,8 @@
             if (entity == null) {
                 continue;
             }
-            this.entityList.add(entity);
+            //this.entityList.add(entity);
+            this.entityQueue.add(entity);
             // CraftBukkit end
             this.b(entity);
         }
diff -Naur src_origin/main/java/net/minecraft/server/WorldServer.java src/main/java/net/minecraft/server/WorldServer.java
--- src_origin/main/java/net/minecraft/server/WorldServer.java	2016-08-25 04:49:44.184594280 +0800
+++ src/main/java/net/minecraft/server/WorldServer.java	2016-08-25 16:43:40.569602337 +0800
@@ -3,24 +3,33 @@
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
 import java.util.Random;
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.UUID;
+import java.util.concurrent.Callable;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.ForkJoinTask;
+import java.util.concurrent.RecursiveAction;
+import java.util.concurrent.RecursiveTask;
 import javax.annotation.Nullable;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start
 import java.util.logging.Level;
+import java.util.stream.IntStream;
 
 import org.bukkit.WeatherType;
 import org.bukkit.block.BlockState;
@@ -28,6 +37,7 @@
 
 import org.bukkit.event.block.BlockFormEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public class WorldServer extends World implements IAsyncTaskHandler {
@@ -37,7 +47,9 @@
     public EntityTracker tracker;
     private final PlayerChunkMap manager;
     // private final Set<NextTickListEntry> nextTickListHash = Sets.newHashSet();
-    private final HashTreeSet<NextTickListEntry> nextTickList = new HashTreeSet<NextTickListEntry>(); // CraftBukkit - HashTreeSet
+    public static HashTreeSet<NextTickListEntry> nextTickList = new HashTreeSet<NextTickListEntry>(); // CraftBukkit - HashTreeSet
+    public static final Set<NextTickListEntry> nextTickQueue = Sets.newConcurrentHashSet();
+    private final Set<NextTickListEntry> nextTickList_remove = Sets.newConcurrentHashSet();
     private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
     public boolean savingDisabled;
     private boolean O;
@@ -47,7 +59,8 @@
     protected final VillageSiege siegeManager = new VillageSiege(this);
     private final WorldServer.BlockActionDataList[] S = new WorldServer.BlockActionDataList[] { new WorldServer.BlockActionDataList(null), new WorldServer.BlockActionDataList(null)};
     private int T;
-    private final List<NextTickListEntry> U = Lists.newArrayList();
+    //private final List<NextTickListEntry> U = Lists.newArrayList();
+    private final Queue<NextTickListEntry> U = Queues.newConcurrentLinkedQueue();
 
     // CraftBukkit start
     public final int dimension;
@@ -224,7 +237,9 @@
         long time = this.worldData.getTime();
         if (this.getGameRules().getBoolean("doMobSpawning") && this.worldData.getType() != WorldType.DEBUG_ALL_BLOCK_STATES && (this.allowMonsters || this.allowAnimals) && (this instanceof WorldServer && this.players.size() > 0)) {
             timings.mobSpawn.startTiming(); // Spigot
-            this.spawnerCreature.a(this, this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldData.getTime() % 400L == 0L);
+            //this.spawnerCreature.a(this, this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldData.getTime() % 400L == 0L);
+            SpigotWorldConfig.TickTask = ForkJoinTask.adapt(new mobspawn(this, this.allowMonsters && (this.ticksPerMonsterSpawns != 0 && time % this.ticksPerMonsterSpawns == 0L), this.allowAnimals && (this.ticksPerAnimalSpawns != 0 && time % this.ticksPerAnimalSpawns == 0L), this.worldData.getTime() % 400L == 0L));
+            SpigotWorldConfig.TickPool.submit(SpigotWorldConfig.TickTask);
             timings.mobSpawn.stopTiming(); // Spigot
             // CraftBukkit end
         }
@@ -282,8 +297,19 @@
         return list != null && !list.isEmpty() ? (BiomeBase.BiomeMeta) WeightedRandom.a(this.random, list) : null;
     }
 
+    //forkjoin
     public boolean a(EnumCreatureType enumcreaturetype, BiomeBase.BiomeMeta biomebase_biomemeta, BlockPosition blockposition) {
-        List list = this.getChunkProviderServer().a(enumcreaturetype, blockposition);
+        //List list = this.getChunkProviderServer().a(enumcreaturetype, blockposition);
+        SpigotWorldConfig.TickTask = ForkJoinTask.adapt(new biometa(this, enumcreaturetype, blockposition));
+        SpigotWorldConfig.TickPool.submit(SpigotWorldConfig.TickTask);
+        List list = null;
+        try {
+            list = (List) SpigotWorldConfig.TickTask.get();
+        } catch (InterruptedException ex) {
+            java.util.logging.Logger.getLogger(WorldServer.class.getName()).log(Level.SEVERE, null, ex);
+        } catch (ExecutionException ex) {
+            java.util.logging.Logger.getLogger(WorldServer.class.getName()).log(Level.SEVERE, null, ex);
+        }
 
         return list != null && !list.isEmpty() ? list.contains(biomebase_biomemeta) : false;
     }
@@ -557,6 +583,7 @@
         this.a(blockposition, block, i, 0);
     }
 
+    //world.a
     public void a(BlockPosition blockposition, Block block, int i, int j) {
         if (blockposition instanceof BlockPosition.MutableBlockPosition || blockposition instanceof BlockPosition.PooledBlockPosition) {
             blockposition = new BlockPosition(blockposition);
@@ -591,12 +618,14 @@
 
             // CraftBukkit - use nextTickList
             if (!this.nextTickList.contains(nextticklistentry)) {
-                this.nextTickList.add(nextticklistentry);
+                //this.nextTickList.add(nextticklistentry);
+                this.nextTickQueue.add(nextticklistentry);
             }
         }
 
     }
-
+    
+    //world.b
     public void b(BlockPosition blockposition, Block block, int i, int j) {
         if (blockposition instanceof BlockPosition.MutableBlockPosition || blockposition instanceof BlockPosition.PooledBlockPosition) {
             blockposition = new BlockPosition(blockposition);
@@ -614,11 +643,13 @@
 
         // CraftBukkit - use nextTickList
         if (!this.nextTickList.contains(nextticklistentry)) {
-            this.nextTickList.add(nextticklistentry);
+            //this.nextTickList.add(nextticklistentry);
+            this.nextTickQueue.add(nextticklistentry);
         }
 
     }
-
+    
+    r rt;
     public void tickEntities() {
         if (false && this.players.isEmpty()) { // CraftBukkit - this prevents entity cleanup, other issues on servers with no players
             if (this.emptyTime++ >= 300) {
@@ -628,7 +659,9 @@
             this.m();
         }
 
-        this.worldProvider.r();
+        //this.worldProvider.r();
+        rt = new r();
+        rt.fork();
         super.tickEntities();
         spigotConfig.currentPrimedTnt = 0; // Spigot
     }
@@ -672,7 +705,8 @@
                     this.getChunkAt(j, k).b(entity);
                 }
 
-                this.entityList.remove(entity);
+                //this.entityList.remove(entity);
+                this.entityQueue.remove(entity);
                 this.c(entity);
             }
 
@@ -707,7 +741,18 @@
                 this.methodProfiler.a("cleaning");
 
                 NextTickListEntry nextticklistentry;
+                
+                this.nextTickList.parallelStream().forEach(ntle -> {
+                    if (!flag && ntle.b > this.worldData.getTime()) {
+                        return;
+                    }
 
+                    // CraftBukkit - use nextTickList
+                    this.nextTickList.remove(ntle);
+                    // this.nextTickListHash.remove(nextticklistentry);
+                    this.U.add(ntle);
+                });
+                /*
                 for (int j = 0; j < i; ++j) {
                     nextticklistentry = (NextTickListEntry) this.nextTickList.first();
                     if (!flag && nextticklistentry.b > this.worldData.getTime()) {
@@ -718,10 +763,57 @@
                     this.nextTickList.remove(nextticklistentry);
                     // this.nextTickListHash.remove(nextticklistentry);
                     this.U.add(nextticklistentry);
-                }
-
+                }*/
+                
                 this.methodProfiler.b();
                 this.methodProfiler.a("ticking");
+                
+                this.U.parallelStream().forEachOrdered(ntle -> {
+                    boolean flag1 = false;
+
+                    if (this.areChunksLoadedBetween(ntle.a.a(0, 0, 0), ntle.a.a(0, 0, 0))) {
+                        IBlockData iblockdata = this.getType(ntle.a);
+
+                        if (iblockdata.getMaterial() != Material.AIR && Block.a(iblockdata.getBlock(), ntle.a())) {
+                            try {
+                                iblockdata.getBlock().b((World) this, ntle.a, iblockdata, this.random);
+                            } catch (Throwable throwable) {
+                                CrashReport crashreport = CrashReport.a(throwable, "Exception while ticking a block");
+                                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being ticked");
+
+                                CrashReportSystemDetails.a(crashreportsystemdetails, ntle.a, iblockdata);
+                                throw new ReportedException(crashreport);
+                            }
+                        }
+                    } else {
+                        this.a(ntle.a, ntle.a(), 0);
+                    }
+                });
+                /*
+                while (!this.U.isEmpty()) {
+                    nextticklistentry = (NextTickListEntry) this.U.poll();
+                    boolean flag1 = false;
+
+                    if (this.areChunksLoadedBetween(nextticklistentry.a.a(0, 0, 0), nextticklistentry.a.a(0, 0, 0))) {
+                        IBlockData iblockdata = this.getType(nextticklistentry.a);
+
+                        if (iblockdata.getMaterial() != Material.AIR && Block.a(iblockdata.getBlock(), nextticklistentry.a())) {
+                            try {
+                                iblockdata.getBlock().b((World) this, nextticklistentry.a, iblockdata, this.random);
+                            } catch (Throwable throwable) {
+                                CrashReport crashreport = CrashReport.a(throwable, "Exception while ticking a block");
+                                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being ticked");
+
+                                CrashReportSystemDetails.a(crashreportsystemdetails, nextticklistentry.a, iblockdata);
+                                throw new ReportedException(crashreport);
+                            }
+                        }
+                    } else {
+                        this.a(nextticklistentry.a, nextticklistentry.a(), 0);
+                    }
+                    
+                }*/
+                /*
                 Iterator iterator = this.U.iterator();
 
                 while (iterator.hasNext()) {
@@ -746,7 +838,7 @@
                     } else {
                         this.a(nextticklistentry.a, nextticklistentry.a(), 0);
                     }
-                }
+                }*/
 
                 this.methodProfiler.b();
                 this.U.clear();
@@ -775,10 +867,61 @@
 
             if (i == 0) {
                 iterator = this.nextTickList.iterator();
+                while (iterator.hasNext()) {
+                    NextTickListEntry nextticklistentry = (NextTickListEntry) iterator.next();
+                    BlockPosition blockposition = nextticklistentry.a;
+
+                    if (blockposition.getX() >= structureboundingbox.a && blockposition.getX() < structureboundingbox.d && blockposition.getZ() >= structureboundingbox.c && blockposition.getZ() < structureboundingbox.f) {
+                        if (flag) {
+                            if (i == 0) {
+                                // this.nextTickListHash.remove(nextticklistentry); // CraftBukkit - removed
+                            }
+
+                            //iterator.remove();
+                            this.nextTickList_remove.add(nextticklistentry);
+                        }
+
+                        if (arraylist == null) {
+                            arraylist = Lists.newArrayList();
+                        }
+
+                        arraylist.add(nextticklistentry);
+                    }
+                }
+                if (!this.nextTickList_remove.isEmpty()){
+                    this.nextTickList.removeAll(this.nextTickList_remove);
+                    this.nextTickList_remove.clear();
+                }
             } else {
                 iterator = this.U.iterator();
-            }
+                while (iterator.hasNext()) {
+                    NextTickListEntry nextticklistentry = (NextTickListEntry) iterator.next();
+                    BlockPosition blockposition = nextticklistentry.a;
+
+                    if (blockposition.getX() >= structureboundingbox.a && blockposition.getX() < structureboundingbox.d && blockposition.getZ() >= structureboundingbox.c && blockposition.getZ() < structureboundingbox.f) {
+                        if (flag) {
+                            if (i == 0) {
+                                // this.nextTickListHash.remove(nextticklistentry); // CraftBukkit - removed
+                            }
+
+                            //iterator.remove();
+                            this.nextTickList_remove.add(nextticklistentry);
+                        }
 
+                        if (arraylist == null) {
+                            arraylist = Lists.newArrayList();
+                        }
+
+                        arraylist.add(nextticklistentry);
+                    }
+                }
+                if (!this.nextTickList_remove.isEmpty()){
+                    this.nextTickList.removeAll(this.nextTickList_remove);
+                    this.nextTickList_remove.clear();
+                }
+            }
+            
+            /*
             while (iterator.hasNext()) {
                 NextTickListEntry nextticklistentry = (NextTickListEntry) iterator.next();
                 BlockPosition blockposition = nextticklistentry.a;
@@ -798,7 +941,7 @@
 
                     arraylist.add(nextticklistentry);
                 }
-            }
+            }*/
         }
 
         return arraylist;
@@ -856,12 +999,15 @@
                 if (chunk == null) {
                     continue;
                 }
+                chunk.tileEntities.values().parallelStream().filter(tileentity -> (tileentity.position.getX() >= i) && (tileentity.position.getY() >= j) &&
+                    (tileentity.position.getZ() >= k) && (tileentity.position.getX() < l) && (tileentity.position.getY() < i1) && (tileentity.position.getZ() < j1)).forEach(tileentity -> arraylist.add(tileentity));
+                /*
                 for (Object te : chunk.tileEntities.values()) {
                     TileEntity tileentity = (TileEntity) te;
                     if ((tileentity.position.getX() >= i) && (tileentity.position.getY() >= j) && (tileentity.position.getZ() >= k) && (tileentity.position.getX() < l) && (tileentity.position.getY() < i1) && (tileentity.position.getZ() < j1)) {
                         arraylist.add(tileentity);
                     }
-                }
+                }*/
             }
         }
         /*
@@ -1077,16 +1223,23 @@
 
     public void a(Collection<Entity> collection) {
         ArrayList arraylist = Lists.newArrayList(collection);
+        
+        arraylist.parallelStream().filter(entity -> this.i((Entity)entity)).forEach(entity -> {
+            this.entityQueue.add((Entity)entity);
+            this.b((Entity)entity);
+        });
+        /*
         Iterator iterator = arraylist.iterator();
 
         while (iterator.hasNext()) {
             Entity entity = (Entity) iterator.next();
 
             if (this.i(entity)) {
-                this.entityList.add(entity);
+                //this.entityList.add(entity);
+                this.entityQueue.add(entity);
                 this.b(entity);
             }
-        }
+        }*/
 
     }
 
@@ -1389,4 +1542,47 @@
             this();
         }
     }
+    
+    class biometa implements Callable<List> {
+        WorldServer ws;
+        EnumCreatureType enumcreaturetype;
+        BlockPosition blockposition;
+        
+        biometa(WorldServer ws, EnumCreatureType enumcreaturetype, BlockPosition blockposition){
+            this.ws = ws;
+            this.enumcreaturetype = enumcreaturetype;
+            this.blockposition = blockposition;
+        }
+        
+        @Override
+        public List call() throws Exception {
+            return ws.getChunkProviderServer().a(enumcreaturetype, blockposition);
+        }
+    }
+    
+    class r extends RecursiveAction {
+        
+        @Override
+        protected void compute() {
+            worldProvider.r();
+        }
+    }
+    
+    class mobspawn implements Callable<Integer> {
+        WorldServer ws;
+        boolean flag, flag1, flag2;
+        
+        mobspawn(WorldServer ws, boolean flag, boolean flag1, boolean flag2){
+            this.ws = ws;
+            this.flag = flag;
+            this.flag1 = flag1;
+            this.flag2 = flag2;
+        }
+        
+        @Override
+        public Integer call() throws Exception {
+            return spawnerCreature.a(ws, flag, flag1, flag2);
+        }
+    }
+    
 }
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java src/main/java/org/bukkit/craftbukkit/CraftWorld.java
--- src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-08-25 04:49:44.494594309 +0800
+++ src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-08-25 16:43:40.887602367 +0800
@@ -613,7 +613,7 @@
 
     public List<Entity> getEntities() {
         List<Entity> list = new ArrayList<Entity>();
-
+        world.entityList = new ArrayList(world.entityQueue);
         for (Object o : world.entityList) {
             if (o instanceof net.minecraft.server.Entity) {
                 net.minecraft.server.Entity mcEnt = (net.minecraft.server.Entity) o;
@@ -631,7 +631,7 @@
 
     public List<LivingEntity> getLivingEntities() {
         List<LivingEntity> list = new ArrayList<LivingEntity>();
-
+        world.entityList = new ArrayList(world.entityQueue);
         for (Object o : world.entityList) {
             if (o instanceof net.minecraft.server.Entity) {
                 net.minecraft.server.Entity mcEnt = (net.minecraft.server.Entity) o;
@@ -656,7 +656,7 @@
     @SuppressWarnings("unchecked")
     public <T extends Entity> Collection<T> getEntitiesByClass(Class<T> clazz) {
         Collection<T> list = new ArrayList<T>();
-
+        world.entityList = new ArrayList(world.entityQueue);
         for (Object entity: world.entityList) {
             if (entity instanceof net.minecraft.server.Entity) {
                 Entity bukkitEntity = ((net.minecraft.server.Entity) entity).getBukkitEntity();
@@ -678,7 +678,7 @@
 
     public Collection<Entity> getEntitiesByClasses(Class<?>... classes) {
         Collection<Entity> list = new ArrayList<Entity>();
-
+        world.entityList = new ArrayList(world.entityQueue);
         for (Object entity: world.entityList) {
             if (entity instanceof net.minecraft.server.Entity) {
                 Entity bukkitEntity = ((net.minecraft.server.Entity) entity).getBukkitEntity();
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
--- src_origin/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java	2016-08-25 04:49:49.159594746 +0800
+++ src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java	2016-08-25 16:43:42.545602522 +0800
@@ -498,7 +498,8 @@
             } else if (source == DamageSource.HOT_FLOOR) {
                 cause = DamageCause.HOT_FLOOR;
             } else {
-                throw new IllegalStateException(String.format("Unhandled damage of %s by %s from %s", entity, damager, source.translationIndex));
+                //throw new IllegalStateException(String.format("Unhandled damage of %s by %s from %s", entity, damager, source.translationIndex));
+                cause = DamageCause.CONTACT;
             }
             EntityDamageEvent event = callEvent(new EntityDamageByBlockEvent(damager, entity.getBukkitEntity(), cause, modifiers, modifierFunctions));
             if (!event.isCancelled()) {
@@ -557,8 +558,8 @@
         if (cause != null) {
             return callEntityDamageEvent(null, entity, cause, modifiers, modifierFunctions);
         }
-
-        throw new IllegalStateException(String.format("Unhandled damage of %s from %s", entity, source.translationIndex));
+        return callEntityDamageEvent(null, entity, DamageCause.CONTACT, modifiers, modifierFunctions);
+        //throw new IllegalStateException(String.format("Unhandled damage of %s from %s", entity, source.translationIndex));
     }
 
     private static EntityDamageEvent callEntityDamageEvent(Entity damager, Entity damagee, DamageCause cause, Map<DamageModifier, Double> modifiers, Map<DamageModifier, Function<? super Double, Double>> modifierFunctions) {
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-08-25 04:49:50.193594842 +0800
+++ src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-08-25 16:43:43.529602614 +0800
@@ -5,12 +5,14 @@
 import java.util.Iterator;
 import java.util.Set;
 import java.util.TreeSet;
+import java.util.concurrent.ConcurrentSkipListSet;
 
 public class HashTreeSet<V> implements Set<V> {
 
     private HashSet<V> hash = new HashSet<V>();
-    private TreeSet<V> tree = new TreeSet<V>();
-
+    //private TreeSet<V> tree = new TreeSet<V>();
+    private ConcurrentSkipListSet<V> tree = new ConcurrentSkipListSet<V>();
+    
     public HashTreeSet() {
 
     }
@@ -111,7 +113,13 @@
     }
 
     public V first() {
-        return tree.first();
+        //return tree.first();
+        if (tree.first() != null) {
+            return tree.first();
+        } else {
+            this.remove(tree.first());
+            return this.first();
+        }
     }
 
 }
diff -Naur src_origin/main/java/org/spigotmc/ActivationRange.java src/main/java/org/spigotmc/ActivationRange.java
--- src_origin/main/java/org/spigotmc/ActivationRange.java	2016-08-25 04:49:37.760593679 +0800
+++ src/main/java/org/spigotmc/ActivationRange.java	2016-08-25 16:43:37.509602051 +0800
@@ -1,6 +1,7 @@
 package org.spigotmc;
 
 import java.util.List;
+import java.util.Queue;
 import java.util.Set;
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.Chunk;
@@ -141,7 +142,8 @@
      */
     private static void activateChunkEntities(Chunk chunk)
     {
-        for ( List<Entity> slice : chunk.entitySlices )
+        //for ( List<Entity> slice : chunk.entitySlices )
+        for ( Queue<Entity> slice : chunk.entitySlices )
         {
             for ( Entity entity : slice )
             {
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2016-08-25 04:49:37.752593678 +0800
+++ src/main/java/org/spigotmc/AsyncCatcher.java	2016-08-25 16:43:37.498602050 +0800
@@ -1,5 +1,6 @@
 package org.spigotmc;
 
+import java.util.concurrent.ForkJoinTask;
 import net.minecraft.server.MinecraftServer;
 
 public class AsyncCatcher
@@ -9,9 +10,13 @@
 
     public static void catchOp(String reason)
     {
+        /*
         if ( enabled && Thread.currentThread() != MinecraftServer.getServer().primaryThread )
         {
-            throw new IllegalStateException( "Asynchronous " + reason + "!" );
-        }
+            SpigotWorldConfig.TickTask = ForkJoinTask.adapt(Thread.currentThread());
+            SpigotWorldConfig.TickPool.submit(SpigotWorldConfig.TickTask);
+            //MinecraftServer.LOGGER.warn("Asynchronous " + reason + "!");
+            //throw new IllegalStateException( "Asynchronous " + reason + "!" );
+        }*/
     }
 }
diff -Naur src_origin/main/java/org/spigotmc/SpigotWorldConfig.java src/main/java/org/spigotmc/SpigotWorldConfig.java
--- src_origin/main/java/org/spigotmc/SpigotWorldConfig.java	2016-08-25 04:49:37.755593679 +0800
+++ src/main/java/org/spigotmc/SpigotWorldConfig.java	2016-08-25 16:43:37.512602051 +0800
@@ -1,11 +1,123 @@
 package org.spigotmc;
 
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.ForkJoinPool;
+import java.util.concurrent.ForkJoinTask;
+import java.util.concurrent.ForkJoinWorkerThread;
+import java.util.concurrent.ThreadFactory;
+import net.minecraft.server.Chunk;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
 public class SpigotWorldConfig
 {
+    //hose start
+    static public final int cpu_core = Runtime.getRuntime().availableProcessors();
+    /*
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fttp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("TileTickPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fmp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("MovePool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fpcp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("PlayerChunkPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };*/
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory ftp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("TickPool-" + thread.getPoolIndex());
+            //thread.setDaemon(true);
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkPool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    /*
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcfpt3 = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkFlushPool_T3-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    static final ForkJoinPool.ForkJoinWorkerThreadFactory fcpp = new ForkJoinPool.ForkJoinWorkerThreadFactory() {
+        @Override
+        public ForkJoinWorkerThread newThread(ForkJoinPool pool) {
+            final ForkJoinWorkerThread thread = ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);
+            thread.setName("ChunkPopulate_Pool-" + thread.getPoolIndex());
+            return thread;
+        }
+    };
+    
+    public static ForkJoinPool TileTickPool;
+    public static ForkJoinPool MovePool;
+    public static ForkJoinPool PlayerChunkPool;*/
+    public static ForkJoinTask<?> TickTask;
+    public static ForkJoinTask<Chunk> ChunkTask;
+    public static ForkJoinPool TickPool;
+    public static ForkJoinPool ChunkPool;
+    //public static ForkJoinPool ChunkPool;
+    
+    //static public FutureTask CollideTask;
+        
+    /*static final ThreadFactory tfcp = new ThreadFactoryBuilder().setNameFormat("Collide_Pool-%d").build();
+    static public final ExecutorService tickpool_executor = Executors.newFixedThreadPool(cpu_core, tfcp);*/
+    
+    public static int worldtickentitypool_core_multiple;
+    
+    public static int getthreadnumber(){
+        return cpu_core*worldtickentitypool_core_multiple;
+    }
+    
+    private void wetp_core_multiple()
+    {
+        worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 2);
+        //ChunkPool = new ForkJoinPool(getthreadnumber(), fcp, null, false);
+        
+        
+        TickPool = new ForkJoinPool(getthreadnumber(), ftp, null, false);
+        ChunkPool = new ForkJoinPool(getthreadnumber(), fcp, null, false);
+        /*
+        TileTickPool = new ForkJoinPool(getthreadnumber(), fttp, null, false);
+        MovePool = new ForkJoinPool(getthreadnumber(), fmp, null, false);
+        PlayerChunkPool = new ForkJoinPool(getthreadnumber(), fpcp, null, false);
+        
+        ChunkFlushPool_T3 = new ForkJoinPool(getthreadnumber(), fcfpt3, null, false);
+        ChunkPopulate_Pool = new ForkJoinPool(getthreadnumber(), fcpp, null, false);*/
+        //executor = new ThreadPoolExecutor(getthreadnumber(), getthreadnumber(), 1, TimeUnit.DAYS, queue);
+        log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
+    }
+    //hose end
 
     private final String worldName;
     private final YamlConfiguration config;
