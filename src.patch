diff -Naur src_origin/main/java/net/minecraft/server/AttributeModifiable.java src/main/java/net/minecraft/server/AttributeModifiable.java
--- src_origin/main/java/net/minecraft/server/AttributeModifiable.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/AttributeModifiable.java	2016-03-07 17:08:40.206614946 +0800
@@ -0,0 +1,168 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Maps;
+import com.google.common.collect.Sets;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentMap;
+
+public class AttributeModifiable implements AttributeInstance {
+
+    private final AttributeMapBase a;
+    private final IAttribute b;
+    /*private final Map<Integer, Set<AttributeModifier>> c = Maps.newHashMap();
+    private final Map<String, Set<AttributeModifier>> d = Maps.newHashMap();
+    private final Map<UUID, AttributeModifier> e = Maps.newHashMap();*/
+    private final ConcurrentMap<Integer, HashSet<AttributeModifier>> c = Maps.newConcurrentMap();
+    private final ConcurrentMap<String, HashSet<AttributeModifier>> d = Maps.newConcurrentMap();
+    private final ConcurrentMap<UUID, AttributeModifier> e = Maps.newConcurrentMap();
+    private double f;
+    private boolean g = true;
+    private double h;
+
+    public AttributeModifiable(AttributeMapBase attributemapbase, IAttribute iattribute) {
+        this.a = attributemapbase;
+        this.b = iattribute;
+        this.f = iattribute.b();
+
+        for (int i = 0; i < 3; ++i) {
+            //this.c.put(Integer.valueOf(i), Sets.newHashSet());
+            this.c.put(Integer.valueOf(i), new HashSet());
+        }
+
+    }
+
+    public IAttribute getAttribute() {
+        return this.b;
+    }
+
+    public double b() {
+        return this.f;
+    }
+
+    public void setValue(double d0) {
+        if (d0 != this.b()) {
+            this.f = d0;
+            this.f();
+        }
+    }
+
+    public Collection<AttributeModifier> a(int i) {
+        return (Collection) this.c.get(Integer.valueOf(i));
+    }
+
+    public Collection<AttributeModifier> c() {
+        HashSet hashset = Sets.newHashSet();
+
+        for (int i = 0; i < 3; ++i) {
+            hashset.addAll(this.a(i));
+        }
+
+        return hashset;
+    }
+
+    public AttributeModifier a(UUID uuid) {
+        return (AttributeModifier) this.e.get(uuid);
+    }
+
+    public boolean a(AttributeModifier attributemodifier) {
+        return this.e.get(attributemodifier.a()) != null;
+    }
+
+    public void b(AttributeModifier attributemodifier) {
+        if (this.a(attributemodifier.a()) != null) {
+            throw new IllegalArgumentException("Modifier is already applied on this attribute!");
+        } else {
+            //Object object = (Set) this.d.get(attributemodifier.b());
+            Object object = (HashSet) this.d.get(attributemodifier.b());
+
+            if (object == null) {
+                //object = Sets.newHashSet();
+                object = new HashSet();
+                //this.d.put(attributemodifier.b(), object);
+                this.d.put(attributemodifier.b(), (HashSet)object);
+            }
+
+            ((Set) this.c.get(Integer.valueOf(attributemodifier.c()))).add(attributemodifier);
+            ((Set) object).add(attributemodifier);
+            this.e.put(attributemodifier.a(), attributemodifier);
+            this.f();
+        }
+    }
+
+    protected void f() {
+        this.g = true;
+        this.a.a((AttributeInstance) this);
+    }
+
+    public void c(AttributeModifier attributemodifier) {
+        for (int i = 0; i < 3; ++i) {
+            Set set = (Set) this.c.get(Integer.valueOf(i));
+
+            set.remove(attributemodifier);
+        }
+
+        Set set1 = (Set) this.d.get(attributemodifier.b());
+
+        if (set1 != null) {
+            set1.remove(attributemodifier);
+            if (set1.isEmpty()) {
+                this.d.remove(attributemodifier.b());
+            }
+        }
+
+        this.e.remove(attributemodifier.a());
+        this.f();
+    }
+
+    public double getValue() {
+        if (this.g) {
+            this.h = this.g();
+            this.g = false;
+        }
+
+        return this.h;
+    }
+
+    private double g() {
+        double d0 = this.b();
+
+        AttributeModifier attributemodifier;
+
+        for (Iterator iterator = this.b(0).iterator(); iterator.hasNext(); d0 += attributemodifier.d()) {
+            attributemodifier = (AttributeModifier) iterator.next();
+        }
+
+        double d1 = d0;
+
+        Iterator iterator1;
+        AttributeModifier attributemodifier1;
+
+        for (iterator1 = this.b(1).iterator(); iterator1.hasNext(); d1 += d0 * attributemodifier1.d()) {
+            attributemodifier1 = (AttributeModifier) iterator1.next();
+        }
+
+        for (iterator1 = this.b(2).iterator(); iterator1.hasNext(); d1 *= 1.0D + attributemodifier1.d()) {
+            attributemodifier1 = (AttributeModifier) iterator1.next();
+        }
+
+        return this.b.a(d1);
+    }
+
+    private Collection<AttributeModifier> b(int i) {
+        HashSet hashset = Sets.newHashSet(this.a(i));
+
+        for (IAttribute iattribute = this.b.d(); iattribute != null; iattribute = iattribute.d()) {
+            AttributeInstance attributeinstance = this.a.a(iattribute);
+
+            if (attributeinstance != null) {
+                hashset.addAll(attributeinstance.a(i));
+            }
+        }
+
+        return hashset;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java src/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java
--- src_origin/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java	2016-02-26 15:27:07.267203267 +0800
+++ src/main/java/net/minecraft/server/BlockMinecartTrackAbstract.java	2016-03-07 17:08:40.866615008 +0800
@@ -3,6 +3,7 @@
 import com.google.common.collect.Lists;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 public abstract class BlockMinecartTrackAbstract extends Block {
 
@@ -247,7 +248,8 @@
         private final BlockMinecartTrackAbstract d;
         private IBlockData e;
         private final boolean f;
-        private final List<BlockPosition> g = Lists.newArrayList();
+        //private final List<BlockPosition> g = Lists.newArrayList();
+        private final List<BlockPosition> g = Lists.newCopyOnWriteArrayList();
 
         public MinecartTrackLogic(World world, BlockPosition blockposition, IBlockData iblockdata) {
             this.b = world;
diff -Naur src_origin/main/java/net/minecraft/server/BlockPiston.java src/main/java/net/minecraft/server/BlockPiston.java
--- src_origin/main/java/net/minecraft/server/BlockPiston.java	2016-02-26 15:27:07.429203282 +0800
+++ src/main/java/net/minecraft/server/BlockPiston.java	2016-03-07 17:08:41.029615023 +0800
@@ -4,11 +4,9 @@
 
 // CraftBukkit start
 import java.util.AbstractList;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.ListIterator;
 
 import com.google.common.collect.ImmutableList;
+import java.util.concurrent.CopyOnWriteArrayList;
 import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.event.block.BlockPistonRetractEvent;
 import org.bukkit.event.block.BlockPistonExtendEvent;
@@ -72,6 +70,7 @@
             if (!this.sticky) {
                 org.bukkit.block.Block block = world.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ());
                 BlockPistonRetractEvent event = new BlockPistonRetractEvent(block, ImmutableList.<org.bukkit.block.Block>of(), CraftBlock.notchToBlockFace(enumdirection));
+                event.setAsynchronous();
                 world.getServer().getPluginManager().callEvent(event);
 
                 if (event.isCancelled()) {
@@ -312,9 +311,11 @@
             // CraftBukkit start
             final org.bukkit.block.Block bblock = world.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ());
 
-            final List<BlockPosition> moved = pistonextendschecker.getMovedBlocks();
-            final List<BlockPosition> broken = pistonextendschecker.getBrokenBlocks();
-
+            /*final List<BlockPosition> moved = pistonextendschecker.getMovedBlocks();
+            final List<BlockPosition> broken = pistonextendschecker.getBrokenBlocks();*/
+            final CopyOnWriteArrayList<BlockPosition> moved = pistonextendschecker.getMovedBlocks();
+            final CopyOnWriteArrayList<BlockPosition> broken = pistonextendschecker.getBrokenBlocks();
+            
             List<org.bukkit.block.Block> blocks = new AbstractList<org.bukkit.block.Block>() {
 
                 @Override
diff -Naur src_origin/main/java/net/minecraft/server/BlockRedstoneTorch.java src/main/java/net/minecraft/server/BlockRedstoneTorch.java
--- src_origin/main/java/net/minecraft/server/BlockRedstoneTorch.java	2016-02-26 15:27:07.667203304 +0800
+++ src/main/java/net/minecraft/server/BlockRedstoneTorch.java	2016-03-07 17:08:41.243615043 +0800
@@ -1,7 +1,6 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
@@ -15,7 +14,8 @@
 
     private boolean a(World world, BlockPosition blockposition, boolean flag) {
         if (!BlockRedstoneTorch.b.containsKey(world)) {
-            BlockRedstoneTorch.b.put(world, Lists.<BlockRedstoneTorch.RedstoneUpdateInfo>newArrayList()); // CraftBukkit - fix decompile error
+            //BlockRedstoneTorch.b.put(world, Lists.<BlockRedstoneTorch.RedstoneUpdateInfo>newArrayList()); // CraftBukkit - fix decompile error
+            BlockRedstoneTorch.b.put(world, Lists.<BlockRedstoneTorch.RedstoneUpdateInfo>newCopyOnWriteArrayList()); // CraftBukkit - fix decompile error
         }
 
         List list = (List) BlockRedstoneTorch.b.get(world);
diff -Naur src_origin/main/java/net/minecraft/server/BlockRedstoneWire.java src/main/java/net/minecraft/server/BlockRedstoneWire.java
--- src_origin/main/java/net/minecraft/server/BlockRedstoneWire.java	2016-02-26 15:27:07.697203307 +0800
+++ src/main/java/net/minecraft/server/BlockRedstoneWire.java	2016-03-07 17:08:41.253615044 +0800
@@ -2,11 +2,16 @@
 
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
+import io.netty.util.internal.ConcurrentSet;
 import java.util.ArrayList;
 import java.util.EnumSet;
 import java.util.Iterator;
+import java.util.List;
+import java.util.Queue;
 import java.util.Random;
 import java.util.Set;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArraySet;
 
 import org.bukkit.event.block.BlockRedstoneEvent; // CraftBukkit
 
@@ -18,7 +23,8 @@
     public static final BlockStateEnum<BlockRedstoneWire.EnumRedstoneWireConnection> WEST = BlockStateEnum.of("west", BlockRedstoneWire.EnumRedstoneWireConnection.class);
     public static final BlockStateInteger POWER = BlockStateInteger.of("power", 0, 15);
     private boolean Q = true;
-    private final Set<BlockPosition> R = Sets.newHashSet();
+    //private final Set<BlockPosition> R = Sets.newHashSet();
+    private final ConcurrentSet<BlockPosition> R = new ConcurrentSet<BlockPosition>();
 
     public BlockRedstoneWire() {
         super(Material.ORIENTABLE);
@@ -65,7 +71,8 @@
 
     private IBlockData e(World world, BlockPosition blockposition, IBlockData iblockdata) {
         iblockdata = this.a(world, blockposition, blockposition, iblockdata);
-        ArrayList arraylist = Lists.newArrayList(this.R);
+        //ArrayList arraylist = Lists.newArrayList(this.R);
+        Queue arraylist = new ConcurrentLinkedQueue(this.R);
 
         this.R.clear();
         Iterator iterator = arraylist.iterator();
diff -Naur src_origin/main/java/net/minecraft/server/BlockSapling.java src/main/java/net/minecraft/server/BlockSapling.java
--- src_origin/main/java/net/minecraft/server/BlockSapling.java	2016-02-26 15:27:07.744203311 +0800
+++ src/main/java/net/minecraft/server/BlockSapling.java	2016-03-07 17:08:41.299615048 +0800
@@ -4,6 +4,9 @@
 
 // CraftBukkit start
 import java.util.List;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 import org.bukkit.Location;
 import org.bukkit.TreeType;
@@ -43,7 +46,9 @@
                     TreeType treeType = BlockSapling.treeType;
                     BlockSapling.treeType = null;
                     Location location = new Location(world.getWorld(), blockposition.getX(), blockposition.getY(), blockposition.getZ());
-                    List<BlockState> blocks = (List<BlockState>) world.capturedBlockStates.clone();
+                    //List<BlockState> blocks = (List<BlockState>) world.capturedBlockStates.clone();
+                    Queue<BlockState> blocks = new ConcurrentLinkedQueue<BlockState>();
+                    blocks.addAll((Queue<BlockState>) world.capturedBlockStates);
                     world.capturedBlockStates.clear();
                     StructureGrowEvent event = null;
                     if (treeType != null) {
diff -Naur src_origin/main/java/net/minecraft/server/ChatBaseComponent.java src/main/java/net/minecraft/server/ChatBaseComponent.java
--- src_origin/main/java/net/minecraft/server/ChatBaseComponent.java	2016-02-26 15:27:08.023203337 +0800
+++ src/main/java/net/minecraft/server/ChatBaseComponent.java	2016-03-07 17:08:41.546615071 +0800
@@ -8,7 +8,8 @@
 
 public abstract class ChatBaseComponent implements IChatBaseComponent {
 
-    protected List<IChatBaseComponent> a = Lists.newArrayList();
+    //protected List<IChatBaseComponent> a = Lists.newArrayList();
+    protected List<IChatBaseComponent> a = Lists.newCopyOnWriteArrayList();
     private ChatModifier b;
 
     public ChatBaseComponent() {}
diff -Naur src_origin/main/java/net/minecraft/server/Chunk.java src/main/java/net/minecraft/server/Chunk.java
--- src_origin/main/java/net/minecraft/server/Chunk.java	2016-02-26 15:27:08.084203343 +0800
+++ src/main/java/net/minecraft/server/Chunk.java	2016-03-07 17:08:41.599615076 +0800
@@ -1,13 +1,11 @@
 package net.minecraft.server;
 
 import com.google.common.base.Predicate;
-import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
 import java.util.Arrays;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
 import java.util.Random;
 import java.util.concurrent.Callable;
 import java.util.concurrent.ConcurrentLinkedQueue;
@@ -15,6 +13,9 @@
 import org.apache.logging.log4j.Logger;
 
 import com.google.common.collect.Lists; // CraftBukkit
+import java.util.Queue;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 import org.bukkit.Bukkit; // CraftBukkit
 
 public class Chunk {
@@ -30,8 +31,10 @@
     public final int locX;
     public final int locZ;
     private boolean k;
-    public final Map<BlockPosition, TileEntity> tileEntities;
-    public final List<Entity>[] entitySlices; // Spigot
+    //public final Map<BlockPosition, TileEntity> tileEntities;
+    public final ConcurrentMap<BlockPosition, TileEntity> tileEntities;
+    //public final List<Entity>[] entitySlices; // Spigot
+    public final Queue<Entity>[] entitySlices; // Spigot
     private boolean done;
     private boolean lit;
     private boolean p;
@@ -77,17 +80,20 @@
         this.e = new byte[256];
         this.f = new int[256];
         this.g = new boolean[256];
-        this.tileEntities = Maps.newHashMap();
+        //this.tileEntities = Maps.newHashMap();
+        this.tileEntities = new ConcurrentHashMap<BlockPosition, TileEntity>();
         this.v = 4096;
         this.w = Queues.newConcurrentLinkedQueue();
-        this.entitySlices = (List[]) (new List[16]); // Spigot
+        //this.entitySlices = (List[]) (new List[16]); // Spigot
+        this.entitySlices = (Queue[]) (new ConcurrentLinkedQueue[16]); // Spigot
         this.world = world;
         this.locX = i;
         this.locZ = j;
         this.heightMap = new int[256];
 
         for (int k = 0; k < this.entitySlices.length; ++k) {
-            this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            //this.entitySlices[k] = new org.bukkit.craftbukkit.util.UnsafeList(); // Spigot
+            this.entitySlices[k] = new ConcurrentLinkedQueue(); // Spigot
         }
 
         Arrays.fill(this.f, -999);
@@ -832,6 +838,7 @@
             if ( tileentity instanceof IInventory )
             {
                 for ( org.bukkit.entity.HumanEntity h : Lists.<org.bukkit.entity.HumanEntity>newArrayList((List<org.bukkit.entity.HumanEntity>) ( (IInventory) tileentity ).getViewers() ) )
+                //for ( org.bukkit.entity.HumanEntity h : Lists.<org.bukkit.entity.HumanEntity>newCopyOnWriteArrayList((List<org.bukkit.entity.HumanEntity>) ( (IInventory) tileentity ).getViewers() ) )
                 {
                     if ( h instanceof org.bukkit.craftbukkit.entity.CraftHumanEntity )
                     {
@@ -846,7 +853,8 @@
 
         for (int i = 0; i < this.entitySlices.length; ++i) {
             // CraftBukkit start
-            List<Entity> newList = Lists.newArrayList(this.entitySlices[i]);
+            //List<Entity> newList = Lists.newArrayList(this.entitySlices[i]);
+            Queue<Entity> newList = new ConcurrentLinkedQueue<Entity>(this.entitySlices[i]);
             java.util.Iterator<Entity> iter = newList.iterator();
             while (iter.hasNext()) {
                 Entity entity = iter.next();
@@ -956,7 +964,7 @@
     public boolean isEmpty() {
         return false;
     }
-
+    
     public void loadNearby(IChunkProvider ichunkprovider, IChunkProvider ichunkprovider1, int i, int j) {
         world.timings.syncChunkLoadPostTimer.startTiming(); // Spigot
         boolean flag = ichunkprovider.isChunkLoaded(i, j - 1);
@@ -1305,11 +1313,13 @@
         }
     }
 
-    public Map<BlockPosition, TileEntity> getTileEntities() {
+    //public Map<BlockPosition, TileEntity> getTileEntities() {
+    public ConcurrentMap<BlockPosition, TileEntity> getTileEntities() {
         return this.tileEntities;
     }
 
-    public List<Entity>[] getEntitySlices() {
+    public Queue<Entity>[] getEntitySlices() {
+    //public List<Entity>[] getEntitySlices() {
         return this.entitySlices;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderGenerate.java src/main/java/net/minecraft/server/ChunkProviderGenerate.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderGenerate.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderGenerate.java	2016-03-07 17:08:41.603615077 +0800
@@ -0,0 +1,499 @@
+package net.minecraft.server;
+
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.FutureTask;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.hose.GetChunkATPool;
+import org.hose.GetCreateChunkPool;
+import org.spigotmc.SpigotWorldConfig;
+
+public class ChunkProviderGenerate implements IChunkProvider {
+
+    private Random h;
+    private NoiseGeneratorOctaves i;
+    private NoiseGeneratorOctaves j;
+    private NoiseGeneratorOctaves k;
+    private NoiseGenerator3 l;
+    public NoiseGeneratorOctaves a;
+    public NoiseGeneratorOctaves b;
+    public NoiseGeneratorOctaves c;
+    private World m;
+    private final boolean n;
+    private WorldType o;
+    private final double[] p;
+    private final float[] q;
+    private CustomWorldSettingsFinal r;
+    private Block s;
+    private double[] t;
+    private WorldGenBase u;
+    private WorldGenStronghold v;
+    private WorldGenVillage w;
+    private WorldGenMineshaft x;
+    private WorldGenLargeFeature y;
+    private WorldGenBase z;
+    private WorldGenMonument A;
+    private BiomeBase[] B;
+    double[] d;
+    double[] e;
+    double[] f;
+    double[] g;
+
+    public ChunkProviderGenerate(World world, long i, boolean flag, String s) {
+        this.s = Blocks.WATER;
+        this.t = new double[256];
+        this.u = new WorldGenCaves();
+        this.v = new WorldGenStronghold();
+        this.w = new WorldGenVillage();
+        this.x = new WorldGenMineshaft();
+        this.y = new WorldGenLargeFeature();
+        this.z = new WorldGenCanyon();
+        this.A = new WorldGenMonument();
+        this.m = world;
+        this.n = flag;
+        this.o = world.getWorldData().getType();
+        this.h = new Random(i);
+        this.i = new NoiseGeneratorOctaves(this.h, 16);
+        this.j = new NoiseGeneratorOctaves(this.h, 16);
+        this.k = new NoiseGeneratorOctaves(this.h, 8);
+        this.l = new NoiseGenerator3(this.h, 4);
+        this.a = new NoiseGeneratorOctaves(this.h, 10);
+        this.b = new NoiseGeneratorOctaves(this.h, 16);
+        this.c = new NoiseGeneratorOctaves(this.h, 8);
+        this.p = new double[825];
+        this.q = new float[25];
+
+        for (int j = -2; j <= 2; ++j) {
+            for (int k = -2; k <= 2; ++k) {
+                float f = 10.0F / MathHelper.c((float) (j * j + k * k) + 0.2F);
+
+                this.q[j + 2 + (k + 2) * 5] = f;
+            }
+        }
+
+        if (s != null) {
+            this.r = CustomWorldSettingsFinal.CustomWorldSettings.a(s).b();
+            this.s = this.r.E ? Blocks.LAVA : Blocks.WATER;
+            world.b(this.r.q);
+        }
+
+    }
+
+    public void a(int i, int j, ChunkSnapshot chunksnapshot) {
+        this.B = this.m.getWorldChunkManager().getBiomes(this.B, i * 4 - 2, j * 4 - 2, 10, 10);
+        this.a(i * 4, 0, j * 4);
+
+        for (int k = 0; k < 4; ++k) {
+            int l = k * 5;
+            int i1 = (k + 1) * 5;
+
+            for (int j1 = 0; j1 < 4; ++j1) {
+                int k1 = (l + j1) * 33;
+                int l1 = (l + j1 + 1) * 33;
+                int i2 = (i1 + j1) * 33;
+                int j2 = (i1 + j1 + 1) * 33;
+
+                for (int k2 = 0; k2 < 32; ++k2) {
+                    double d0 = 0.125D;
+                    double d1 = this.p[k1 + k2];
+                    double d2 = this.p[l1 + k2];
+                    double d3 = this.p[i2 + k2];
+                    double d4 = this.p[j2 + k2];
+                    double d5 = (this.p[k1 + k2 + 1] - d1) * d0;
+                    double d6 = (this.p[l1 + k2 + 1] - d2) * d0;
+                    double d7 = (this.p[i2 + k2 + 1] - d3) * d0;
+                    double d8 = (this.p[j2 + k2 + 1] - d4) * d0;
+
+                    for (int l2 = 0; l2 < 8; ++l2) {
+                        double d9 = 0.25D;
+                        double d10 = d1;
+                        double d11 = d2;
+                        double d12 = (d3 - d1) * d9;
+                        double d13 = (d4 - d2) * d9;
+
+                        for (int i3 = 0; i3 < 4; ++i3) {
+                            double d14 = 0.25D;
+                            double d15 = (d11 - d10) * d14;
+                            double d16 = d10 - d15;
+
+                            for (int j3 = 0; j3 < 4; ++j3) {
+                                if ((d16 += d15) > 0.0D) {
+                                    chunksnapshot.a(k * 4 + i3, k2 * 8 + l2, j1 * 4 + j3, Blocks.STONE.getBlockData());
+                                } else if (k2 * 8 + l2 < this.r.q) {
+                                    chunksnapshot.a(k * 4 + i3, k2 * 8 + l2, j1 * 4 + j3, this.s.getBlockData());
+                                }
+                            }
+
+                            d10 += d12;
+                            d11 += d13;
+                        }
+
+                        d1 += d5;
+                        d2 += d6;
+                        d3 += d7;
+                        d4 += d8;
+                    }
+                }
+            }
+        }
+
+    }
+
+    public void a(int i, int j, ChunkSnapshot chunksnapshot, BiomeBase[] abiomebase) {
+        double d0 = 0.03125D;
+
+        this.t = this.l.a(this.t, (double) (i * 16), (double) (j * 16), 16, 16, d0 * 2.0D, d0 * 2.0D, 1.0D);
+
+        for (int k = 0; k < 16; ++k) {
+            for (int l = 0; l < 16; ++l) {
+                BiomeBase biomebase = abiomebase[l + k * 16];
+
+                biomebase.a(this.m, this.h, chunksnapshot, i * 16 + k, j * 16 + l, this.t[l + k * 16]);
+            }
+        }
+
+    }
+    
+    public Chunk getOrCreateChunk(int i, int j) {
+        //return getOrCreateChunk_hose(i, j);
+        SpigotWorldConfig.GetCreateChunkTask = new FutureTask(new GetCreateChunkPool(this, i, j));
+        SpigotWorldConfig.getcreatechunkatpool_executor.submit(SpigotWorldConfig.GetCreateChunkTask);
+        try {
+            return SpigotWorldConfig.GetCreateChunkTask.get();
+        } catch (InterruptedException ex) {
+            Logger.getLogger(ChunkProviderGenerate.class.getName()).log(Level.SEVERE, null, ex);
+        } catch (ExecutionException ex) {
+            Logger.getLogger(ChunkProviderGenerate.class.getName()).log(Level.SEVERE, null, ex);
+        }
+        return null;
+    }
+    
+    public Chunk getOrCreateChunk_hose(int i, int j) {
+        this.h.setSeed((long) i * 341873128712L + (long) j * 132897987541L);
+        ChunkSnapshot chunksnapshot = new ChunkSnapshot();
+
+        this.a(i, j, chunksnapshot);
+        this.B = this.m.getWorldChunkManager().getBiomeBlock(this.B, i * 16, j * 16, 16, 16);
+        this.a(i, j, chunksnapshot, this.B);
+        if (this.r.r) {
+            this.u.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.z) {
+            this.z.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.w && this.n) {
+            this.x.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.v && this.n) {
+            this.w.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.u && this.n) {
+            this.v.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.x && this.n) {
+            this.y.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        if (this.r.y && this.n) {
+            this.A.a(this, this.m, i, j, chunksnapshot);
+        }
+
+        Chunk chunk = new Chunk(this.m, chunksnapshot, i, j);
+        byte[] abyte = chunk.getBiomeIndex();
+
+        for (int k = 0; k < abyte.length; ++k) {
+            abyte[k] = (byte) this.B[k].id;
+        }
+
+        chunk.initLighting();
+        return chunk;
+    }
+
+    private void a(int i, int j, int k) {
+        this.g = this.b.a(this.g, i, k, 5, 5, (double) this.r.e, (double) this.r.f, (double) this.r.g);
+        float f = this.r.a;
+        float f1 = this.r.b;
+
+        this.d = this.k.a(this.d, i, j, k, 5, 33, 5, (double) (f / this.r.h), (double) (f1 / this.r.i), (double) (f / this.r.j));
+        this.e = this.i.a(this.e, i, j, k, 5, 33, 5, (double) f, (double) f1, (double) f);
+        this.f = this.j.a(this.f, i, j, k, 5, 33, 5, (double) f, (double) f1, (double) f);
+        boolean flag = false;
+        boolean flag1 = false;
+        int l = 0;
+        int i1 = 0;
+
+        for (int j1 = 0; j1 < 5; ++j1) {
+            for (int k1 = 0; k1 < 5; ++k1) {
+                float f2 = 0.0F;
+                float f3 = 0.0F;
+                float f4 = 0.0F;
+                byte b0 = 2;
+                BiomeBase biomebase = this.B[j1 + 2 + (k1 + 2) * 10];
+
+                for (int l1 = -b0; l1 <= b0; ++l1) {
+                    for (int i2 = -b0; i2 <= b0; ++i2) {
+                        BiomeBase biomebase1 = this.B[j1 + l1 + 2 + (k1 + i2 + 2) * 10];
+                        float f5 = this.r.n + biomebase1.an * this.r.m;
+                        float f6 = this.r.p + biomebase1.ao * this.r.o;
+
+                        if (this.o == WorldType.AMPLIFIED && f5 > 0.0F) {
+                            f5 = 1.0F + f5 * 2.0F;
+                            f6 = 1.0F + f6 * 4.0F;
+                        }
+
+                        float f7 = this.q[l1 + 2 + (i2 + 2) * 5] / (f5 + 2.0F);
+
+                        if (biomebase1.an > biomebase.an) {
+                            f7 /= 2.0F;
+                        }
+
+                        f2 += f6 * f7;
+                        f3 += f5 * f7;
+                        f4 += f7;
+                    }
+                }
+
+                f2 /= f4;
+                f3 /= f4;
+                f2 = f2 * 0.9F + 0.1F;
+                f3 = (f3 * 4.0F - 1.0F) / 8.0F;
+                double d0 = this.g[i1] / 8000.0D;
+
+                if (d0 < 0.0D) {
+                    d0 = -d0 * 0.3D;
+                }
+
+                d0 = d0 * 3.0D - 2.0D;
+                if (d0 < 0.0D) {
+                    d0 /= 2.0D;
+                    if (d0 < -1.0D) {
+                        d0 = -1.0D;
+                    }
+
+                    d0 /= 1.4D;
+                    d0 /= 2.0D;
+                } else {
+                    if (d0 > 1.0D) {
+                        d0 = 1.0D;
+                    }
+
+                    d0 /= 8.0D;
+                }
+
+                ++i1;
+                double d1 = (double) f3;
+                double d2 = (double) f2;
+
+                d1 += d0 * 0.2D;
+                d1 = d1 * (double) this.r.k / 8.0D;
+                double d3 = (double) this.r.k + d1 * 4.0D;
+
+                for (int j2 = 0; j2 < 33; ++j2) {
+                    double d4 = ((double) j2 - d3) * (double) this.r.l * 128.0D / 256.0D / d2;
+
+                    if (d4 < 0.0D) {
+                        d4 *= 4.0D;
+                    }
+
+                    double d5 = this.e[l] / (double) this.r.d;
+                    double d6 = this.f[l] / (double) this.r.c;
+                    double d7 = (this.d[l] / 10.0D + 1.0D) / 2.0D;
+                    double d8 = MathHelper.b(d5, d6, d7) - d4;
+
+                    if (j2 > 29) {
+                        double d9 = (double) ((float) (j2 - 29) / 3.0F);
+
+                        d8 = d8 * (1.0D - d9) + -10.0D * d9;
+                    }
+
+                    this.p[l] = d8;
+                    ++l;
+                }
+            }
+        }
+
+    }
+
+    public boolean isChunkLoaded(int i, int j) {
+        return true;
+    }
+   
+    public void getChunkAt(IChunkProvider ichunkprovider, int i, int j) {
+        //getChunkAt_hose(ichunkprovider, i, j);
+        SpigotWorldConfig.GetChunkATTask = new FutureTask(new GetChunkATPool(this, ichunkprovider, i, j));
+        SpigotWorldConfig.getchunkatpool_executor.submit(SpigotWorldConfig.GetChunkATTask);
+    }
+    
+    public void getChunkAt_hose(IChunkProvider ichunkprovider, int i, int j) {
+        BlockFalling.instaFall = true;
+        int k = i * 16;
+        int l = j * 16;
+        BlockPosition blockposition = new BlockPosition(k, 0, l);
+        BiomeBase biomebase = this.m.getBiome(blockposition.a(16, 0, 16));
+
+        this.h.setSeed(this.m.getSeed());
+        long i1 = this.h.nextLong() / 2L * 2L + 1L;
+        long j1 = this.h.nextLong() / 2L * 2L + 1L;
+
+        this.h.setSeed((long) i * i1 + (long) j * j1 ^ this.m.getSeed());
+        boolean flag = false;
+        ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i, j);
+
+        if (this.r.w && this.n) {
+            this.x.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        if (this.r.v && this.n) {
+            flag = this.w.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        if (this.r.u && this.n) {
+            this.v.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        if (this.r.x && this.n) {
+            this.y.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        if (this.r.y && this.n) {
+            this.A.a(this.m, this.h, chunkcoordintpair);
+        }
+
+        int k1;
+        int l1;
+        int i2;
+
+        if (biomebase != BiomeBase.DESERT && biomebase != BiomeBase.DESERT_HILLS && this.r.A && !flag && this.h.nextInt(this.r.B) == 0) {
+            k1 = this.h.nextInt(16) + 8;
+            l1 = this.h.nextInt(256);
+            i2 = this.h.nextInt(16) + 8;
+            (new WorldGenLakes(Blocks.WATER)).generate(this.m, this.h, blockposition.a(k1, l1, i2));
+        }
+
+        if (!flag && this.h.nextInt(this.r.D / 10) == 0 && this.r.C) {
+            k1 = this.h.nextInt(16) + 8;
+            l1 = this.h.nextInt(this.h.nextInt(248) + 8);
+            i2 = this.h.nextInt(16) + 8;
+            if (l1 < this.m.F() || this.h.nextInt(this.r.D / 8) == 0) {
+                (new WorldGenLakes(Blocks.LAVA)).generate(this.m, this.h, blockposition.a(k1, l1, i2));
+            }
+        }
+
+        if (this.r.s) {
+            for (k1 = 0; k1 < this.r.t; ++k1) {
+                l1 = this.h.nextInt(16) + 8;
+                i2 = this.h.nextInt(256);
+                int j2 = this.h.nextInt(16) + 8;
+
+                (new WorldGenDungeons()).generate(this.m, this.h, blockposition.a(l1, i2, j2));
+            }
+        }
+
+        biomebase.a(this.m, this.h, new BlockPosition(k, 0, l));
+        SpawnerCreature.a(this.m, biomebase, k + 8, l + 8, 16, 16, this.h);
+        blockposition = blockposition.a(8, 0, 8);
+
+        for (k1 = 0; k1 < 16; ++k1) {
+            for (l1 = 0; l1 < 16; ++l1) {
+                BlockPosition blockposition1 = this.m.q(blockposition.a(k1, 0, l1));
+                BlockPosition blockposition2 = blockposition1.down();
+
+                if (this.m.v(blockposition2)) {
+                    this.m.setTypeAndData(blockposition2, Blocks.ICE.getBlockData(), 2);
+                }
+
+                if (this.m.f(blockposition1, true)) {
+                    this.m.setTypeAndData(blockposition1, Blocks.SNOW_LAYER.getBlockData(), 2);
+                }
+            }
+        }
+
+        BlockFalling.instaFall = false;
+    }
+
+    public boolean a(IChunkProvider ichunkprovider, Chunk chunk, int i, int j) {
+        boolean flag = false;
+
+        if (this.r.y && this.n && chunk.w() < 3600L) {
+            flag |= this.A.a(this.m, this.h, new ChunkCoordIntPair(i, j));
+        }
+
+        return flag;
+    }
+
+    public boolean saveChunks(boolean flag, IProgressUpdate iprogressupdate) {
+        return true;
+    }
+
+    public void c() {}
+
+    public boolean unloadChunks() {
+        return false;
+    }
+
+    public boolean canSave() {
+        return true;
+    }
+
+    public String getName() {
+        return "RandomLevelSource";
+    }
+
+    public List<BiomeBase.BiomeMeta> getMobsFor(EnumCreatureType enumcreaturetype, BlockPosition blockposition) {
+        BiomeBase biomebase = this.m.getBiome(blockposition);
+
+        if (this.n) {
+            if (enumcreaturetype == EnumCreatureType.MONSTER && this.y.a(blockposition)) {
+                return this.y.b();
+            }
+
+            if (enumcreaturetype == EnumCreatureType.MONSTER && this.r.y && this.A.a(this.m, blockposition)) {
+                return this.A.b();
+            }
+        }
+
+        return biomebase.getMobs(enumcreaturetype);
+    }
+
+    public BlockPosition findNearestMapFeature(World world, String s, BlockPosition blockposition) {
+        return "Stronghold".equals(s) && this.v != null ? this.v.getNearestGeneratedFeature(world, blockposition) : null;
+    }
+
+    public int getLoadedChunks() {
+        return 0;
+    }
+
+    public void recreateStructures(Chunk chunk, int i, int j) {
+        if (this.r.w && this.n) {
+            this.x.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+        if (this.r.v && this.n) {
+            this.w.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+        if (this.r.u && this.n) {
+            this.v.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+        if (this.r.x && this.n) {
+            this.y.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+        if (this.r.y && this.n) {
+            this.A.a(this, this.m, i, j, (ChunkSnapshot) null);
+        }
+
+    }
+
+    public Chunk getChunkAt(BlockPosition blockposition) {
+        return this.getOrCreateChunk(blockposition.getX() >> 4, blockposition.getZ() >> 4);
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/ChunkProviderServer.java src/main/java/net/minecraft/server/ChunkProviderServer.java
--- src_origin/main/java/net/minecraft/server/ChunkProviderServer.java	2016-02-26 15:27:08.093203344 +0800
+++ src/main/java/net/minecraft/server/ChunkProviderServer.java	2016-03-07 17:08:41.645615081 +0800
@@ -1,37 +1,35 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Lists;
+import io.netty.util.internal.chmv8.ConcurrentHashMapV8;
 import java.io.IOException;
-import java.util.ArrayList;
-import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Set;
-import java.util.concurrent.ConcurrentHashMap;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start
 import java.util.Random;
-import java.util.logging.Level;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.bukkit.Server;
 import org.bukkit.craftbukkit.chunkio.ChunkIOExecutor;
 import org.bukkit.craftbukkit.util.LongHash;
 import org.bukkit.craftbukkit.util.LongHashSet;
-import org.bukkit.craftbukkit.util.LongObjectHashMap;
+import org.bukkit.event.Event;
 import org.bukkit.event.world.ChunkUnloadEvent;
 // CraftBukkit end
 
 public class ChunkProviderServer implements IChunkProvider {
 
     private static final Logger b = LogManager.getLogger();
-    public LongHashSet unloadQueue = new LongHashSet(); // CraftBukkit - LongHashSet
+    //public LongHashSet unloadQueue = new LongHashSet(); // CraftBukkit - LongHashSet
+    public ConcurrentHashMapV8<Long, Long> unloadQueue = new ConcurrentHashMapV8<Long, Long>(); // CraftBukkit
     public Chunk emptyChunk;
     public IChunkProvider chunkProvider;
     private IChunkLoader chunkLoader;
     public boolean forceChunkLoad = false; // CraftBukkit - true -> false
-    public LongObjectHashMap<Chunk> chunks = new LongObjectHashMap<Chunk>();
+    //public LongObjectHashMap<Chunk> chunks = new LongObjectHashMap<Chunk>();
+    public ConcurrentHashMap<Long, Chunk> chunks = new ConcurrentHashMap<Long, Chunk>();
     public WorldServer world;
 
     public ChunkProviderServer(WorldServer worldserver, IChunkLoader ichunkloader, IChunkProvider ichunkprovider) {
@@ -42,10 +40,13 @@
     }
 
     public boolean isChunkLoaded(int i, int j) {
+        //return this.chunks.containsKey(LongHash.toLong(i, j)); // CraftBukkit
+        //System.out.println(this.chunks.size()+","+this.chunks.values().size());
         return this.chunks.containsKey(LongHash.toLong(i, j)); // CraftBukkit
     }
 
     // CraftBukkit start - Change return type to Collection and return the values of our chunk map
+    //public java.util.Collection a() {
     public java.util.Collection a() {
         // return this.chunkList;
         return this.chunks.values();
@@ -53,12 +54,15 @@
     }
 
     public void queueUnload(int i, int j) {
+        long key = LongHash.toLong(i, j);
         if (this.world.worldProvider.e()) {
             if (!this.world.c(i, j)) {
                 // CraftBukkit start
-                this.unloadQueue.add(i, j);
+                //this.unloadQueue.add(i, j);
+                this.unloadQueue.put(key, key);
 
-                Chunk c = chunks.get(LongHash.toLong(i, j));
+                //Chunk c = chunks.get(LongHash.toLong(i, j));
+                Chunk c = chunks.get(key);
                 if (c != null) {
                     c.mustSave = true;
                 }
@@ -66,9 +70,11 @@
             }
         } else {
             // CraftBukkit start
-            this.unloadQueue.add(i, j);
+            //this.unloadQueue.add(i, j);
+            this.unloadQueue.put(key, key);
 
-            Chunk c = chunks.get(LongHash.toLong(i, j));
+            //Chunk c = chunks.get(LongHash.toLong(i, j));
+            Chunk c = chunks.get(key);
             if (c != null) {
                 c.mustSave = true;
             }
@@ -85,21 +91,26 @@
 
             this.queueUnload(chunk.locX, chunk.locZ);
         }
-
+        
     }
 
     // CraftBukkit start - Add async variant, provide compatibility
     public Chunk getChunkIfLoaded(int x, int z) {
+        //return chunks.get(LongHash.toLong(x, z));
         return chunks.get(LongHash.toLong(x, z));
     }
 
     public Chunk getChunkAt(int i, int j) {
         return getChunkAt(i, j, null);
     }
-
-    public Chunk getChunkAt(int i, int j, Runnable runnable) {
-        unloadQueue.remove(i, j);
-        Chunk chunk = chunks.get(LongHash.toLong(i, j));
+    
+    synchronized public Chunk getChunkAt(int i, int j, Runnable runnable) {
+    //public Chunk getChunkAt(int i, int j, Runnable runnable) {
+        long key = LongHash.toLong(i, j);
+        //unloadQueue.remove(i, j);
+        unloadQueue.remove(key);
+        //Chunk chunk = chunks.get(LongHash.toLong(i, j));
+        Chunk chunk = chunks.get(key);
         ChunkRegionLoader loader = null;
 
         if (this.chunkLoader instanceof ChunkRegionLoader) {
@@ -126,8 +137,11 @@
         return chunk;
     }
     public Chunk originalGetChunkAt(int i, int j) {
-        this.unloadQueue.remove(i, j);
-        Chunk chunk = (Chunk) this.chunks.get(LongHash.toLong(i, j));
+        long key = LongHash.toLong(i, j);
+        //this.unloadQueue.remove(i, j);
+        this.unloadQueue.remove(key);
+        //Chunk chunk = (Chunk) this.chunks.get(LongHash.toLong(i, j));
+        Chunk chunk = (Chunk) this.chunks.get(key);
         boolean newChunk = false;
         // CraftBukkit end
 
@@ -152,7 +166,8 @@
                 }
                 newChunk = true; // CraftBukkit
             }
-
+            
+            //this.chunks.put(LongHash.toLong(i, j), chunk);
             this.chunks.put(LongHash.toLong(i, j), chunk);
             
             chunk.addEntities();
@@ -165,7 +180,10 @@
                  * the World constructor. We can't reliably alter that, so we have
                  * no way of creating a CraftWorld/CraftServer at that point.
                  */
-                server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, newChunk));
+                //server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, newChunk));
+                Event ev = new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, newChunk);
+                ev.setAsynchronous();
+                server.getPluginManager().callEvent(ev);
             }
 
             // Update neighbor counts
@@ -192,6 +210,7 @@
 
     public Chunk getOrCreateChunk(int i, int j) {
         // CraftBukkit start
+        //Chunk chunk = (Chunk) this.chunks.get(LongHash.toLong(i, j));
         Chunk chunk = (Chunk) this.chunks.get(LongHash.toLong(i, j));
 
         chunk = chunk == null ? (!this.world.ad() && !this.forceChunkLoad ? this.emptyChunk : this.getChunkAt(i, j)) : chunk;
@@ -286,7 +305,10 @@
                     }
                 }
                 BlockSand.instaFall = false;
-                this.world.getServer().getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(chunk.bukkitChunk));
+                //this.world.getServer().getPluginManager().callEvent(new org.bukkit.event.world.ChunkPopulateEvent(chunk.bukkitChunk));
+                Event ev = new org.bukkit.event.world.ChunkPopulateEvent(chunk.bukkitChunk);
+                ev.setAsynchronous();
+                this.world.getServer().getPluginManager().callEvent(ev);
                 // CraftBukkit end
                 
                 chunk.e();
@@ -344,11 +366,16 @@
             // CraftBukkit start
             Server server = this.world.getServer();
             for (int i = 0; i < 100 && !this.unloadQueue.isEmpty(); ++i) {
-                long chunkcoordinates = this.unloadQueue.popFirst();
+                //long chunkcoordinates = this.unloadQueue.popFirst();
+                long chunkcoordinates = this.unloadQueue.entrySet().iterator().next().getKey();
+                //remove after get it
+                this.unloadQueue.remove(chunkcoordinates);
                 Chunk chunk = this.chunks.get(chunkcoordinates);
                 if (chunk == null) continue;
 
                 ChunkUnloadEvent event = new ChunkUnloadEvent(chunk.bukkitChunk);
+                //set event async
+                event.setAsynchronous();
                 server.getPluginManager().callEvent(event);
                 if (!event.isCancelled()) {
 
@@ -356,9 +383,10 @@
                         chunk.removeEntities();
                         this.saveChunk(chunk);
                         this.saveChunkNOP(chunk);
+                        //this.chunks.remove(chunkcoordinates); // CraftBukkit
                         this.chunks.remove(chunkcoordinates); // CraftBukkit
                     }
-
+                    
                     // this.unloadQueue.remove(olong);
 
                     // Update neighbor counts
diff -Naur src_origin/main/java/net/minecraft/server/CommandSpreadPlayers.java src/main/java/net/minecraft/server/CommandSpreadPlayers.java
--- src_origin/main/java/net/minecraft/server/CommandSpreadPlayers.java	2016-02-26 15:27:08.290203362 +0800
+++ src/main/java/net/minecraft/server/CommandSpreadPlayers.java	2016-03-07 17:08:41.812615096 +0800
@@ -40,6 +40,7 @@
             double d4 = a(astring[i++], d3 + 1.0D);
             boolean flag = d(astring[i++]);
             ArrayList arraylist = Lists.newArrayList();
+            //List arraylist = Lists.newCopyOnWriteArrayList();
 
             while (i < astring.length) {
                 String s = astring[i++];
diff -Naur src_origin/main/java/net/minecraft/server/Container.java src/main/java/net/minecraft/server/Container.java
--- src_origin/main/java/net/minecraft/server/Container.java	2016-02-26 15:27:08.349203368 +0800
+++ src/main/java/net/minecraft/server/Container.java	2016-03-07 17:08:41.863615101 +0800
@@ -22,12 +22,17 @@
 
     public List<ItemStack> b = Lists.newArrayList();
     public List<Slot> c = Lists.newArrayList();
+    /*public List<ItemStack> b = Lists.newCopyOnWriteArrayList();
+    public List<Slot> c = Lists.newCopyOnWriteArrayList();*/
     public int windowId;
     private int dragType = -1;
     private int g;
     private final Set<Slot> h = Sets.newHashSet();
+    //private final Set<Slot> h = new CopyOnWriteArraySet<Slot>();
     protected List<ICrafting> listeners = Lists.newArrayList();
+    //protected List<ICrafting> listeners =Lists.newCopyOnWriteArrayList();
     private Set<EntityHuman> i = Sets.newHashSet();
+    //private Set<EntityHuman> i = new CopyOnWriteArraySet<EntityHuman>();
     private int tickCount; // Spigot
 
     // CraftBukkit start
@@ -63,6 +68,7 @@
 
     public List<ItemStack> a() {
         ArrayList arraylist = Lists.newArrayList();
+        //List arraylist = Lists.newCopyOnWriteArrayList();
 
         for (int i = 0; i < this.c.size(); ++i) {
             arraylist.add(((Slot) this.c.get(i)).getItem());
diff -Naur src_origin/main/java/net/minecraft/server/CraftingManager.java src/main/java/net/minecraft/server/CraftingManager.java
--- src_origin/main/java/net/minecraft/server/CraftingManager.java	2016-02-26 15:27:08.668203398 +0800
+++ src/main/java/net/minecraft/server/CraftingManager.java	2016-03-07 17:08:42.132615126 +0800
@@ -8,12 +8,14 @@
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
 
 public class CraftingManager {
 
     private static final CraftingManager a = new CraftingManager();
+    //do not use "newCopyOnWriteArrayList"
     public List<IRecipe> recipes = Lists.newArrayList();
     // CraftBukkit start
     public IRecipe lastRecipe;
@@ -215,9 +217,11 @@
             }
         }
 
-        HashMap hashmap;
+        //HashMap hashmap;
+        ConcurrentHashMap hashmap;
 
-        for (hashmap = Maps.newHashMap(); i < aobject.length; i += 2) {
+        //for (hashmap = Maps.newHashMap(); i < aobject.length; i += 2) {
+        for (hashmap = new ConcurrentHashMap(); i < aobject.length; i += 2) {
             Character character = (Character) aobject[i];
             ItemStack itemstack1 = null;
 
diff -Naur src_origin/main/java/net/minecraft/server/CrashReport.java src/main/java/net/minecraft/server/CrashReport.java
--- src_origin/main/java/net/minecraft/server/CrashReport.java	2016-02-26 15:27:08.705203401 +0800
+++ src/main/java/net/minecraft/server/CrashReport.java	2016-03-07 17:08:42.160615129 +0800
@@ -12,6 +12,7 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.Callable;
+import java.util.concurrent.CopyOnWriteArrayList;
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.lang3.ArrayUtils;
 import org.apache.logging.log4j.LogManager;
@@ -23,7 +24,8 @@
     private final String b;
     private final Throwable c;
     private final CrashReportSystemDetails d = new CrashReportSystemDetails(this, "System Details");
-    private final List<CrashReportSystemDetails> e = Lists.newArrayList();
+    //private final List<CrashReportSystemDetails> e = Lists.newArrayList();
+    private final List<CrashReportSystemDetails> e = Lists.newCopyOnWriteArrayList();
     private File f;
     private boolean g = true;
     private StackTraceElement[] h = new StackTraceElement[0];
diff -Naur src_origin/main/java/net/minecraft/server/DedicatedServer.java src/main/java/net/minecraft/server/DedicatedServer.java
--- src_origin/main/java/net/minecraft/server/DedicatedServer.java	2016-02-26 15:27:08.757203406 +0800
+++ src/main/java/net/minecraft/server/DedicatedServer.java	2016-03-07 17:08:42.211615134 +0800
@@ -29,7 +29,8 @@
 public class DedicatedServer extends MinecraftServer implements IMinecraftServer {
 
     private static final Logger LOGGER = LogManager.getLogger();
-    private final List<ServerCommand> l = Collections.synchronizedList(Lists.<ServerCommand>newArrayList()); // CraftBukkit - fix decompile error
+    //private final List<ServerCommand> l = Collections.synchronizedList(Lists.<ServerCommand>newArrayList()); // CraftBukkit - fix decompile error
+    private final List<ServerCommand> l = Lists.newCopyOnWriteArrayList(); // CraftBukkit - fix decompile error
     private RemoteStatusListener m;
     private RemoteControlListener n;
     public PropertyManager propertyManager;
diff -Naur src_origin/main/java/net/minecraft/server/EntityFallingBlock.java src/main/java/net/minecraft/server/EntityFallingBlock.java
--- src_origin/main/java/net/minecraft/server/EntityFallingBlock.java	2016-02-26 15:27:09.384203465 +0800
+++ src/main/java/net/minecraft/server/EntityFallingBlock.java	2016-03-07 17:08:42.775615186 +0800
@@ -1,8 +1,8 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.List;
 
 import org.bukkit.craftbukkit.event.CraftEventFactory; // CraftBukkit
 
@@ -16,6 +16,8 @@
     private int fallHurtMax = 40;
     private float fallHurtAmount = 2.0F;
     public NBTTagCompound tileEntityData;
+    //add drop tag
+    protected boolean is_droped;
 
     public EntityFallingBlock(World world) {
         super(world);
@@ -115,7 +117,14 @@
                                     }
                                 }
                             } else if (this.dropItem && this.world.getGameRules().getBoolean("doEntityDrops")) {
-                                this.a(new ItemStack(block, 1, block.getDropData(this.block)), 0.0F);
+                                //casue sand dup
+                                //this.a(new ItemStack(block, 1, block.getDropData(this.block)), 0.0F);
+                                if (is_droped) {
+                                    //do nothing
+                                } else {
+                                    is_droped = true;
+                                    this.a(new ItemStack(block, 1, block.getDropData(this.block)), 0.0F);
+                                }
                             }
                         }
                     }
@@ -138,7 +147,8 @@
             int i = MathHelper.f(f - 1.0F);
 
             if (i > 0) {
-                ArrayList arraylist = Lists.newArrayList(this.world.getEntities(this, this.getBoundingBox()));
+                //ArrayList arraylist = Lists.newArrayList(this.world.getEntities(this, this.getBoundingBox()));
+                List arraylist = Lists.newCopyOnWriteArrayList(this.world.getEntities(this, this.getBoundingBox()));
                 boolean flag = block == Blocks.ANVIL;
                 DamageSource damagesource = flag ? DamageSource.ANVIL : DamageSource.FALLING_BLOCK;
                 Iterator iterator = arraylist.iterator();
diff -Naur src_origin/main/java/net/minecraft/server/EntityItem.java src/main/java/net/minecraft/server/EntityItem.java
--- src_origin/main/java/net/minecraft/server/EntityItem.java	2016-02-26 15:27:09.641203489 +0800
+++ src/main/java/net/minecraft/server/EntityItem.java	2016-03-07 17:08:43.025615210 +0800
@@ -81,10 +81,10 @@
                     this.motZ = (double) ((this.random.nextFloat() - this.random.nextFloat()) * 0.2F);
                     this.makeSound("random.fizz", 0.4F, 2.0F + this.random.nextFloat() * 0.4F);
                 }
-
-                if (!this.world.isClientSide) {
+                /*
+                if (!this.world.isClientSide && this.ak == false) {
                     this.w();
-                }
+                }*/
             }
 
             float f = 0.98F;
@@ -143,6 +143,7 @@
     }
     // Spigot end
 
+    //merge will cause dup through portal
     private void w() {
         // Spigot start
         double radius = world.spigotConfig.itemMerge;
@@ -375,9 +376,10 @@
 
     public void c(int i) {
         super.c(i);
-        if (!this.world.isClientSide) {
+        /*
+        if (!this.world.isClientSide && this.ak == false) {
             this.w();
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/Entity.java src/main/java/net/minecraft/server/Entity.java
--- src_origin/main/java/net/minecraft/server/Entity.java	2016-02-26 15:27:08.930203422 +0800
+++ src/main/java/net/minecraft/server/Entity.java	2016-03-07 17:08:42.386615150 +0800
@@ -263,12 +263,12 @@
             this.world.methodProfiler.a("portal");
             MinecraftServer minecraftserver = ((WorldServer) this.world).getMinecraftServer();
             int i = this.L();
-
             if (this.ak) {
                 if (true || minecraftserver.getAllowNether()) { // CraftBukkit
                     if (this.vehicle == null && this.al++ >= i) {
                         this.al = i;
                         this.portalCooldown = this.aq();
+
                         byte b0;
 
                         if (this.world.worldProvider.getDimension() == -1) {
@@ -291,9 +291,14 @@
                     this.al = 0;
                 }
             }
-
+            /*
             if (this.portalCooldown > 0) {
                 --this.portalCooldown;
+            }*/
+            if (this.portalCooldown > 0) {
+                --this.portalCooldown;
+            } else {
+                this.teleport_count = 0;
             }
 
             this.world.methodProfiler.b();
@@ -1891,7 +1896,8 @@
     }
 
     public void c(int i) {
-        if (!this.world.isClientSide && !this.dead) {
+        //fix dup
+        if (!this.world.isClientSide && !this.dead && this.teleport_count == 0) {
             this.world.methodProfiler.a("changeDimension");
             MinecraftServer minecraftserver = MinecraftServer.getServer();
             // CraftBukkit start - Move logic into new function "teleportToLocation"
@@ -1924,8 +1930,11 @@
         }
     }
 
+    int teleport_count = 0;
     public void teleportTo(Location exit, boolean portal) {
-        if (true) {
+        //if (true) {
+        if (true && teleport_count == 0) {
+            teleport_count = 1;
             WorldServer worldserver = ((CraftWorld) getBukkitEntity().getLocation().getWorld()).getHandle();
             WorldServer worldserver1 = ((CraftWorld) exit.getWorld()).getHandle();
             int i = worldserver1.dimension;
diff -Naur src_origin/main/java/net/minecraft/server/EntityLiving.java src/main/java/net/minecraft/server/EntityLiving.java
--- src_origin/main/java/net/minecraft/server/EntityLiving.java	2016-02-26 15:27:09.784203502 +0800
+++ src/main/java/net/minecraft/server/EntityLiving.java	2016-03-07 17:08:43.151615221 +0800
@@ -461,7 +461,8 @@
 
     // CraftBukkit start
     private boolean isTickingEffects = false;
-    private List<Object> effectsToProcess = Lists.newArrayList();
+    //private List<Object> effectsToProcess = Lists.newArrayList();
+    private List<Object> effectsToProcess = Lists.newCopyOnWriteArrayList();
     // CraftBukkit end
 
     protected void bi() {
diff -Naur src_origin/main/java/net/minecraft/server/EntityMinecartAbstract.java src/main/java/net/minecraft/server/EntityMinecartAbstract.java
--- src_origin/main/java/net/minecraft/server/EntityMinecartAbstract.java	2016-02-26 15:27:09.793203503 +0800
+++ src/main/java/net/minecraft/server/EntityMinecartAbstract.java	2016-03-07 17:08:43.159615222 +0800
@@ -238,9 +238,14 @@
                     this.al = 0;
                 }
             }
-
+            /*
             if (this.portalCooldown > 0) {
                 --this.portalCooldown;
+            }*/
+            if (this.portalCooldown > 0) {
+                -- this.portalCooldown;
+            } else {
+                this.teleport_count = 0;
             }
 
             this.world.methodProfiler.b();
diff -Naur src_origin/main/java/net/minecraft/server/EntityPlayer.java src/main/java/net/minecraft/server/EntityPlayer.java
--- src_origin/main/java/net/minecraft/server/EntityPlayer.java	2016-02-26 15:27:09.996203522 +0800
+++ src/main/java/net/minecraft/server/EntityPlayer.java	2016-03-07 17:08:43.343615239 +0800
@@ -10,6 +10,7 @@
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -33,8 +34,11 @@
     public final PlayerInteractManager playerInteractManager;
     public double d;
     public double e;
-    public final List<ChunkCoordIntPair> chunkCoordIntPairQueue = Lists.newLinkedList();
-    public final List<Integer> removeQueue = Lists.newLinkedList();
+    //public final List<ChunkCoordIntPair> chunkCoordIntPairQueue = Lists.newLinkedList();
+    //casue negative array size
+    public final ConcurrentLinkedQueue<ChunkCoordIntPair> chunkCoordIntPairQueue = new ConcurrentLinkedQueue<ChunkCoordIntPair>();
+    //public final List<Integer> removeQueue = Lists.newLinkedList();
+    public final ConcurrentLinkedQueue<Integer> removeQueue = new ConcurrentLinkedQueue<Integer>();
     private final ServerStatisticManager bK;
     private float bL = Float.MIN_VALUE;
     private float bM = -1.0E8F;
@@ -217,9 +221,11 @@
         }
 
         if (!this.chunkCoordIntPairQueue.isEmpty()) {
-            ArrayList arraylist = Lists.newArrayList();
+            //ArrayList arraylist = Lists.newArrayList();
+            List arraylist = Lists.newCopyOnWriteArrayList();
             Iterator iterator1 = this.chunkCoordIntPairQueue.iterator();
-            ArrayList arraylist1 = Lists.newArrayList();
+            //ArrayList arraylist1 = Lists.newArrayList();
+            List arraylist1 = Lists.newCopyOnWriteArrayList();
 
             Chunk chunk;
 
@@ -894,11 +900,16 @@
     }
 
     public void copyTo(EntityHuman entityhuman, boolean flag) {
-        super.copyTo(entityhuman, flag);
-        this.lastSentExp = -1;
-        this.bM = -1.0F;
-        this.bN = -1;
-        this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
+        try {
+            super.copyTo(entityhuman, flag);
+            this.lastSentExp = -1;
+            this.bM = -1.0F;
+            this.bN = -1;
+            this.removeQueue.addAll(((EntityPlayer) entityhuman).removeQueue);
+        } catch (Exception ex){
+            
+        }
+        
     }
 
     protected void a(MobEffect mobeffect) {
diff -Naur src_origin/main/java/net/minecraft/server/EntitySlice.java src/main/java/net/minecraft/server/EntitySlice.java
--- src_origin/main/java/net/minecraft/server/EntitySlice.java	2016-02-26 15:27:10.178203539 +0800
+++ src/main/java/net/minecraft/server/EntitySlice.java	2016-03-07 17:08:43.518615256 +0800
@@ -7,16 +7,19 @@
 import java.util.AbstractSet;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
 import java.util.Set;
+import java.util.concurrent.ConcurrentMap;
 
 public class EntitySlice<T> extends AbstractSet<T> {
 
     private static final Set<Class<?>> a = Sets.newConcurrentHashSet(); // CraftBukkit
-    private final Map<Class<?>, List<T>> b = Maps.newHashMap();
+    //private final Map<Class<?>, List<T>> b = Maps.newHashMap();
+    private final ConcurrentMap<Class<?>, List<T>> b = Maps.newConcurrentMap();
+    
     private final Set<Class<?>> c = Sets.newIdentityHashSet();
     private final Class<T> d;
-    private final List<T> e = Lists.newArrayList();
+    //private final List<T> e = Lists.newArrayList();
+    private final List<T> e = Lists.newCopyOnWriteArrayList();
 
     public EntitySlice(Class<T> oclass) {
         this.d = oclass;
@@ -77,6 +80,7 @@
         List list = (List) this.b.get(oclass);
 
         if (list == null) {
+            //this.b.put(oclass, Lists.newArrayList(t0));
             this.b.put(oclass, Lists.newArrayList(t0));
         } else {
             list.add(t0);
diff -Naur src_origin/main/java/net/minecraft/server/EntityTrackerEntry.java src/main/java/net/minecraft/server/EntityTrackerEntry.java
--- src_origin/main/java/net/minecraft/server/EntityTrackerEntry.java	2016-02-26 15:27:10.392203559 +0800
+++ src/main/java/net/minecraft/server/EntityTrackerEntry.java	2016-03-07 17:08:43.711615274 +0800
@@ -1,10 +1,11 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Sets;
 import java.util.Collection;
 import java.util.Iterator;
+import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -39,7 +40,8 @@
     private boolean x;
     private boolean y;
     public boolean n;
-    public Set<EntityPlayer> trackedPlayers = Sets.newHashSet();
+    //public Set<EntityPlayer> trackedPlayers = Sets.newHashSet();
+    public LinkedHashSet<EntityPlayer> trackedPlayers = new LinkedHashSet<EntityPlayer>();
 
     public EntityTrackerEntry(Entity entity, int i, int j, boolean flag) {
         this.tracker = entity;
@@ -424,9 +426,14 @@
     }
 
     public void scanPlayers(List<EntityHuman> list) {
+        Iterator it = list.iterator();
+        while(it.hasNext()){
+            this.updatePlayer((EntityPlayer) it.next());
+        }
+        /*
         for (int i = 0; i < list.size(); ++i) {
             this.updatePlayer((EntityPlayer) list.get(i));
-        }
+        }*/
 
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/EntityTracker.java src/main/java/net/minecraft/server/EntityTracker.java
--- src_origin/main/java/net/minecraft/server/EntityTracker.java	2016-02-26 15:27:10.352203555 +0800
+++ src/main/java/net/minecraft/server/EntityTracker.java	2016-03-07 17:08:43.687615272 +0800
@@ -1,11 +1,11 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
-import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.List;
 import java.util.Set;
-import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.CopyOnWriteArraySet;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -13,10 +13,18 @@
 
     private static final Logger a = LogManager.getLogger();
     private final WorldServer world;
-    private Set<EntityTrackerEntry> c = Sets.newHashSet();
-    public IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    //private Set<EntityTrackerEntry> c = Sets.newHashSet();
+    private Set<EntityTrackerEntry> c = new CopyOnWriteArraySet<EntityTrackerEntry>();
+    //public IntHashMap<EntityTrackerEntry> trackedEntities = new IntHashMap();
+    public ConcurrentHashMap<Integer, EntityTrackerEntry> trackedEntities = new ConcurrentHashMap<Integer, EntityTrackerEntry>();
     private int e;
 
+    //for spigot
+    private int g(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
+    
     public EntityTracker(WorldServer worldserver) {
         this.world = worldserver;
         this.e = worldserver.getMinecraftServer().getPlayerList().d();
@@ -94,23 +102,40 @@
     }
 
     public void addEntity(Entity entity, int i, final int j, boolean flag) {
-        org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
-        i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
-        if (i > this.e) {
-            i = this.e;
-        }
-
-        try {
-            if (this.trackedEntities.b(entity.getId())) {
-                throw new IllegalStateException("Entity is already tracked!");
+        synchronized (this) {
+            org.spigotmc.AsyncCatcher.catchOp( "entity track"); // Spigot
+            i = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, i); // Spigot
+            if (i > this.e) {
+                i = this.e;
             }
 
-            EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, j, flag);
 
-            this.c.add(entitytrackerentry);
-            this.trackedEntities.a(entity.getId(), entitytrackerentry);
-            entitytrackerentry.scanPlayers(this.world.players);
-        } catch (Throwable throwable) {
+            //just track once
+            //if (this.trackedEntities.b(entity.getId())) {
+            if (this.trackedEntities.containsKey(this.g(entity.getId()))) {
+                //do nothing
+                //throw new IllegalStateException("Entity is already tracked!");
+                //throw new Exception();
+            } else {
+                EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, j, flag);
+
+                this.c.add(entitytrackerentry);
+                //key point causing error
+                //this.trackedEntities.a(entity.getId(), entitytrackerentry);
+                this.trackedEntities.put(this.g(entity.getId()), entitytrackerentry);
+
+                entitytrackerentry.scanPlayers(this.world.players);
+            }
+        }
+        /*
+        EntityTrackerEntry entitytrackerentry = new EntityTrackerEntry(entity, i, j, flag);
+
+        this.c.add(entitytrackerentry);
+        //key point causing error
+        this.trackedEntities.a(entity.getId(), entitytrackerentry);
+        entitytrackerentry.scanPlayers(this.world.players);*/
+        
+        /*} catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.a(throwable, "Adding entity to track");
             CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Entity To Track");
 
@@ -141,7 +166,7 @@
             } catch (ReportedException reportedexception) {
                 EntityTracker.a.error("\"Silently\" catching entity tracking error.", reportedexception);
             }
-        }
+        }*/
 
     }
 
@@ -158,8 +183,11 @@
             }
         }
 
-        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
-
+        //EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.d(entity.getId());
+        EntityTrackerEntry entitytrackerentry1 = (EntityTrackerEntry) this.trackedEntities.get(this.g(entity.getId()));
+        //remember to remove trackedEntities.
+        this.trackedEntities.remove(this.g(entity.getId()));
+        
         if (entitytrackerentry1 != null) {
             this.c.remove(entitytrackerentry1);
             entitytrackerentry1.a();
@@ -168,8 +196,11 @@
     }
 
     public void updatePlayers() {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         Iterator iterator = this.c.iterator();
+        //observe track list size
+        //System.out.println(this.c.size()+","+this.trackedEntities.size()+","+arraylist.size());
 
         while (iterator.hasNext()) {
             EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) iterator.next();
@@ -211,7 +242,8 @@
     }
 
     public void a(Entity entity, Packet packet) {
-        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        //EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(this.g(entity.getId()));
 
         if (entitytrackerentry != null) {
             entitytrackerentry.broadcast(packet);
@@ -220,7 +252,8 @@
     }
 
     public void sendPacketToEntity(Entity entity, Packet packet) {
-        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        //EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(entity.getId());
+        EntityTrackerEntry entitytrackerentry = (EntityTrackerEntry) this.trackedEntities.get(this.g(entity.getId()));
 
         if (entitytrackerentry != null) {
             entitytrackerentry.broadcastIncludingSelf(packet);
diff -Naur src_origin/main/java/net/minecraft/server/Explosion.java src/main/java/net/minecraft/server/Explosion.java
--- src_origin/main/java/net/minecraft/server/Explosion.java	2016-02-26 15:27:10.556203574 +0800
+++ src/main/java/net/minecraft/server/Explosion.java	2016-03-07 17:08:43.876615289 +0800
@@ -8,6 +8,8 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.event.CraftEventFactory;
@@ -28,7 +30,9 @@
     public final Entity source;
     private final float size;
     private final List<BlockPosition> blocks = Lists.newArrayList();
-    private final Map<EntityHuman, Vec3D> k = Maps.newHashMap();
+    //private final List<BlockPosition> blocks = Lists.newCopyOnWriteArrayList();
+    //private final Map<EntityHuman, Vec3D> k = Maps.newHashMap();
+    private final ConcurrentMap<EntityHuman, Vec3D> k = new ConcurrentHashMap<EntityHuman, Vec3D>();
     public boolean wasCanceled = false; // CraftBukkit - add field
 
     public Explosion(World world, Entity entity, double d0, double d1, double d2, float f, boolean flag, boolean flag1) {
@@ -263,7 +267,8 @@
 
     }
 
-    public Map<EntityHuman, Vec3D> b() {
+    //public Map<EntityHuman, Vec3D> b() {
+    public ConcurrentMap<EntityHuman, Vec3D> b() {
         return this.k;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/HandshakeListener.java src/main/java/net/minecraft/server/HandshakeListener.java
--- src_origin/main/java/net/minecraft/server/HandshakeListener.java	2016-02-26 15:27:10.687203587 +0800
+++ src/main/java/net/minecraft/server/HandshakeListener.java	2016-03-07 17:08:43.987615300 +0800
@@ -2,14 +2,15 @@
 
 // CraftBukkit start
 import java.net.InetAddress;
-import java.util.HashMap;
+import java.util.concurrent.ConcurrentHashMap;
 // CraftBukkit end
 
 public class HandshakeListener implements PacketHandshakingInListener {
 
     private static final com.google.gson.Gson gson = new com.google.gson.Gson(); // Spigot
     // CraftBukkit start - add fields
-    private static final HashMap<InetAddress, Long> throttleTracker = new HashMap<InetAddress, Long>();
+    //private static final HashMap<InetAddress, Long> throttleTracker = new HashMap<InetAddress, Long>();
+    private static final ConcurrentHashMap<InetAddress, Long> throttleTracker = new ConcurrentHashMap<InetAddress, Long>();
     private static int throttleCounter = 0;
     // CraftBukkit end
 
diff -Naur src_origin/main/java/net/minecraft/server/IntCache.java src/main/java/net/minecraft/server/IntCache.java
--- src_origin/main/java/net/minecraft/server/IntCache.java	2016-02-26 15:27:10.750203593 +0800
+++ src/main/java/net/minecraft/server/IntCache.java	2016-03-07 17:08:44.041615305 +0800
@@ -10,7 +10,7 @@
     private static List<int[]> c = Lists.newArrayList();
     private static List<int[]> d = Lists.newArrayList();
     private static List<int[]> e = Lists.newArrayList();
-
+    
     public static synchronized int[] a(int i) {
         int[] aint;
 
diff -Naur src_origin/main/java/net/minecraft/server/ItemStack.java src/main/java/net/minecraft/server/ItemStack.java
--- src_origin/main/java/net/minecraft/server/ItemStack.java	2016-02-26 15:27:11.336203647 +0800
+++ src/main/java/net/minecraft/server/ItemStack.java	2016-03-07 17:08:44.591615356 +0800
@@ -8,6 +8,9 @@
 // CraftBukkit start
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.CopyOnWriteArrayList;
 
 import org.bukkit.Location;
 import org.bukkit.TreeType;
@@ -125,7 +128,9 @@
             Location location = new Location(world.getWorld(), blockposition.getX(), blockposition.getY(), blockposition.getZ());
             TreeType treeType = BlockSapling.treeType;
             BlockSapling.treeType = null;
-            List<BlockState> blocks = (List<BlockState>) world.capturedBlockStates.clone();
+            //List<BlockState> blocks = (List<BlockState>) world.capturedBlockStates.clone();
+            Queue<BlockState> blocks = new ConcurrentLinkedQueue<BlockState>();
+            blocks.addAll((Queue<BlockState>) world.capturedBlockStates);
             world.capturedBlockStates.clear();
             StructureGrowEvent event = null;
             if (treeType != null) {
@@ -150,12 +155,19 @@
 
         if (flag) {
             org.bukkit.event.block.BlockPlaceEvent placeEvent = null;
-            List<BlockState> blocks = (List<BlockState>) world.capturedBlockStates.clone();
+            //List<BlockState> blocks = (List<BlockState>) world.capturedBlockStates.clone();
+            Queue<BlockState> blocks = new ConcurrentLinkedQueue<BlockState>();
+            blocks.addAll((Queue<BlockState>)world.capturedBlockStates);
+            BlockState first_block = null;
+            if (blocks.iterator().hasNext()){
+                first_block = blocks.iterator().next();
+            }
             world.capturedBlockStates.clear();
             if (blocks.size() > 1) {
                 placeEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callBlockMultiPlaceEvent(world, entityhuman, blocks, blockposition.getX(), blockposition.getY(), blockposition.getZ());
             } else if (blocks.size() == 1) {
-                placeEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPlaceEvent(world, entityhuman, blocks.get(0), blockposition.getX(), blockposition.getY(), blockposition.getZ());
+                //placeEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPlaceEvent(world, entityhuman, blocks.get(0), blockposition.getX(), blockposition.getY(), blockposition.getZ());
+                placeEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callBlockPlaceEvent(world, entityhuman, first_block, blockposition.getX(), blockposition.getY(), blockposition.getZ());
             }
 
             if (placeEvent != null && (placeEvent.isCancelled() || !placeEvent.canBuild())) {
diff -Naur src_origin/main/java/net/minecraft/server/JsonList.java src/main/java/net/minecraft/server/JsonList.java
--- src_origin/main/java/net/minecraft/server/JsonList.java	2016-02-26 15:27:11.423203656 +0800
+++ src/main/java/net/minecraft/server/JsonList.java	2016-03-07 17:08:44.641615361 +0800
@@ -25,6 +25,8 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 import org.apache.commons.io.IOUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -34,7 +36,8 @@
     protected static final Logger a = LogManager.getLogger();
     protected final Gson b;
     private final File c;
-    private final Map<String, V> d = Maps.newHashMap();
+    //private final Map<String, V> d = Maps.newHashMap();
+    private final ConcurrentMap<String, V> d = new ConcurrentHashMap<String, V>();
     private boolean e = true;
     private static final ParameterizedType f = new ParameterizedType() {
         public Type[] getActualTypeArguments() {
@@ -145,6 +148,7 @@
         return new JsonListEntry((Object) null, jsonobject);
     }
 
+    //do not change it
     protected Map<String, V> e() {
         return this.d;
     }
diff -Naur src_origin/main/java/net/minecraft/server/MinecraftServer.java src/main/java/net/minecraft/server/MinecraftServer.java
--- src_origin/main/java/net/minecraft/server/MinecraftServer.java	2016-02-26 15:27:11.493203662 +0800
+++ src/main/java/net/minecraft/server/MinecraftServer.java	2016-03-07 17:08:44.736615370 +0800
@@ -2,7 +2,6 @@
 
 import com.google.common.base.Charsets;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Queues;
 import com.google.common.util.concurrent.Futures;
 import com.google.common.util.concurrent.ListenableFuture;
 import com.google.common.util.concurrent.ListenableFutureTask;
@@ -17,7 +16,6 @@
 import java.awt.GraphicsEnvironment;
 import java.awt.image.BufferedImage;
 import java.io.File;
-import java.io.IOException;
 import java.net.Proxy;
 import java.security.KeyPair;
 import java.text.SimpleDateFormat;
@@ -46,6 +44,9 @@
 
 import org.bukkit.craftbukkit.Main;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
+import org.bukkit.event.Event;
+import org.hose.ChunkGenPool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class MinecraftServer implements Runnable, ICommandListener, IAsyncTaskHandler, IMojangStatistics {
@@ -57,6 +58,7 @@
     private final MojangStatisticsGenerator n = new MojangStatisticsGenerator("server", this, az());
     public File universe;
     private final List<IUpdatePlayerListBox> p = Lists.newArrayList();
+    //private final List<IUpdatePlayerListBox> p = Lists.newCopyOnWriteArrayList();
     protected final ICommandHandler b;
     public final MethodProfiler methodProfiler = new MethodProfiler();
     private ServerConnection q; // Spigot
@@ -366,7 +368,10 @@
                     }
 
                     ++i;
-                    worldserver.chunkProviderServer.getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    //chunk loader
+                    //worldserver.chunkProviderServer.getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+                    SpigotWorldConfig.ChunkGenTask = new FutureTask(new ChunkGenPool(worldserver, blockposition, k, l));
+                    SpigotWorldConfig.chunkgenpool_executor.submit(SpigotWorldConfig.ChunkGenTask);
                 }
             }
         }
@@ -642,7 +647,7 @@
     protected void A() throws ExceptionWorldConflict { // CraftBukkit - added throws
         SpigotTimings.serverTickTimer.startTiming(); // Spigot
         long i = System.nanoTime();
-
+        
         ++this.ticks;
         if (this.T) {
             this.T = false;
@@ -710,10 +715,15 @@
 
         // Spigot start
         FutureTask<?> entry;
-        int count = this.j.size();
+        /*int count = this.j.size();
         while (count-- > 0 && (entry = this.j.poll()) != null) {
             SystemUtils.a(entry, MinecraftServer.LOGGER);
-         }
+        }*/
+        //int count = this.j.size();
+        Iterator it = this.j.iterator();
+        while (it.hasNext() && (entry = this.j.poll()) != null) {
+            SystemUtils.a(entry, MinecraftServer.LOGGER);
+        }
         // Spigot end
 
         this.methodProfiler.c("levels");
@@ -1023,7 +1033,8 @@
     }
 
     public String getServerModName() {
-        return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        //return "Spigot"; // Spigot - Spigot > // CraftBukkit - cb > vanilla!
+        return "HOSE"; // HOSE -> Spigot - Spigot > // CraftBukkit - cb > vanilla!
     }
 
     public CrashReport b(CrashReport crashreport) {
@@ -1105,7 +1116,8 @@
     }
 
     public String getName() {
-        return "Server";
+        //return "Server";
+        return org.bukkit.ChatColor.GREEN+"Server";
     }
 
     public void sendMessage(IChatBaseComponent ichatbasecomponent) {
diff -Naur src_origin/main/java/net/minecraft/server/PacketPlayOutMapChunk.java src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java
--- src_origin/main/java/net/minecraft/server/PacketPlayOutMapChunk.java	2016-02-26 15:27:12.026203712 +0800
+++ src/main/java/net/minecraft/server/PacketPlayOutMapChunk.java	2016-03-07 17:08:45.182615412 +0800
@@ -4,6 +4,7 @@
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Iterator;
+import java.util.List;
 
 public class PacketPlayOutMapChunk implements Packet<PacketListenerPlayOut> {
 
@@ -55,7 +56,8 @@
     public static PacketPlayOutMapChunk.ChunkMap a(Chunk chunk, boolean flag, boolean flag1, int i) {
         ChunkSection[] achunksection = chunk.getSections();
         PacketPlayOutMapChunk.ChunkMap packetplayoutmapchunk_chunkmap = new PacketPlayOutMapChunk.ChunkMap();
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
 
         int j;
 
diff -Naur src_origin/main/java/net/minecraft/server/PersistentCollection.java src/main/java/net/minecraft/server/PersistentCollection.java
--- src_origin/main/java/net/minecraft/server/PersistentCollection.java	2016-02-26 15:27:12.587203764 +0800
+++ src/main/java/net/minecraft/server/PersistentCollection.java	2016-03-07 17:08:45.627615453 +0800
@@ -1,7 +1,6 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 import java.io.DataInputStream;
 import java.io.DataOutput;
 import java.io.DataOutputStream;
@@ -12,14 +11,17 @@
 import java.io.OutputStream;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 public class PersistentCollection {
 
     private IDataManager b;
-    protected Map<String, PersistentBase> a = Maps.newHashMap();
+    //protected Map<String, PersistentBase> a = Maps.newHashMap();
+    protected ConcurrentMap<String, PersistentBase> a = new ConcurrentHashMap<String, PersistentBase>();
     public List<PersistentBase> c = Lists.newArrayList(); // Spigot
-    private Map<String, Short> d = Maps.newHashMap();
+    //private Map<String, Short> d = Maps.newHashMap();
+    private ConcurrentMap<String, Short> d = new ConcurrentHashMap<String, Short>();
 
     public PersistentCollection(IDataManager idatamanager) {
         this.b = idatamanager;
diff -Naur src_origin/main/java/net/minecraft/server/PistonExtendsChecker.java src/main/java/net/minecraft/server/PistonExtendsChecker.java
--- src_origin/main/java/net/minecraft/server/PistonExtendsChecker.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/net/minecraft/server/PistonExtendsChecker.java	2016-03-07 17:08:45.658615456 +0800
@@ -0,0 +1,195 @@
+package net.minecraft.server;
+
+import com.google.common.collect.Lists;
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.CopyOnWriteArrayList;
+
+public class PistonExtendsChecker {
+
+    private final World a;
+    private final BlockPosition b;
+    private final BlockPosition c;
+    private final EnumDirection d;
+    /*
+    private final List<BlockPosition> e = Lists.newArrayList();
+    private final List<BlockPosition> f = Lists.newArrayList();*/
+    private final CopyOnWriteArrayList<BlockPosition> e = Lists.newCopyOnWriteArrayList();
+    private final CopyOnWriteArrayList<BlockPosition> f = Lists.newCopyOnWriteArrayList();
+    
+
+    public PistonExtendsChecker(World world, BlockPosition blockposition, EnumDirection enumdirection, boolean flag) {
+        this.a = world;
+        this.b = blockposition;
+        if (flag) {
+            this.d = enumdirection;
+            this.c = blockposition.shift(enumdirection);
+        } else {
+            this.d = enumdirection.opposite();
+            this.c = blockposition.shift(enumdirection, 2);
+        }
+
+    }
+
+    public boolean a() {
+        this.e.clear();
+        this.f.clear();
+        Block block = this.a.getType(this.c).getBlock();
+
+        if (!BlockPiston.a(block, this.a, this.c, this.d, false)) {
+            if (block.k() != 1) {
+                return false;
+            } else {
+                this.f.add(this.c);
+                return true;
+            }
+        } else if (!this.a(this.c)) {
+            return false;
+        } else {
+            Iterator it = this.e.iterator();
+            while (it.hasNext()){
+                BlockPosition blockposition = (BlockPosition) it.next();
+
+                if (this.a.getType(blockposition).getBlock() == Blocks.SLIME && !this.b(blockposition)) {
+                    return false;
+                }
+            }
+            /*
+            for (int i = 0; i < this.e.size(); ++i) {
+                BlockPosition blockposition = (BlockPosition) this.e.get(i);
+
+                if (this.a.getType(blockposition).getBlock() == Blocks.SLIME && !this.b(blockposition)) {
+                    return false;
+                }
+            }*/
+
+            return true;
+        }
+    }
+
+    private boolean a(BlockPosition blockposition) {
+        Block block = this.a.getType(blockposition).getBlock();
+
+        if (block.getMaterial() == Material.AIR) {
+            return true;
+        } else if (!BlockPiston.a(block, this.a, blockposition, this.d, false)) {
+            return true;
+        } else if (blockposition.equals(this.b)) {
+            return true;
+        } else if (this.e.contains(blockposition)) {
+            return true;
+        } else {
+            int i = 1;
+
+            if (i + this.e.size() > 12) {
+                return false;
+            } else {
+                while (block == Blocks.SLIME) {
+                    BlockPosition blockposition1 = blockposition.shift(this.d.opposite(), i);
+
+                    block = this.a.getType(blockposition1).getBlock();
+                    if (block.getMaterial() == Material.AIR || !BlockPiston.a(block, this.a, blockposition1, this.d, false) || blockposition1.equals(this.b)) {
+                        break;
+                    }
+
+                    ++i;
+                    if (i + this.e.size() > 12) {
+                        return false;
+                    }
+                }
+
+                int j = 0;
+
+                int k;
+
+                for (k = i - 1; k >= 0; --k) {
+                    this.e.add(blockposition.shift(this.d.opposite(), k));
+                    ++j;
+                }
+
+                k = 1;
+
+                while (true) {
+                    BlockPosition blockposition2 = blockposition.shift(this.d, k);
+                    int l = this.e.indexOf(blockposition2);
+
+                    if (l > -1) {
+                        this.a(j, l);
+
+                        for (int i1 = 0; i1 <= l + j; ++i1) {
+                            BlockPosition blockposition3 = (BlockPosition) this.e.get(i1);
+
+                            if (this.a.getType(blockposition3).getBlock() == Blocks.SLIME && !this.b(blockposition3)) {
+                                return false;
+                            }
+                        }
+
+                        return true;
+                    }
+
+                    block = this.a.getType(blockposition2).getBlock();
+                    if (block.getMaterial() == Material.AIR) {
+                        return true;
+                    }
+
+                    if (!BlockPiston.a(block, this.a, blockposition2, this.d, true) || blockposition2.equals(this.b)) {
+                        return false;
+                    }
+
+                    if (block.k() == 1) {
+                        this.f.add(blockposition2);
+                        return true;
+                    }
+
+                    if (this.e.size() >= 12) {
+                        return false;
+                    }
+
+                    this.e.add(blockposition2);
+                    ++j;
+                    ++k;
+                }
+            }
+        }
+    }
+
+    private void a(int i, int j) {
+        ArrayList arraylist = Lists.newArrayList();
+        ArrayList arraylist1 = Lists.newArrayList();
+        ArrayList arraylist2 = Lists.newArrayList();
+
+        arraylist.addAll(this.e.subList(0, j));
+        arraylist1.addAll(this.e.subList(this.e.size() - i, this.e.size()));
+        arraylist2.addAll(this.e.subList(j, this.e.size() - i));
+        this.e.clear();
+        this.e.addAll(arraylist);
+        this.e.addAll(arraylist1);
+        this.e.addAll(arraylist2);
+    }
+
+    private boolean b(BlockPosition blockposition) {
+        EnumDirection[] aenumdirection = EnumDirection.values();
+        int i = aenumdirection.length;
+
+        for (int j = 0; j < i; ++j) {
+            EnumDirection enumdirection = aenumdirection[j];
+
+            if (enumdirection.k() != this.d.k() && !this.a(blockposition.shift(enumdirection))) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    //public List<BlockPosition> getMovedBlocks() {
+    public CopyOnWriteArrayList<BlockPosition> getMovedBlocks() {
+        return this.e;
+    }
+
+    //public List<BlockPosition> getBrokenBlocks() {
+    public CopyOnWriteArrayList<BlockPosition> getBrokenBlocks() {
+        return this.f;
+    }
+}
diff -Naur src_origin/main/java/net/minecraft/server/PlayerChunkMap.java src/main/java/net/minecraft/server/PlayerChunkMap.java
--- src_origin/main/java/net/minecraft/server/PlayerChunkMap.java	2016-02-26 15:27:12.591203765 +0800
+++ src/main/java/net/minecraft/server/PlayerChunkMap.java	2016-03-07 17:08:45.670615457 +0800
@@ -1,7 +1,6 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
-import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import org.apache.logging.log4j.LogManager;
@@ -19,7 +18,8 @@
 
     private static final Logger a = LogManager.getLogger();
     private final WorldServer world;
-    private final List<EntityPlayer> managedPlayers = Lists.newArrayList();
+    //private final List<EntityPlayer> managedPlayers = Lists.newArrayList();
+    private final List<EntityPlayer> managedPlayers = Lists.newCopyOnWriteArrayList();
     private final LongHashMap<PlayerChunkMap.PlayerChunk> d = new LongHashMap();
     private final Queue<PlayerChunkMap.PlayerChunk> e = new java.util.concurrent.ConcurrentLinkedQueue<PlayerChunkMap.PlayerChunk>(); // CraftBukkit ArrayList -> ConcurrentLinkedQueue
     private final Queue<PlayerChunkMap.PlayerChunk> f = new java.util.concurrent.ConcurrentLinkedQueue<PlayerChunkMap.PlayerChunk>(); // CraftBukkit ArrayList -> ConcurrentLinkedQueue
@@ -68,6 +68,7 @@
             WorldProvider worldprovider = this.world.worldProvider;
 
             if (!worldprovider.e()) {
+                //async this
                 this.world.chunkProviderServer.b();
             }
             // CraftBukkit start
@@ -85,7 +86,8 @@
         return this.d.getEntry(k) != null;
     }
 
-    private PlayerChunkMap.PlayerChunk a(int i, int j, boolean flag) {
+    public PlayerChunkMap.PlayerChunk a(int i, int j, boolean flag) {
+    //private PlayerChunkMap.PlayerChunk a(int i, int j, boolean flag) {
         long k = (long) i + 2147483647L | (long) j + 2147483647L << 32;
         PlayerChunkMap.PlayerChunk playerchunkmap_playerchunk = (PlayerChunkMap.PlayerChunk) this.d.getEntry(k);
 
@@ -146,7 +148,8 @@
     }
 
     public void b(EntityPlayer entityplayer) {
-        ArrayList arraylist = Lists.newArrayList(entityplayer.chunkCoordIntPairQueue);
+        //ArrayList arraylist = Lists.newArrayList(entityplayer.chunkCoordIntPairQueue);
+        List arraylist = Lists.newCopyOnWriteArrayList(entityplayer.chunkCoordIntPairQueue);
         int i = 0;
         int j = this.g;
         int k = (int) entityplayer.locX >> 4;
@@ -178,7 +181,7 @@
         }
 
         i %= 4;
-
+        
         for (k1 = 0; k1 < j * 2; ++k1) {
             i1 += this.i[i][0];
             j1 += this.i[i][1];
@@ -256,9 +259,11 @@
                     this.a(pair.x, pair.z, true).a(entityplayer);
                 }
 
+                /*
                 if (j1 > 1 || j1 < -1 || k1 > 1 || k1 < -1) {
+                    //Collections.sort(entityplayer.chunkCoordIntPairQueue, new ChunkCoordComparator(entityplayer));
                     Collections.sort(entityplayer.chunkCoordIntPairQueue, new ChunkCoordComparator(entityplayer));
-                }
+                }*/
                 // CraftBukkit end
             }
         }
@@ -274,7 +279,8 @@
         i = MathHelper.clamp(i, 3, 32);
         if (i != this.g) {
             int j = i - this.g;
-            ArrayList arraylist = Lists.newArrayList(this.managedPlayers);
+            //ArrayList arraylist = Lists.newArrayList(this.managedPlayers);
+            List arraylist = Lists.newCopyOnWriteArrayList(this.managedPlayers);
             Iterator iterator = arraylist.iterator();
 
             while (iterator.hasNext()) {
@@ -313,10 +319,12 @@
         return i * 16 - 16;
     }
 
-    class PlayerChunk {
+    public class PlayerChunk {
 
-        private final List<EntityPlayer> b = Lists.newArrayList();
-        private final ChunkCoordIntPair location;
+        //private final List<EntityPlayer> b = Lists.newArrayList();
+        private final List<EntityPlayer> b = Lists.newCopyOnWriteArrayList();
+        //private final ChunkCoordIntPair location;
+        public final ChunkCoordIntPair location;
         private short[] dirtyBlocks = new short[64];
         private int dirtyCount;
         private int f;
diff -Naur src_origin/main/java/net/minecraft/server/PlayerConnection.java src/main/java/net/minecraft/server/PlayerConnection.java
--- src_origin/main/java/net/minecraft/server/PlayerConnection.java	2016-02-26 15:27:12.653203771 +0800
+++ src/main/java/net/minecraft/server/PlayerConnection.java	2016-03-07 17:08:45.720615462 +0800
@@ -3,7 +3,6 @@
 import com.google.common.collect.Lists;
 import com.google.common.primitives.Doubles;
 import com.google.common.primitives.Floats;
-import com.google.common.util.concurrent.Futures;
 import io.netty.buffer.Unpooled;
 import io.netty.util.concurrent.Future;
 import io.netty.util.concurrent.GenericFutureListener;
@@ -23,6 +22,7 @@
 import java.util.concurrent.ExecutionException;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.HashSet;
+import java.util.concurrent.ConcurrentHashMap;
 
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.event.CraftEventFactory;
@@ -80,12 +80,19 @@
     private static final AtomicIntegerFieldUpdater chatSpamField = AtomicIntegerFieldUpdater.newUpdater(PlayerConnection.class, "chatThrottle");
     // CraftBukkit end
     private int m;
-    private IntHashMap<Short> n = new IntHashMap();
+    //private IntHashMap<Short> n = new IntHashMap();
+    private ConcurrentHashMap<Integer, Short> n = new ConcurrentHashMap();
     private double o;
     private double p;
     private double q;
     private boolean checkMovement = true;
     private boolean processedDisconnect; // CraftBukkit - added
+    
+    //for spigot
+    private int g(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
 
     public PlayerConnection(MinecraftServer minecraftserver, NetworkManager networkmanager, EntityPlayer entityplayer) {
         this.minecraftServer = minecraftserver;
@@ -1700,7 +1707,8 @@
                     this.player.broadcastCarriedItem();
                     this.player.g = false;
                 } else {
-                    this.n.a(this.player.activeContainer.windowId, Short.valueOf(packetplayinwindowclick.d()));
+                    //this.n.a(this.player.activeContainer.windowId, Short.valueOf(packetplayinwindowclick.d()));
+                    this.n.put(this.g(this.player.activeContainer.windowId), Short.valueOf(packetplayinwindowclick.d()));
                     this.player.playerConnection.sendPacket(new PacketPlayOutTransaction(packetplayinwindowclick.a(), packetplayinwindowclick.d(), false));
                     this.player.activeContainer.a(this.player, false);
                     ArrayList arraylist1 = Lists.newArrayList();
@@ -1818,7 +1826,8 @@
     public void a(PacketPlayInTransaction packetplayintransaction) {
         if (this.player.dead) return; // CraftBukkit
         PlayerConnectionUtils.ensureMainThread(packetplayintransaction, this, this.player.u());
-        Short oshort = (Short) this.n.get(this.player.activeContainer.windowId);
+        //Short oshort = (Short) this.n.get(this.player.activeContainer.windowId);
+        Short oshort = (Short) this.n.get(this.g(this.player.activeContainer.windowId));
 
         if (oshort != null && packetplayintransaction.b() == oshort.shortValue() && this.player.activeContainer.windowId == packetplayintransaction.a() && !this.player.activeContainer.c(this.player) && !this.player.isSpectator()) {
             this.player.activeContainer.a(this.player, true);
diff -Naur src_origin/main/java/net/minecraft/server/PlayerList.java src/main/java/net/minecraft/server/PlayerList.java
--- src_origin/main/java/net/minecraft/server/PlayerList.java	2016-02-26 15:27:12.726203777 +0800
+++ src/main/java/net/minecraft/server/PlayerList.java	2016-03-07 17:08:45.789615468 +0800
@@ -15,6 +15,8 @@
 import java.util.List;
 import java.util.Map;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -48,13 +50,16 @@
     private static final Logger f = LogManager.getLogger();
     private static final SimpleDateFormat g = new SimpleDateFormat("yyyy-MM-dd \'at\' HH:mm:ss z");
     private final MinecraftServer server;
-    public final List<EntityPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
-    private final Map<UUID, EntityPlayer> j = Maps.newHashMap();
+    //public final List<EntityPlayer> players = new java.util.concurrent.CopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
+    public final List<EntityPlayer> players = Lists.newCopyOnWriteArrayList(); // CraftBukkit - ArrayList -> CopyOnWriteArrayList: Iterator safety
+    //private final Map<UUID, EntityPlayer> j = Maps.newHashMap();
+    private final ConcurrentMap<UUID, EntityPlayer> j = new ConcurrentHashMap<UUID, EntityPlayer>();
     private final GameProfileBanList k;
     private final IpBanList l;
     private final OpList operators;
     private final WhiteList whitelist;
-    private final Map<UUID, ServerStatisticManager> o;
+    //private final Map<UUID, ServerStatisticManager> o;
+    private final ConcurrentMap<UUID, ServerStatisticManager> o;
     public IPlayerFileData playerFileData;
     private boolean hasWhitelist;
     protected int maxPlayers;
@@ -77,7 +82,8 @@
         this.l = new IpBanList(PlayerList.b);
         this.operators = new OpList(PlayerList.c);
         this.whitelist = new WhiteList(PlayerList.d);
-        this.o = Maps.newHashMap();
+        //this.o = Maps.newHashMap();
+        this.o = new ConcurrentHashMap<UUID, ServerStatisticManager>();
         this.server = minecraftserver;
         this.k.a(false);
         this.l.a(false);
@@ -951,6 +957,7 @@
     public String b(boolean flag) {
         String s = "";
         ArrayList arraylist = Lists.newArrayList(this.players);
+        //List arraylist = Lists.newCopyOnWriteArrayList(this.players);
 
         for (int i = 0; i < arraylist.size(); ++i) {
             if (i > 0) {
@@ -1134,6 +1141,7 @@
 
     public List<EntityPlayer> b(String s) {
         ArrayList arraylist = Lists.newArrayList();
+        //List arraylist = Lists.newCopyOnWriteArrayList();
         Iterator iterator = this.players.iterator();
 
         while (iterator.hasNext()) {
diff -Naur src_origin/main/java/net/minecraft/server/PortalTravelAgent.java src/main/java/net/minecraft/server/PortalTravelAgent.java
--- src_origin/main/java/net/minecraft/server/PortalTravelAgent.java	2016-02-26 15:27:12.766203781 +0800
+++ src/main/java/net/minecraft/server/PortalTravelAgent.java	2016-03-07 17:08:45.818615471 +0800
@@ -1,9 +1,9 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Lists;
 import java.util.Iterator;
-import java.util.List;
+import java.util.Queue;
 import java.util.Random;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 // CraftBukkit start
 import org.bukkit.Location;
@@ -16,7 +16,8 @@
     private final WorldServer a;
     private final Random b;
     private final LongHashMap<PortalTravelAgent.ChunkCoordinatesPortal> c = new LongHashMap();
-    private final List<Long> d = Lists.newArrayList();
+    //private final List<Long> d = Lists.newArrayList();
+    private final Queue<Long> d = new ConcurrentLinkedQueue<Long>();
 
     public PortalTravelAgent(WorldServer worldserver) {
         this.a = worldserver;
diff -Naur src_origin/main/java/net/minecraft/server/RecipesFurnace.java src/main/java/net/minecraft/server/RecipesFurnace.java
--- src_origin/main/java/net/minecraft/server/RecipesFurnace.java	2016-02-26 15:27:12.987203802 +0800
+++ src/main/java/net/minecraft/server/RecipesFurnace.java	2016-03-07 17:08:46.006615489 +0800
@@ -4,13 +4,18 @@
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 public class RecipesFurnace {
 
     private static final RecipesFurnace a = new RecipesFurnace();
-    public Map<ItemStack, ItemStack> recipes = Maps.newHashMap();
+    /*public Map<ItemStack, ItemStack> recipes = Maps.newHashMap();
     private Map<ItemStack, Float> c = Maps.newHashMap();
-    public Map customRecipes = Maps.newHashMap(); // CraftBukkit - add field
+    public Map customRecipes = Maps.newHashMap(); // CraftBukkit - add field*/
+    public ConcurrentMap<ItemStack, ItemStack> recipes = new ConcurrentHashMap<ItemStack, ItemStack>();
+    private ConcurrentMap<ItemStack, Float> c = new ConcurrentHashMap<ItemStack, Float>();
+    public ConcurrentMap customRecipes = new ConcurrentHashMap();
 
     public static RecipesFurnace getInstance() {
         return RecipesFurnace.a;
diff -Naur src_origin/main/java/net/minecraft/server/RegionFileCache.java src/main/java/net/minecraft/server/RegionFileCache.java
--- src_origin/main/java/net/minecraft/server/RegionFileCache.java	2016-02-26 15:27:13.038203807 +0800
+++ src/main/java/net/minecraft/server/RegionFileCache.java	2016-03-07 17:08:46.046615492 +0800
@@ -1,16 +1,17 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Maps;
 import java.io.DataInputStream;
 import java.io.DataOutputStream;
 import java.io.File;
 import java.io.IOException;
 import java.util.Iterator;
-import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 public class RegionFileCache {
 
-    public static final Map<File, RegionFile> a = Maps.newHashMap(); // Spigot - private -> public
+    //public static final Map<File, RegionFile> a = Maps.newHashMap(); // Spigot - private -> public
+    public static final ConcurrentMap<File, RegionFile> a = new ConcurrentHashMap<File, RegionFile>(); // Spigot - private -> public
 
     public static synchronized RegionFile a(File file, int i, int j) {
         File file1 = new File(file, "region");
diff -Naur src_origin/main/java/net/minecraft/server/ScoreboardServer.java src/main/java/net/minecraft/server/ScoreboardServer.java
--- src_origin/main/java/net/minecraft/server/ScoreboardServer.java	2016-02-26 15:27:13.079203810 +0800
+++ src/main/java/net/minecraft/server/ScoreboardServer.java	2016-03-07 17:08:46.087615496 +0800
@@ -7,11 +7,13 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
 
 public class ScoreboardServer extends Scoreboard {
 
     private final MinecraftServer a;
-    private final Set<ScoreboardObjective> b = Sets.newHashSet();
+    //private final Set<ScoreboardObjective> b = Sets.newHashSet();
+    private final Set<ScoreboardObjective> b = new CopyOnWriteArraySet<ScoreboardObjective>();
     private PersistentScoreboard c;
 
     public ScoreboardServer(MinecraftServer minecraftserver) {
diff -Naur src_origin/main/java/net/minecraft/server/ServerConnection.java src/main/java/net/minecraft/server/ServerConnection.java
--- src_origin/main/java/net/minecraft/server/ServerConnection.java	2016-02-26 15:27:13.131203815 +0800
+++ src/main/java/net/minecraft/server/ServerConnection.java	2016-03-07 17:08:46.135615501 +0800
@@ -23,7 +23,9 @@
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -61,6 +63,8 @@
     public volatile boolean d;
     private final List<ChannelFuture> g = Collections.synchronizedList(Lists.<ChannelFuture>newArrayList());
     private final List<NetworkManager> h = Collections.synchronizedList(Lists.<NetworkManager>newArrayList());
+    /*private final List<ChannelFuture> g = Lists.<ChannelFuture>newCopyOnWriteArrayList();
+    private final Queue<NetworkManager> h = new ConcurrentLinkedQueue<NetworkManager>();*/
 
     public ServerConnection(MinecraftServer minecraftserver) {
         this.f = minecraftserver;
diff -Naur src_origin/main/java/net/minecraft/server/ServerStatisticManager.java src/main/java/net/minecraft/server/ServerStatisticManager.java
--- src_origin/main/java/net/minecraft/server/ServerStatisticManager.java	2016-02-26 15:27:13.135203816 +0800
+++ src/main/java/net/minecraft/server/ServerStatisticManager.java	2016-03-07 17:08:46.159615503 +0800
@@ -15,6 +15,7 @@
 import java.util.Map;
 import java.util.Set;
 import java.util.Map.Entry;
+import java.util.concurrent.CopyOnWriteArraySet;
 import org.apache.commons.io.FileUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
@@ -24,7 +25,8 @@
     private static final Logger b = LogManager.getLogger();
     private final MinecraftServer c;
     private final File d;
-    private final Set<Statistic> e = Sets.newHashSet();
+    //private final Set<Statistic> e = Sets.newHashSet();
+    private final Set<Statistic> e = new CopyOnWriteArraySet<Statistic>();
     private int f = -300;
     private boolean g = false;
 
diff -Naur src_origin/main/java/net/minecraft/server/SpawnerCreature.java src/main/java/net/minecraft/server/SpawnerCreature.java
--- src_origin/main/java/net/minecraft/server/SpawnerCreature.java	2016-02-26 15:27:13.289203830 +0800
+++ src/main/java/net/minecraft/server/SpawnerCreature.java	2016-03-07 17:08:46.274615514 +0800
@@ -1,21 +1,26 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Sets;
+import io.netty.util.internal.chmv8.ConcurrentHashMapV8;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
-import java.util.Set;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.FutureTask;
+import java.util.logging.Level;
+import java.util.logging.Logger;
 
 // CraftBukkit start
 import org.bukkit.craftbukkit.util.LongHash;
-import org.bukkit.craftbukkit.util.LongHashSet;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
+import org.hose.SpawnerCreature_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public final class SpawnerCreature {
 
     private static final int a = (int) Math.pow(17.0D, 2.0D);
-    private final LongHashSet b = new LongHashSet(); // CraftBukkit
+    //private final LongHashSet b = new LongHashSet(); // CraftBukkit
+    private final ConcurrentHashMapV8<Long, Long> b = new ConcurrentHashMapV8<Long, Long>(); // CraftBukkit
 
     public SpawnerCreature() {}
 
@@ -23,13 +28,15 @@
     private int getEntityCount(WorldServer server, Class oClass)
     {
         int i = 0;
-        Iterator<Long> it = this.b.iterator();
+        //Iterator<Long> it = this.b.iterator();
+        Iterator<Long> it = this.b.keySet().iterator();
         while ( it.hasNext() )
         {
             Long coord = it.next();
             int x = LongHash.msw( coord );
             int z = LongHash.lsw( coord );
-            if ( !server.chunkProviderServer.unloadQueue.contains( coord ) && server.isChunkLoaded( x, z, true ) )
+            //if ( !server.chunkProviderServer.unloadQueue.contains( coord ) && server.isChunkLoaded( x, z, true ) )
+            if ( !server.chunkProviderServer.unloadQueue.containsKey( coord ) && server.isChunkLoaded( x, z, true ) )
             {
                 i += server.getChunkAt( x, z ).entityCount.get( oClass );
             }
@@ -37,7 +44,22 @@
         return i;
     }
     // Spigot end
-
+    /*
+    public int a(WorldServer worldserver, boolean flag, boolean flag1, boolean flag2) {
+        //return a_hose(worldserver, flag, flag1, flag2);
+        SpigotWorldConfig.SpawnerCreatureTask = new FutureTask(new SpawnerCreature_Pool(this, worldserver, flag, flag1, flag2));
+        SpigotWorldConfig.spawncreaturepool_executor.submit(SpigotWorldConfig.SpawnerCreatureTask);
+        try {
+            return SpigotWorldConfig.SpawnerCreatureTask.get();
+        } catch (InterruptedException ex) {
+            Logger.getLogger(SpawnerCreature.class.getName()).log(Level.SEVERE, null, ex);
+        } catch (ExecutionException ex) {
+            Logger.getLogger(SpawnerCreature.class.getName()).log(Level.SEVERE, null, ex);
+        }
+        return 0;
+    }*/
+    
+    //callable
     public int a(WorldServer worldserver, boolean flag, boolean flag1, boolean flag2) {
         if (!flag && !flag1) {
             return 0;
@@ -47,8 +69,9 @@
             Iterator iterator = worldserver.players.iterator();
 
             int j;
-            int k;
-
+            //int k;
+            int k = 0;
+            //long st01 = System.nanoTime();
             while (iterator.hasNext()) {
                 EntityHuman entityhuman = (EntityHuman) iterator.next();
 
@@ -70,10 +93,12 @@
                             // ChunkCoordIntPair chunkcoordintpair = new ChunkCoordIntPair(i1 + l, k + j);
 
                             long chunkCoords = LongHash.toLong(i1 + l, k + j);
-                            if (!this.b.contains(chunkCoords)) {
+                            //if (!this.b.contains(chunkCoords)) {
+                            if (!this.b.containsKey(chunkCoords)) {
                                 ++i;
                                 if (!flag3 && worldserver.getWorldBorder().isInBounds(i1 + l, k + j)) {
-                                    this.b.add(chunkCoords);
+                                    //this.b.add(chunkCoords);
+                                    this.b.put(chunkCoords, chunkCoords);
                                 }
                             }
                             // CraftBukkit end
@@ -81,17 +106,26 @@
                     }
                 }
             }
-
+            /*long et01 = System.nanoTime();
+            System.out.println("01: "+(et01-st01)+"ns");*/
+            
             int j1 = 0;
             BlockPosition blockposition = worldserver.getSpawn();
             EnumCreatureType[] aenumcreaturetype = EnumCreatureType.values();
 
             j = aenumcreaturetype.length;
 
+            //long st02 = System.nanoTime();
             for (int k1 = 0; k1 < j; ++k1) {
+                //create callable evry type
+                //j1 = spawn_calc_hose(aenumcreaturetype, blockposition, i, j1, k, k1, worldserver, flag, flag1, flag2);
+                SpigotWorldConfig.SpawnerCreatureTask = new FutureTask(new SpawnerCreature_Pool(this, aenumcreaturetype, blockposition, i, j1, k, k1, worldserver, flag, flag1, flag2));
+                SpigotWorldConfig.spawncreaturepool_executor.submit(SpigotWorldConfig.SpawnerCreatureTask);
+                
+                /*
                 EnumCreatureType enumcreaturetype = aenumcreaturetype[k1];
 
-               // CraftBukkit start - Use per-world spawn limits
+                // CraftBukkit start - Use per-world spawn limits
                 int limit = enumcreaturetype.b();
                 switch (enumcreaturetype) {
                     case MONSTER:
@@ -111,111 +145,244 @@
                 if (limit == 0) {
                     continue;
                 }
-				int mobcnt = 0; // Spigot
+                int mobcnt = 0; // Spigot
                 // CraftBukkit end
 
                 if ((!enumcreaturetype.d() || flag1) && (enumcreaturetype.d() || flag) && (!enumcreaturetype.e() || flag2)) {
-                    k = worldserver.a(enumcreaturetype.a());
-                    int l1 = limit * i / a; // CraftBukkit - use per-world limits
+                k = worldserver.a(enumcreaturetype.a());
+                int l1 = limit * i / a; // CraftBukkit - use per-world limits
+
+                if ((mobcnt = getEntityCount(worldserver, enumcreaturetype.a())) <= limit * i / 256) {
+                //Iterator iterator1 = this.b.iterator();
+                Iterator iterator1 = this.b.keySet().iterator();
+
+                int moblimit = (limit * i / 256) - mobcnt + 1; // Spigot - up to 1 more than limit
+                label115:
+                while (iterator1.hasNext() && (moblimit > 0)) { // Spigot - while more allowed
+                // CraftBukkit start = use LongHash and LongObjectHashMap
+                long key = ((Long) iterator1.next()).longValue();
+                BlockPosition blockposition1 = getRandomPosition(worldserver, LongHash.msw(key), LongHash.lsw(key));
+                // CraftBukkit
+                int i2 = blockposition1.getX();
+                int j2 = blockposition1.getY();
+                int k2 = blockposition1.getZ();
+                Block block = worldserver.getType(blockposition1).getBlock();
+
+                if (!block.isOccluding()) {
+                int l2 = 0;
+                int i3 = 0;
+
+                while (i3 < 3) {
+                int j3 = i2;
+                int k3 = j2;
+                int l3 = k2;
+                byte b1 = 6;
+                BiomeBase.BiomeMeta biomebase_biomemeta = null;
+                GroupDataEntity groupdataentity = null;
+                int i4 = 0;
+
+                while (true) {
+                if (i4 < 4) {
+                label108: {
+                j3 += worldserver.random.nextInt(b1) - worldserver.random.nextInt(b1);
+                k3 += worldserver.random.nextInt(1) - worldserver.random.nextInt(1);
+                l3 += worldserver.random.nextInt(b1) - worldserver.random.nextInt(b1);
+                BlockPosition blockposition2 = new BlockPosition(j3, k3, l3);
+                float f = (float) j3 + 0.5F;
+                float f1 = (float) l3 + 0.5F;
+
+                if (!worldserver.isPlayerNearby((double) f, (double) k3, (double) f1, 24.0D) && blockposition.c((double) f, (double) k3, (double) f1) >= 576.0D) {
+                    if (biomebase_biomemeta == null) {
+                        biomebase_biomemeta = worldserver.a(enumcreaturetype, blockposition2);
+                    if (biomebase_biomemeta == null) {
+                        break label108;
+                    }
+                }
 
-                    if ((mobcnt = getEntityCount(worldserver, enumcreaturetype.a())) <= limit * i / 256) {
-                        Iterator iterator1 = this.b.iterator();
+                if (worldserver.a(enumcreaturetype, biomebase_biomemeta, blockposition2) && a(EntityPositionTypes.a(biomebase_biomemeta.b), worldserver, blockposition2)) {
+                EntityInsentient entityinsentient;
 
-                        int moblimit = (limit * i / 256) - mobcnt + 1; // Spigot - up to 1 more than limit
-                        label115:
-                        while (iterator1.hasNext() && (moblimit > 0)) { // Spigot - while more allowed
-                            // CraftBukkit start = use LongHash and LongObjectHashMap
-                            long key = ((Long) iterator1.next()).longValue();
-                            BlockPosition blockposition1 = getRandomPosition(worldserver, LongHash.msw(key), LongHash.lsw(key));
-                            // CraftBukkit
-                            int i2 = blockposition1.getX();
-                            int j2 = blockposition1.getY();
-                            int k2 = blockposition1.getZ();
-                            Block block = worldserver.getType(blockposition1).getBlock();
-
-                            if (!block.isOccluding()) {
-                                int l2 = 0;
-                                int i3 = 0;
-
-                                while (i3 < 3) {
-                                    int j3 = i2;
-                                    int k3 = j2;
-                                    int l3 = k2;
-                                    byte b1 = 6;
-                                    BiomeBase.BiomeMeta biomebase_biomemeta = null;
-                                    GroupDataEntity groupdataentity = null;
-                                    int i4 = 0;
-
-                                    while (true) {
-                                        if (i4 < 4) {
-                                            label108: {
-                                                j3 += worldserver.random.nextInt(b1) - worldserver.random.nextInt(b1);
-                                                k3 += worldserver.random.nextInt(1) - worldserver.random.nextInt(1);
-                                                l3 += worldserver.random.nextInt(b1) - worldserver.random.nextInt(b1);
-                                                BlockPosition blockposition2 = new BlockPosition(j3, k3, l3);
-                                                float f = (float) j3 + 0.5F;
-                                                float f1 = (float) l3 + 0.5F;
-
-                                                if (!worldserver.isPlayerNearby((double) f, (double) k3, (double) f1, 24.0D) && blockposition.c((double) f, (double) k3, (double) f1) >= 576.0D) {
-                                                    if (biomebase_biomemeta == null) {
-                                                        biomebase_biomemeta = worldserver.a(enumcreaturetype, blockposition2);
-                                                        if (biomebase_biomemeta == null) {
-                                                            break label108;
-                                                        }
-                                                    }
+                try {
+                entityinsentient = (EntityInsentient) biomebase_biomemeta.b.getConstructor(new Class[] { World.class}).newInstance(new Object[] { worldserver});
+                } catch (Exception exception) {
+                exception.printStackTrace();
+                return j1;
+                }
+
+                entityinsentient.setPositionRotation((double) f, (double) k3, (double) f1, worldserver.random.nextFloat() * 360.0F, 0.0F);
+                if (entityinsentient.bR() && entityinsentient.canSpawn()) {
+                groupdataentity = entityinsentient.prepare(worldserver.E(new BlockPosition(entityinsentient)), groupdataentity);
+                if (entityinsentient.canSpawn()) {
+                ++l2;
+                worldserver.addEntity(entityinsentient, SpawnReason.NATURAL); // CraftBukkit - Added a reason for spawning this creature
+                //SpigotWorldConfig.SpawnerCreatureTask = new FutureTask(new SpawnerCreature_Pool(worldserver, entityinsentient));
+                //SpigotWorldConfig.spawncreaturepool_executor.submit(SpigotWorldConfig.SpawnerCreatureTask);
+                }
+
+                // Spigot start
+                if ( --moblimit <= 0 )
+                {
+                // If we're past limit, stop spawn
+                continue label115;
+                }
+                // Spigot end
+                if (l2 >= entityinsentient.bV()) {
+                continue label115;
+                }
+                }
+
+                j1 += l2;
+                }
+                }
+
+                ++i4;
+                continue;
+                }
+                }
+
+                ++i3;
+                break;
+                }
+                }
+                }
+                }
+                }
+                }*/
+            }
+            /*long et02 = System.nanoTime();
+            System.out.println("02: "+(et02-st02)+"ns");
+            System.out.println("j1: "+j1);*/
+            return j1;
+        }
+    }
+    
+    public int spawn_calc_hose(EnumCreatureType[] aenumcreaturetype, BlockPosition blockposition, int i, int j1, int k, int k1, WorldServer worldserver, boolean flag, boolean flag1, boolean flag2){
+        EnumCreatureType enumcreaturetype = aenumcreaturetype[k1];
+
+        // CraftBukkit start - Use per-world spawn limits
+        int limit = enumcreaturetype.b();
+        switch (enumcreaturetype) {
+            case MONSTER:
+                limit = worldserver.getWorld().getMonsterSpawnLimit();
+                break;
+            case CREATURE:
+                limit = worldserver.getWorld().getAnimalSpawnLimit();
+                break;
+            case WATER_CREATURE:
+                limit = worldserver.getWorld().getWaterAnimalSpawnLimit();
+                break;
+            case AMBIENT:
+                limit = worldserver.getWorld().getAmbientSpawnLimit();
+                break;
+        }
 
-                                                    if (worldserver.a(enumcreaturetype, biomebase_biomemeta, blockposition2) && a(EntityPositionTypes.a(biomebase_biomemeta.b), worldserver, blockposition2)) {
-                                                        EntityInsentient entityinsentient;
+        if (limit == 0) {
+            return 0;
+        }
+                        int mobcnt = 0; // Spigot
+        // CraftBukkit end
 
-                                                        try {
-                                                            entityinsentient = (EntityInsentient) biomebase_biomemeta.b.getConstructor(new Class[] { World.class}).newInstance(new Object[] { worldserver});
-                                                        } catch (Exception exception) {
-                                                            exception.printStackTrace();
-                                                            return j1;
-                                                        }
-
-                                                        entityinsentient.setPositionRotation((double) f, (double) k3, (double) f1, worldserver.random.nextFloat() * 360.0F, 0.0F);
-                                                        if (entityinsentient.bR() && entityinsentient.canSpawn()) {
-                                                            groupdataentity = entityinsentient.prepare(worldserver.E(new BlockPosition(entityinsentient)), groupdataentity);
-                                                            if (entityinsentient.canSpawn()) {
-                                                                ++l2;
-                                                                worldserver.addEntity(entityinsentient, SpawnReason.NATURAL); // CraftBukkit - Added a reason for spawning this creature
-                                                            }
-
-                                                            // Spigot start
-                                                            if ( --moblimit <= 0 )
-                                                            {
-                                                                // If we're past limit, stop spawn
-                                                                continue label115;
-                                                            }
-                                                            // Spigot end
-                                                            if (l2 >= entityinsentient.bV()) {
-                                                                continue label115;
-                                                            }
-                                                        }
+        if ((!enumcreaturetype.d() || flag1) && (enumcreaturetype.d() || flag) && (!enumcreaturetype.e() || flag2)) {
+            k = worldserver.a(enumcreaturetype.a());
+            int l1 = limit * i / a; // CraftBukkit - use per-world limits
+
+            if ((mobcnt = getEntityCount(worldserver, enumcreaturetype.a())) <= limit * i / 256) {
+                //Iterator iterator1 = this.b.iterator();
+                Iterator iterator1 = this.b.keySet().iterator();
+
+                int moblimit = (limit * i / 256) - mobcnt + 1; // Spigot - up to 1 more than limit
+                label115:
+                while (iterator1.hasNext() && (moblimit > 0)) { // Spigot - while more allowed
+                    // CraftBukkit start = use LongHash and LongObjectHashMap
+                    long key = ((Long) iterator1.next()).longValue();
+                    BlockPosition blockposition1 = getRandomPosition(worldserver, LongHash.msw(key), LongHash.lsw(key));
+                    // CraftBukkit
+                    int i2 = blockposition1.getX();
+                    int j2 = blockposition1.getY();
+                    int k2 = blockposition1.getZ();
+                    Block block = worldserver.getType(blockposition1).getBlock();
+
+                    if (!block.isOccluding()) {
+                        int l2 = 0;
+                        int i3 = 0;
+
+                        while (i3 < 3) {
+                            int j3 = i2;
+                            int k3 = j2;
+                            int l3 = k2;
+                            byte b1 = 6;
+                            BiomeBase.BiomeMeta biomebase_biomemeta = null;
+                            GroupDataEntity groupdataentity = null;
+                            int i4 = 0;
+
+                            while (true) {
+                                if (i4 < 4) {
+                                    label108: {
+                                        j3 += worldserver.random.nextInt(b1) - worldserver.random.nextInt(b1);
+                                        k3 += worldserver.random.nextInt(1) - worldserver.random.nextInt(1);
+                                        l3 += worldserver.random.nextInt(b1) - worldserver.random.nextInt(b1);
+                                        BlockPosition blockposition2 = new BlockPosition(j3, k3, l3);
+                                        float f = (float) j3 + 0.5F;
+                                        float f1 = (float) l3 + 0.5F;
+
+                                        if (!worldserver.isPlayerNearby((double) f, (double) k3, (double) f1, 24.0D) && blockposition.c((double) f, (double) k3, (double) f1) >= 576.0D) {
+                                            if (biomebase_biomemeta == null) {
+                                                biomebase_biomemeta = worldserver.a(enumcreaturetype, blockposition2);
+                                                if (biomebase_biomemeta == null) {
+                                                    break label108;
+                                                }
+                                            }
+
+                                            if (worldserver.a(enumcreaturetype, biomebase_biomemeta, blockposition2) && a(EntityPositionTypes.a(biomebase_biomemeta.b), worldserver, blockposition2)) {
+                                                EntityInsentient entityinsentient;
 
-                                                        j1 += l2;
+                                                try {
+                                                    entityinsentient = (EntityInsentient) biomebase_biomemeta.b.getConstructor(new Class[] { World.class}).newInstance(new Object[] { worldserver});
+                                                } catch (Exception exception) {
+                                                    exception.printStackTrace();
+                                                    return j1;
+                                                }
+
+                                                entityinsentient.setPositionRotation((double) f, (double) k3, (double) f1, worldserver.random.nextFloat() * 360.0F, 0.0F);
+                                                if (entityinsentient.bR() && entityinsentient.canSpawn()) {
+                                                    groupdataentity = entityinsentient.prepare(worldserver.E(new BlockPosition(entityinsentient)), groupdataentity);
+                                                    if (entityinsentient.canSpawn()) {
+                                                        ++l2;
+                                                        worldserver.addEntity(entityinsentient, SpawnReason.NATURAL); // CraftBukkit - Added a reason for spawning this creature
+                                                    }
+
+                                                    // Spigot start
+                                                    if ( --moblimit <= 0 )
+                                                    {
+                                                        // If we're past limit, stop spawn
+                                                        continue label115;
+                                                    }
+                                                    // Spigot end
+                                                    if (l2 >= entityinsentient.bV()) {
+                                                        continue label115;
                                                     }
                                                 }
 
-                                                ++i4;
-                                                continue;
+                                                j1 += l2;
                                             }
                                         }
 
-                                        ++i3;
-                                        break;
+                                        ++i4;
+                                        continue;
                                     }
                                 }
+
+                                ++i3;
+                                break;
                             }
                         }
                     }
                 }
             }
-
-            return j1;
         }
+        return j1;
     }
+    
 
     protected static BlockPosition getRandomPosition(World world, int i, int j) {
         Chunk chunk = world.getChunkAt(i, j);
diff -Naur src_origin/main/java/net/minecraft/server/StructureGenerator.java src/main/java/net/minecraft/server/StructureGenerator.java
--- src_origin/main/java/net/minecraft/server/StructureGenerator.java	2016-02-26 15:27:13.339203835 +0800
+++ src/main/java/net/minecraft/server/StructureGenerator.java	2016-03-07 17:08:46.319615518 +0800
@@ -1,16 +1,17 @@
 package net.minecraft.server;
 
-import com.google.common.collect.Maps;
 import java.util.Iterator;
 import java.util.List;
-import java.util.Map;
 import java.util.Random;
 import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 public abstract class StructureGenerator extends WorldGenBase {
 
     private PersistentStructure d;
-    protected Map<Long, StructureStart> e = Maps.newHashMap();
+    //protected Map<Long, StructureStart> e = Maps.newHashMap(); //casue concurrent problem
+    protected ConcurrentMap<Long, StructureStart> e = new ConcurrentHashMap<Long, StructureStart>();
 
     public StructureGenerator() {}
 
diff -Naur src_origin/main/java/net/minecraft/server/TileEntityBeacon.java src/main/java/net/minecraft/server/TileEntityBeacon.java
--- src_origin/main/java/net/minecraft/server/TileEntityBeacon.java	2016-02-26 15:27:13.400203841 +0800
+++ src/main/java/net/minecraft/server/TileEntityBeacon.java	2016-03-07 17:08:46.392615525 +0800
@@ -14,6 +14,7 @@
 
     public static final MobEffectList[][] a = new MobEffectList[][] { { MobEffectList.FASTER_MOVEMENT, MobEffectList.FASTER_DIG}, { MobEffectList.RESISTANCE, MobEffectList.JUMP}, { MobEffectList.INCREASE_DAMAGE}, { MobEffectList.REGENERATION}};
     private final List<TileEntityBeacon.BeaconColorTracker> f = Lists.newArrayList();
+    //private final List<TileEntityBeacon.BeaconColorTracker> f = Lists.newCopyOnWriteArrayList();
     private boolean i;
     private int j = -1;
     private int k;
diff -Naur src_origin/main/java/net/minecraft/server/TileEntity.java src/main/java/net/minecraft/server/TileEntity.java
--- src_origin/main/java/net/minecraft/server/TileEntity.java	2016-02-26 15:27:13.351203836 +0800
+++ src/main/java/net/minecraft/server/TileEntity.java	2016-03-07 17:08:46.335615519 +0800
@@ -3,6 +3,8 @@
 import com.google.common.collect.Maps;
 import java.util.Map;
 import java.util.concurrent.Callable;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -13,8 +15,10 @@
 
     public CustomTimingsHandler tickTimer = org.bukkit.craftbukkit.SpigotTimings.getTileEntityTimings(this); // Spigot
     private static final Logger a = LogManager.getLogger();
-    private static Map<String, Class<? extends TileEntity>> f = Maps.newHashMap();
-    private static Map<Class<? extends TileEntity>, String> g = Maps.newHashMap();
+    /*private static Map<String, Class<? extends TileEntity>> f = Maps.newHashMap();
+    private static Map<Class<? extends TileEntity>, String> g = Maps.newHashMap();*/
+    private static ConcurrentMap<String, Class<? extends TileEntity>> f = new ConcurrentHashMap<String, Class<? extends TileEntity>>();
+    private static ConcurrentMap<Class<? extends TileEntity>, String> g = new ConcurrentHashMap<Class<? extends TileEntity>, String>();
     protected World world;
     protected BlockPosition position;
     protected boolean d;
diff -Naur src_origin/main/java/net/minecraft/server/TileEntityPiston.java src/main/java/net/minecraft/server/TileEntityPiston.java
--- src_origin/main/java/net/minecraft/server/TileEntityPiston.java	2016-02-26 15:27:13.607203860 +0800
+++ src/main/java/net/minecraft/server/TileEntityPiston.java	2016-03-07 17:08:46.578615542 +0800
@@ -12,7 +12,8 @@
     private boolean h;
     private float i;
     private float j;
-    private List<Entity> k = Lists.newArrayList();
+    //private List<Entity> k = Lists.newArrayList();
+    private List<Entity> k = Lists.newCopyOnWriteArrayList();
 
     public TileEntityPiston() {}
 
diff -Naur src_origin/main/java/net/minecraft/server/UserCache.java src/main/java/net/minecraft/server/UserCache.java
--- src_origin/main/java/net/minecraft/server/UserCache.java	2016-02-26 15:27:13.676203866 +0800
+++ src/main/java/net/minecraft/server/UserCache.java	2016-03-07 17:08:46.652615549 +0800
@@ -33,15 +33,18 @@
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
-import java.util.Map;
 import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 import org.apache.commons.io.IOUtils;
 
 public class UserCache {
 
     public static final SimpleDateFormat a = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z");
-    private final Map<String, UserCache.UserCacheEntry> c = Maps.newHashMap();
-    private final Map<UUID, UserCache.UserCacheEntry> d = Maps.newHashMap();
+    /*private final Map<String, UserCache.UserCacheEntry> c = Maps.newHashMap();
+    private final Map<UUID, UserCache.UserCacheEntry> d = Maps.newHashMap();*/
+    private final ConcurrentMap<String, UserCache.UserCacheEntry> c = new ConcurrentHashMap<String, UserCache.UserCacheEntry>();
+    private final ConcurrentMap<UUID, UserCache.UserCacheEntry> d = new ConcurrentHashMap<UUID, UserCache.UserCacheEntry>();
     private final java.util.Deque<GameProfile> e = new java.util.concurrent.LinkedBlockingDeque<GameProfile>(); // CraftBukkit
     private final MinecraftServer f;
     protected final Gson b;
@@ -155,6 +158,7 @@
 
     public String[] a() {
         ArrayList arraylist = Lists.newArrayList(this.c.keySet());
+        //List arraylist = Lists.newCopyOnWriteArrayList(this.c.keySet());
 
         return (String[]) arraylist.toArray(new String[arraylist.size()]);
     }
diff -Naur src_origin/main/java/net/minecraft/server/WorldBorder.java src/main/java/net/minecraft/server/WorldBorder.java
--- src_origin/main/java/net/minecraft/server/WorldBorder.java	2016-02-26 15:27:13.784203876 +0800
+++ src/main/java/net/minecraft/server/WorldBorder.java	2016-03-07 17:08:46.759615559 +0800
@@ -7,6 +7,7 @@
 public class WorldBorder {
 
     private final List<IWorldBorderListener> a = Lists.newArrayList();
+    //private final List<IWorldBorderListener> a = Lists.newCopyOnWriteArrayList();
     private double b = 0.0D;
     private double c = 0.0D;
     private double d = 6.0E7D;
@@ -186,6 +187,7 @@
 
     protected List<IWorldBorderListener> k() {
         return Lists.newArrayList(this.a);
+        //return Lists.newCopyOnWriteArrayList(this.a);
     }
 
     public void a(IWorldBorderListener iworldborderlistener) {
diff -Naur src_origin/main/java/net/minecraft/server/WorldGenLargeFeature.java src/main/java/net/minecraft/server/WorldGenLargeFeature.java
--- src_origin/main/java/net/minecraft/server/WorldGenLargeFeature.java	2016-02-26 15:27:13.882203886 +0800
+++ src/main/java/net/minecraft/server/WorldGenLargeFeature.java	2016-03-07 17:08:46.846615567 +0800
@@ -17,6 +17,7 @@
 
     public WorldGenLargeFeature() {
         this.f = Lists.newArrayList();
+        //this.f = Lists.newCopyOnWriteArrayList();
         this.g = 32;
         this.h = 8;
         this.f.add(new BiomeBase.BiomeMeta(EntityWitch.class, 1, 1, 1));
diff -Naur src_origin/main/java/net/minecraft/server/WorldGenVillagePieces.java src/main/java/net/minecraft/server/WorldGenVillagePieces.java
--- src_origin/main/java/net/minecraft/server/WorldGenVillagePieces.java	2016-02-26 15:27:14.039203900 +0800
+++ src/main/java/net/minecraft/server/WorldGenVillagePieces.java	2016-03-07 17:08:46.987615580 +0800
@@ -2,9 +2,13 @@
 
 import com.google.common.collect.Lists;
 import java.util.ArrayList;
+import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Queue;
 import java.util.Random;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
 public class WorldGenVillagePieces {
 
@@ -25,8 +29,9 @@
     }
 
     public static List<WorldGenVillagePieces.WorldGenVillagePieceWeight> a(Random random, int i) {
-        ArrayList arraylist = Lists.newArrayList();
-
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Collections.synchronizedList(Lists.newArrayList());
+        
         arraylist.add(new WorldGenVillagePieces.WorldGenVillagePieceWeight(WorldGenVillagePieces.WorldGenVillageHouse.class, 4, MathHelper.nextInt(random, 2 + i, 4 + i * 2)));
         arraylist.add(new WorldGenVillagePieces.WorldGenVillagePieceWeight(WorldGenVillagePieces.WorldGenVillageTemple.class, 20, MathHelper.nextInt(random, 0 + i, 1 + i)));
         arraylist.add(new WorldGenVillagePieces.WorldGenVillagePieceWeight(WorldGenVillagePieces.WorldGenVillageLibrary.class, 20, MathHelper.nextInt(random, 0 + i, 2 + i)));
diff -Naur src_origin/main/java/net/minecraft/server/World.java src/main/java/net/minecraft/server/World.java
--- src_origin/main/java/net/minecraft/server/World.java	2016-02-26 15:27:13.782203876 +0800
+++ src/main/java/net/minecraft/server/World.java	2016-03-07 17:08:46.731615556 +0800
@@ -2,25 +2,27 @@
 
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
-import java.util.Set;
 import java.util.UUID;
 import java.util.concurrent.Callable;
 
 // CraftBukkit start
 import com.google.common.collect.Maps;
 import java.util.Map;
-
+import java.util.Queue;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ConcurrentMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import java.util.concurrent.FutureTask;
 import org.bukkit.Bukkit;
 import org.bukkit.block.BlockState;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
-import org.bukkit.craftbukkit.util.LongHashSet;
 import org.bukkit.craftbukkit.SpigotTimings; // Spigot
 import org.bukkit.generator.ChunkGenerator;
 import org.bukkit.craftbukkit.CraftServer;
@@ -29,8 +31,10 @@
 import org.bukkit.event.block.BlockCanBuildEvent;
 import org.bukkit.event.block.BlockPhysicsEvent;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
-import org.bukkit.event.weather.WeatherChangeEvent;
-import org.bukkit.event.weather.ThunderChangeEvent;
+import org.hose.AddParticlePool;
+import org.hose.EntityTick_Pool;
+import org.hose.TileTick_Pool;
+import org.spigotmc.SpigotWorldConfig;
 // CraftBukkit end
 
 public abstract class World implements IBlockAccess {
@@ -38,39 +42,52 @@
     private int a = 63;
     protected boolean e;
     // Spigot start - guard entity list from removals
-    public final List<Entity> entityList = new java.util.ArrayList<Entity>()
+    //public final List<Entity> entityList = new java.util.ArrayList<Entity>()
+    public final List<Entity> entityList = new CopyOnWriteArrayList<Entity>();
+    //public final CopyOnWriteArrayList<Entity> entityList = new CopyOnWriteArrayList<Entity>()
+    /*
+    public final List<Entity> entityList = new CopyOnWriteArrayList<Entity>()
     {
         @Override
         public Entity remove(int index)
         {
-            guard();
+            //guard();
             return super.remove( index );
         }
 
         @Override
         public boolean remove(Object o)
         {
-            guard();
+            //guard();
             return super.remove( o );
         }
-
-        private void guard()
-        {
-            if ( guardEntityList )
-            {
-                throw new java.util.ConcurrentModificationException();
-            }
-        }
-    };
+        
+        
+        //private void guard()
+        //{
+        //    if ( guardEntityList )
+        //    {
+        //        throw new java.util.ConcurrentModificationException();
+        //    }
+        //}
+    };*/
     // Spigot end
-    protected final List<Entity> g = Lists.newArrayList();
+    /*protected final List<Entity> g = Lists.newArrayList();
     public final List<TileEntity> h = Lists.newArrayList();
     public final List<TileEntity> tileEntityList = Lists.newArrayList();
     private final List<TileEntity> b = Lists.newArrayList();
     private final List<TileEntity> c = Lists.newArrayList();
     public final List<EntityHuman> players = Lists.newArrayList();
-    public final List<Entity> k = Lists.newArrayList();
-    protected final IntHashMap<Entity> entitiesById = new IntHashMap();
+    public final List<Entity> k = Lists.newArrayList();*/
+    protected final List<Entity> g = Lists.newCopyOnWriteArrayList();
+    public final List<TileEntity> h = Lists.newCopyOnWriteArrayList();
+    public final List<TileEntity> tileEntityList = Lists.newCopyOnWriteArrayList();
+    private final Queue<TileEntity> b = new ConcurrentLinkedQueue<TileEntity>();
+    private final List<TileEntity> c = Lists.newCopyOnWriteArrayList();
+    public final List<EntityHuman> players = Lists.newCopyOnWriteArrayList();
+    public final List<Entity> k = Lists.newCopyOnWriteArrayList();
+    //protected final IntHashMap<Entity> entitiesById = new IntHashMap();
+    protected final ConcurrentHashMap<Integer, Entity> entitiesById = new ConcurrentHashMap();
     private long d = 16777215L;
     private int I;
     protected int m = (new Random()).nextInt();
@@ -82,8 +99,10 @@
     private int J;
     public final Random random = new Random();
     public WorldProvider worldProvider; // CraftBukkit - remove final
-    protected List<IWorldAccess> u = Lists.newArrayList();
-    protected IChunkProvider chunkProvider;
+    //protected List<IWorldAccess> u = Lists.newArrayList();
+    protected List<IWorldAccess> u = Lists.newCopyOnWriteArrayList();
+    //protected IChunkProvider chunkProvider;
+    public IChunkProvider chunkProvider;
     protected final IDataManager dataManager;
     public WorldData worldData; // CraftBukkit - public
     protected boolean isLoading;
@@ -110,7 +129,8 @@
 
     public boolean captureBlockStates = false;
     public boolean captureTreeGeneration = false;
-    public ArrayList<BlockState> capturedBlockStates= new ArrayList<BlockState>(){
+    //public ArrayList<BlockState> capturedBlockStates= new ArrayList<BlockState>(){
+    public Queue<BlockState> capturedBlockStates= new ConcurrentLinkedQueue<BlockState>(){
         @Override
         public boolean add( BlockState blockState ) {
             Iterator<BlockState> blockStateIterator = this.iterator();
@@ -141,6 +161,12 @@
     private org.spigotmc.TickLimiter tileLimiter;
     private int tileTickPosition;
 
+    //for spigot
+    private int g(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
+    
     public static long chunkToKey(int x, int z)
     {
         long k = ( ( ( (long) x ) & 0xFFFF0000L ) << 16 ) | ( ( ( (long) x ) & 0x0000FFFFL ) << 0 );
@@ -172,6 +198,7 @@
     }
 
     public Chunk getChunkIfLoaded(int x, int z) {
+        //System.out.println(((ChunkProviderServer) this.chunkProvider).chunks.size()+","+((ChunkProviderServer) this.chunkProvider).unloadQueue.size());
         return ((ChunkProviderServer) this.chunkProvider).getChunkIfLoaded(x, z);
     }
 
@@ -225,7 +252,7 @@
 
             public void c(WorldBorder worldborder, double d0) {}
         }); 
-        this.getServer().addWorld(this.world); 
+        this.getServer().addWorld(this.world);
         // CraftBukkit end
         timings = new SpigotTimings.WorldTimingsHandler(this); // Spigot - code below can generate new world and access timings 
         this.entityLimiter = new org.spigotmc.TickLimiter(spigotConfig.entityMaxTickTime);
@@ -476,9 +503,14 @@
     }
 
     public void notify(BlockPosition blockposition) {
+        Iterator it = this.u.iterator();
+        while (it.hasNext()){
+            ((IWorldAccess) it.next()).a(blockposition);
+        }
+        /*
         for (int i = 0; i < this.u.size(); ++i) {
             ((IWorldAccess) this.u.get(i)).a(blockposition);
-        }
+        }*/
 
     }
 
@@ -517,9 +549,14 @@
     }
 
     public void b(int i, int j, int k, int l, int i1, int j1) {
+        Iterator it = this.u.iterator();
+        while (it.hasNext()){
+            ((IWorldAccess) it.next()).a(i, j, k, l, i1, j1);
+        }
+        /*
         for (int k1 = 0; k1 < this.u.size(); ++k1) {
             ((IWorldAccess) this.u.get(k1)).a(i, j, k, l, i1, j1);
-        }
+        }*/
 
     }
 
@@ -569,6 +606,7 @@
                 CraftWorld world = ((WorldServer) this).getWorld();
                 if (world != null) {
                     BlockPhysicsEvent event = new BlockPhysicsEvent(world.getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()), CraftMagicNumbers.getId(block));
+                    event.setAsynchronous();
                     this.getServer().getPluginManager().callEvent(event);
 
                     if (event.isCancelled()) {
@@ -768,7 +806,7 @@
     public IBlockData getType(BlockPosition blockposition, boolean useCaptured) {
         // CraftBukkit start - tree generation
         if (captureTreeGeneration && useCaptured) {
-    // Spigot end
+        // Spigot end
             Iterator<BlockState> it = capturedBlockStates.iterator();
             while (it.hasNext()) {
                 BlockState previous = it.next();
@@ -967,10 +1005,13 @@
     }
 
     public void addParticle(EnumParticle enumparticle, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
-        this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        //this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        SpigotWorldConfig.AddParticleTask = new FutureTask(new AddParticlePool(this, enumparticle, d0, d1, d2, d3, d4, d5, aint));
+        SpigotWorldConfig.addparticlepool_executor.submit(SpigotWorldConfig.AddParticleTask);
     }
 
-    private void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
+    public void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
+    //private void a(int i, boolean flag, double d0, double d1, double d2, double d3, double d4, double d5, int... aint) {
         for (int j = 0; j < this.u.size(); ++j) {
             ((IWorldAccess) this.u.get(j)).a(i, flag, d0, d1, d2, d3, d4, d5, aint);
         }
@@ -1062,17 +1103,25 @@
     }
 
     protected void a(Entity entity) {
-        for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).a(entity);
+        Iterator it = this.u.iterator();
+        while (it.hasNext()){
+            ((IWorldAccess) it.next()).a(entity);
         }
+        /*for (int i = 0; i < this.u.size(); ++i) {
+            ((IWorldAccess) this.u.get(i)).a(entity);
+        }*/
 
         entity.valid = true; // CraftBukkit
     }
 
     protected void b(Entity entity) {
-        for (int i = 0; i < this.u.size(); ++i) {
-            ((IWorldAccess) this.u.get(i)).b(entity);
+        Iterator it = this.u.iterator();
+        while (it.hasNext()){
+            ((IWorldAccess) it.next()).b(entity);
         }
+        /*for (int i = 0; i < this.u.size(); ++i) {
+            ((IWorldAccess) this.u.get(i)).b(entity);
+        }*/
 
         entity.valid = false; // CraftBukkit
     }
@@ -1120,13 +1169,13 @@
             this.everyoneSleeping();
         }
 
-        if (!guardEntityList) { // Spigot - It will get removed after the tick if we are ticking
+        //if (!guardEntityList) { // Spigot - It will get removed after the tick if we are ticking
         int i = entity.ae;
         int j = entity.ag;
 
         if (entity.ad && this.isChunkLoaded(i, j, true)) {
             this.getChunkAt(i, j).b(entity);
-        }
+        //}
 
         // CraftBukkit start - Decrement loop variable field if we've already ticked this entity
         int index = this.entityList.indexOf(entity);
@@ -1146,7 +1195,8 @@
     }
 
     public List<AxisAlignedBB> getCubes(Entity entity, AxisAlignedBB axisalignedbb) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         int i = MathHelper.floor(axisalignedbb.a);
         int j = MathHelper.floor(axisalignedbb.d + 1.0D);
         int k = MathHelper.floor(axisalignedbb.b);
@@ -1253,7 +1303,8 @@
     }
 
     public List<AxisAlignedBB> a(AxisAlignedBB axisalignedbb) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         int i = MathHelper.floor(axisalignedbb.a);
         int j = MathHelper.floor(axisalignedbb.d + 1.0D);
         int k = MathHelper.floor(axisalignedbb.b);
@@ -1337,13 +1388,14 @@
     public void a(BlockPosition blockposition, Block block, int i, int j) {}
 
     public void b(BlockPosition blockposition, Block block, int i, int j) {}
-
+    
     public void tickEntities() {
         this.methodProfiler.a("entities");
         this.methodProfiler.a("global");
-
+        //System.out.println(this.players.size()+","+this.entitiesById.size());
         int i;
-        Entity entity;
+        //Entity entity;
+        Entity entity = null;
         CrashReport crashreport;
         CrashReportSystemDetails crashreportsystemdetails;
 
@@ -1396,10 +1448,11 @@
 
         this.g.clear();
         this.methodProfiler.c("regular");
-
+        //observe
+        //System.out.println(this.chunkTickList.size()+","+this.entitiesById.size());
         org.spigotmc.ActivationRange.activateEntities(this); // Spigot
         timings.entityTick.startTiming(); // Spigot
-        guardEntityList = true; // Spigot
+        //guardEntityList = true; // Spigot
         // CraftBukkit start - Use field for loop variable
         int entitiesThisCycle = 0;
         if (tickPosition < 0) tickPosition = 0;
@@ -1422,7 +1475,9 @@
             if (!entity.dead) {
                 try {
                     SpigotTimings.tickEntityTimer.startTiming(); // Spigot
-                    this.g(entity);
+                    //this.g(entity);
+                    SpigotWorldConfig.EntityTickTask = new FutureTask(new EntityTick_Pool(this, entity));
+                    SpigotWorldConfig.entitytick_pool_executor.submit(SpigotWorldConfig.EntityTickTask);
                     SpigotTimings.tickEntityTimer.stopTiming(); // Spigot
                 } catch (Throwable throwable1) {
                     crashreport = CrashReport.a(throwable1, "Ticking entity");
@@ -1449,7 +1504,7 @@
 
             this.methodProfiler.b();
         }
-        guardEntityList = false; // Spigot
+        //guardEntityList = false; // Spigot
 
         timings.entityTick.stopTiming(); // Spigot
         this.methodProfiler.c("blockEntities");
@@ -1485,7 +1540,14 @@
                 if (this.isLoaded(blockposition) && this.N.a(blockposition)) {
                     try {
                         tileentity.tickTimer.startTiming(); // Spigot
-                        ((IUpdatePlayerListBox) tileentity).c();
+                        //tile tick
+                        //check object type
+                        if (tileentity instanceof TileEntityHopper) {
+                            SpigotWorldConfig.TileTickTask = new FutureTask(new TileTick_Pool(tileentity));
+                            SpigotWorldConfig.tiletickpool_executor.submit(SpigotWorldConfig.TileTickTask);
+                        } else {
+                            ((IUpdatePlayerListBox) tileentity).c();
+                        }
                     } catch (Throwable throwable2) {
                         CrashReport crashreport1 = CrashReport.a(throwable2, "Ticking block entity");
                         CrashReportSystemDetails crashreportsystemdetails1 = crashreport1.a("Block entity being ticked");
@@ -1524,8 +1586,9 @@
 
         this.methodProfiler.c("pendingBlockEntities");
         if (!this.b.isEmpty()) {
-            for (int l = 0; l < this.b.size(); ++l) {
-                TileEntity tileentity1 = (TileEntity) this.b.get(l);
+            Iterator it = this.b.iterator();
+            while (it.hasNext()){
+                TileEntity tileentity1 = (TileEntity) it.next();
 
                 if (!tileentity1.x()) {
                     /* CraftBukkit start - Order matters, moved down
@@ -1533,7 +1596,7 @@
                         this.a(tileentity1);
                     }
                     // CraftBukkit end */
-
+                    
                     if (this.isLoaded(tileentity1.getPosition())) {
                         this.getChunkAtWorldCoords(tileentity1.getPosition()).a(tileentity1.getPosition(), tileentity1);
                     }
@@ -1541,6 +1604,24 @@
                     this.notify(tileentity1.getPosition());
                 }
             }
+            /*
+            for (int l = 0; l < this.b.size(); ++l) {
+                TileEntity tileentity1 = (TileEntity) this.b.get(l);
+
+                if (!tileentity1.x()) {*/
+                    /* CraftBukkit start - Order matters, moved down
+                    if (!this.h.contains(tileentity1)) {
+                        this.a(tileentity1);
+                    }
+                    // CraftBukkit end */
+                    /*
+                    if (this.isLoaded(tileentity1.getPosition())) {
+                        this.getChunkAtWorldCoords(tileentity1.getPosition()).a(tileentity1.getPosition(), tileentity1);
+                    }
+
+                    this.notify(tileentity1.getPosition());
+                }
+            }*/
 
             this.b.clear();
         }
@@ -1912,7 +1993,8 @@
         }
     }
 
-    public Map<BlockPosition, TileEntity> capturedTileEntities = Maps.newHashMap();
+    //public Map<BlockPosition, TileEntity> capturedTileEntities = Maps.newHashMap();
+    public ConcurrentMap<BlockPosition, TileEntity> capturedTileEntities = new ConcurrentHashMap<BlockPosition, TileEntity>();
 
     public TileEntity getTileEntity(BlockPosition blockposition) {
         if (!this.isValidLocation(blockposition)) {
@@ -1929,13 +2011,26 @@
             TileEntity tileentity1;
 
             if (this.M) {
+                Iterator it = this.b.iterator();
+                while (it.hasNext()){
+                    tileentity1 = (TileEntity) it.next();
+                    try {
+                        if (!tileentity1.x() && tileentity1.getPosition().equals(blockposition)) {
+                            tileentity = tileentity1;
+                            break;
+                        }
+                    } catch(Exception ex){
+                        System.out.println(ex+" this.b error");
+                    }
+                }
+                /*
                 for (i = 0; i < this.b.size(); ++i) {
                     tileentity1 = (TileEntity) this.b.get(i);
                     if (!tileentity1.x() && tileentity1.getPosition().equals(blockposition)) {
                         tileentity = tileentity1;
                         break;
                     }
-                }
+                }*/
             }
 
             if (tileentity == null) {
@@ -1943,13 +2038,22 @@
             }
 
             if (tileentity == null) {
+                Iterator it = this.b.iterator();
+                while (it.hasNext()){
+                    tileentity1 = (TileEntity) it.next();
+                    if (!tileentity1.x() && tileentity1.getPosition().equals(blockposition)) {
+                        tileentity = tileentity1;
+                        break;
+                    }
+                }
+                /*
                 for (i = 0; i < this.b.size(); ++i) {
                     tileentity1 = (TileEntity) this.b.get(i);
                     if (!tileentity1.x() && tileentity1.getPosition().equals(blockposition)) {
                         tileentity = tileentity1;
                         break;
                     }
-                }
+                }*/
             }
 
             return tileentity;
@@ -2171,8 +2275,10 @@
 
             // Spigot start - Always update the chunk the player is on
             long key = chunkToKey( j, k );
-            int existingPlayers = Math.max( 0, chunkTickList.get( key ) ); // filter out -1
-            chunkTickList.put( key, (short) ( existingPlayers + 1 ) );
+            synchronized (this.chunkTickList) {
+                int existingPlayers = Math.max( 0, chunkTickList.get( key ) ); // filter out -1
+                chunkTickList.put( key, (short) ( existingPlayers + 1 ) );
+            }
 
             // Check and see if we update the chunks surrounding the player this tick
             for ( int chunk = 0; chunk < chunksPerPlayer; chunk++ )
@@ -2180,9 +2286,11 @@
                 int dx = ( random.nextBoolean() ? 1 : -1 ) * random.nextInt( randRange );
                 int dz = ( random.nextBoolean() ? 1 : -1 ) * random.nextInt( randRange );
                 long hash = chunkToKey( dx + j, dz + k );
-                if ( !chunkTickList.contains( hash ) && this.chunkProvider.isChunkLoaded(dx + j, dz + k ) )
-                {
-                    chunkTickList.put( hash, (short) -1 ); // no players
+                synchronized (this.chunkTickList) {
+                    if ( !chunkTickList.contains( hash ) && this.chunkProvider.isChunkLoaded(dx + j, dz + k ) )
+                    {
+                        chunkTickList.put( hash, (short) -1 ); // no players
+                    }
                 }
             }
         }
@@ -2504,7 +2612,8 @@
     }
 
     public List<Entity> a(Entity entity, AxisAlignedBB axisalignedbb, Predicate<? super Entity> predicate) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         int i = MathHelper.floor((axisalignedbb.a - 2.0D) / 16.0D);
         int j = MathHelper.floor((axisalignedbb.d + 2.0D) / 16.0D);
         int k = MathHelper.floor((axisalignedbb.c - 2.0D) / 16.0D);
@@ -2522,7 +2631,8 @@
     }
 
     public <T extends Entity> List<T> a(Class<? extends T> oclass, Predicate<? super T> predicate) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         Iterator iterator = this.entityList.iterator();
 
         while (iterator.hasNext()) {
@@ -2537,7 +2647,8 @@
     }
 
     public <T extends Entity> List<T> b(Class<? extends T> oclass, Predicate<? super T> predicate) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
         Iterator iterator = this.players.iterator();
 
         while (iterator.hasNext()) {
@@ -2560,7 +2671,8 @@
         int j = MathHelper.floor((axisalignedbb.d + 2.0D) / 16.0D);
         int k = MathHelper.floor((axisalignedbb.c - 2.0D) / 16.0D);
         int l = MathHelper.floor((axisalignedbb.f + 2.0D) / 16.0D);
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
 
         for (int i1 = i; i1 <= j; ++i1) {
             for (int j1 = k; j1 <= l; ++j1) {
@@ -2595,7 +2707,8 @@
     }
 
     public Entity a(int i) {
-        return (Entity) this.entitiesById.get(i);
+        //return (Entity) this.entitiesById.get(i);
+        return (Entity) this.entitiesById.get(this.g(i));
     }
 
     public void b(BlockPosition blockposition, TileEntity tileentity) {
@@ -2618,14 +2731,14 @@
                     continue;
                 }
             }
-            
+
             if (oclass.isAssignableFrom(entity.getClass())) {
             // if ((!(entity instanceof EntityInsentient) || !((EntityInsentient) entity).isPersistent()) && oclass.isAssignableFrom(entity.getClass())) {
                 // CraftBukkit end
                 ++i;
             }
         }
-
+        
         return i;
     }
 
diff -Naur src_origin/main/java/net/minecraft/server/WorldMap.java src/main/java/net/minecraft/server/WorldMap.java
--- src_origin/main/java/net/minecraft/server/WorldMap.java	2016-02-26 15:27:14.088203905 +0800
+++ src/main/java/net/minecraft/server/WorldMap.java	2016-03-07 17:08:47.036615585 +0800
@@ -6,9 +6,13 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.Queue;
 
 // CraftBukkit start
 import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ConcurrentMap;
 
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
@@ -22,8 +26,10 @@
     public byte map;
     public byte scale;
     public byte[] colors = new byte[16384];
-    public List<WorldMap.WorldMapHumanTracker> g = Lists.newArrayList();
-    public Map<EntityHuman, WorldMap.WorldMapHumanTracker> i = Maps.newHashMap(); // Spigot
+    //public List<WorldMap.WorldMapHumanTracker> g = Lists.newArrayList();
+    public Queue<WorldMap.WorldMapHumanTracker> g = new ConcurrentLinkedQueue<WorldMap.WorldMapHumanTracker>();
+    //public Map<EntityHuman, WorldMap.WorldMapHumanTracker> i = Maps.newHashMap(); // Spigot
+    public ConcurrentMap<EntityHuman, WorldMap.WorldMapHumanTracker> i = new ConcurrentHashMap<EntityHuman, WorldMap.WorldMapHumanTracker>(); // Spigot
     public Map<UUID, MapIcon> decorations = Maps.newLinkedHashMap(); // Spigot
 
     // CraftBukkit start
@@ -148,6 +154,20 @@
             this.decorations.remove(entityhuman.getUniqueID()); // Spigot
         }
 
+        Iterator it = this.g.iterator();
+        while (it.hasNext()){
+            WorldMap.WorldMapHumanTracker worldmap_worldmaphumantracker1 = (WorldMap.WorldMapHumanTracker) it.next();
+
+            if (!worldmap_worldmaphumantracker1.trackee.dead && (worldmap_worldmaphumantracker1.trackee.inventory.c(itemstack) || itemstack.y())) {
+                if (!itemstack.y() && worldmap_worldmaphumantracker1.trackee.dimension == this.map) {
+                    this.a(0, worldmap_worldmaphumantracker1.trackee.world, worldmap_worldmaphumantracker1.trackee.getUniqueID(), worldmap_worldmaphumantracker1.trackee.locX, worldmap_worldmaphumantracker1.trackee.locZ, (double) worldmap_worldmaphumantracker1.trackee.yaw); // Spigot
+                }
+            } else {
+                this.i.remove(worldmap_worldmaphumantracker1.trackee);
+                this.g.remove(worldmap_worldmaphumantracker1);
+            }
+        }
+        /*
         for (int i = 0; i < this.g.size(); ++i) {
             WorldMap.WorldMapHumanTracker worldmap_worldmaphumantracker1 = (WorldMap.WorldMapHumanTracker) this.g.get(i);
 
@@ -159,7 +179,7 @@
                 this.i.remove(worldmap_worldmaphumantracker1.trackee);
                 this.g.remove(worldmap_worldmaphumantracker1);
             }
-        }
+        }*/
 
         if (itemstack.y()) {
             EntityItemFrame entityitemframe = itemstack.z();
diff -Naur src_origin/main/java/net/minecraft/server/WorldServer.java src/main/java/net/minecraft/server/WorldServer.java
--- src_origin/main/java/net/minecraft/server/WorldServer.java	2016-02-26 15:27:14.144203910 +0800
+++ src/main/java/net/minecraft/server/WorldServer.java	2016-03-07 17:08:47.100615591 +0800
@@ -3,27 +3,26 @@
 import com.google.common.base.Predicate;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
-import com.google.common.collect.Sets;
 import com.google.common.util.concurrent.ListenableFuture;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Random;
-import java.util.Set;
-import java.util.TreeSet;
 import java.util.UUID;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start
 import java.util.*;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentLinkedQueue;
 import java.util.logging.Level;
 
 import org.bukkit.WeatherType;
 import org.bukkit.block.BlockState;
-import org.bukkit.craftbukkit.util.LongHash;
 import org.bukkit.craftbukkit.util.HashTreeSet;
+import org.bukkit.craftbukkit.util.LongHash;
 
 import org.bukkit.event.block.BlockFormEvent;
 import org.bukkit.event.weather.LightningStrikeEvent;
@@ -37,7 +36,8 @@
     private final PlayerChunkMap manager;
     // private final Set<NextTickListEntry> L = Sets.newHashSet(); // PAIL: Rename nextTickListHash
     private final HashTreeSet<NextTickListEntry> M = new HashTreeSet<NextTickListEntry>(); // CraftBukkit - HashTreeSet // PAIL: Rename nextTickList
-    private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
+    //private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
+    private final Map<UUID, Entity> entitiesByUUID = new ConcurrentHashMap<UUID, Entity>();
     public ChunkProviderServer chunkProviderServer;
     public boolean savingDisabled;
     private boolean O;
@@ -48,8 +48,9 @@
     private WorldServer.BlockActionDataList[] S = new WorldServer.BlockActionDataList[] { new WorldServer.BlockActionDataList(null), new WorldServer.BlockActionDataList(null)};
     private int T;
     private static final List<StructurePieceTreasure> U = Lists.newArrayList(new StructurePieceTreasure[] { new StructurePieceTreasure(Items.STICK, 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.PLANKS), 0, 1, 3, 10), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG), 0, 1, 3, 10), new StructurePieceTreasure(Items.STONE_AXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_AXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.STONE_PICKAXE, 0, 1, 1, 3), new StructurePieceTreasure(Items.WOODEN_PICKAXE, 0, 1, 1, 5), new StructurePieceTreasure(Items.APPLE, 0, 2, 3, 5), new StructurePieceTreasure(Items.BREAD, 0, 2, 3, 3), new StructurePieceTreasure(Item.getItemOf(Blocks.LOG2), 0, 1, 3, 10)});
-    private List<NextTickListEntry> V = Lists.newArrayList();
-
+    //private List<NextTickListEntry> V = Lists.newArrayList();
+    private Queue<NextTickListEntry> V = new ConcurrentLinkedQueue<NextTickListEntry>();
+    
     // CraftBukkit start
     public final int dimension;
 
@@ -370,18 +371,21 @@
         }
     }
 
+    //tick block
     protected void h() {
         super.h();
         if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
             // Spigot start
-           gnu.trove.iterator.TLongShortIterator iterator = this.chunkTickList.iterator();
+            synchronized (this.chunkTickList) {
+                gnu.trove.iterator.TLongShortIterator iterator = this.chunkTickList.iterator();
 
-            while (iterator.hasNext()) {
-                iterator.advance();
-                long chunkCoord = iterator.key();
+                while (iterator.hasNext()) {
+                    iterator.advance();
+                    long chunkCoord = iterator.key();
 
-                this.getChunkAt(World.keyToX( chunkCoord ), World.keyToZ( chunkCoord )).b(false);
-                // Spigot end
+                    this.getChunkAt(World.keyToX( chunkCoord ), World.keyToZ( chunkCoord )).b(false);
+                    // Spigot end
+                }
             }
 
         } else {
@@ -394,117 +398,122 @@
             //    int k = chunkcoordintpair1.x * 16;
             //    int l = chunkcoordintpair1.z * 16;
             // Spigot start
-            for (gnu.trove.iterator.TLongShortIterator iter = chunkTickList.iterator(); iter.hasNext(); )
-            {
-                iter.advance();
-                long chunkCoord = iter.key();
-                int chunkX = World.keyToX( chunkCoord );
-                int chunkZ = World.keyToZ( chunkCoord );
-                // If unloaded, or in procedd of being unloaded, drop it
-                if ( ( !this.chunkProvider.isChunkLoaded( chunkX, chunkZ ) ) || ( this.chunkProviderServer.unloadQueue.contains( chunkX, chunkZ ) ) )
+            synchronized (this.chunkTickList) {
+                for (gnu.trove.iterator.TLongShortIterator iter = chunkTickList.iterator(); iter.hasNext(); )
                 {
-                    iter.remove();
-                    continue;
-                }
-                // Spigot end
-                // ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) iterator.next();
-                int k = chunkX * 16;
-                int l = chunkZ * 16;
-
-                this.methodProfiler.a("getChunk");
-                Chunk chunk = this.getChunkAt(chunkX, chunkZ);
-                // CraftBukkit end
-
-                this.a(k, l, chunk);
-                this.methodProfiler.c("tickChunk");
-                chunk.b(false);
-                this.methodProfiler.c("thunder");
-                int i1;
-                BlockPosition blockposition;
-
-                if (this.random.nextInt(100000) == 0 && this.S() && this.R()) {
-                    this.m = this.m * 3 + 1013904223;
-                    i1 = this.m >> 2;
-                    blockposition = this.a(new BlockPosition(k + (i1 & 15), 0, l + (i1 >> 8 & 15)));
-                    if (this.isRainingAt(blockposition)) {
-                        this.strikeLightning(new EntityLightning(this, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ()));
+                    iter.advance();
+                    long chunkCoord = iter.key();
+                    int chunkX = World.keyToX( chunkCoord );
+                    int chunkZ = World.keyToZ( chunkCoord );
+                    long key = LongHash.toLong(chunkX, chunkZ);
+                    // If unloaded, or in procedd of being unloaded, drop it
+                    //if ( ( !this.chunkProvider.isChunkLoaded( chunkX, chunkZ ) ) || ( this.chunkProviderServer.unloadQueue.contains( chunkX, chunkZ ) ) )
+                    if ( ( !this.chunkProvider.isChunkLoaded( chunkX, chunkZ ) ) || ( this.chunkProviderServer.unloadQueue.containsKey(key) ) )
+                    {
+                        iter.remove();
+                        continue;
                     }
-                }
+                    // Spigot end
+                    // ChunkCoordIntPair chunkcoordintpair = (ChunkCoordIntPair) iterator.next();
+                    int k = chunkX * 16;
+                    int l = chunkZ * 16;
 
-                this.methodProfiler.c("iceandsnow");
-                if (this.random.nextInt(16) == 0) {
-                    this.m = this.m * 3 + 1013904223;
-                    i1 = this.m >> 2;
-                    blockposition = this.q(new BlockPosition(k + (i1 & 15), 0, l + (i1 >> 8 & 15)));
-                    BlockPosition blockposition1 = blockposition.down();
-
-                    if (this.w(blockposition1)) {
-                        // CraftBukkit start
-                        BlockState blockState = this.getWorld().getBlockAt(blockposition1.getX(), blockposition1.getY(), blockposition1.getZ()).getState();
-                        blockState.setTypeId(Block.getId(Blocks.ICE));
-
-                        BlockFormEvent iceBlockForm = new BlockFormEvent(blockState.getBlock(), blockState);
-                        this.getServer().getPluginManager().callEvent(iceBlockForm);
-                        if (!iceBlockForm.isCancelled()) {
-                            blockState.update(true);
-                        }
-                        // CraftBukkit end
-                    }
+                    this.methodProfiler.a("getChunk");
+                    Chunk chunk = this.getChunkAt(chunkX, chunkZ);
+                    // CraftBukkit end
 
-                    if (this.S() && this.f(blockposition, true)) {
-                        // CraftBukkit start
-                        BlockState blockState = this.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()).getState();
-                        blockState.setTypeId(Block.getId(Blocks.SNOW_LAYER));
-
-                        BlockFormEvent snow = new BlockFormEvent(blockState.getBlock(), blockState);
-                        this.getServer().getPluginManager().callEvent(snow);
-                        if (!snow.isCancelled()) {
-                            blockState.update(true);
+                    this.a(k, l, chunk);
+                    this.methodProfiler.c("tickChunk");
+                    chunk.b(false);
+                    this.methodProfiler.c("thunder");
+                    int i1;
+                    BlockPosition blockposition;
+
+                    if (this.random.nextInt(100000) == 0 && this.S() && this.R()) {
+                        this.m = this.m * 3 + 1013904223;
+                        i1 = this.m >> 2;
+                        blockposition = this.a(new BlockPosition(k + (i1 & 15), 0, l + (i1 >> 8 & 15)));
+                        if (this.isRainingAt(blockposition)) {
+                            this.strikeLightning(new EntityLightning(this, (double) blockposition.getX(), (double) blockposition.getY(), (double) blockposition.getZ()));
                         }
-                        // CraftBukkit end
                     }
 
-                    if (this.S() && this.getBiome(blockposition1).e()) {
-                        this.getType(blockposition1).getBlock().k(this, blockposition1);
-                    }
-                }
-
-                this.methodProfiler.c("tickBlocks");
-                i1 = this.getGameRules().c("randomTickSpeed");
-                if (i1 > 0) {
-                    ChunkSection[] achunksection = chunk.getSections();
-                    int j1 = achunksection.length;
-
-                    for (int k1 = 0; k1 < j1; ++k1) {
-                        ChunkSection chunksection = achunksection[k1];
+                    this.methodProfiler.c("iceandsnow");
+                    if (this.random.nextInt(16) == 0) {
+                        this.m = this.m * 3 + 1013904223;
+                        i1 = this.m >> 2;
+                        blockposition = this.q(new BlockPosition(k + (i1 & 15), 0, l + (i1 >> 8 & 15)));
+                        BlockPosition blockposition1 = blockposition.down();
+
+                        if (this.w(blockposition1)) {
+                            // CraftBukkit start
+                            BlockState blockState = this.getWorld().getBlockAt(blockposition1.getX(), blockposition1.getY(), blockposition1.getZ()).getState();
+                            blockState.setTypeId(Block.getId(Blocks.ICE));
+
+                            BlockFormEvent iceBlockForm = new BlockFormEvent(blockState.getBlock(), blockState);
+                            this.getServer().getPluginManager().callEvent(iceBlockForm);
+                            if (!iceBlockForm.isCancelled()) {
+                                blockState.update(true);
+                            }
+                            // CraftBukkit end
+                        }
 
-                        if (chunksection != null && chunksection.shouldTick()) {
-                            for (int l1 = 0; l1 < i1; ++l1) {
-                                this.m = this.m * 3 + 1013904223;
-                                int i2 = this.m >> 2;
-                                int j2 = i2 & 15;
-                                int k2 = i2 >> 8 & 15;
-                                int l2 = i2 >> 16 & 15;
+                        if (this.S() && this.f(blockposition, true)) {
+                            // CraftBukkit start
+                            BlockState blockState = this.getWorld().getBlockAt(blockposition.getX(), blockposition.getY(), blockposition.getZ()).getState();
+                            blockState.setTypeId(Block.getId(Blocks.SNOW_LAYER));
+
+                            BlockFormEvent snow = new BlockFormEvent(blockState.getBlock(), blockState);
+                            this.getServer().getPluginManager().callEvent(snow);
+                            if (!snow.isCancelled()) {
+                                blockState.update(true);
+                            }
+                            // CraftBukkit end
+                        }
 
-                                ++j;
-                                IBlockData iblockdata = chunksection.getType(j2, l2, k2);
-                                Block block = iblockdata.getBlock();
+                        if (this.S() && this.getBiome(blockposition1).e()) {
+                            this.getType(blockposition1).getBlock().k(this, blockposition1);
+                        }
+                    }
 
-                                if (block.isTicking()) {
-                                    ++i;
-                                    block.a((World) this, new BlockPosition(j2 + k, l2 + chunksection.getYPosition(), k2 + l), iblockdata, this.random);
+                    this.methodProfiler.c("tickBlocks");
+                    i1 = this.getGameRules().c("randomTickSpeed");
+                    if (i1 > 0) {
+                        ChunkSection[] achunksection = chunk.getSections();
+                        int j1 = achunksection.length;
+
+                        for (int k1 = 0; k1 < j1; ++k1) {
+                            ChunkSection chunksection = achunksection[k1];
+
+                            if (chunksection != null && chunksection.shouldTick()) {
+                                for (int l1 = 0; l1 < i1; ++l1) {
+                                    this.m = this.m * 3 + 1013904223;
+                                    int i2 = this.m >> 2;
+                                    int j2 = i2 & 15;
+                                    int k2 = i2 >> 8 & 15;
+                                    int l2 = i2 >> 16 & 15;
+
+                                    ++j;
+                                    IBlockData iblockdata = chunksection.getType(j2, l2, k2);
+                                    Block block = iblockdata.getBlock();
+
+                                    if (block.isTicking()) {
+                                        ++i;
+                                        block.a((World) this, new BlockPosition(j2 + k, l2 + chunksection.getYPosition(), k2 + l), iblockdata, this.random);
+                                    }
                                 }
                             }
                         }
                     }
                 }
             }
-
         }
         // Spigot Start
         if ( spigotConfig.clearChunksOnTick )
-        {
-            chunkTickList.clear();
+        {   
+            synchronized (this.chunkTickList) {
+                chunkTickList.clear();
+            }
         }
         // Spigot End
     }
@@ -602,6 +611,7 @@
         this.emptyTime = 0;
     }
 
+    //tick pending
     public boolean a(boolean flag) {
         if (this.worldData.getType() == WorldType.DEBUG_ALL_BLOCK_STATES) {
             return false;
@@ -624,9 +634,9 @@
                 this.methodProfiler.a("cleaning");
 
                 NextTickListEntry nextticklistentry;
-
-                for (int j = 0; j < i; ++j) {
-                    nextticklistentry = (NextTickListEntry) this.M.first();
+                Iterator it = this.M.iterator();
+                while (it.hasNext()){
+                    nextticklistentry = (NextTickListEntry) it.next();
                     if (!flag && nextticklistentry.b > this.worldData.getTime()) {
                         break;
                     }
@@ -635,6 +645,23 @@
                     this.M.remove(nextticklistentry);
                     this.V.add(nextticklistentry);
                 }
+                /*
+                for (int j = 0; j < i; ++j) {
+                    try {
+                        nextticklistentry = (NextTickListEntry) this.M.first();
+                        if (!flag && nextticklistentry.b > this.worldData.getTime()) {
+                            break;
+                        }
+
+                        // CraftBukkit - use M, PAIL: Rename nextTickList
+                        this.M.remove(nextticklistentry);
+                        this.V.add(nextticklistentry);
+                    } catch (Exception ex){
+                        LogManager.getLogger().warn(this.M.size()+":"+ex);
+                        
+                        break;
+                    }
+                }*/
 
                 this.methodProfiler.b();
                 this.methodProfiler.a("ticking");
@@ -682,7 +709,8 @@
     }
 
     public List<NextTickListEntry> a(StructureBoundingBox structureboundingbox, boolean flag) {
-        ArrayList arraylist = null;
+        //ArrayList arraylist = null;
+        List arraylist = null;
 
         for (int i = 0; i < 2; ++i) {
             Iterator iterator;
@@ -704,7 +732,8 @@
                     }
 
                     if (arraylist == null) {
-                        arraylist = Lists.newArrayList();
+                        //arraylist = Lists.newArrayList();
+                        arraylist = Lists.newCopyOnWriteArrayList();
                     }
 
                     arraylist.add(nextticklistentry);
@@ -759,7 +788,8 @@
     }
 
     public List<TileEntity> getTileEntities(int i, int j, int k, int l, int i1, int j1) {
-        ArrayList arraylist = Lists.newArrayList();
+        //ArrayList arraylist = Lists.newArrayList();
+        List arraylist = Lists.newCopyOnWriteArrayList();
 
         // CraftBukkit start - Get tile entities from chunks instead of world
         for (int chunkX = (i >> 4); chunkX <= ((l - 1) >> 4); chunkX++) {
@@ -929,13 +959,16 @@
             // CraftBukkit - ArrayList -> Collection
             Collection arraylist = this.chunkProviderServer.a();
             Iterator iterator = arraylist.iterator();
+            try {
+                while (iterator.hasNext()) {
+                    Chunk chunk = (Chunk) iterator.next();
 
-            while (iterator.hasNext()) {
-                Chunk chunk = (Chunk) iterator.next();
-
-                if (chunk != null && !this.manager.a(chunk.locX, chunk.locZ)) {
-                    this.chunkProviderServer.queueUnload(chunk.locX, chunk.locZ);
+                    if (chunk != null && !this.manager.a(chunk.locX, chunk.locZ)) {
+                        this.chunkProviderServer.queueUnload(chunk.locX, chunk.locZ);
+                    }
                 }
+            } catch (Exception exception) {
+                LogManager.getLogger().error("Couldn\'t save chunk", exception);
             }
 
         }
@@ -966,15 +999,23 @@
         // CraftBukkit end
     }
 
+    //for spigot
+    private int g(int i) {
+        i ^= i >>> 20 ^ i >>> 12;
+        return i ^ i >>> 7 ^ i >>> 4;
+    }
+    
     protected void a(Entity entity) {
         super.a(entity);
-        this.entitiesById.a(entity.getId(), entity);
+        //this.entitiesById.a(entity.getId(), entity);
+        this.entitiesById.put(this.g(entity.getId()), entity);
         this.entitiesByUUID.put(entity.getUniqueID(), entity);
         Entity[] aentity = entity.aB();
 
         if (aentity != null) {
             for (int i = 0; i < aentity.length; ++i) {
-                this.entitiesById.a(aentity[i].getId(), aentity[i]);
+                //this.entitiesById.a(aentity[i].getId(), aentity[i]);
+                this.entitiesById.put(this.g(aentity[i].getId()), aentity[i]);
             }
         }
 
@@ -982,13 +1023,18 @@
 
     protected void b(Entity entity) {
         super.b(entity);
-        this.entitiesById.d(entity.getId());
+        //this.entitiesById.d(entity.getId());
+        //remove it
+        //this.entitiesById.get(this.g(entity.getId()));
+        this.entitiesById.remove(this.g(entity.getId()));
         this.entitiesByUUID.remove(entity.getUniqueID());
         Entity[] aentity = entity.aB();
 
         if (aentity != null) {
             for (int i = 0; i < aentity.length; ++i) {
-                this.entitiesById.d(aentity[i].getId());
+                //this.entitiesById.d(aentity[i].getId());
+                //this.entitiesById.get(this.g(aentity[i].getId()));
+                this.entitiesById.remove(this.g(aentity[i].getId()));
             }
         }
 
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java
--- src_origin/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java	2016-02-26 15:27:16.164204099 +0800
+++ src/main/java/org/bukkit/craftbukkit/chunkio/ChunkIOProvider.java	2016-03-07 17:08:48.882615758 +0800
@@ -10,10 +10,7 @@
 import org.bukkit.craftbukkit.util.LongHash;
 
 import java.util.concurrent.atomic.AtomicInteger;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-import net.minecraft.server.Entity;
-import net.minecraft.server.EntitySlice;
+import org.bukkit.event.Event;
 
 class ChunkIOProvider implements AsynchronousExecutor.CallBackProvider<QueuedChunk, Chunk, Runnable, RuntimeException> {
     private final AtomicInteger threadNumber = new AtomicInteger(1);
@@ -56,7 +53,10 @@
 
         Server server = queuedChunk.provider.world.getServer();
         if (server != null) {
-            server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, false));
+            Event ev = new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, false);
+            //server.getPluginManager().callEvent(new org.bukkit.event.world.ChunkLoadEvent(chunk.bukkitChunk, false));
+            ev.setAsynchronous();
+            server.getPluginManager().callEvent(ev);
         }
 
         // Update neighbor counts
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java src/main/java/org/bukkit/craftbukkit/CraftWorld.java
--- src_origin/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-02-26 15:27:14.770203969 +0800
+++ src/main/java/org/bukkit/craftbukkit/CraftWorld.java	2016-03-07 17:08:47.650615642 +0800
@@ -194,8 +194,9 @@
             world.chunkProviderServer.saveChunk(chunk);
             world.chunkProviderServer.saveChunkNOP(chunk);
         }
-
-        world.chunkProviderServer.unloadQueue.remove(x, z);
+        long key = LongHash.toLong(x, z);
+        //world.chunkProviderServer.unloadQueue.remove(x, z);
+        world.chunkProviderServer.unloadQueue.remove(key);
         world.chunkProviderServer.chunks.remove(LongHash.toLong(x, z));
 
         return true;
@@ -203,8 +204,9 @@
 
     public boolean regenerateChunk(int x, int z) {
         unloadChunk(x, z, false, false);
-
-        world.chunkProviderServer.unloadQueue.remove(x, z);
+        long key = LongHash.toLong(x, z);
+        //world.chunkProviderServer.unloadQueue.remove(x, z);
+        world.chunkProviderServer.unloadQueue.remove(key);
 
         net.minecraft.server.Chunk chunk = null;
 
@@ -252,8 +254,9 @@
             // Use the default variant of loadChunk when generate == true.
             return world.chunkProviderServer.getChunkAt(x, z) != null;
         }
-
-        world.chunkProviderServer.unloadQueue.remove(x, z);
+        long key = LongHash.toLong(x, z);
+        //world.chunkProviderServer.unloadQueue.remove(x, z);
+        world.chunkProviderServer.unloadQueue.remove(key);
         net.minecraft.server.Chunk chunk = world.chunkProviderServer.chunks.get(LongHash.toLong(x, z));
 
         if (chunk == null) {
@@ -1371,6 +1374,27 @@
         }
 
         ChunkProviderServer cps = world.chunkProviderServer;
+        Iterator it = cps.chunks.values().iterator();
+        net.minecraft.server.Chunk chunk;
+        while (it.hasNext()){
+            //net.minecraft.server.Chunk chunk = (net.minecraft.server.Chunk) it.next();
+            chunk = (net.minecraft.server.Chunk) it.next();
+            long key = LongHash.toLong(chunk.locX, chunk.locZ);
+            // If in use, skip it
+            if (isChunkInUse(chunk.locX, chunk.locZ)) {
+                continue;
+            }
+
+            // Already unloading?
+            //if (cps.unloadQueue.contains(chunk.locX, chunk.locZ)) {
+            if (cps.unloadQueue.containsKey(key)) {
+                continue;
+            }
+
+            // Add unload request
+            cps.queueUnload(chunk.locX, chunk.locZ);
+        }
+        /*
         for (net.minecraft.server.Chunk chunk : cps.chunks.values()) {
             // If in use, skip it
             if (isChunkInUse(chunk.locX, chunk.locZ)) {
@@ -1384,7 +1408,7 @@
 
             // Add unload request
             cps.queueUnload(chunk.locX, chunk.locZ);
-        }
+        }*/
     }
     // Spigot start
     private final Spigot spigot = new Spigot()
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java
--- src_origin/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java	2016-02-26 15:27:19.207204384 +0800
+++ src/main/java/org/bukkit/craftbukkit/event/CraftEventFactory.java	2016-03-07 17:08:51.531616006 +0800
@@ -8,6 +8,8 @@
 
 import com.google.common.base.Function;
 import com.google.common.base.Functions;
+import java.util.Iterator;
+import java.util.Queue;
 
 import net.minecraft.server.*;
 
@@ -91,7 +93,8 @@
     /**
      * Block place methods
      */
-    public static BlockMultiPlaceEvent callBlockMultiPlaceEvent(World world, EntityHuman who, List<BlockState> blockStates, int clickedX, int clickedY, int clickedZ) {
+    //public static BlockMultiPlaceEvent callBlockMultiPlaceEvent(World world, EntityHuman who, List<BlockState> blockStates, int clickedX, int clickedY, int clickedZ) {
+    public static BlockMultiPlaceEvent callBlockMultiPlaceEvent(World world, EntityHuman who, Queue<BlockState> blockStates, int clickedX, int clickedY, int clickedZ) {
         CraftWorld craftWorld = world.getWorld();
         CraftServer craftServer = world.getServer();
         Player player = (who == null) ? null : (Player) who.getBukkitEntity();
@@ -99,14 +102,30 @@
         Block blockClicked = craftWorld.getBlockAt(clickedX, clickedY, clickedZ);
 
         boolean canBuild = true;
+        Iterator it = blockStates.iterator();
+        while (it.hasNext()){
+            BlockState bs = (BlockState) it.next();
+            if (!canBuild(craftWorld, player, bs.getX(), bs.getZ())) {
+                canBuild = false;
+                break;
+            }
+        }
+        /*
         for (int i = 0; i < blockStates.size(); i++) {
             if (!canBuild(craftWorld, player, blockStates.get(i).getX(), blockStates.get(i).getZ())) {
                 canBuild = false;
                 break;
             }
-        }
+        }*/
 
-        BlockMultiPlaceEvent event = new BlockMultiPlaceEvent(blockStates, blockClicked, player.getItemInHand(), player, canBuild);
+        //BlockMultiPlaceEvent event = new BlockMultiPlaceEvent(blockStates, blockClicked, player.getItemInHand(), player, canBuild);
+        BlockState first_stat = null;
+        if (blockStates.iterator().hasNext()){
+            first_stat = blockStates.iterator().next();
+        }
+        
+        BlockMultiPlaceEvent event = new BlockMultiPlaceEvent(blockStates, first_stat, first_stat.getBlock(), blockClicked, player.getItemInHand(), player, canBuild);
+        
         craftServer.getPluginManager().callEvent(event);
 
         return event;
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
--- src_origin/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java	2016-02-26 15:27:20.478204503 +0800
+++ src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java	2016-03-07 17:08:52.666616112 +0800
@@ -42,6 +42,7 @@
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
+import java.util.concurrent.CopyOnWriteArraySet;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import net.minecraft.server.NBTCompressedStreamTools;
@@ -226,7 +227,8 @@
     private int repairCost;
     private int hideFlag;
 
-    private static final Set<String> HANDLED_TAGS = Sets.newHashSet();
+    //private static final Set<String> HANDLED_TAGS = Sets.newHashSet();
+    private static final Set<String> HANDLED_TAGS = new CopyOnWriteArraySet<String>();
 
     private final Map<String, NBTBase> unhandledTags = new HashMap<String, NBTBase>();
 
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/potion/CraftPotionBrewer.java src/main/java/org/bukkit/craftbukkit/potion/CraftPotionBrewer.java
--- src_origin/main/java/org/bukkit/craftbukkit/potion/CraftPotionBrewer.java	2016-02-26 15:27:21.354204585 +0800
+++ src/main/java/org/bukkit/craftbukkit/potion/CraftPotionBrewer.java	2016-03-07 17:08:53.534616193 +0800
@@ -3,7 +3,6 @@
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
-import java.util.Map;
 
 import net.minecraft.server.MobEffect;
 
@@ -11,10 +10,12 @@
 import org.bukkit.potion.PotionBrewer;
 import org.bukkit.potion.PotionEffect;
 
-import com.google.common.collect.Maps;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 
 public class CraftPotionBrewer implements PotionBrewer {
-    private static final Map<Integer, Collection<PotionEffect>> cache = Maps.newHashMap();
+    //private static final Map<Integer, Collection<PotionEffect>> cache = Maps.newHashMap();
+    private static final ConcurrentMap<Integer, Collection<PotionEffect>> cache = new ConcurrentHashMap<Integer, Collection<PotionEffect>>();
 
     public Collection<PotionEffect> getEffectsFromDamage(int damage) {
         if (cache.containsKey(damage))
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java src/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java	2016-02-26 15:27:22.149204659 +0800
+++ src/main/java/org/bukkit/craftbukkit/util/AsynchronousExecutor.java	2016-03-07 17:08:54.344616269 +0800
@@ -5,7 +5,9 @@
 import java.util.List;
 import java.util.Map;
 import java.util.Queue;
+import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentLinkedQueue;
+import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.LinkedBlockingQueue;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.ThreadPoolExecutor;
@@ -216,7 +218,8 @@
 
     final CallBackProvider<P, T, C, E> provider;
     final Queue<Task> finished = new ConcurrentLinkedQueue<Task>();
-    final Map<P, Task> tasks = new HashMap<P, Task>();
+    //final Map<P, Task> tasks = new HashMap<P, Task>();
+    final ConcurrentMap<P, Task> tasks = new ConcurrentHashMap<P, Task>();
     final ThreadPoolExecutor pool;
 
     /**
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-02-26 15:27:22.350204678 +0800
+++ src/main/java/org/bukkit/craftbukkit/util/HashTreeSet.java	2016-03-07 17:08:54.585616291 +0800
@@ -1,15 +1,17 @@
 package org.bukkit.craftbukkit.util;
 
+import com.google.common.collect.Sets;
 import java.util.Collection;
-import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
-import java.util.TreeSet;
+import java.util.concurrent.ConcurrentSkipListSet;
 
 public class HashTreeSet<V> implements Set<V> {
 
-    private HashSet<V> hash = new HashSet<V>();
-    private TreeSet<V> tree = new TreeSet<V>();
+    //private HashSet<V> hash = new HashSet<V>();
+    private Set<V> hash = Sets.newConcurrentHashSet();
+    //private TreeSet<V> tree = new TreeSet<V>();
+    private ConcurrentSkipListSet<V> tree = new ConcurrentSkipListSet<V>();
 
     public HashTreeSet() {
 
@@ -112,6 +114,6 @@
 
     public V first() {
         return tree.first();
-    }
+   }
 
 }
diff -Naur src_origin/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java src/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java
--- src_origin/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java	2016-02-26 15:27:22.480204690 +0800
+++ src/main/java/org/bukkit/craftbukkit/util/LongObjectHashMap.java	1970-01-01 08:00:00.000000000 +0800
@@ -1,422 +0,0 @@
-package org.bukkit.craftbukkit.util;
-
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.io.ObjectOutputStream;
-import java.io.Serializable;
-import java.util.AbstractCollection;
-import java.util.AbstractSet;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.ConcurrentModificationException;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.Map;
-import java.util.NoSuchElementException;
-import java.util.Set;
-
-@SuppressWarnings("unchecked")
-public class LongObjectHashMap<V> implements Cloneable, Serializable {
-    static final long serialVersionUID = 2841537710170573815L;
-
-    private static final long EMPTY_KEY = Long.MIN_VALUE;
-    private static final int  BUCKET_SIZE = 4096;
-
-    private transient long[][] keys;
-    private transient V[][]    values;
-    private transient int      modCount;
-    private transient int      size;
-
-    public LongObjectHashMap() {
-        initialize();
-    }
-
-    public LongObjectHashMap(Map<? extends Long, ? extends V> map) {
-        this();
-        putAll(map);
-    }
-
-    public int size() {
-        return size;
-    }
-
-    public boolean isEmpty() {
-        return size == 0;
-    }
-
-    public boolean containsKey(long key) {
-        return get(key) != null;
-    }
-
-    public boolean containsValue(V value) {
-        for (V val : values()) {
-            if (val == value || val.equals(value)) {
-                return true;
-            }
-        }
-
-        return false;
-    }
-
-    public V get(long key) {
-        int index = (int) (keyIndex(key) & (BUCKET_SIZE - 1));
-        long[] inner = keys[index];
-        if (inner == null) return null;
-
-        for (int i = 0; i < inner.length; i++) {
-            long innerKey = inner[i];
-            if (innerKey == EMPTY_KEY) {
-                return null;
-            } else if (innerKey == key) {
-                return values[index][i];
-            }
-        }
-
-        return null;
-    }
-
-    public V put(long key, V value) {
-        int index = (int) (keyIndex(key) & (BUCKET_SIZE - 1));
-        long[] innerKeys = keys[index];
-        V[] innerValues = values[index];
-        modCount++;
-
-        if (innerKeys == null) {
-            // need to make a new chain
-            keys[index] = innerKeys = new long[8];
-            Arrays.fill(innerKeys, EMPTY_KEY);
-            values[index] = innerValues = (V[]) new Object[8];
-            innerKeys[0] = key;
-            innerValues[0] = value;
-            size++;
-        } else {
-            int i;
-            for (i = 0; i < innerKeys.length; i++) {
-                // found an empty spot in the chain to put this
-                if (innerKeys[i] == EMPTY_KEY) {
-                    size++;
-                    innerKeys[i] = key;
-                    innerValues[i] = value;
-                    return null;
-                }
-
-                // found an existing entry in the chain with this key, replace it
-                if (innerKeys[i] == key) {
-                    V oldValue = innerValues[i];
-                    innerKeys[i] = key;
-                    innerValues[i] = value;
-                    return oldValue;
-                }
-            }
-
-            // chain is full, resize it and add our new entry
-            keys[index] = innerKeys = Arrays.copyOf(innerKeys, i << 1);
-            Arrays.fill(innerKeys, i, innerKeys.length, EMPTY_KEY);
-            values[index] = innerValues = Arrays.copyOf(innerValues, i << 1);
-            innerKeys[i] = key;
-            innerValues[i] = value;
-            size++;
-        }
-
-        return null;
-    }
-
-    public V remove(long key) {
-        int index = (int) (keyIndex(key) & (BUCKET_SIZE - 1));
-        long[] inner = keys[index];
-        if (inner == null) {
-            return null;
-        }
-
-        for (int i = 0; i < inner.length; i++) {
-            // hit the end of the chain, didn't find this entry
-            if (inner[i] == EMPTY_KEY) {
-                break;
-            }
-
-            if (inner[i] == key) {
-                V value = values[index][i];
-
-                for (i++; i < inner.length; i++) {
-                    if (inner[i] == EMPTY_KEY) {
-                        break;
-                    }
-
-                    inner[i - 1] = inner[i];
-                    values[index][i - 1] = values[index][i];
-                }
-
-                inner[i - 1] = EMPTY_KEY;
-                values[index][i - 1] = null;
-                size--;
-                modCount++;
-                return value;
-            }
-        }
-
-        return null;
-    }
-
-    public void putAll(Map<? extends Long, ? extends V> map) {
-        for (Map.Entry entry : map.entrySet()) {
-            put((Long) entry.getKey(), (V) entry.getValue());
-        }
-    }
-
-    public void clear() {
-        if (size == 0) {
-            return;
-        }
-
-        modCount++;
-        size = 0;
-        Arrays.fill(keys, null);
-        Arrays.fill(values, null);
-    }
-
-    public Set<Long> keySet() {
-        return new KeySet();
-    }
-
-    public Collection<V> values() {
-        return new ValueCollection();
-    }
-
-    /**
-     * Returns a Set of Entry objects for the HashMap. This is not how the internal
-     * implementation is laid out so this constructs the entire Set when called. For
-     * this reason it should be avoided if at all possible.
-     *
-     * @return Set of Entry objects
-     * @deprecated
-     */
-    @Deprecated
-    public Set<Map.Entry<Long, V>> entrySet() {
-        HashSet<Map.Entry<Long, V>> set = new HashSet<Map.Entry<Long, V>>();
-        for (long key : keySet()) {
-            set.add(new Entry(key, get(key)));
-        }
-
-        return set;
-    }
-
-    public Object clone() throws CloneNotSupportedException {
-        LongObjectHashMap clone = (LongObjectHashMap) super.clone();
-        // Make sure we clear any existing information from the clone
-        clone.clear();
-        // Make sure the clone is properly setup for new entries
-        clone.initialize();
-
-        // Iterate through the data normally to do a safe clone
-        for (long key : keySet()) {
-            final V value = get(key);
-            clone.put(key, value);
-        }
-
-        return clone;
-    }
-
-    private void initialize() {
-        keys = new long[BUCKET_SIZE][];
-        values = (V[][]) new Object[BUCKET_SIZE][];
-    }
-
-    private long keyIndex(long key) {
-        key ^= key >>> 33;
-        key *= 0xff51afd7ed558ccdL;
-        key ^= key >>> 33;
-        key *= 0xc4ceb9fe1a85ec53L;
-        key ^= key >>> 33;
-        return key;
-    }
-
-    private void writeObject(ObjectOutputStream outputStream) throws IOException {
-        outputStream.defaultWriteObject();
-
-        for (long key : keySet()) {
-            V value = get(key);
-            outputStream.writeLong(key);
-            outputStream.writeObject(value);
-        }
-
-        outputStream.writeLong(EMPTY_KEY);
-        outputStream.writeObject(null);
-    }
-
-    private void readObject(ObjectInputStream inputStream) throws ClassNotFoundException, IOException {
-        inputStream.defaultReadObject();
-        initialize();
-
-        while (true) {
-            long key = inputStream.readLong();
-            V value = (V) inputStream.readObject();
-            if (key == EMPTY_KEY && value == null) {
-                break;
-            }
-
-            put(key, value);
-        }
-    }
-
-
-    private class ValueIterator implements Iterator<V> {
-        private int count;
-        private int index;
-        private int innerIndex;
-        private int expectedModCount;
-        private long lastReturned = EMPTY_KEY;
-
-        long prevKey = EMPTY_KEY;
-        V prevValue;
-
-        ValueIterator() {
-            expectedModCount = LongObjectHashMap.this.modCount;
-        }
-
-        public boolean hasNext() {
-            return count < LongObjectHashMap.this.size;
-        }
-
-        public void remove() {
-            if (LongObjectHashMap.this.modCount != expectedModCount) {
-                throw new ConcurrentModificationException();
-            }
-
-            if (lastReturned == EMPTY_KEY) {
-                throw new IllegalStateException();
-            }
-
-            count--;
-            LongObjectHashMap.this.remove(lastReturned);
-            lastReturned = EMPTY_KEY;
-            expectedModCount = LongObjectHashMap.this.modCount;
-        }
-
-        public V next() {
-            if (LongObjectHashMap.this.modCount != expectedModCount) {
-                throw new ConcurrentModificationException();
-            }
-
-            if (!hasNext()) {
-                throw new NoSuchElementException();
-            }
-
-            long[][] keys = LongObjectHashMap.this.keys;
-            count++;
-
-            if (prevKey != EMPTY_KEY) {
-                innerIndex++;
-            }
-
-            for (; index < keys.length; index++) {
-                if (keys[index] != null) {
-                    for (; innerIndex < keys[index].length; innerIndex++) {
-                        long key = keys[index][innerIndex];
-                        V value = values[index][innerIndex];
-                        if (key == EMPTY_KEY) {
-                            break;
-                        }
-
-                        lastReturned = key;
-                        prevKey = key;
-                        prevValue = value;
-                        return prevValue;
-                    }
-                    innerIndex = 0;
-                }
-            }
-
-            throw new NoSuchElementException();
-        }
-    }
-
-    private class KeyIterator implements Iterator<Long> {
-        final ValueIterator iterator;
-
-        public KeyIterator() {
-            iterator = new ValueIterator();
-        }
-
-        public void remove() {
-            iterator.remove();
-        }
-
-        public boolean hasNext() {
-            return iterator.hasNext();
-        }
-
-        public Long next() {
-            iterator.next();
-            return iterator.prevKey;
-        }
-    }
-
-
-    private class KeySet extends AbstractSet<Long> {
-        public void clear() {
-            LongObjectHashMap.this.clear();
-        }
-
-        public int size() {
-            return LongObjectHashMap.this.size();
-        }
-
-        public boolean contains(Object key) {
-            return key instanceof Long && LongObjectHashMap.this.containsKey((Long) key);
-
-        }
-
-        public boolean remove(Object key) {
-            return LongObjectHashMap.this.remove((Long) key) != null;
-        }
-
-        public Iterator<Long> iterator() {
-            return new KeyIterator();
-        }
-    }
-
-
-    private class ValueCollection extends AbstractCollection<V> {
-        public void clear() {
-            LongObjectHashMap.this.clear();
-        }
-
-        public int size() {
-            return LongObjectHashMap.this.size();
-        }
-
-        public boolean contains(Object value) {
-            return LongObjectHashMap.this.containsValue((V) value);
-        }
-
-        public Iterator<V> iterator() {
-            return new ValueIterator();
-        }
-    }
-
-
-    private class Entry implements Map.Entry<Long, V> {
-        private final Long key;
-        private V value;
-
-        Entry(long k, V v) {
-            key = k;
-            value = v;
-        }
-
-        public Long getKey() {
-            return key;
-        }
-
-        public V getValue() {
-            return value;
-        }
-
-        public V setValue(V v) {
-            V old = value;
-            value = v;
-            put(key, v);
-            return old;
-        }
-    }
-}
diff -Naur src_origin/main/java/org/hose/AddParticlePool.java src/main/java/org/hose/AddParticlePool.java
--- src_origin/main/java/org/hose/AddParticlePool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/AddParticlePool.java	2016-03-07 17:08:38.065614746 +0800
@@ -0,0 +1,41 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.EnumParticle;
+import net.minecraft.server.World;
+/**
+ *
+ * @author softpak
+ */
+public class AddParticlePool implements Callable{
+    private World w;
+    private EnumParticle ep;
+    private int[] aint;
+    private double d0, d1, d2, d3, d4, d5;
+    
+    public AddParticlePool(World w, EnumParticle ep, double d0, double d1, double d2, double d3, double d4, double d5, int... aint){
+        this.w = w;
+        this.ep = ep;
+        this.aint = aint;
+        this.d0 = d0;
+        this.d1 = d1;
+        this.d2 = d2;
+        this.d3 = d3;
+        this.d4 = d4;
+        this.d5 = d5;
+    }
+    
+    @Override
+    public Object call() throws Exception {
+        //this.a(enumparticle.c(), enumparticle.e(), d0, d1, d2, d3, d4, d5, aint);
+        w.a(ep.c(), ep.e(), d0, d1, d2, d3, d4, d5, aint);
+        return null;
+    }
+    
+    
+}
diff -Naur src_origin/main/java/org/hose/ChangeEntityThreadCommand.java src/main/java/org/hose/ChangeEntityThreadCommand.java
--- src_origin/main/java/org/hose/ChangeEntityThreadCommand.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChangeEntityThreadCommand.java	2016-03-07 17:08:38.109614750 +0800
@@ -0,0 +1,52 @@
+package org.hose;
+
+import com.google.common.base.Joiner;
+import net.minecraft.server.MinecraftServer;
+import com.google.common.collect.Iterables;
+import org.bukkit.ChatColor;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.spigotmc.SpigotWorldConfig;
+
+public class ChangeEntityThreadCommand extends Command
+{
+
+    public ChangeEntityThreadCommand(String name)
+    {
+        super( name );
+        this.description = "Change the Entity thread number for the server";
+        this.usageMessage = "/ctp";
+        this.setPermission( "bukkit.command.ctp" );
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String currentAlias, String[] args)
+    {
+        if ( !testPermission( sender ) )
+        {
+            return true;
+        }
+        StringBuilder sb;
+        if (args.length > 0){//cahnge thread pool size
+            try {
+                SpigotWorldConfig.entitytick_pool_executor.setCorePoolSize(Integer.parseInt(args[0]));
+                SpigotWorldConfig.entitytick_pool_executor.setMaximumPoolSize(Integer.parseInt(args[0]));
+                sb = new StringBuilder( ChatColor.GOLD + "Entity thread pool size: "+ SpigotWorldConfig.entitytick_pool_executor.getCorePoolSize() );
+            } catch (Exception ex) {
+                sb = new StringBuilder( ChatColor.GOLD + "Something is wrong with setting entity thread pool size. ");
+            }
+        } else {
+            sb = new StringBuilder( ChatColor.GOLD + "Entity thread pool size: "+ SpigotWorldConfig.entitytick_pool_executor.getCorePoolSize() );
+        }
+        
+        sender.sendMessage( sb.toString() );
+        
+        return true;
+    }
+
+    private String format(double tps)
+    {
+        return ( ( tps > 18.0 ) ? ChatColor.GREEN : ( tps > 16.0 ) ? ChatColor.YELLOW : ChatColor.RED ).toString()
+                + ( ( tps > 20.0 ) ? "*" : "" ) + Math.min( Math.round( tps * 100.0 ) / 100.0, 20.0 );
+    }
+}
diff -Naur src_origin/main/java/org/hose/ChunkGenPool.java src/main/java/org/hose/ChunkGenPool.java
--- src_origin/main/java/org/hose/ChunkGenPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/ChunkGenPool.java	2016-03-07 17:08:38.149614753 +0800
@@ -0,0 +1,38 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.WorldServer;
+
+/**
+ *
+ * @author softpak
+ */
+public class ChunkGenPool  implements Callable<Chunk>{
+    WorldServer worldserver;
+    BlockPosition blockposition;
+    
+    int k, l;
+    
+    public ChunkGenPool(WorldServer worldserver, BlockPosition blockposition, int k, int l) {
+        this.worldserver = worldserver;
+        this.blockposition = blockposition;
+        this.k = k;
+        this.l = l;
+    }
+
+    @Override
+    public Chunk call() throws Exception {
+        //worldserver.chunkProviderServer.getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+        return worldserver.chunkProviderServer.getChunkAt(blockposition.getX() + k >> 4, blockposition.getZ() + l >> 4);
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/EntityTick_Pool.java src/main/java/org/hose/EntityTick_Pool.java
--- src_origin/main/java/org/hose/EntityTick_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/EntityTick_Pool.java	2016-03-07 17:08:38.189614757 +0800
@@ -0,0 +1,56 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Entity;
+import net.minecraft.server.World;
+
+/**
+ *
+ * @author softpak
+ */
+public class EntityTick_Pool  implements Callable{
+    /*
+    private Entity e;
+    private World w;
+    private int start, end;
+
+    public t_Pool(World w, Entity e, int start, int end) {
+        this.e = e;
+        this.w = w;
+        this.start = start;
+        this.end = end;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        //hoseentitytick(entity);
+        w.hoseentitytick(e,start,end);
+        //el.m();
+        return null;
+    }*/
+    
+    
+    private Entity e;
+    private World w;
+
+    public EntityTick_Pool(World w, Entity e) {
+        this.e = e;
+        this.w = w;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        //hoseentitytick(entity);
+        this.w.g(e);
+        //el.m();
+        return null;
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/GetChunkATPool.java src/main/java/org/hose/GetChunkATPool.java
--- src_origin/main/java/org/hose/GetChunkATPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/GetChunkATPool.java	2016-03-07 17:08:38.229614761 +0800
@@ -0,0 +1,35 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.ChunkProviderGenerate;
+import net.minecraft.server.IChunkProvider;
+/**
+ *
+ * @author softpak
+ */
+public class GetChunkATPool implements Callable{
+    ChunkProviderGenerate cpg;
+    IChunkProvider ichunkprovider;
+    int i, j;
+    
+    public GetChunkATPool(ChunkProviderGenerate cpg, IChunkProvider ichunkprovider, int i, int j) {
+        this.cpg = cpg;
+        this.ichunkprovider = ichunkprovider;
+        this.i = i;
+        this.j = j;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        cpg.getChunkAt_hose(ichunkprovider, i, j);
+        return null;
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/GetCreateChunkPool.java src/main/java/org/hose/GetCreateChunkPool.java
--- src_origin/main/java/org/hose/GetCreateChunkPool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/GetCreateChunkPool.java	2016-03-07 17:08:38.269614765 +0800
@@ -0,0 +1,32 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.Chunk;
+import net.minecraft.server.ChunkProviderGenerate;
+/**
+ *
+ * @author softpak
+ */
+public class GetCreateChunkPool implements Callable<Chunk>{
+    ChunkProviderGenerate cpg;
+    int i, j;
+    
+    public GetCreateChunkPool(ChunkProviderGenerate cpg, int i, int j) {
+        this.cpg = cpg;
+        this.i = i;
+        this.j = j;
+    }
+
+    @Override
+    public Chunk call() throws Exception {
+        return cpg.getOrCreateChunk_hose(i, j);
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/SpawnerCreature_Pool.java src/main/java/org/hose/SpawnerCreature_Pool.java
--- src_origin/main/java/org/hose/SpawnerCreature_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/SpawnerCreature_Pool.java	2016-03-07 17:08:38.309614768 +0800
@@ -0,0 +1,50 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.BlockPosition;
+import net.minecraft.server.EntityInsentient;
+import net.minecraft.server.EnumCreatureType;
+import net.minecraft.server.IUpdatePlayerListBox;
+import net.minecraft.server.SpawnerCreature;
+import net.minecraft.server.WorldServer;
+import org.bukkit.event.entity.CreatureSpawnEvent;
+
+/**
+ *
+ * @author softpak
+ */
+public class SpawnerCreature_Pool  implements Callable<Integer>{
+    SpawnerCreature sc;
+    boolean flag, flag1, flag2;
+    WorldServer worldserver;
+    EnumCreatureType[] aenumcreaturetype;
+    BlockPosition blockposition;
+    int i, j1, k, k1;
+
+    public SpawnerCreature_Pool(SpawnerCreature sc, EnumCreatureType[] aenumcreaturetype, BlockPosition blockposition, int i, int j1, int k, int k1, WorldServer worldserver, boolean flag, boolean flag1, boolean flag2) {
+        this.sc = sc;
+        this.flag = flag;
+        this.flag2 = flag1;
+        this.flag2 = flag2;
+        this.worldserver = worldserver;
+        this.aenumcreaturetype = aenumcreaturetype;
+        this.i = i;
+        this.k = k;
+        this.j1 = j1;
+        this.k1 = k1;
+        this.blockposition = blockposition;
+    }
+
+    @Override
+    public Integer call() throws Exception {
+        return sc.spawn_calc_hose(aenumcreaturetype, blockposition, i, j1, k, k1, worldserver, flag, flag1, flag2);
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/hose/TileTick_Pool.java src/main/java/org/hose/TileTick_Pool.java
--- src_origin/main/java/org/hose/TileTick_Pool.java	1970-01-01 08:00:00.000000000 +0800
+++ src/main/java/org/hose/TileTick_Pool.java	2016-03-07 17:08:38.349614772 +0800
@@ -0,0 +1,32 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package org.hose;
+
+import java.util.concurrent.Callable;
+import net.minecraft.server.IUpdatePlayerListBox;
+import net.minecraft.server.TileEntity;
+
+/**
+ *
+ * @author softpak
+ */
+public class TileTick_Pool  implements Callable{
+    private TileEntity tileentity;
+
+    public TileTick_Pool(TileEntity tileentity) {
+        this.tileentity = tileentity;
+    }
+
+    @Override
+    public Object call() throws Exception {
+        //((IUpdatePlayerListBox) tileentity).c();
+        ((IUpdatePlayerListBox) this.tileentity).c();
+        return null;
+    }
+    
+
+    
+}
diff -Naur src_origin/main/java/org/spigotmc/ActivationRange.java src/main/java/org/spigotmc/ActivationRange.java
--- src_origin/main/java/org/spigotmc/ActivationRange.java	2016-02-26 15:27:05.386203091 +0800
+++ src/main/java/org/spigotmc/ActivationRange.java	2016-03-07 17:08:38.531614789 +0800
@@ -1,8 +1,7 @@
 package org.spigotmc;
 
-import java.util.ArrayList;
 import java.util.List;
-import java.util.Set;
+import java.util.Queue;
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.Chunk;
 import net.minecraft.server.Entity;
@@ -21,7 +20,6 @@
 import net.minecraft.server.EntityMonster;
 import net.minecraft.server.EntityProjectile;
 import net.minecraft.server.EntitySheep;
-import net.minecraft.server.EntitySlice;
 import net.minecraft.server.EntitySlime;
 import net.minecraft.server.EntityTNTPrimed;
 import net.minecraft.server.EntityVillager;
@@ -31,7 +29,6 @@
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.World;
 import org.bukkit.craftbukkit.SpigotTimings;
-import org.bukkit.entity.Creeper;
 
 public class ActivationRange
 {
@@ -143,7 +140,8 @@
      */
     private static void activateChunkEntities(Chunk chunk)
     {
-        for ( List<Entity> slice : chunk.entitySlices )
+        //for ( List<Entity> slice : chunk.entitySlices )
+        for ( Queue<Entity> slice : chunk.entitySlices )
         {
             for ( Entity entity : slice )
             {
diff -Naur src_origin/main/java/org/spigotmc/AsyncCatcher.java src/main/java/org/spigotmc/AsyncCatcher.java
--- src_origin/main/java/org/spigotmc/AsyncCatcher.java	2016-02-26 15:27:05.429203095 +0800
+++ src/main/java/org/spigotmc/AsyncCatcher.java	2016-03-07 17:08:38.618614797 +0800
@@ -5,7 +5,7 @@
 public class AsyncCatcher
 {
 
-    public static boolean enabled = true;
+    public static boolean enabled = false;
 
     public static void catchOp(String reason)
     {
diff -Naur src_origin/main/java/org/spigotmc/SpigotConfig.java src/main/java/org/spigotmc/SpigotConfig.java
--- src_origin/main/java/org/spigotmc/SpigotConfig.java	2016-02-26 15:27:05.584203109 +0800
+++ src/main/java/org/spigotmc/SpigotConfig.java	2016-03-07 17:08:38.948614828 +0800
@@ -26,6 +26,7 @@
 import org.bukkit.configuration.ConfigurationSection;
 import org.bukkit.configuration.InvalidConfigurationException;
 import org.bukkit.configuration.file.YamlConfiguration;
+import org.hose.ChangeEntityThreadCommand;
 
 public class SpigotConfig
 {
@@ -275,6 +276,11 @@
     {
         commands.put( "tps", new TicksPerSecondCommand( "tps" ) );
     }
+    
+    private static void ctpCommand()
+    {
+        commands.put( "ctp", new ChangeEntityThreadCommand( "ctp" ) );
+    }
 
     public static int playerSample;
     private static void playerSample()
diff -Naur src_origin/main/java/org/spigotmc/SpigotWorldConfig.java src/main/java/org/spigotmc/SpigotWorldConfig.java
--- src_origin/main/java/org/spigotmc/SpigotWorldConfig.java	2016-02-26 15:27:05.636203114 +0800
+++ src/main/java/org/spigotmc/SpigotWorldConfig.java	2016-03-07 17:08:38.996614833 +0800
@@ -1,13 +1,74 @@
 package org.spigotmc;
 
+import com.google.common.util.concurrent.ThreadFactoryBuilder;
 import java.util.Arrays;
 import java.util.List;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.FutureTask;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import net.minecraft.server.Chunk;
 import org.bukkit.Bukkit;
 import org.bukkit.configuration.file.YamlConfiguration;
 
 public class SpigotWorldConfig
 {
+    static public final int cpu_core = Runtime.getRuntime().availableProcessors();
+    
+    static public FutureTask AddParticleTask;
+    static public FutureTask EntityTickTask;
+    static public FutureTask<Chunk> ChunkGenTask;
+    static public FutureTask GetChunkATTask;
+    static public FutureTask<Chunk> GetCreateChunkTask;
+    static public FutureTask TileTickTask;
+    static public FutureTask<Integer> SpawnerCreatureTask;
+    
+    static final ThreadFactory tfttp = new ThreadFactoryBuilder().setNameFormat("TileTick_Pool-%d").build();
+    static public final ExecutorService tiletickpool_executor = Executors.newFixedThreadPool(cpu_core*10, tfttp);
+    
+    static final ThreadFactory tfgccp = new ThreadFactoryBuilder().setNameFormat("GetCreateChunkPool-%d").build();
+    static public final ExecutorService getcreatechunkatpool_executor = Executors.newFixedThreadPool(cpu_core*10, tfgccp);
+            
+    static final ThreadFactory tfgcap = new ThreadFactoryBuilder().setNameFormat("GetChunkATPool-%d").build();
+    static public final ExecutorService getchunkatpool_executor = Executors.newFixedThreadPool(cpu_core*10, tfgcap);
+    
+    static final ThreadFactory tfcgp = new ThreadFactoryBuilder().setNameFormat("ChunkGenPool-%d").build();
+    static public final ExecutorService chunkgenpool_executor = Executors.newFixedThreadPool(cpu_core*10, tfcgp);
+    
+    static final ThreadFactory tfapp = new ThreadFactoryBuilder().setNameFormat("AddParticlePool-%d").build();
+    static public final ExecutorService addparticlepool_executor = Executors.newFixedThreadPool(cpu_core, tfapp);
+    
+    static final ThreadFactory tfetp = new ThreadFactoryBuilder().setNameFormat("EntityTick_Pool-%d").build();
+    static public ThreadPoolExecutor entitytick_pool_executor;
 
+    static final ThreadFactory tfscp = new ThreadFactoryBuilder().setNameFormat("SpawnerCreature_Pool-%d").build();
+    static public ExecutorService spawncreaturepool_executor;
+    
+    public static int worldtickentitypool_core_multiple;
+    
+    public static int getthreadnumber(){
+        return cpu_core*worldtickentitypool_core_multiple;
+    }
+    
+    static public BlockingQueue entitytick_queue = new LinkedBlockingQueue(5000000);//capacity 5M 
+    //static public ThreadPoolExecutor executor;
+    
+    
+    private void wetp_core_multiple()
+    {
+        worldtickentitypool_core_multiple = getInt("wetp-core-multiple", 4);
+        entitytick_pool_executor = new ThreadPoolExecutor(getthreadnumber(), getthreadnumber(), 1, TimeUnit.DAYS, entitytick_queue, tfetp);
+        spawncreaturepool_executor = Executors.newFixedThreadPool(getthreadnumber(), tfscp);
+        //executor = new ThreadPoolExecutor(getthreadnumber(), getthreadnumber(), 1, TimeUnit.DAYS, queue);
+        log("WETP Core Multiple: " + worldtickentitypool_core_multiple);
+    }
+    
+    
+    
     private final String worldName;
     private final YamlConfiguration config;
     private boolean verbose;
diff -Naur src_origin/test/java/org/bukkit/MaterialTest.java src/test/java/org/bukkit/MaterialTest.java
--- src_origin/test/java/org/bukkit/MaterialTest.java	2016-02-26 15:27:06.194203166 +0800
+++ src/test/java/org/bukkit/MaterialTest.java	2016-03-07 17:08:39.722614901 +0800
@@ -4,22 +4,23 @@
 import static org.hamcrest.Matchers.*;
 
 import java.util.Collections;
-import java.util.Map;
 
 import net.minecraft.server.Item;
 
 import org.bukkit.support.AbstractTestingBase;
 import org.junit.Test;
 
-import com.google.common.collect.Maps;
 import java.util.Iterator;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ConcurrentMap;
 import org.bukkit.craftbukkit.util.CraftMagicNumbers;
 
 public class MaterialTest extends AbstractTestingBase {
 
     @Test
     public void verifyMapping() {
-        Map<Integer, Material> materials = Maps.newHashMap();
+        //Map<Integer, Material> materials = Maps.newHashMap();
+        ConcurrentMap<Integer, Material> materials = new ConcurrentHashMap<Integer, Material>();
         for (Material material : Material.values()) {
             if (INVALIDATED_MATERIALS.contains(material)) {
                 continue;
